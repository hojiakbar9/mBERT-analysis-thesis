id,classname,method_name,method_sig,method_def_line,mut_location,mut_start,mut_end,mut_operator,orig_token,pred_token,pred_pos,pred_score,masked_expr,masked_seq
0,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14538,14541,BinaryOperatorMutator,==,=,0,0.2843572,this.encodeTable <mask> org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,"boolean isUrlSafe() {
        return this.encodeTable<mask>URL_SAFE_ENCODE_TABLE;
    }"
1,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14538,14541,BinaryOperatorMutator,==,IS,1,0.2492414,this.encodeTable <mask> org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,"boolean isUrlSafe() {
        return this.encodeTable<mask>URL_SAFE_ENCODE_TABLE;
    }"
2,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14538,14541,BinaryOperatorMutator,==,.,2,0.2025588,this.encodeTable <mask> org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,"boolean isUrlSafe() {
        return this.encodeTable<mask>URL_SAFE_ENCODE_TABLE;
    }"
3,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14538,14541,BinaryOperatorMutator,==,Is,3,0.079036824,this.encodeTable <mask> org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,"boolean isUrlSafe() {
        return this.encodeTable<mask>URL_SAFE_ENCODE_TABLE;
    }"
4,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14538,14541,BinaryOperatorMutator,==,_,4,0.03650931,this.encodeTable <mask> org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,"boolean isUrlSafe() {
        return this.encodeTable<mask>URL_SAFE_ENCODE_TABLE;
    }"
5,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14522,14537,IdentifierMutator-Variable,this.encodeTable,table,0,0.70714295,<mask>,"boolean isUrlSafe() {
        return<mask> == URL_SAFE_ENCODE_TABLE;
    }"
6,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14522,14537,IdentifierMutator-Variable,this.encodeTable,encoding,1,0.062470734,<mask>,"boolean isUrlSafe() {
        return<mask> == URL_SAFE_ENCODE_TABLE;
    }"
7,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14522,14537,IdentifierMutator-Variable,this.encodeTable,enc,2,0.022495214,<mask>,"boolean isUrlSafe() {
        return<mask> == URL_SAFE_ENCODE_TABLE;
    }"
8,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14522,14537,IdentifierMutator-Variable,this.encodeTable,type,3,0.013758537,<mask>,"boolean isUrlSafe() {
        return<mask> == URL_SAFE_ENCODE_TABLE;
    }"
9,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14522,14537,IdentifierMutator-Variable,this.encodeTable,tables,4,0.01133225,<mask>,"boolean isUrlSafe() {
        return<mask> == URL_SAFE_ENCODE_TABLE;
    }"
10,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14522,14525,IdentifierMutator-ThisAccess,this,config,1,0.03620054,<mask>,"boolean isUrlSafe() {
        return<mask>.encodeTable == URL_SAFE_ENCODE_TABLE;
    }"
11,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14522,14525,IdentifierMutator-ThisAccess,this,options,2,0.015777318,<mask>,"boolean isUrlSafe() {
        return<mask>.encodeTable == URL_SAFE_ENCODE_TABLE;
    }"
12,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14522,14525,IdentifierMutator-ThisAccess,this,settings,3,0.014880351,<mask>,"boolean isUrlSafe() {
        return<mask>.encodeTable == URL_SAFE_ENCODE_TABLE;
    }"
13,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14522,14525,IdentifierMutator-ThisAccess,this,env,4,0.009000222,<mask>,"boolean isUrlSafe() {
        return<mask>.encodeTable == URL_SAFE_ENCODE_TABLE;
    }"
14,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14527,14537,FieldReferenceMutator,encodeTable,table,0,0.61776394,this.<mask>,"boolean isUrlSafe() {
        return this.<mask> == URL_SAFE_ENCODE_TABLE;
    }"
15,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14527,14537,FieldReferenceMutator,encodeTable,enc,1,0.036451984,this.<mask>,"boolean isUrlSafe() {
        return this.<mask> == URL_SAFE_ENCODE_TABLE;
    }"
16,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14527,14537,FieldReferenceMutator,encodeTable,code,2,0.03590355,this.<mask>,"boolean isUrlSafe() {
        return this.<mask> == URL_SAFE_ENCODE_TABLE;
    }"
17,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14527,14537,FieldReferenceMutator,encodeTable,type,3,0.03188064,this.<mask>,"boolean isUrlSafe() {
        return this.<mask> == URL_SAFE_ENCODE_TABLE;
    }"
18,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14527,14537,FieldReferenceMutator,encodeTable,name,4,0.025844902,this.<mask>,"boolean isUrlSafe() {
        return this.<mask> == URL_SAFE_ENCODE_TABLE;
    }"
19,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,table,0,0.7777944,<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
20,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,null,1,0.05689768,<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
21,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,0,2,0.047562327,<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
22,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,TABLE,3,0.0229317,<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
23,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,1,4,0.010206895,<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
24,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,FieldReferenceMutator,URL_SAFE_ENCODE_TABLE,table,0,0.7777944,org.apache.commons.codec.binary.Base64.<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
25,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,FieldReferenceMutator,URL_SAFE_ENCODE_TABLE,null,1,0.05689768,org.apache.commons.codec.binary.Base64.<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
26,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,FieldReferenceMutator,URL_SAFE_ENCODE_TABLE,0,2,0.047562327,org.apache.commons.codec.binary.Base64.<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
27,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,FieldReferenceMutator,URL_SAFE_ENCODE_TABLE,TABLE,3,0.0229317,org.apache.commons.codec.binary.Base64.<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
28,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,FieldReferenceMutator,URL_SAFE_ENCODE_TABLE,1,4,0.010206895,org.apache.commons.codec.binary.Base64.<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
29,Base64.java,hasData,boolean hasData(),368,369,14794,14797,BinaryOperatorMutator,!=,==,0,0.7420034,this.buffer <mask> null,"boolean hasData() {
        return this.buffer<mask>null;
    }"
30,Base64.java,hasData,boolean hasData(),368,369,14794,14797,BinaryOperatorMutator,!=,=,2,0.046860874,this.buffer <mask> null,"boolean hasData() {
        return this.buffer<mask>null;
    }"
31,Base64.java,hasData,boolean hasData(),368,369,14794,14797,BinaryOperatorMutator,!=,==,3,0.015022981,this.buffer <mask> null,"boolean hasData() {
        return this.buffer<mask>null;
    }"
32,Base64.java,hasData,boolean hasData(),368,369,14794,14797,BinaryOperatorMutator,!=,===,4,0.014372619,this.buffer <mask> null,"boolean hasData() {
        return this.buffer<mask>null;
    }"
33,Base64.java,hasData,boolean hasData(),368,369,14783,14793,IdentifierMutator-Variable,this.buffer,data,0,0.8235272,<mask>,"boolean hasData() {
        return<mask> != null;
    }"
34,Base64.java,hasData,boolean hasData(),368,369,14783,14793,IdentifierMutator-Variable,this.buffer,result,1,0.025498437,<mask>,"boolean hasData() {
        return<mask> != null;
    }"
35,Base64.java,hasData,boolean hasData(),368,369,14783,14793,IdentifierMutator-Variable,this.buffer,response,2,0.006110003,<mask>,"boolean hasData() {
        return<mask> != null;
    }"
36,Base64.java,hasData,boolean hasData(),368,369,14783,14793,IdentifierMutator-Variable,this.buffer,value,3,0.0050241635,<mask>,"boolean hasData() {
        return<mask> != null;
    }"
37,Base64.java,hasData,boolean hasData(),368,369,14783,14793,IdentifierMutator-Variable,this.buffer,d,4,0.00488934,<mask>,"boolean hasData() {
        return<mask> != null;
    }"
38,Base64.java,hasData,boolean hasData(),368,369,14783,14786,IdentifierMutator-ThisAccess,this,buffer,1,0.019601444,<mask>,"boolean hasData() {
        return<mask>.buffer != null;
    }"
39,Base64.java,hasData,boolean hasData(),368,369,14783,14786,IdentifierMutator-ThisAccess,this,m,2,0.011960568,<mask>,"boolean hasData() {
        return<mask>.buffer != null;
    }"
40,Base64.java,hasData,boolean hasData(),368,369,14783,14786,IdentifierMutator-ThisAccess,this,b,3,0.0068625947,<mask>,"boolean hasData() {
        return<mask>.buffer != null;
    }"
41,Base64.java,hasData,boolean hasData(),368,369,14783,14786,IdentifierMutator-ThisAccess,this,data,4,0.006812522,<mask>,"boolean hasData() {
        return<mask>.buffer != null;
    }"
42,Base64.java,hasData,boolean hasData(),368,369,14788,14793,FieldReferenceMutator,buffer,data,0,0.8169109,this.<mask>,"boolean hasData() {
        return this.<mask> != null;
    }"
43,Base64.java,hasData,boolean hasData(),368,369,14788,14793,FieldReferenceMutator,buffer,next,1,0.015416469,this.<mask>,"boolean hasData() {
        return this.<mask> != null;
    }"
44,Base64.java,hasData,boolean hasData(),368,369,14788,14793,FieldReferenceMutator,buffer,value,2,0.010786855,this.<mask>,"boolean hasData() {
        return this.<mask> != null;
    }"
45,Base64.java,hasData,boolean hasData(),368,369,14788,14793,FieldReferenceMutator,buffer,table,3,0.008582931,this.<mask>,"boolean hasData() {
        return this.<mask> != null;
    }"
46,Base64.java,hasData,boolean hasData(),368,369,14798,14801,IdentifierMutator-Literal,null,buffer,1,0.0090063745,<mask>,"boolean hasData() {
        return this.buffer !=<mask>;
    }"
47,Base64.java,hasData,boolean hasData(),368,369,14798,14801,IdentifierMutator-Literal,null,0,2,0.008980388,<mask>,"boolean hasData() {
        return this.buffer !=<mask>;
    }"
48,Base64.java,hasData,boolean hasData(),368,369,14798,14801,IdentifierMutator-Literal,null,"""""",3,0.0042835455,<mask>,"boolean hasData() {
        return this.buffer !=<mask>;
    }"
49,Base64.java,hasData,boolean hasData(),368,369,14798,14801,IdentifierMutator-Literal,null,nil,4,0.0038371386,<mask>,"boolean hasData() {
        return this.buffer !=<mask>;
    }"
50,Base64.java,avail,int avail(),377,378,15000,15033,IdentifierMutator-Conditional,buffer!=null?pos-readPos:0,avail,0,0.6324072,<mask>,"int avail() {
        return<mask>;
    }"
51,Base64.java,avail,int avail(),377,378,15000,15033,IdentifierMutator-Conditional,buffer!=null?pos-readPos:0,0,1,0.11783128,<mask>,"int avail() {
        return<mask>;
    }"
52,Base64.java,avail,int avail(),377,378,15000,15033,IdentifierMutator-Conditional,buffer!=null?pos-readPos:0,1,2,0.05654944,<mask>,"int avail() {
        return<mask>;
    }"
53,Base64.java,avail,int avail(),377,378,15000,15033,IdentifierMutator-Conditional,buffer!=null?pos-readPos:0,available,3,0.04339945,<mask>,"int avail() {
        return<mask>;
    }"
54,Base64.java,avail,int avail(),377,378,15000,15033,IdentifierMutator-Conditional,buffer!=null?pos-readPos:0,capacity,4,0.014927301,<mask>,"int avail() {
        return<mask>;
    }"
55,Base64.java,avail,int avail(),377,378,15006,15009,BinaryOperatorMutator,!=,==,0,0.84894454,buffer <mask> null,"int avail() {
        return buffer<mask>null ? pos - readPos : 0;
    }"
56,Base64.java,avail,int avail(),377,378,15006,15009,BinaryOperatorMutator,!=,==,2,0.03189363,buffer <mask> null,"int avail() {
        return buffer<mask>null ? pos - readPos : 0;
    }"
57,Base64.java,avail,int avail(),377,378,15006,15009,BinaryOperatorMutator,!=,=,3,0.02440542,buffer <mask> null,"int avail() {
        return buffer<mask>null ? pos - readPos : 0;
    }"
58,Base64.java,avail,int avail(),377,378,15006,15009,BinaryOperatorMutator,!=,.,4,0.0037829767,buffer <mask> null,"int avail() {
        return buffer<mask>null ? pos - readPos : 0;
    }"
59,Base64.java,avail,int avail(),377,378,15000,15005,IdentifierMutator-Variable,buffer,pos,0,0.6842773,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
60,Base64.java,avail,int avail(),377,378,15000,15005,IdentifierMutator-Variable,buffer,position,1,0.03559566,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
61,Base64.java,avail,int avail(),377,378,15000,15005,IdentifierMutator-Variable,buffer,buf,2,0.02107256,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
62,Base64.java,avail,int avail(),377,378,15000,15005,IdentifierMutator-Variable,buffer,reader,4,0.011582953,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
63,Base64.java,avail,int avail(),377,378,15000,15005,FieldReferenceMutator,buffer,pos,0,0.6842773,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
64,Base64.java,avail,int avail(),377,378,15000,15005,FieldReferenceMutator,buffer,position,1,0.03559566,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
65,Base64.java,avail,int avail(),377,378,15000,15005,FieldReferenceMutator,buffer,buf,2,0.02107256,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
66,Base64.java,avail,int avail(),377,378,15000,15005,FieldReferenceMutator,buffer,reader,4,0.011582953,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
67,Base64.java,avail,int avail(),377,378,15010,15013,IdentifierMutator-Literal,null,0,2,3.0271194E-4,<mask>,"int avail() {
        return buffer !=<mask> ? pos - readPos : 0;
    }"
68,Base64.java,avail,int avail(),377,378,15010,15013,IdentifierMutator-Literal,null,nil,3,1.8120975E-4,<mask>,"int avail() {
        return buffer !=<mask> ? pos - readPos : 0;
    }"
69,Base64.java,avail,int avail(),377,378,15010,15013,IdentifierMutator-Literal,null,NULL,4,1.6804806E-4,<mask>,"int avail() {
        return buffer !=<mask> ? pos - readPos : 0;
    }"
70,Base64.java,avail,int avail(),377,378,15020,15022,BinaryOperatorMutator,-,+,1,0.3186232,pos <mask> readPos,"int avail() {
        return buffer != null ? pos<mask>readPos : 0;
    }"
71,Base64.java,avail,int avail(),377,378,15020,15022,BinaryOperatorMutator,-,.,2,0.03662823,pos <mask> readPos,"int avail() {
        return buffer != null ? pos<mask>readPos : 0;
    }"
72,Base64.java,avail,int avail(),377,378,15020,15022,BinaryOperatorMutator,-,/,4,0.013476046,pos <mask> readPos,"int avail() {
        return buffer != null ? pos<mask>readPos : 0;
    }"
73,Base64.java,avail,int avail(),377,378,15017,15019,IdentifierMutator-Variable,pos,buffer,0,0.38500774,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
74,Base64.java,avail,int avail(),377,378,15017,15019,IdentifierMutator-Variable,pos,position,1,0.25913656,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
75,Base64.java,avail,int avail(),377,378,15017,15019,IdentifierMutator-Variable,pos,limit,2,0.04765534,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
76,Base64.java,avail,int avail(),377,378,15017,15019,IdentifierMutator-Variable,pos,available,3,0.03913235,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
77,Base64.java,avail,int avail(),377,378,15017,15019,FieldReferenceMutator,pos,buffer,0,0.38500774,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
78,Base64.java,avail,int avail(),377,378,15017,15019,FieldReferenceMutator,pos,position,1,0.25913656,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
79,Base64.java,avail,int avail(),377,378,15017,15019,FieldReferenceMutator,pos,limit,2,0.04765534,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
80,Base64.java,avail,int avail(),377,378,15017,15019,FieldReferenceMutator,pos,available,3,0.03913235,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
81,Base64.java,avail,int avail(),377,378,15023,15029,IdentifierMutator-Variable,readPos,buffer,0,0.8479305,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
82,Base64.java,avail,int avail(),377,378,15023,15029,IdentifierMutator-Variable,readPos,avail,1,0.043809254,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
83,Base64.java,avail,int avail(),377,378,15023,15029,IdentifierMutator-Variable,readPos,available,2,0.013781001,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
84,Base64.java,avail,int avail(),377,378,15023,15029,IdentifierMutator-Variable,readPos,1,3,0.009437389,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
85,Base64.java,avail,int avail(),377,378,15023,15029,IdentifierMutator-Variable,readPos,start,4,0.009393641,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
86,Base64.java,avail,int avail(),377,378,15023,15029,FieldReferenceMutator,readPos,buffer,0,0.8479305,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
87,Base64.java,avail,int avail(),377,378,15023,15029,FieldReferenceMutator,readPos,avail,1,0.043809254,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
88,Base64.java,avail,int avail(),377,378,15023,15029,FieldReferenceMutator,readPos,available,2,0.013781001,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
89,Base64.java,avail,int avail(),377,378,15023,15029,FieldReferenceMutator,readPos,1,3,0.009437389,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
90,Base64.java,avail,int avail(),377,378,15023,15029,FieldReferenceMutator,readPos,start,4,0.009393641,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
91,Base64.java,avail,int avail(),377,378,15033,15033,IdentifierMutator-Literal,0,pos,1,0.053147975,<mask>,"int avail() {
        return buffer != null ? pos - readPos :<mask>;
    }"
92,Base64.java,avail,int avail(),377,378,15033,15033,IdentifierMutator-Literal,0,avail,2,0.04842747,<mask>,"int avail() {
        return buffer != null ? pos - readPos :<mask>;
    }"
93,Base64.java,avail,int avail(),377,378,15033,15033,IdentifierMutator-Literal,0,position,3,0.011988309,<mask>,"int avail() {
        return buffer != null ? pos - readPos :<mask>;
    }"
94,Base64.java,avail,int avail(),377,378,15033,15033,IdentifierMutator-Literal,0,1,4,0.009000819,<mask>,"int avail() {
        return buffer != null ? pos - readPos :<mask>;
    }"
95,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15126,15129,BinaryOperatorMutator,==,=,2,0.038895022,buffer <mask> null,"void resizeBuffer() {
        if (buffer<mask>null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
96,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15126,15129,BinaryOperatorMutator,==,!=,3,0.0037705088,buffer <mask> null,"void resizeBuffer() {
        if (buffer<mask>null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
97,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15126,15129,BinaryOperatorMutator,==,_,4,8.9660665E-4,buffer <mask> null,"void resizeBuffer() {
        if (buffer<mask>null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
98,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15120,15125,IdentifierMutator-Variable,buffer,Buffer,2,3.5758392E-4,<mask>,"void resizeBuffer() {
        if (<mask> == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
99,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15120,15125,IdentifierMutator-Variable,buffer,buf,3,2.1959419E-4,<mask>,"void resizeBuffer() {
        if (<mask> == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
100,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15120,15125,IdentifierMutator-Variable,buffer,source,4,2.0003051E-4,<mask>,"void resizeBuffer() {
        if (<mask> == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
101,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15120,15125,FieldReferenceMutator,buffer,Buffer,2,3.5758392E-4,<mask>,"void resizeBuffer() {
        if (<mask> == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
102,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15120,15125,FieldReferenceMutator,buffer,buf,3,2.1959419E-4,<mask>,"void resizeBuffer() {
        if (<mask> == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
103,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15120,15125,FieldReferenceMutator,buffer,source,4,2.0003051E-4,<mask>,"void resizeBuffer() {
        if (<mask> == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
104,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15130,15133,IdentifierMutator-Literal,null,0,1,4.752759E-4,<mask>,"void resizeBuffer() {
        if (buffer ==<mask>) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
105,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15130,15133,IdentifierMutator-Literal,null,nil,2,3.5452028E-4,<mask>,"void resizeBuffer() {
        if (buffer ==<mask>) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
106,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15130,15133,IdentifierMutator-Literal,null,NULL,3,3.0958635E-4,<mask>,"void resizeBuffer() {
        if (buffer ==<mask>) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
107,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15156,15156,AssignmentMutator,buffer=newbyte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],*,0,0.5153762,buffer <mask>= new byte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],"void resizeBuffer() {
        if (buffer == null) {
            buffer<mask>= new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
108,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15156,15156,AssignmentMutator,buffer=newbyte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],|,1,0.17859434,buffer <mask>= new byte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],"void resizeBuffer() {
        if (buffer == null) {
            buffer<mask>= new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
109,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15156,15156,AssignmentMutator,buffer=newbyte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],[],2,0.08555169,buffer <mask>= new byte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],"void resizeBuffer() {
        if (buffer == null) {
            buffer<mask>= new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
110,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15156,15156,AssignmentMutator,buffer=newbyte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],||,3,0.036428154,buffer <mask>= new byte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],"void resizeBuffer() {
        if (buffer == null) {
            buffer<mask>= new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
111,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15156,15156,AssignmentMutator,buffer=newbyte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],=,4,0.022377187,buffer <mask>= new byte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],"void resizeBuffer() {
        if (buffer == null) {
            buffer<mask>= new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
112,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15150,15155,IdentifierMutator-Variable,buffer,b,2,3.3286124E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {<mask> = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
113,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15150,15155,IdentifierMutator-Variable,buffer,buf,3,2.9198776E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {<mask> = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
114,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15150,15155,IdentifierMutator-Variable,buffer,buff,4,1.0084516E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {<mask> = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
115,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15150,15155,FieldReferenceMutator,buffer,b,2,3.3286124E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {<mask> = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
116,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15150,15155,FieldReferenceMutator,buffer,buf,3,2.9198776E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {<mask> = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
117,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15150,15155,FieldReferenceMutator,buffer,buff,4,1.0084516E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {<mask> = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
118,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE,size,0,0.34460708,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
119,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE,0,1,0.13565125,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
120,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE,capacity,2,0.12566428,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
121,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE,1024,3,0.029645784,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
122,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE,length,4,0.025477322,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
123,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,FieldReferenceMutator,DEFAULT_BUFFER_SIZE,size,0,0.34460708,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
124,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,FieldReferenceMutator,DEFAULT_BUFFER_SIZE,0,1,0.13565125,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
125,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,FieldReferenceMutator,DEFAULT_BUFFER_SIZE,capacity,2,0.12566428,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
126,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,FieldReferenceMutator,DEFAULT_BUFFER_SIZE,1024,3,0.029645784,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
127,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,FieldReferenceMutator,DEFAULT_BUFFER_SIZE,length,4,0.025477322,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
128,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15205,15205,AssignmentMutator,pos=0,|,0,0.39245072,pos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos<mask>= 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
129,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15205,15205,AssignmentMutator,pos=0,*,1,0.27559638,pos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos<mask>= 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
130,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15205,15205,AssignmentMutator,pos=0,&,2,0.05735226,pos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos<mask>= 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
131,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15205,15205,AssignmentMutator,pos=0,^,3,0.056953393,pos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos<mask>= 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
132,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15205,15205,AssignmentMutator,pos=0,<<,4,0.027322184,pos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos<mask>= 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
133,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15202,15204,IdentifierMutator-Variable,pos,position,1,0.247314,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
134,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15202,15204,IdentifierMutator-Variable,pos,offset,2,0.1119119,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
135,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15202,15204,IdentifierMutator-Variable,pos,size,3,0.048590504,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
136,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15202,15204,IdentifierMutator-Variable,pos,length,4,0.034745116,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
137,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15202,15204,FieldReferenceMutator,pos,position,1,0.247314,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
138,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15202,15204,FieldReferenceMutator,pos,offset,2,0.1119119,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
139,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15202,15204,FieldReferenceMutator,pos,size,3,0.048590504,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
140,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15202,15204,FieldReferenceMutator,pos,length,4,0.034745116,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
141,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15208,15208,IdentifierMutator-Literal,0,pos,1,0.013057393,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos =<mask>;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
142,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15208,15208,IdentifierMutator-Literal,0,1,2,0.005226168,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos =<mask>;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
143,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15208,15208,IdentifierMutator-Literal,0,position,3,0.005217901,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos =<mask>;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
144,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15208,15208,IdentifierMutator-Literal,0,size,4,0.0017768156,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos =<mask>;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
145,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15230,15230,AssignmentMutator,readPos=0,|,0,0.37869298,readPos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos<mask>= 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
146,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15230,15230,AssignmentMutator,readPos=0,*,1,0.21572544,readPos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos<mask>= 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
147,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15230,15230,AssignmentMutator,readPos=0,&,2,0.16219305,readPos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos<mask>= 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
148,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15230,15230,AssignmentMutator,readPos=0,/,3,0.05325817,readPos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos<mask>= 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
149,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15230,15230,AssignmentMutator,readPos=0,^,4,0.048508678,readPos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos<mask>= 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
150,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,IdentifierMutator-Variable,readPos,offset,0,0.19163232,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
151,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,IdentifierMutator-Variable,readPos,limit,1,0.09158048,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
152,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,IdentifierMutator-Variable,readPos,size,2,0.0835456,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
153,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,IdentifierMutator-Variable,readPos,count,3,0.062918335,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
154,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,IdentifierMutator-Variable,readPos,length,4,0.061428133,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
155,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,FieldReferenceMutator,readPos,offset,0,0.19163232,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
156,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,FieldReferenceMutator,readPos,limit,1,0.09158048,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
157,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,FieldReferenceMutator,readPos,size,2,0.0835456,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
158,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,FieldReferenceMutator,readPos,count,3,0.062918335,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
159,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,FieldReferenceMutator,readPos,length,4,0.061428133,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
160,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15233,15233,IdentifierMutator-Literal,0,pos,1,0.32420737,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos =<mask>;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
161,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15233,15233,IdentifierMutator-Literal,0,position,2,0.015387487,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos =<mask>;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
162,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15233,15233,IdentifierMutator-Literal,0,1,3,0.007912336,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos =<mask>;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
163,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15233,15233,IdentifierMutator-Literal,0,offset,4,0.0037060792,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos =<mask>;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
164,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15298,15300,BinaryOperatorMutator,*,/,2,0.05686551,buffer.length <mask> org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length<mask>DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
165,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15298,15300,BinaryOperatorMutator,*,/,3,0.010096999,buffer.length <mask> org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length<mask>DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
166,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15298,15300,BinaryOperatorMutator,*,//,4,0.0057115383,buffer.length <mask> org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length<mask>DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
167,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15297,IdentifierMutator-Variable,buffer.length,size,0,0.15002394,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
168,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15297,IdentifierMutator-Variable,buffer.length,1024,1,0.09849174,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
169,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15297,IdentifierMutator-Variable,buffer.length,2,2,0.05713501,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
170,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15297,IdentifierMutator-Variable,buffer.length,SIZE,3,0.042523887,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
171,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15297,IdentifierMutator-Variable,buffer.length,8,4,0.036943916,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
172,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15290,IdentifierMutator-Variable,buffer,Buffer,1,0.0046080067,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask>.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
173,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15290,IdentifierMutator-Variable,buffer,buf,3,3.1533375E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask>.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
174,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15290,IdentifierMutator-Variable,buffer,queue,4,1.9087548E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask>.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
175,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15290,FieldReferenceMutator,buffer,Buffer,1,0.0046080067,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask>.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
176,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15290,FieldReferenceMutator,buffer,buf,3,3.1533375E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask>.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
177,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15290,FieldReferenceMutator,buffer,queue,4,1.9087548E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask>.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
178,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15292,15297,FieldReferenceMutator,length,size,1,5.9637625E-4,buffer.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
179,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15292,15297,FieldReferenceMutator,length,capacity,2,5.5692275E-4,buffer.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
180,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15292,15297,FieldReferenceMutator,length,position,3,8.739172E-5,buffer.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
181,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,2,0,0.6583112,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
182,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,4,1,0.15488945,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
183,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,3,2,0.051842883,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
184,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,8,3,0.037875786,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
185,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,1024,4,0.0108403815,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
186,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,FieldReferenceMutator,DEFAULT_BUFFER_RESIZE_FACTOR,2,0,0.6583112,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
187,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,FieldReferenceMutator,DEFAULT_BUFFER_RESIZE_FACTOR,4,1,0.15488945,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
188,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,FieldReferenceMutator,DEFAULT_BUFFER_RESIZE_FACTOR,3,2,0.051842883,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
189,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,FieldReferenceMutator,DEFAULT_BUFFER_RESIZE_FACTOR,8,3,0.037875786,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
190,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,FieldReferenceMutator,DEFAULT_BUFFER_RESIZE_FACTOR,1024,4,0.0108403815,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
191,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15351,15359,MethodCallMutator,arraycopy,copy,0,0.98117334,"System.<mask>(buffer, 0, b, 0, buffer.length)","void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.<mask>(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
192,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15351,15359,MethodCallMutator,arraycopy,array,1,0.0031739804,"System.<mask>(buffer, 0, b, 0, buffer.length)","void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.<mask>(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
193,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15351,15359,MethodCallMutator,arraycopy,write,2,0.0031280164,"System.<mask>(buffer, 0, b, 0, buffer.length)","void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.<mask>(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
194,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15351,15359,MethodCallMutator,arraycopy,bytes,3,0.0029730068,"System.<mask>(buffer, 0, b, 0, buffer.length)","void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.<mask>(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
195,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15351,15359,MethodCallMutator,arraycopy,read,4,0.0015968026,"System.<mask>(buffer, 0, b, 0, buffer.length)","void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.<mask>(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
196,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15361,15366,IdentifierMutator-Variable,buffer,Buffer,2,1.1309912E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(<mask>, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
197,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15361,15366,IdentifierMutator-Variable,buffer,buf,3,2.4314462E-5,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(<mask>, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
198,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15361,15366,IdentifierMutator-Variable,buffer,source,4,2.391295E-5,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(<mask>, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
199,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15361,15366,FieldReferenceMutator,buffer,Buffer,2,1.1309912E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(<mask>, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
200,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15361,15366,FieldReferenceMutator,buffer,buf,3,2.4314462E-5,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(<mask>, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
201,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15361,15366,FieldReferenceMutator,buffer,source,4,2.391295E-5,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(<mask>, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
202,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15369,15369,IdentifierMutator-Literal,0,pos,1,0.010127073,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer,<mask>, b, 0, buffer.length);
            buffer = b;
        }
    }"
203,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15369,15369,IdentifierMutator-Literal,0,1,2,0.007938074,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer,<mask>, b, 0, buffer.length);
            buffer = b;
        }
    }"
204,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15369,15369,IdentifierMutator-Literal,0,length,3,0.003676184,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer,<mask>, b, 0, buffer.length);
            buffer = b;
        }
    }"
205,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15369,15369,IdentifierMutator-Literal,0,len,4,0.0019418129,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer,<mask>, b, 0, buffer.length);
            buffer = b;
        }
    }"
206,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15372,15372,IdentifierMutator-Variable,b,buffer,1,7.7730726E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0,<mask>, 0, buffer.length);
            buffer = b;
        }
    }"
207,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15372,15372,IdentifierMutator-Variable,b,a,2,3.4320206E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0,<mask>, 0, buffer.length);
            buffer = b;
        }
    }"
208,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15372,15372,IdentifierMutator-Variable,b,buf,3,2.3874287E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0,<mask>, 0, buffer.length);
            buffer = b;
        }
    }"
209,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15375,15375,IdentifierMutator-Literal,0,pos,1,0.044146985,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b,<mask>, buffer.length);
            buffer = b;
        }
    }"
210,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15375,15375,IdentifierMutator-Literal,0,1,2,0.02007706,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b,<mask>, buffer.length);
            buffer = b;
        }
    }"
211,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15375,15375,IdentifierMutator-Literal,0,size,3,0.0020945072,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b,<mask>, buffer.length);
            buffer = b;
        }
    }"
212,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15375,15375,IdentifierMutator-Literal,0,4,4,0.0019141458,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b,<mask>, buffer.length);
            buffer = b;
        }
    }"
213,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15390,IdentifierMutator-Variable,buffer.length,pos,0,0.93046486,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>);
            buffer = b;
        }
    }"
214,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15390,IdentifierMutator-Variable,buffer.length,len,1,0.022601316,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>);
            buffer = b;
        }
    }"
215,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15390,IdentifierMutator-Variable,buffer.length,size,2,0.007844301,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>);
            buffer = b;
        }
    }"
216,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15390,IdentifierMutator-Variable,buffer.length,n,3,0.005124929,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>);
            buffer = b;
        }
    }"
217,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15390,IdentifierMutator-Variable,buffer.length,offset,4,0.0050978553,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>);
            buffer = b;
        }
    }"
218,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15383,IdentifierMutator-Variable,buffer,b,1,0.0108165145,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>.length);
            buffer = b;
        }
    }"
219,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15383,IdentifierMutator-Variable,buffer,buf,3,7.636923E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>.length);
            buffer = b;
        }
    }"
220,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15383,IdentifierMutator-Variable,buffer,buffers,4,4.4694712E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>.length);
            buffer = b;
        }
    }"
221,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15383,FieldReferenceMutator,buffer,b,1,0.0108165145,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>.length);
            buffer = b;
        }
    }"
222,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15383,FieldReferenceMutator,buffer,buf,3,7.636923E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>.length);
            buffer = b;
        }
    }"
223,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15383,FieldReferenceMutator,buffer,buffers,4,4.4694712E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>.length);
            buffer = b;
        }
    }"
224,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15385,15390,FieldReferenceMutator,length,position,1,1.21198726E-4,buffer.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.<mask>);
            buffer = b;
        }
    }"
225,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15385,15390,FieldReferenceMutator,length,size,3,2.1060217E-5,buffer.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.<mask>);
            buffer = b;
        }
    }"
226,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15385,15390,FieldReferenceMutator,length,count,4,1.6033995E-5,buffer.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.<mask>);
            buffer = b;
        }
    }"
227,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15412,15412,AssignmentMutator,buffer=b,[],0,0.540444,buffer <mask>= b,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer<mask>= b;
        }
    }"
228,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15412,15412,AssignmentMutator,buffer=b,|,1,0.22721569,buffer <mask>= b,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer<mask>= b;
        }
    }"
229,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15412,15412,AssignmentMutator,buffer=b,.,2,0.06996397,buffer <mask>= b,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer<mask>= b;
        }
    }"
230,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15412,15412,AssignmentMutator,buffer=b,.,3,0.04075797,buffer <mask>= b,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer<mask>= b;
        }
    }"
231,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15412,15412,AssignmentMutator,buffer=b,^,4,0.026115466,buffer <mask>= b,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer<mask>= b;
        }
    }"
232,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15406,15411,IdentifierMutator-Variable,buffer,buf,2,8.3654636E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);<mask> = b;
        }
    }"
233,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15406,15411,IdentifierMutator-Variable,buffer,buffers,3,7.569468E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);<mask> = b;
        }
    }"
234,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15406,15411,IdentifierMutator-Variable,buffer,Buffer,4,7.2781055E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);<mask> = b;
        }
    }"
235,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15406,15411,FieldReferenceMutator,buffer,buf,2,8.3654636E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);<mask> = b;
        }
    }"
236,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15406,15411,FieldReferenceMutator,buffer,buffers,3,7.569468E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);<mask> = b;
        }
    }"
237,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15406,15411,FieldReferenceMutator,buffer,Buffer,4,7.2781055E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);<mask> = b;
        }
    }"
238,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15415,15415,IdentifierMutator-Variable,b,null,1,0.04959017,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer =<mask>;
        }
    }"
239,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15415,15415,IdentifierMutator-Variable,b,0,2,7.0119475E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer =<mask>;
        }
    }"
240,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15415,15415,IdentifierMutator-Variable,b,a,4,4.905091E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer =<mask>;
        }
    }"
241,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16094,16097,BinaryOperatorMutator,!=,==,1,0.45218226,buffer <mask> null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer<mask>null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
242,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16094,16097,BinaryOperatorMutator,!=,==,2,0.047833145,buffer <mask> null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer<mask>null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
243,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16094,16097,BinaryOperatorMutator,!=,=,3,0.03781092,buffer <mask> null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer<mask>null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
244,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16094,16097,BinaryOperatorMutator,!=,.,4,0.0011795348,buffer <mask> null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer<mask>null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
245,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16088,16093,IdentifierMutator-Variable,buffer,Buffer,2,0.001379807,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
246,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16088,16093,IdentifierMutator-Variable,buffer,buf,3,0.0012884246,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
247,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16088,16093,IdentifierMutator-Variable,buffer,b,4,9.435706E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
248,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16088,16093,FieldReferenceMutator,buffer,Buffer,2,0.001379807,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
249,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16088,16093,FieldReferenceMutator,buffer,buf,3,0.0012884246,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
250,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16088,16093,FieldReferenceMutator,buffer,b,4,9.435706E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
251,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16098,16101,IdentifierMutator-Literal,null,NULL,2,1.9541365E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer !=<mask>) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
252,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16098,16101,IdentifierMutator-Literal,null,nil,3,1.2972395E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer !=<mask>) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
253,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16098,16101,IdentifierMutator-Literal,null,undefined,4,8.553869E-5,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer !=<mask>) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
254,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16133,16135,MethodCallMutator,min,max,1,0.43923885,"Math.<mask>(avail(), bAvail)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.<mask>(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
255,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16133,16135,MethodCallMutator,min,div,3,0.00548859,"Math.<mask>(avail(), bAvail)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.<mask>(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
256,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16133,16135,MethodCallMutator,min,max,4,0.0036105274,"Math.<mask>(avail(), bAvail)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.<mask>(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
257,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16137,16141,MethodCallMutator,avail,len,0,0.21274447,<mask>(),"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(<mask>(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
258,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16137,16141,MethodCallMutator,avail,size,1,0.20552523,<mask>(),"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(<mask>(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
259,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16137,16141,MethodCallMutator,avail,length,2,0.14602524,<mask>(),"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(<mask>(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
260,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16137,16141,MethodCallMutator,avail,limit,3,0.059206054,<mask>(),"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(<mask>(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
261,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16137,16141,MethodCallMutator,avail,pos,4,0.048109766,<mask>(),"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(<mask>(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
262,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16146,16151,IdentifierMutator-Variable,bAvail,pos,0,0.6592787,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(),<mask>);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
263,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16146,16151,IdentifierMutator-Variable,bAvail,len,1,0.13366164,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(),<mask>);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
264,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16146,16151,IdentifierMutator-Variable,bAvail,avail,2,0.053922977,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(),<mask>);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
265,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16146,16151,IdentifierMutator-Variable,bAvail,size,3,0.015085614,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(),<mask>);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
266,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16146,16151,IdentifierMutator-Variable,bAvail,limit,4,0.011050773,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(),<mask>);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
267,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16174,16182,MethodCallMutator,arraycopy,copy,0,0.99833965,"System.<mask>(buffer, readPos, b, bPos, len)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.<mask>(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
268,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16174,16182,MethodCallMutator,arraycopy,fill,1,3.4171567E-4,"System.<mask>(buffer, readPos, b, bPos, len)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.<mask>(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
269,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16174,16182,MethodCallMutator,arraycopy,write,2,2.0039365E-4,"System.<mask>(buffer, readPos, b, bPos, len)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.<mask>(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
270,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16174,16182,MethodCallMutator,arraycopy,array,3,1.7687648E-4,"System.<mask>(buffer, readPos, b, bPos, len)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.<mask>(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
271,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16174,16182,MethodCallMutator,arraycopy,printf,4,1.7013906E-4,"System.<mask>(buffer, readPos, b, bPos, len)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.<mask>(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
272,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16184,16189,IdentifierMutator-Variable,buffer,buf,1,0.01167198,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(<mask>, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
273,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16184,16189,IdentifierMutator-Variable,buffer,b,2,0.008444166,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(<mask>, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
274,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16184,16189,IdentifierMutator-Variable,buffer,buff,3,0.0029453745,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(<mask>, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
275,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16184,16189,IdentifierMutator-Variable,buffer,a,4,0.0023439303,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(<mask>, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
276,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16184,16189,FieldReferenceMutator,buffer,buf,1,0.01167198,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(<mask>, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
277,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16184,16189,FieldReferenceMutator,buffer,b,2,0.008444166,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(<mask>, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
278,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16184,16189,FieldReferenceMutator,buffer,buff,3,0.0029453745,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(<mask>, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
279,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16184,16189,FieldReferenceMutator,buffer,a,4,0.0023439303,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(<mask>, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
280,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16192,16198,IdentifierMutator-Variable,readPos,0,0,0.9508908,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer,<mask>, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
281,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16192,16198,IdentifierMutator-Variable,readPos,pos,1,0.02585314,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer,<mask>, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
282,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16192,16198,IdentifierMutator-Variable,readPos,off,2,0.011324168,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer,<mask>, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
283,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16192,16198,IdentifierMutator-Variable,readPos,offset,3,0.002104259,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer,<mask>, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
284,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16192,16198,IdentifierMutator-Variable,readPos,1,4,0.0016274123,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer,<mask>, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
285,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16192,16198,FieldReferenceMutator,readPos,0,0,0.9508908,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer,<mask>, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
286,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16192,16198,FieldReferenceMutator,readPos,pos,1,0.02585314,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer,<mask>, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
287,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16192,16198,FieldReferenceMutator,readPos,off,2,0.011324168,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer,<mask>, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
288,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16192,16198,FieldReferenceMutator,readPos,offset,3,0.002104259,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer,<mask>, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
289,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16192,16198,FieldReferenceMutator,readPos,1,4,0.0016274123,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer,<mask>, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
290,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16201,16201,IdentifierMutator-Variable,b,a,1,0.0011328368,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos,<mask>, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
291,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16201,16201,IdentifierMutator-Variable,b,buffer,2,2.3662632E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos,<mask>, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
292,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16201,16201,IdentifierMutator-Variable,b,buf,3,1.8105848E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos,<mask>, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
293,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16204,16207,IdentifierMutator-Variable,bPos,pos,0,0.56247526,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b,<mask>, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
294,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16204,16207,IdentifierMutator-Variable,bPos,0,1,0.34757817,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b,<mask>, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
295,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16204,16207,IdentifierMutator-Variable,bPos,off,2,0.05494578,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b,<mask>, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
296,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16204,16207,IdentifierMutator-Variable,bPos,offset,3,0.01869896,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b,<mask>, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
297,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16204,16207,IdentifierMutator-Variable,bPos,Pos,4,0.0021752357,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b,<mask>, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
298,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16210,16212,IdentifierMutator-Variable,len,pos,1,0.001361776,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos,<mask>);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
299,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16210,16212,IdentifierMutator-Variable,len,buf,3,1.345864E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos,<mask>);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
300,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16210,16212,IdentifierMutator-Variable,len,length,4,1.2441842E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos,<mask>);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
301,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16235,16235,AssignmentMutator,readPos+=len,++,0,0.23853356,readPos <mask>= len,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos<mask>+= len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
302,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16235,16235,AssignmentMutator,readPos+=len,*,1,0.14060964,readPos <mask>= len,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos<mask>+= len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
303,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16235,16235,AssignmentMutator,readPos+=len,*,2,0.107039355,readPos <mask>= len,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos<mask>+= len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
304,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16235,16235,AssignmentMutator,readPos+=len,//,3,0.051434364,readPos <mask>= len,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos<mask>+= len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
305,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16235,16235,AssignmentMutator,readPos+=len,|,4,0.03569236,readPos <mask>= len,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos<mask>+= len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
306,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16228,16234,IdentifierMutator-Variable,readPos,pos,0,0.97443265,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
307,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16228,16234,IdentifierMutator-Variable,readPos,pos,1,0.00805827,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
308,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16228,16234,IdentifierMutator-Variable,readPos,position,2,0.0028835642,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
309,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16228,16234,IdentifierMutator-Variable,readPos,offset,3,0.0021928048,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
310,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16228,16234,IdentifierMutator-Variable,readPos,buf,4,0.0011568589,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
311,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16228,16234,FieldReferenceMutator,readPos,pos,0,0.97443265,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
312,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16228,16234,FieldReferenceMutator,readPos,pos,1,0.00805827,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
313,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16228,16234,FieldReferenceMutator,readPos,position,2,0.0028835642,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
314,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16228,16234,FieldReferenceMutator,readPos,offset,3,0.0021928048,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
315,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16228,16234,FieldReferenceMutator,readPos,buf,4,0.0011568589,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
316,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16239,16241,IdentifierMutator-Variable,len,1,1,3.2851513E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos +=<mask>;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
317,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16239,16241,IdentifierMutator-Variable,len,pos,2,1.470315E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos +=<mask>;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
318,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16239,16241,IdentifierMutator-Variable,len,2,3,1.19557204E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos +=<mask>;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
319,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16239,16241,IdentifierMutator-Variable,len,length,4,9.130195E-5,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos +=<mask>;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
320,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16267,16270,BinaryOperatorMutator,>=,==,0,0.41370165,readPos <mask> pos,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos<mask>pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
321,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16267,16270,BinaryOperatorMutator,>=,<,1,0.2689006,readPos <mask> pos,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos<mask>pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
322,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16267,16270,BinaryOperatorMutator,>=,==,2,0.06717408,readPos <mask> pos,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos<mask>pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
323,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16267,16270,BinaryOperatorMutator,>=,<=,3,0.060286615,readPos <mask> pos,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos<mask>pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
324,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16267,16270,BinaryOperatorMutator,>=,!=,4,0.044120852,readPos <mask> pos,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos<mask>pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
325,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16260,16266,IdentifierMutator-Variable,readPos,len,0,0.42013893,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (<mask> >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
326,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16260,16266,IdentifierMutator-Variable,readPos,end,1,0.16804026,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (<mask> >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
327,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16260,16266,IdentifierMutator-Variable,readPos,pos,2,0.056399062,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (<mask> >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
328,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16260,16266,IdentifierMutator-Variable,readPos,offset,3,0.030005377,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (<mask> >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
329,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16260,16266,IdentifierMutator-Variable,readPos,length,4,0.021527313,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (<mask> >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
330,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16260,16266,FieldReferenceMutator,readPos,len,0,0.42013893,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (<mask> >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
331,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16260,16266,FieldReferenceMutator,readPos,end,1,0.16804026,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (<mask> >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
332,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16260,16266,FieldReferenceMutator,readPos,pos,2,0.056399062,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (<mask> >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
333,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16260,16266,FieldReferenceMutator,readPos,offset,3,0.030005377,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (<mask> >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
334,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16260,16266,FieldReferenceMutator,readPos,length,4,0.021527313,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (<mask> >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
335,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16271,16273,IdentifierMutator-Variable,pos,len,0,0.28455284,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >=<mask>) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
336,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16271,16273,IdentifierMutator-Variable,pos,limit,1,0.21690519,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >=<mask>) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
337,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16271,16273,IdentifierMutator-Variable,pos,0,2,0.06752911,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >=<mask>) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
338,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16271,16273,IdentifierMutator-Variable,pos,avail,3,0.043255575,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >=<mask>) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
339,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16271,16273,IdentifierMutator-Variable,pos,length,4,0.03642658,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >=<mask>) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
340,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16271,16273,FieldReferenceMutator,pos,len,0,0.28455284,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >=<mask>) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
341,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16271,16273,FieldReferenceMutator,pos,limit,1,0.21690519,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >=<mask>) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
342,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16271,16273,FieldReferenceMutator,pos,0,2,0.06752911,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >=<mask>) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
343,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16271,16273,FieldReferenceMutator,pos,avail,3,0.043255575,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >=<mask>) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
344,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16271,16273,FieldReferenceMutator,pos,length,4,0.03642658,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >=<mask>) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
345,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16300,16300,AssignmentMutator,buffer=null,&,0,0.36721906,buffer <mask>= null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer<mask>= null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
346,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16300,16300,AssignmentMutator,buffer=null,*,1,0.16766943,buffer <mask>= null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer<mask>= null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
347,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16300,16300,AssignmentMutator,buffer=null,!,2,0.15266971,buffer <mask>= null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer<mask>= null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
348,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16300,16300,AssignmentMutator,buffer=null,|,3,0.10399579,buffer <mask>= null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer<mask>= null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
349,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16300,16300,AssignmentMutator,buffer=null,||,4,0.048361983,buffer <mask>= null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer<mask>= null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
350,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16294,16299,IdentifierMutator-Variable,buffer,reader,1,0.0015831838,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
351,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16294,16299,IdentifierMutator-Variable,buffer,buf,3,0.001275371,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
352,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16294,16299,IdentifierMutator-Variable,buffer,buffers,4,7.604636E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
353,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16294,16299,FieldReferenceMutator,buffer,reader,1,0.0015831838,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
354,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16294,16299,FieldReferenceMutator,buffer,buf,3,0.001275371,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
355,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16294,16299,FieldReferenceMutator,buffer,buffers,4,7.604636E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
356,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16303,16306,IdentifierMutator-Literal,null,b,1,0.0015397727,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer =<mask>;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
357,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16303,16306,IdentifierMutator-Literal,null,nil,2,0.0015025269,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer =<mask>;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
358,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16303,16306,IdentifierMutator-Literal,null,"""""",3,0.0010780207,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer =<mask>;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
359,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16303,16306,IdentifierMutator-Literal,null,undefined,4,7.549706E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer =<mask>;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
360,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,414,16342,16344,IdentifierMutator-Variable,len,pos,0,0.55149883,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return<mask>;
        }
        return eof ? -1 : 0;
    }"
361,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,414,16342,16344,IdentifierMutator-Variable,len,0,1,0.14823556,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return<mask>;
        }
        return eof ? -1 : 0;
    }"
362,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,414,16342,16344,IdentifierMutator-Variable,len,1,3,0.018986786,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return<mask>;
        }
        return eof ? -1 : 0;
    }"
363,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,414,16342,16344,IdentifierMutator-Variable,len,ret,4,0.01760152,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return<mask>;
        }
        return eof ? -1 : 0;
    }"
364,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16372,16383,IdentifierMutator-Conditional,eof?-1:0,pos,0,0.4132851,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return<mask>;
    }"
365,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16372,16383,IdentifierMutator-Conditional,eof?-1:0,0,1,0.39153162,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return<mask>;
    }"
366,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16372,16383,IdentifierMutator-Conditional,eof?-1:0,len,2,0.06130656,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return<mask>;
    }"
367,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16372,16383,IdentifierMutator-Conditional,eof?-1:0,1,3,0.014663061,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return<mask>;
    }"
368,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16372,16383,IdentifierMutator-Conditional,eof?-1:0,avail,4,0.008316818,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return<mask>;
    }"
369,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16372,16374,IdentifierMutator-Variable,eof,negative,0,0.46555838,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
370,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16372,16374,IdentifierMutator-Variable,eof,partial,1,0.027055623,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
371,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16372,16374,IdentifierMutator-Variable,eof,done,2,0.01645625,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
372,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16372,16374,IdentifierMutator-Variable,eof,0,3,0.015793405,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
373,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16372,16374,IdentifierMutator-Variable,eof,empty,4,0.013175751,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
374,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16372,16374,FieldReferenceMutator,eof,negative,0,0.46555838,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
375,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16372,16374,FieldReferenceMutator,eof,partial,1,0.027055623,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
376,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16372,16374,FieldReferenceMutator,eof,done,2,0.01645625,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
377,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16372,16374,FieldReferenceMutator,eof,0,3,0.015793405,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
378,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16372,16374,FieldReferenceMutator,eof,empty,4,0.013175751,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
379,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16378,16378,UnaryOperatorMutator,-,+,1,0.002213229,<mask>1,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ?<mask>1 : 0;
    }"
380,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16378,16378,UnaryOperatorMutator,-,$,3,3.0042714E-4,<mask>1,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ?<mask>1 : 0;
    }"
381,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16378,16378,UnaryOperatorMutator,-,.,4,2.4760352E-4,<mask>1,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ?<mask>1 : 0;
    }"
382,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16379,16379,IdentifierMutator-Literal,1,2,2,6.3267804E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -<mask> : 0;
    }"
383,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16379,16379,IdentifierMutator-Literal,1,2,3,5.305354E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -<mask> : 0;
    }"
384,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16379,16379,IdentifierMutator-Literal,1,L,4,1.7710835E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -<mask> : 0;
    }"
385,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16383,16383,IdentifierMutator-Literal,0,pos,0,0.37865454,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 :<mask>;
    }"
386,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16383,16383,IdentifierMutator-Literal,0,len,2,0.20832486,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 :<mask>;
    }"
387,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16383,16383,IdentifierMutator-Literal,0,1,3,0.022323206,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 :<mask>;
    }"
388,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,416,16383,16383,IdentifierMutator-Literal,0,ret,4,0.022128034,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            System.arraycopy(buffer, readPos, b, bPos, len);
            readPos += len;
            if (readPos >= pos) {
                buffer = null;
            }
            return len;
        }
        return eof ? -1 :<mask>;
    }"
389,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,438,17242,17244,IdentifierMutator-Variable,eof,done,0,0.19429876,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
390,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,438,17242,17244,IdentifierMutator-Variable,eof,finished,1,0.16145582,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
391,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,438,17242,17244,IdentifierMutator-Variable,eof,end,2,0.074207194,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
392,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,438,17242,17244,IdentifierMutator-Variable,eof,stop,3,0.066900685,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
393,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,438,17242,17244,IdentifierMutator-Variable,eof,error,4,0.0407589,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
394,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,438,17242,17244,FieldReferenceMutator,eof,done,0,0.19429876,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
395,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,438,17242,17244,FieldReferenceMutator,eof,finished,1,0.16145582,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
396,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,438,17242,17244,FieldReferenceMutator,eof,end,2,0.074207194,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
397,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,438,17242,17244,FieldReferenceMutator,eof,stop,3,0.066900685,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
398,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,438,17242,17244,FieldReferenceMutator,eof,error,4,0.0407589,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
399,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,443,17400,17402,BinaryOperatorMutator,<,>,1,0.25205335,inAvail <mask> 0,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail<mask>0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
400,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,443,17400,17402,BinaryOperatorMutator,<,>,3,0.053521637,inAvail <mask> 0,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail<mask>0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
401,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,443,17400,17402,BinaryOperatorMutator,<,==,4,0.052368738,inAvail <mask> 0,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail<mask>0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
402,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,443,17393,17399,IdentifierMutator-Variable,inAvail,pos,0,0.7517562,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (<mask> < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
403,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,443,17393,17399,IdentifierMutator-Variable,inAvail,offset,1,0.08945218,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (<mask> < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
404,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,443,17393,17399,IdentifierMutator-Variable,inAvail,abs,2,0.0102591915,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (<mask> < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
405,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,443,17393,17399,IdentifierMutator-Variable,inAvail,off,3,0.007988152,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (<mask> < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
406,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,443,17393,17399,IdentifierMutator-Variable,inAvail,i,4,0.0068571665,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (<mask> < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
407,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,443,17403,17403,IdentifierMutator-Literal,0,1,1,0.0028293866,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail <<mask>) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
408,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,443,17403,17403,IdentifierMutator-Literal,0,pos,3,1.4442338E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail <<mask>) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
409,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,443,17403,17403,IdentifierMutator-Literal,0,size,4,1.2638369E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail <<mask>) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
410,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,444,17423,17423,AssignmentMutator,eof=true,|,0,0.97770643,eof <mask>= true,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof<mask>= true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
411,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,444,17423,17423,AssignmentMutator,eof=true,&,1,0.008145292,eof <mask>= true,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof<mask>= true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
412,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,444,17423,17423,AssignmentMutator,eof=true,!,2,0.0038271723,eof <mask>= true,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof<mask>= true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
413,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,444,17423,17423,AssignmentMutator,eof=true,|,3,0.0017310834,eof <mask>= true,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof<mask>= true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
414,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,444,17423,17423,AssignmentMutator,eof=true,||,4,0.0016703724,eof <mask>= true,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof<mask>= true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
415,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,444,17420,17422,IdentifierMutator-Variable,eof,done,0,0.5250192,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
416,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,444,17420,17422,IdentifierMutator-Variable,eof,finished,1,0.12915988,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
417,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,444,17420,17422,IdentifierMutator-Variable,eof,ended,2,0.03053205,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
418,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,444,17420,17422,IdentifierMutator-Variable,eof,closed,3,0.029502647,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
419,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,444,17420,17422,IdentifierMutator-Variable,eof,end,4,0.027778732,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
420,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,444,17420,17422,FieldReferenceMutator,eof,done,0,0.5250192,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
421,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,444,17420,17422,FieldReferenceMutator,eof,finished,1,0.12915988,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
422,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,444,17420,17422,FieldReferenceMutator,eof,ended,2,0.03053205,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
423,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,444,17420,17422,FieldReferenceMutator,eof,closed,3,0.029502647,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
424,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,444,17420,17422,FieldReferenceMutator,eof,end,4,0.027778732,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
425,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,444,17426,17429,IdentifierMutator-Literal,true,false,1,0.018989656,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof =<mask>;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
426,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,444,17426,17429,IdentifierMutator-Literal,true,TRUE,2,3.1368452E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof =<mask>;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
427,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,444,17426,17429,IdentifierMutator-Literal,true,1,4,1.6627122E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof =<mask>;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
428,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17462,17465,BinaryOperatorMutator,||,|,2,0.0071264445,(buffer == null) <mask> ((buffer.length - pos) < encodeSize),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null<mask>buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
429,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17462,17465,BinaryOperatorMutator,||,.,3,0.0054187533,(buffer == null) <mask> ((buffer.length - pos) < encodeSize),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null<mask>buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
430,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17462,17465,BinaryOperatorMutator,||,?,4,0.0022501089,(buffer == null) <mask> ((buffer.length - pos) < encodeSize),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null<mask>buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
431,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17454,17457,BinaryOperatorMutator,==,=,2,0.0045053973,buffer <mask> null,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer<mask>null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
432,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17454,17457,BinaryOperatorMutator,==,===,3,0.003271591,buffer <mask> null,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer<mask>null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
433,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17454,17457,BinaryOperatorMutator,==,_,4,7.145099E-4,buffer <mask> null,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer<mask>null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
434,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17448,17453,IdentifierMutator-Variable,buffer,buf,1,0.0022869138,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (<mask> == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
435,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17448,17453,IdentifierMutator-Variable,buffer,queue,2,0.0013071565,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (<mask> == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
436,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17448,17453,IdentifierMutator-Variable,buffer,Buffer,4,0.001093673,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (<mask> == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
437,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17448,17453,FieldReferenceMutator,buffer,buf,1,0.0022869138,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (<mask> == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
438,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17448,17453,FieldReferenceMutator,buffer,queue,2,0.0013071565,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (<mask> == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
439,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17448,17453,FieldReferenceMutator,buffer,Buffer,4,0.001093673,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (<mask> == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
440,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17458,17461,IdentifierMutator-Literal,null,NULL,1,7.0559524E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer ==<mask> || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
441,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17458,17461,IdentifierMutator-Literal,null,nil,2,6.426485E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer ==<mask> || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
442,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17458,17461,IdentifierMutator-Literal,null,undefined,4,1.4356709E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer ==<mask> || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
443,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17485,17487,BinaryOperatorMutator,<,>,1,0.18230161,(buffer.length - pos) <mask> encodeSize,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos<mask>encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
444,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17485,17487,BinaryOperatorMutator,<,>,3,0.090189576,(buffer.length - pos) <mask> encodeSize,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos<mask>encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
445,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17485,17487,BinaryOperatorMutator,<,==,4,0.067225225,(buffer.length - pos) <mask> encodeSize,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos<mask>encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
446,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17479,17481,BinaryOperatorMutator,-,*,1,0.15344656,buffer.length <mask> pos,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length<mask>pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
447,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17479,17481,BinaryOperatorMutator,-,+,2,0.1075529,buffer.length <mask> pos,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length<mask>pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
448,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17479,17481,BinaryOperatorMutator,-,/,3,0.05484094,buffer.length <mask> pos,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length<mask>pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
449,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17479,17481,BinaryOperatorMutator,-,_,4,0.02774839,buffer.length <mask> pos,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length<mask>pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
450,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17466,17478,IdentifierMutator-Variable,buffer.length,size,0,0.36834443,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
451,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17466,17478,IdentifierMutator-Variable,buffer.length,limit,1,0.14885868,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
452,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17466,17478,IdentifierMutator-Variable,buffer.length,length,2,0.06917371,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
453,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17466,17478,IdentifierMutator-Variable,buffer.length,capacity,3,0.062514275,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
454,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17466,17478,IdentifierMutator-Variable,buffer.length,end,4,0.041550223,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
455,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17466,17471,IdentifierMutator-Variable,buffer,buf,1,0.0018659565,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask>.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
456,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17466,17471,IdentifierMutator-Variable,buffer,buffers,2,0.0014083367,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask>.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
457,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17466,17471,IdentifierMutator-Variable,buffer,input,4,4.2346347E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask>.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
458,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17466,17471,FieldReferenceMutator,buffer,buf,1,0.0018659565,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask>.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
459,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17466,17471,FieldReferenceMutator,buffer,buffers,2,0.0014083367,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask>.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
460,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17466,17471,FieldReferenceMutator,buffer,input,4,4.2346347E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask>.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
461,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17473,17478,FieldReferenceMutator,length,size,1,0.003997627,buffer.<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
462,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17473,17478,FieldReferenceMutator,length,position,2,0.0032238394,buffer.<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
463,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17473,17478,FieldReferenceMutator,length,len,3,0.0021605846,buffer.<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
464,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17473,17478,FieldReferenceMutator,length,capacity,4,0.0014499035,buffer.<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
465,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17482,17484,IdentifierMutator-Variable,pos,offset,1,0.06881157,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
466,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17482,17484,IdentifierMutator-Variable,pos,size,2,0.025420422,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
467,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17482,17484,IdentifierMutator-Variable,pos,1,3,0.022509627,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
468,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17482,17484,IdentifierMutator-Variable,pos,len,4,0.020821935,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
469,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17482,17484,FieldReferenceMutator,pos,offset,1,0.06881157,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
470,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17482,17484,FieldReferenceMutator,pos,size,2,0.025420422,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
471,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17482,17484,FieldReferenceMutator,pos,1,3,0.022509627,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
472,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17482,17484,FieldReferenceMutator,pos,len,4,0.020821935,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
473,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17488,17497,IdentifierMutator-Variable,encodeSize,0,0,0.20743708,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
474,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17488,17497,IdentifierMutator-Variable,encodeSize,limit,1,0.19221807,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
475,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17488,17497,IdentifierMutator-Variable,encodeSize,length,2,0.050543293,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
476,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17488,17497,IdentifierMutator-Variable,encodeSize,size,3,0.047710393,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
477,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17488,17497,IdentifierMutator-Variable,encodeSize,len,4,0.04746102,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
478,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17488,17497,FieldReferenceMutator,encodeSize,0,0,0.20743708,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
479,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17488,17497,FieldReferenceMutator,encodeSize,limit,1,0.19221807,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
480,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17488,17497,FieldReferenceMutator,encodeSize,length,2,0.050543293,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
481,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17488,17497,FieldReferenceMutator,encodeSize,size,3,0.047710393,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
482,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,445,17488,17497,FieldReferenceMutator,encodeSize,len,4,0.04746102,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
483,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,446,17518,17529,MethodCallMutator,resizeBuffer,flush,0,0.3780323,<mask>(),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer"
484,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,446,17518,17529,MethodCallMutator,resizeBuffer,close,1,0.29456574,<mask>(),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer"
485,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,446,17518,17529,MethodCallMutator,resizeBuffer,reset,2,0.03776145,<mask>(),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer"
486,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,446,17518,17529,MethodCallMutator,resizeBuffer,end,3,0.03066888,<mask>(),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer"
487,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,446,17518,17529,MethodCallMutator,resizeBuffer,complete,4,0.03007615,<mask>(),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer"
488,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,448,17568,17574,IdentifierMutator-Variable,modulus,mode,0,0.17134255,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
489,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,448,17568,17574,IdentifierMutator-Variable,modulus,type,1,0.13142978,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
490,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,448,17568,17574,IdentifierMutator-Variable,modulus,bit,2,0.039191253,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
491,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,448,17568,17574,IdentifierMutator-Variable,modulus,pos,3,0.03375763,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
492,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,448,17568,17574,IdentifierMutator-Variable,modulus,version,4,0.027490968,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
493,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,448,17568,17574,FieldReferenceMutator,modulus,mode,0,0.17134255,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
494,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,448,17568,17574,FieldReferenceMutator,modulus,type,1,0.13142978,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
495,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,448,17568,17574,FieldReferenceMutator,modulus,bit,2,0.039191253,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
496,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,448,17568,17574,FieldReferenceMutator,modulus,pos,3,0.03375763,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
497,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,448,17568,17574,FieldReferenceMutator,modulus,version,4,0.027490968,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
498,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,449,17600,17600,IdentifierMutator-Literal,1,0,1,0.054954752,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
499,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,449,17600,17600,IdentifierMutator-Literal,1,3,2,0.04661077,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
500,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,449,17600,17600,IdentifierMutator-Literal,1,2,3,0.017740346,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
501,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,449,17600,17600,IdentifierMutator-Literal,1,4,4,0.008284727,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
502,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17637,17637,AssignmentMutator,buffer[pos++]=encodeTable[(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.7590315,buffer[pos++] <mask>= encodeTable[(x >> 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++]<mask>= encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
503,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17637,17637,AssignmentMutator,buffer[pos++]=encodeTable[(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.18873869,buffer[pos++] <mask>= encodeTable[(x >> 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++]<mask>= encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
504,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17637,17637,AssignmentMutator,buffer[pos++]=encodeTable[(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.020246686,buffer[pos++] <mask>= encodeTable[(x >> 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++]<mask>= encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
505,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17637,17637,AssignmentMutator,buffer[pos++]=encodeTable[(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.009587456,buffer[pos++] <mask>= encodeTable[(x >> 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++]<mask>= encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
506,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17637,17637,AssignmentMutator,buffer[pos++]=encodeTable[(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,4,0.0032216315,buffer[pos++] <mask>= encodeTable[(x >> 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++]<mask>= encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
507,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17631,17635,ArrayAccessMutator,pos++,pos,0,0.99829334,buffer[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
508,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17631,17635,ArrayAccessMutator,pos++,++,1,1.8626895E-4,buffer[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
509,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17631,17635,ArrayAccessMutator,pos++,neg,2,1.3344926E-4,buffer[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
510,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17631,17635,ArrayAccessMutator,pos++,push,3,1.0868133E-4,buffer[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
511,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17631,17635,ArrayAccessMutator,pos++,position,4,9.961791E-5,buffer[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
512,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17624,17629,IdentifierMutator-Variable,buffer,buf,2,6.9732615E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :<mask>[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++"
513,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17624,17629,IdentifierMutator-Variable,buffer,byte,3,6.6206E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :<mask>[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++"
514,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17624,17629,IdentifierMutator-Variable,buffer,Buffer,4,4.5481455E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :<mask>[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++"
515,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17624,17629,FieldReferenceMutator,buffer,buf,2,6.9732615E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :<mask>[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++"
516,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17624,17629,FieldReferenceMutator,buffer,byte,3,6.6206E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :<mask>[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++"
517,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17624,17629,FieldReferenceMutator,buffer,Buffer,4,4.5481455E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :<mask>[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++"
518,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17634,17635,UnaryOperatorMutator,++,+,2,2.5552875E-4,pos<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
519,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17634,17635,UnaryOperatorMutator,++,++;,3,7.411792E-5,pos<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
520,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17634,17635,UnaryOperatorMutator,++,--,4,5.8394104E-5,pos<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
521,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17631,17633,IdentifierMutator-Variable,pos,neg,1,4.9532995E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
522,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17631,17633,IdentifierMutator-Variable,pos,len,2,3.780034E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
523,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17631,17633,IdentifierMutator-Variable,pos,size,3,3.673594E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
524,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17631,17633,FieldReferenceMutator,pos,neg,1,4.9532995E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
525,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17631,17633,FieldReferenceMutator,pos,len,2,3.780034E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
526,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17631,17633,FieldReferenceMutator,pos,size,3,3.673594E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
527,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17652,17672,ArrayAccessMutator,(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.900394,encodeTable[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
              "
528,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17652,17672,ArrayAccessMutator,(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.021540886,encodeTable[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
              "
529,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17652,17672,ArrayAccessMutator,(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,2,0.011227727,encodeTable[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
              "
530,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17652,17672,ArrayAccessMutator,(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,xx,3,0.0072812657,encodeTable[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
              "
531,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17652,17672,ArrayAccessMutator,(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,X,4,0.004639651,encodeTable[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
              "
532,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17640,17650,IdentifierMutator-Variable,encodeTable,encode,0,0.3502056,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
533,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17640,17650,IdentifierMutator-Variable,encodeTable,decode,1,0.078881785,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
534,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17640,17650,IdentifierMutator-Variable,encodeTable,table,2,0.055399686,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
535,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17640,17650,IdentifierMutator-Variable,encodeTable,encoded,3,0.033183258,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
536,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17640,17650,IdentifierMutator-Variable,encodeTable,encoding,4,0.025917934,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
537,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17640,17650,FieldReferenceMutator,encodeTable,encode,0,0.3502056,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
538,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17640,17650,FieldReferenceMutator,encodeTable,decode,1,0.078881785,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
539,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17640,17650,FieldReferenceMutator,encodeTable,table,2,0.055399686,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
540,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17640,17650,FieldReferenceMutator,encodeTable,encoded,3,0.033183258,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
541,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17640,17650,FieldReferenceMutator,encodeTable,encoding,4,0.025917934,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
542,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17660,17662,BinaryOperatorMutator,&,|,2,0.0015625239,(x >> 2) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
      "
543,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17660,17662,BinaryOperatorMutator,&,^,3,1.20068624E-4,(x >> 2) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
      "
544,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17660,17662,BinaryOperatorMutator,&,~,4,3.0527593E-5,(x >> 2) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
      "
545,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17654,17657,BinaryOperatorMutator,>>,<<,0,0.7636425,x <mask> 2,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x<mask>2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
546,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17654,17657,BinaryOperatorMutator,>>,<<,1,0.20518024,x <mask> 2,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x<mask>2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
547,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17654,17657,BinaryOperatorMutator,>>,>>>,3,0.009546914,x <mask> 2,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x<mask>2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
548,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17653,17653,IdentifierMutator-Variable,x,y,1,0.0012006484,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(<mask> >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
549,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17653,17653,IdentifierMutator-Variable,x,xx,2,1.7857723E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(<mask> >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
550,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17653,17653,IdentifierMutator-Variable,x,b,3,9.344628E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(<mask> >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
551,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17653,17653,FieldReferenceMutator,x,y,1,0.0012006484,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(<mask> >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
552,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17653,17653,FieldReferenceMutator,x,xx,2,1.7857723E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(<mask> >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
553,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17653,17653,FieldReferenceMutator,x,b,3,9.344628E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(<mask> >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
554,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17658,17658,IdentifierMutator-Literal,2,6,1,0.20613815,<mask>," encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
555,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17658,17658,IdentifierMutator-Literal,2,4,2,0.19874048,<mask>," encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
556,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17658,17658,IdentifierMutator-Literal,2,3,3,0.07592256,<mask>," encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
557,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17658,17658,IdentifierMutator-Literal,2,5,4,0.07236434,<mask>," encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
558,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17663,17672,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,0,0.40965712,<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
559,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17663,17672,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,1,0.08821417,<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
560,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17663,17672,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,2,0.065015025,<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
561,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17663,17672,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,63,3,0.058936555,<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
562,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17663,17672,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,4,0.057763945,<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
563,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17663,17672,FieldReferenceMutator,MASK_6BITS,mask,0,0.40965712,org.apache.commons.codec.binary.Base64.<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
564,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17663,17672,FieldReferenceMutator,MASK_6BITS,7,1,0.08821417,org.apache.commons.codec.binary.Base64.<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
565,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17663,17672,FieldReferenceMutator,MASK_6BITS,3,2,0.065015025,org.apache.commons.codec.binary.Base64.<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
566,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17663,17672,FieldReferenceMutator,MASK_6BITS,63,3,0.058936555,org.apache.commons.codec.binary.Base64.<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
567,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,450,17663,17672,FieldReferenceMutator,MASK_6BITS,1,4,0.057763945,org.apache.commons.codec.binary.Base64.<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
568,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17709,17709,AssignmentMutator,buffer[pos++]=encodeTable[(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.7252279,buffer[pos++] <mask>= encodeTable[(x << 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"        return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6"
569,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17709,17709,AssignmentMutator,buffer[pos++]=encodeTable[(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.17072235,buffer[pos++] <mask>= encodeTable[(x << 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"        return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6"
570,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17709,17709,AssignmentMutator,buffer[pos++]=encodeTable[(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.045159075,buffer[pos++] <mask>= encodeTable[(x << 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"        return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6"
571,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17709,17709,AssignmentMutator,buffer[pos++]=encodeTable[(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.011590125,buffer[pos++] <mask>= encodeTable[(x << 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"        return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6"
572,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17709,17709,AssignmentMutator,buffer[pos++]=encodeTable[(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],||,4,0.007766007,buffer[pos++] <mask>= encodeTable[(x << 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"        return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6"
573,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17703,17707,ArrayAccessMutator,pos++,pos,0,0.9917168,buffer[<mask>],"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
574,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17703,17707,ArrayAccessMutator,pos++,++,1,0.0013328174,buffer[<mask>],"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
575,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17703,17707,ArrayAccessMutator,pos++,offset,2,4.2848106E-4,buffer[<mask>],"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
576,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17703,17707,ArrayAccessMutator,pos++,len,3,4.192596E-4,buffer[<mask>],"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
577,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17703,17707,ArrayAccessMutator,pos++,size,4,3.425378E-4,buffer[<mask>],"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
578,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17696,17701,IdentifierMutator-Variable,buffer,byte,2,0.0011420909,<mask>," int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &"
579,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17696,17701,IdentifierMutator-Variable,buffer,buf,3,0.001104526,<mask>," int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &"
580,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17696,17701,IdentifierMutator-Variable,buffer,pad,4,5.813769E-4,<mask>," int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &"
581,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17696,17701,FieldReferenceMutator,buffer,byte,2,0.0011420909,<mask>," int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &"
582,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17696,17701,FieldReferenceMutator,buffer,buf,3,0.001104526,<mask>," int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &"
583,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17696,17701,FieldReferenceMutator,buffer,pad,4,5.813769E-4,<mask>," int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &"
584,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17706,17707,UnaryOperatorMutator,++,+,2,1.6009732E-4,pos<mask>,"          return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
585,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17706,17707,UnaryOperatorMutator,++,++;,3,1.3102376E-4,pos<mask>,"          return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
586,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17706,17707,UnaryOperatorMutator,++,--,4,7.566134E-5,pos<mask>,"          return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
587,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17703,17705,IdentifierMutator-Variable,pos,len,1,1.2618772E-4,<mask>,"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK"
588,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17703,17705,IdentifierMutator-Variable,pos,size,2,1.21800396E-4,<mask>,"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK"
589,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17703,17705,IdentifierMutator-Variable,pos,neg,3,7.470588E-5,<mask>,"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK"
590,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17703,17705,FieldReferenceMutator,pos,len,1,1.2618772E-4,<mask>,"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK"
591,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17703,17705,FieldReferenceMutator,pos,size,2,1.21800396E-4,<mask>,"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK"
592,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17703,17705,FieldReferenceMutator,pos,neg,3,7.470588E-5,<mask>,"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK"
593,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17724,17744,ArrayAccessMutator,(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.46944067,encodeTable[<mask>],"    return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
594,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17724,17744,ArrayAccessMutator,(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.07089725,encodeTable[<mask>],"    return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
595,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17724,17744,ArrayAccessMutator,(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,2,0.05649393,encodeTable[<mask>],"    return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
596,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17724,17744,ArrayAccessMutator,(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,pos,3,0.042519633,encodeTable[<mask>],"    return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
597,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17724,17744,ArrayAccessMutator,(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,2,4,0.027682172,encodeTable[<mask>],"    return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
598,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17712,17722,IdentifierMutator-Variable,encodeTable,buffer,0,0.1352958,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
599,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17712,17722,IdentifierMutator-Variable,encodeTable,padding,1,0.13085298,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
600,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17712,17722,IdentifierMutator-Variable,encodeTable,encode,2,0.097900845,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
601,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17712,17722,IdentifierMutator-Variable,encodeTable,pad,3,0.07295836,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
602,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17712,17722,IdentifierMutator-Variable,encodeTable,decode,4,0.0514366,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
603,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17712,17722,FieldReferenceMutator,encodeTable,buffer,0,0.1352958,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
604,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17712,17722,FieldReferenceMutator,encodeTable,padding,1,0.13085298,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
605,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17712,17722,FieldReferenceMutator,encodeTable,encode,2,0.097900845,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
606,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17712,17722,FieldReferenceMutator,encodeTable,pad,3,0.07295836,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
607,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17712,17722,FieldReferenceMutator,encodeTable,decode,4,0.0514366,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
608,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17732,17734,BinaryOperatorMutator,&,|,2,0.01860183,(x << 4) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4)<mask>MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
      "
609,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17732,17734,BinaryOperatorMutator,&,^,3,7.7618205E-4,(x << 4) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4)<mask>MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
      "
610,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17732,17734,BinaryOperatorMutator,&,|,4,3.331899E-4,(x << 4) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4)<mask>MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
      "
611,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17726,17729,BinaryOperatorMutator,<<,>>,0,0.70748925,x <mask> 4,"  return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
   "
612,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17726,17729,BinaryOperatorMutator,<<,>>,1,0.20853873,x <mask> 4,"  return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
   "
613,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17726,17729,BinaryOperatorMutator,<<,-,3,0.010474247,x <mask> 4,"  return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
   "
614,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17726,17729,BinaryOperatorMutator,<<,->,4,0.0030510647,x <mask> 4,"  return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
   "
615,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17725,17725,IdentifierMutator-Variable,x,y,1,1.20980214E-4,<mask>,"   return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
  "
616,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17725,17725,IdentifierMutator-Variable,x,xx,2,6.727812E-5,<mask>,"   return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
  "
617,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17725,17725,IdentifierMutator-Variable,x,X,4,1.879067E-5,<mask>,"   return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
  "
618,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17725,17725,FieldReferenceMutator,x,y,1,1.20980214E-4,<mask>,"   return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
  "
619,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17725,17725,FieldReferenceMutator,x,xx,2,6.727812E-5,<mask>,"   return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
  "
620,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17725,17725,FieldReferenceMutator,x,X,4,1.879067E-5,<mask>,"   return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
  "
621,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17730,17730,IdentifierMutator-Literal,4,1,0,0.19887765,<mask>," return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
    "
622,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17730,17730,IdentifierMutator-Literal,4,3,1,0.14177974,<mask>," return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
    "
623,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17730,17730,IdentifierMutator-Literal,4,6,2,0.12830861,<mask>," return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
    "
624,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17730,17730,IdentifierMutator-Literal,4,5,3,0.11965267,<mask>," return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
    "
625,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17735,17744,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,0,0.41023532,<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
626,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17735,17744,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,1,0.122704715,<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
627,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17735,17744,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,2,0.05653944,<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
628,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17735,17744,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,255,3,0.0391737,<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
629,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17735,17744,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,4,0.037439104,<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
630,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17735,17744,FieldReferenceMutator,MASK_6BITS,mask,0,0.41023532,org.apache.commons.codec.binary.Base64.<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
631,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17735,17744,FieldReferenceMutator,MASK_6BITS,1,1,0.122704715,org.apache.commons.codec.binary.Base64.<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
632,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17735,17744,FieldReferenceMutator,MASK_6BITS,7,2,0.05653944,org.apache.commons.codec.binary.Base64.<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
633,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17735,17744,FieldReferenceMutator,MASK_6BITS,255,3,0.0391737,org.apache.commons.codec.binary.Base64.<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
634,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,451,17735,17744,FieldReferenceMutator,MASK_6BITS,3,4,0.037439104,org.apache.commons.codec.binary.Base64.<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
635,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17857,17860,BinaryOperatorMutator,==,!=,2,0.086140886,encodeTable <mask> org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,"           eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable<mask>STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
636,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17857,17860,BinaryOperatorMutator,==,_,3,0.017122086,encodeTable <mask> org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,"           eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable<mask>STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
637,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17857,17860,BinaryOperatorMutator,==,=,4,0.012852635,encodeTable <mask> org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,"           eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable<mask>STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
638,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17846,17856,IdentifierMutator-Variable,encodeTable,mode,0,0.17699435,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
639,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17846,17856,IdentifierMutator-Variable,encodeTable,type,1,0.13789225,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
640,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17846,17856,IdentifierMutator-Variable,encodeTable,x,2,0.086638995,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
641,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17846,17856,IdentifierMutator-Variable,encodeTable,padding,3,0.03498366,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
642,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17846,17856,IdentifierMutator-Variable,encodeTable,format,4,0.026209446,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
643,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17846,17856,FieldReferenceMutator,encodeTable,mode,0,0.17699435,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
644,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17846,17856,FieldReferenceMutator,encodeTable,type,1,0.13789225,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
645,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17846,17856,FieldReferenceMutator,encodeTable,x,2,0.086638995,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
646,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17846,17856,FieldReferenceMutator,encodeTable,padding,3,0.03498366,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
647,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17846,17856,FieldReferenceMutator,encodeTable,format,4,0.026209446,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
648,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17861,17881,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,null,0,0.8546874,<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
649,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17861,17881,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,0,1,0.039812077,<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
650,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17861,17881,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,1,2,0.016675754,<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
651,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17861,17881,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,nil,3,0.0074899825,<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
652,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17861,17881,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,NULL,4,0.006329378,<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
653,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17861,17881,FieldReferenceMutator,STANDARD_ENCODE_TABLE,null,0,0.8546874,org.apache.commons.codec.binary.Base64.<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
654,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17861,17881,FieldReferenceMutator,STANDARD_ENCODE_TABLE,0,1,0.039812077,org.apache.commons.codec.binary.Base64.<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
655,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17861,17881,FieldReferenceMutator,STANDARD_ENCODE_TABLE,1,2,0.016675754,org.apache.commons.codec.binary.Base64.<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
656,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17861,17881,FieldReferenceMutator,STANDARD_ENCODE_TABLE,nil,3,0.0074899825,org.apache.commons.codec.binary.Base64.<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
657,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,453,17861,17881,FieldReferenceMutator,STANDARD_ENCODE_TABLE,NULL,4,0.006329378,org.apache.commons.codec.binary.Base64.<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
658,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17923,17923,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,|,0,0.6528652,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD," encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the"
659,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17923,17923,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,^,1,0.16533926,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD," encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the"
660,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17923,17923,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,*,2,0.10714945,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD," encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the"
661,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17923,17923,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,&,3,0.019563375,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD," encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the"
662,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17923,17923,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,|,4,0.007915882,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD," encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the"
663,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17917,17921,ArrayAccessMutator,pos++,pos,0,0.9968829,buffer[<mask>]," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
664,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17917,17921,ArrayAccessMutator,pos++,++,1,4.8905157E-4,buffer[<mask>]," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
665,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17917,17921,ArrayAccessMutator,pos++,push,2,2.3605679E-4,buffer[<mask>]," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
666,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17917,17921,ArrayAccessMutator,pos++,size,3,1.4590618E-4,buffer[<mask>]," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
667,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17917,17921,ArrayAccessMutator,pos++,len,4,1.2484242E-4,buffer[<mask>]," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
668,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17910,17915,IdentifierMutator-Variable,buffer,pad,2,0.002047175,<mask>," eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SA"
669,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17910,17915,IdentifierMutator-Variable,buffer,byte,3,0.0013995272,<mask>," eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SA"
670,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17910,17915,IdentifierMutator-Variable,buffer,header,4,0.0012758017,<mask>," eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SA"
671,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17910,17915,FieldReferenceMutator,buffer,pad,2,0.002047175,<mask>," eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SA"
672,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17910,17915,FieldReferenceMutator,buffer,byte,3,0.0013995272,<mask>," eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SA"
673,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17910,17915,FieldReferenceMutator,buffer,header,4,0.0012758017,<mask>," eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SA"
674,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17920,17921,UnaryOperatorMutator,++,++;,2,1.7955797E-4,pos<mask>," pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
675,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17920,17921,UnaryOperatorMutator,++,+,3,1.1226093E-4,pos<mask>," pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
676,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17920,17921,UnaryOperatorMutator,++,--,4,7.178132E-5,pos<mask>," pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
677,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17917,17919,IdentifierMutator-Variable,pos,size,1,1.2489846E-4,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
678,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17917,17919,IdentifierMutator-Variable,pos,len,2,1.1581752E-4,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
679,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17917,17919,IdentifierMutator-Variable,pos,neg,3,7.4294054E-5,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
680,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17917,17919,IdentifierMutator-Variable,pos,count,4,3.158705E-5,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
681,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17917,17919,FieldReferenceMutator,pos,size,1,1.2489846E-4,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
682,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17917,17919,FieldReferenceMutator,pos,len,2,1.1581752E-4,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
683,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17917,17919,FieldReferenceMutator,pos,neg,3,7.4294054E-5,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
684,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17917,17919,FieldReferenceMutator,pos,count,4,3.158705E-5,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
685,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17926,17928,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,SPACE,0,0.08046446,<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
686,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17926,17928,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,ESC,1,0.061571576,<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
687,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17926,17928,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,END,2,0.059094843,<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
688,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17926,17928,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,CONTROL,3,0.04906223,<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
689,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17926,17928,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,OP,4,0.03906672,<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
690,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17926,17928,FieldReferenceMutator,PAD,SPACE,0,0.08046446,org.apache.commons.codec.binary.Base64.<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
691,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17926,17928,FieldReferenceMutator,PAD,ESC,1,0.061571576,org.apache.commons.codec.binary.Base64.<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
692,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17926,17928,FieldReferenceMutator,PAD,END,2,0.059094843,org.apache.commons.codec.binary.Base64.<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
693,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17926,17928,FieldReferenceMutator,PAD,CONTROL,3,0.04906223,org.apache.commons.codec.binary.Base64.<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
694,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,454,17926,17928,FieldReferenceMutator,PAD,OP,4,0.03906672,org.apache.commons.codec.binary.Base64.<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
695,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17968,17968,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,|,0,0.5270846,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"   }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++]<mask>= PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STAND"
696,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17968,17968,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,^,1,0.28804612,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"   }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++]<mask>= PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STAND"
697,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17968,17968,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,*,2,0.11740384,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"   }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++]<mask>= PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STAND"
698,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17968,17968,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,&,3,0.021688653,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"   }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++]<mask>= PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STAND"
699,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17968,17968,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,|,4,0.0054546776,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"   }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++]<mask>= PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STAND"
700,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17962,17966,ArrayAccessMutator,pos++,pos,0,0.99240816,buffer[<mask>],"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
701,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17962,17966,ArrayAccessMutator,pos++,++,1,7.495023E-4,buffer[<mask>],"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
702,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17962,17966,ArrayAccessMutator,pos++,len,2,5.879905E-4,buffer[<mask>],"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
703,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17962,17966,ArrayAccessMutator,pos++,size,3,5.464432E-4,buffer[<mask>],"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
704,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17962,17966,ArrayAccessMutator,pos++,neg,4,3.9207624E-4,buffer[<mask>],"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
705,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17955,17960,IdentifierMutator-Variable,buffer,pad,1,0.105922684,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
706,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17955,17960,IdentifierMutator-Variable,buffer,padding,2,0.103313886,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
707,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17955,17960,IdentifierMutator-Variable,buffer,output,3,0.047545757,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
708,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17955,17960,IdentifierMutator-Variable,buffer,out,4,0.018802049,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
709,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17955,17960,FieldReferenceMutator,buffer,pad,1,0.105922684,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
710,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17955,17960,FieldReferenceMutator,buffer,padding,2,0.103313886,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
711,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17955,17960,FieldReferenceMutator,buffer,output,3,0.047545757,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
712,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17955,17960,FieldReferenceMutator,buffer,out,4,0.018802049,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
713,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17965,17966,UnaryOperatorMutator,++,--,2,2.2116514E-4,pos<mask>,"     }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
714,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17965,17966,UnaryOperatorMutator,++,++;,3,1.4731004E-4,pos<mask>,"     }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
715,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17965,17966,UnaryOperatorMutator,++,+,4,1.0931901E-4,pos<mask>,"     }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
716,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17962,17964,IdentifierMutator-Variable,pos,len,1,5.8309315E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
717,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17962,17964,IdentifierMutator-Variable,pos,neg,2,4.683775E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
718,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17962,17964,IdentifierMutator-Variable,pos,size,3,4.2802066E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
719,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17962,17964,IdentifierMutator-Variable,pos,count,4,1.2716428E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
720,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17962,17964,FieldReferenceMutator,pos,len,1,5.8309315E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
721,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17962,17964,FieldReferenceMutator,pos,neg,2,4.683775E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
722,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17962,17964,FieldReferenceMutator,pos,size,3,4.2802066E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
723,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17962,17964,FieldReferenceMutator,pos,count,4,1.2716428E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
724,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17971,17973,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,SPACE,0,0.12200858,<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
725,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17971,17973,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,END,1,0.09355739,<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
726,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17971,17973,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,0,2,0.054976795,<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
727,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17971,17973,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,NULL,3,0.05491863,<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
728,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17971,17973,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,WHITE,4,0.04002215,<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
729,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17971,17973,FieldReferenceMutator,PAD,SPACE,0,0.12200858,org.apache.commons.codec.binary.Base64.<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
730,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17971,17973,FieldReferenceMutator,PAD,END,1,0.09355739,org.apache.commons.codec.binary.Base64.<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
731,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17971,17973,FieldReferenceMutator,PAD,0,2,0.054976795,org.apache.commons.codec.binary.Base64.<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
732,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17971,17973,FieldReferenceMutator,PAD,NULL,3,0.05491863,org.apache.commons.codec.binary.Base64.<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
733,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,455,17971,17973,FieldReferenceMutator,PAD,WHITE,4,0.04002215,org.apache.commons.codec.binary.Base64.<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
734,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,459,18047,18047,IdentifierMutator-Literal,2,10,0,0.08821452,<mask>,"] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
  "
735,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,459,18047,18047,IdentifierMutator-Literal,2,32,2,0.051304154,<mask>,"] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
  "
736,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,459,18047,18047,IdentifierMutator-Literal,2,8,3,0.04720085,<mask>,"] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
  "
737,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,459,18047,18047,IdentifierMutator-Literal,2,13,4,0.046745274,<mask>,"] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
  "
738,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18084,18084,AssignmentMutator,buffer[pos++]=encodeTable[(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.55993384,buffer[pos++] <mask>= encodeTable[(x >> 10) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++]<mask>= encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
      "
739,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18084,18084,AssignmentMutator,buffer[pos++]=encodeTable[(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.20096484,buffer[pos++] <mask>= encodeTable[(x >> 10) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++]<mask>= encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
      "
740,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18084,18084,AssignmentMutator,buffer[pos++]=encodeTable[(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.1375762,buffer[pos++] <mask>= encodeTable[(x >> 10) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++]<mask>= encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
      "
741,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18084,18084,AssignmentMutator,buffer[pos++]=encodeTable[(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.017520567,buffer[pos++] <mask>= encodeTable[(x >> 10) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++]<mask>= encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
      "
742,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18084,18084,AssignmentMutator,buffer[pos++]=encodeTable[(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS],||,4,0.013834343,buffer[pos++] <mask>= encodeTable[(x >> 10) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++]<mask>= encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
      "
743,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18078,18082,ArrayAccessMutator,pos++,pos,0,0.9974579,buffer[<mask>],"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
744,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18078,18082,ArrayAccessMutator,pos++,++,1,2.2722773E-4,buffer[<mask>],"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
745,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18078,18082,ArrayAccessMutator,pos++,position,2,1.3266483E-4,buffer[<mask>],"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
746,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18078,18082,ArrayAccessMutator,pos++,push,3,1.1517692E-4,buffer[<mask>],"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
747,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18078,18082,ArrayAccessMutator,pos++,len,4,1.0592083E-4,buffer[<mask>],"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
748,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18071,18076,IdentifierMutator-Variable,buffer,byte,2,0.0033770215,<mask>," encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :<mask>[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
  "
749,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18071,18076,IdentifierMutator-Variable,buffer,Buffer,3,0.0012441438,<mask>," encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :<mask>[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
  "
750,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18071,18076,IdentifierMutator-Variable,buffer,Buffer,4,8.9903094E-4,<mask>," encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :<mask>[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
  "
751,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18071,18076,FieldReferenceMutator,buffer,byte,2,0.0033770215,<mask>," encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :<mask>[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
  "
752,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18071,18076,FieldReferenceMutator,buffer,Buffer,3,0.0012441438,<mask>," encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :<mask>[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
  "
753,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18071,18076,FieldReferenceMutator,buffer,Buffer,4,8.9903094E-4,<mask>," encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :<mask>[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
  "
754,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18081,18082,UnaryOperatorMutator,++,+,2,8.97298E-5,pos<mask>,"              buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
755,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18081,18082,UnaryOperatorMutator,++,++;,3,4.1023275E-5,pos<mask>,"              buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
756,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18081,18082,UnaryOperatorMutator,++,+=,4,1.2975764E-5,pos<mask>,"              buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
757,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18078,18080,IdentifierMutator-Variable,pos,len,1,5.3168344E-5,<mask>,"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
    "
758,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18078,18080,IdentifierMutator-Variable,pos,size,2,4.046301E-5,<mask>,"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
    "
759,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18078,18080,IdentifierMutator-Variable,pos,neg,3,3.688734E-5,<mask>,"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
    "
760,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18078,18080,FieldReferenceMutator,pos,len,1,5.3168344E-5,<mask>,"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
    "
761,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18078,18080,FieldReferenceMutator,pos,size,2,4.046301E-5,<mask>,"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
    "
762,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18078,18080,FieldReferenceMutator,pos,neg,3,3.688734E-5,<mask>,"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
    "
763,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18099,18120,ArrayAccessMutator,(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.76318437,encodeTable[<mask>],"        buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
764,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18099,18120,ArrayAccessMutator,(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,1,0.050167717,encodeTable[<mask>],"        buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
765,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18099,18120,ArrayAccessMutator,(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS,2,2,0.037808243,encodeTable[<mask>],"        buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
766,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18099,18120,ArrayAccessMutator,(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,3,0.01987375,encodeTable[<mask>],"        buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
767,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18099,18120,ArrayAccessMutator,(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS,i,4,0.014358742,encodeTable[<mask>],"        buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
768,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18087,18097,IdentifierMutator-Variable,encodeTable,encode,0,0.23676376,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
769,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18087,18097,IdentifierMutator-Variable,encodeTable,table,1,0.16934125,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
770,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18087,18097,IdentifierMutator-Variable,encodeTable,buffer,2,0.052260287,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
771,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18087,18097,IdentifierMutator-Variable,encodeTable,decode,3,0.052082166,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
772,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18087,18097,IdentifierMutator-Variable,encodeTable,encoded,4,0.049330443,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
773,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18087,18097,FieldReferenceMutator,encodeTable,encode,0,0.23676376,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
774,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18087,18097,FieldReferenceMutator,encodeTable,table,1,0.16934125,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
775,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18087,18097,FieldReferenceMutator,encodeTable,buffer,2,0.052260287,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
776,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18087,18097,FieldReferenceMutator,encodeTable,decode,3,0.052082166,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
777,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18087,18097,FieldReferenceMutator,encodeTable,encoded,4,0.049330443,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
778,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18108,18110,BinaryOperatorMutator,&,|,2,2.3115605E-4,(x >> 10) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"   buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
   "
779,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18108,18110,BinaryOperatorMutator,&,^,3,3.7780846E-5,(x >> 10) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"   buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
   "
780,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18108,18110,BinaryOperatorMutator,&,+,4,2.1154929E-5,(x >> 10) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"   buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
   "
781,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18101,18104,BinaryOperatorMutator,>>,>>>,2,0.20307624,x <mask> 10,"      buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x<mask>10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
"
782,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18101,18104,BinaryOperatorMutator,>>,<<,3,0.16924475,x <mask> 10,"      buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x<mask>10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
"
783,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18101,18104,BinaryOperatorMutator,>>,>>>,4,0.022735298,x <mask> 10,"      buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x<mask>10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
"
784,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18100,18100,IdentifierMutator-Variable,x,y,1,2.1688893E-5,<mask>,"       buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(<mask> >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }"
785,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18100,18100,IdentifierMutator-Variable,x,xx,2,7.924042E-6,<mask>,"       buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(<mask> >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }"
786,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18100,18100,IdentifierMutator-Variable,x,X,3,6.468315E-6,<mask>,"       buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(<mask> >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }"
787,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18100,18100,FieldReferenceMutator,x,y,1,2.1688893E-5,<mask>,"       buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(<mask> >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }"
788,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18100,18100,FieldReferenceMutator,x,xx,2,7.924042E-6,<mask>,"       buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(<mask> >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }"
789,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18100,18100,FieldReferenceMutator,x,X,3,6.468315E-6,<mask>,"       buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(<mask> >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }"
790,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18105,18106,IdentifierMutator-Literal,10,6,0,0.4788991,<mask>,"     buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
 "
791,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18105,18106,IdentifierMutator-Literal,10,8,1,0.1464764,<mask>,"     buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
 "
792,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18105,18106,IdentifierMutator-Literal,10,5,2,0.09553842,<mask>,"     buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
 "
793,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18105,18106,IdentifierMutator-Literal,10,2,3,0.085164286,<mask>,"     buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
 "
794,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18105,18106,IdentifierMutator-Literal,10,7,4,0.068057455,<mask>,"     buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
 "
795,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18111,18120,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,0,0.12702222,<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
796,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18111,18120,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,1,0.09988066,<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
797,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18111,18120,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,255,2,0.0651491,<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
798,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18111,18120,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,3,0.06439076,<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
799,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18111,18120,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,4,0.04845752,<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
800,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18111,18120,FieldReferenceMutator,MASK_6BITS,7,0,0.12702222,org.apache.commons.codec.binary.Base64.<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
801,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18111,18120,FieldReferenceMutator,MASK_6BITS,mask,1,0.09988066,org.apache.commons.codec.binary.Base64.<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
802,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18111,18120,FieldReferenceMutator,MASK_6BITS,255,2,0.0651491,org.apache.commons.codec.binary.Base64.<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
803,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18111,18120,FieldReferenceMutator,MASK_6BITS,3,3,0.06439076,org.apache.commons.codec.binary.Base64.<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
804,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,460,18111,18120,FieldReferenceMutator,MASK_6BITS,1,4,0.04845752,org.apache.commons.codec.binary.Base64.<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
805,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18157,18157,AssignmentMutator,buffer[pos++]=encodeTable[(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.5512975,buffer[pos++] <mask>= encodeTable[(x >> 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
   "
806,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18157,18157,AssignmentMutator,buffer[pos++]=encodeTable[(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.20237939,buffer[pos++] <mask>= encodeTable[(x >> 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
   "
807,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18157,18157,AssignmentMutator,buffer[pos++]=encodeTable[(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.13436219,buffer[pos++] <mask>= encodeTable[(x >> 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
   "
808,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18157,18157,AssignmentMutator,buffer[pos++]=encodeTable[(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.020070957,buffer[pos++] <mask>= encodeTable[(x >> 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
   "
809,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18157,18157,AssignmentMutator,buffer[pos++]=encodeTable[(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],||,4,0.014573789,buffer[pos++] <mask>= encodeTable[(x >> 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
   "
810,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18151,18155,ArrayAccessMutator,pos++,pos,0,0.99603266,buffer[<mask>],"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
  "
811,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18151,18155,ArrayAccessMutator,pos++,++,1,0.0011413173,buffer[<mask>],"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
  "
812,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18151,18155,ArrayAccessMutator,pos++,push,2,2.593344E-4,buffer[<mask>],"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
  "
813,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18151,18155,ArrayAccessMutator,pos++,neg,3,1.9067542E-4,buffer[<mask>],"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
  "
814,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18151,18155,ArrayAccessMutator,pos++,+,4,1.5064591E-4,buffer[<mask>],"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
  "
815,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18144,18149,IdentifierMutator-Variable,buffer,Buffer,2,7.934503E-4,<mask>," encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous"
816,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18144,18149,IdentifierMutator-Variable,buffer,byte,3,7.739016E-4,<mask>," encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous"
817,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18144,18149,IdentifierMutator-Variable,buffer,byte,4,7.5885624E-4,<mask>," encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous"
818,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18144,18149,FieldReferenceMutator,buffer,Buffer,2,7.934503E-4,<mask>," encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous"
819,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18144,18149,FieldReferenceMutator,buffer,byte,3,7.739016E-4,<mask>," encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous"
820,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18144,18149,FieldReferenceMutator,buffer,byte,4,7.5885624E-4,<mask>," encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous"
821,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18154,18155,UnaryOperatorMutator,++,+,2,1.05094055E-4,pos<mask>,"              // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
  "
822,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18154,18155,UnaryOperatorMutator,++,++;,3,4.796749E-5,pos<mask>,"              // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
  "
823,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18154,18155,UnaryOperatorMutator,++,+=,4,1.42087665E-5,pos<mask>,"              // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
  "
824,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18151,18153,IdentifierMutator-Variable,pos,neg,2,2.5923408E-5,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
 "
825,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18151,18153,IdentifierMutator-Variable,pos,len,3,2.4739638E-5,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
 "
826,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18151,18153,IdentifierMutator-Variable,pos,size,4,2.109899E-5,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
 "
827,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18151,18153,FieldReferenceMutator,pos,neg,2,2.5923408E-5,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
 "
828,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18151,18153,FieldReferenceMutator,pos,len,3,2.4739638E-5,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
 "
829,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18151,18153,FieldReferenceMutator,pos,size,4,2.109899E-5,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
 "
830,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18172,18192,ArrayAccessMutator,(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.54965144,encodeTable[<mask>],"        // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF"
831,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18172,18192,ArrayAccessMutator,(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,1,0.050864972,encodeTable[<mask>],"        // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF"
832,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18172,18192,ArrayAccessMutator,(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,2,2,0.04915674,encodeTable[<mask>],"        // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF"
833,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18172,18192,ArrayAccessMutator,(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,3,0.036085285,encodeTable[<mask>],"        // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF"
834,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18172,18192,ArrayAccessMutator,(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,10,4,0.01756521,encodeTable[<mask>],"        // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF"
835,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18160,18170,IdentifierMutator-Variable,encodeTable,table,0,0.2331016,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
      "
836,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18160,18170,IdentifierMutator-Variable,encodeTable,encode,1,0.22223565,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
      "
837,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18160,18170,IdentifierMutator-Variable,encodeTable,decode,2,0.07962478,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
      "
838,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18160,18170,IdentifierMutator-Variable,encodeTable,buffer,3,0.07491092,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
      "
839,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18160,18170,IdentifierMutator-Variable,encodeTable,encoded,4,0.02626866,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
      "
840,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18160,18170,FieldReferenceMutator,encodeTable,table,0,0.2331016,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
      "
841,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18160,18170,FieldReferenceMutator,encodeTable,encode,1,0.22223565,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
      "
842,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18160,18170,FieldReferenceMutator,encodeTable,decode,2,0.07962478,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
      "
843,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18160,18170,FieldReferenceMutator,encodeTable,buffer,3,0.07491092,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
      "
844,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18160,18170,FieldReferenceMutator,encodeTable,encoded,4,0.02626866,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
      "
845,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18180,18182,BinaryOperatorMutator,&,|,2,6.2115095E-4,(x >> 4) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"   // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character"
846,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18180,18182,BinaryOperatorMutator,&,^,3,6.288563E-5,(x >> 4) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"   // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character"
847,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18180,18182,BinaryOperatorMutator,&,~,4,1.785641E-5,(x >> 4) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"   // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character"
848,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18174,18177,BinaryOperatorMutator,>>,<<,0,0.33679032,x <mask> 4,"      // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
          "
849,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18174,18177,BinaryOperatorMutator,>>,<<,1,0.32163617,x <mask> 4,"      // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
          "
850,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18174,18177,BinaryOperatorMutator,>>,>>>,4,0.042494435,x <mask> 4,"      // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
          "
851,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18173,18173,IdentifierMutator-Variable,x,y,1,3.6646758E-5,<mask>,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
         "
852,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18173,18173,IdentifierMutator-Variable,x,xx,2,2.0467765E-5,<mask>,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
         "
853,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18173,18173,IdentifierMutator-Variable,x,wx,4,8.492973E-6,<mask>,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
         "
854,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18173,18173,FieldReferenceMutator,x,y,1,3.6646758E-5,<mask>,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
         "
855,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18173,18173,FieldReferenceMutator,x,xx,2,2.0467765E-5,<mask>,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
         "
856,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18173,18173,FieldReferenceMutator,x,wx,4,8.492973E-6,<mask>,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
         "
857,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18178,18178,IdentifierMutator-Literal,4,6,0,0.28941163,<mask>,"     // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
           "
858,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18178,18178,IdentifierMutator-Literal,4,5,2,0.10646676,<mask>,"     // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
           "
859,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18178,18178,IdentifierMutator-Literal,4,7,3,0.094776444,<mask>,"     // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
           "
860,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18178,18178,IdentifierMutator-Literal,4,3,4,0.08587459,<mask>,"     // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
           "
861,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18183,18192,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,0,0.16708395,<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF"
862,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18183,18192,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,1,0.11325246,<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF"
863,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18183,18192,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,2,0.10866814,<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF"
864,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18183,18192,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,3,0.0782032,<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF"
865,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18183,18192,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,63,4,0.044126656,<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF"
866,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18183,18192,FieldReferenceMutator,MASK_6BITS,7,0,0.16708395,org.apache.commons.codec.binary.Base64.<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF"
867,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18183,18192,FieldReferenceMutator,MASK_6BITS,mask,1,0.11325246,org.apache.commons.codec.binary.Base64.<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF"
868,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18183,18192,FieldReferenceMutator,MASK_6BITS,3,2,0.10866814,org.apache.commons.codec.binary.Base64.<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF"
869,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18183,18192,FieldReferenceMutator,MASK_6BITS,1,3,0.0782032,org.apache.commons.codec.binary.Base64.<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF"
870,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,461,18183,18192,FieldReferenceMutator,MASK_6BITS,63,4,0.044126656,org.apache.commons.codec.binary.Base64.<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF"
871,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18229,18229,AssignmentMutator,buffer[pos++]=encodeTable[(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.8267333,buffer[pos++] <mask>= encodeTable[(x << 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator."
872,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18229,18229,AssignmentMutator,buffer[pos++]=encodeTable[(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.11169236,buffer[pos++] <mask>= encodeTable[(x << 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator."
873,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18229,18229,AssignmentMutator,buffer[pos++]=encodeTable[(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.020477286,buffer[pos++] <mask>= encodeTable[(x << 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator."
874,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18229,18229,AssignmentMutator,buffer[pos++]=encodeTable[(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.009080495,buffer[pos++] <mask>= encodeTable[(x << 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator."
875,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18229,18229,AssignmentMutator,buffer[pos++]=encodeTable[(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,4,0.0042648683,buffer[pos++] <mask>= encodeTable[(x << 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator."
876,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18223,18227,ArrayAccessMutator,pos++,pos,0,0.99044764,buffer[<mask>],"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator"
877,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18223,18227,ArrayAccessMutator,pos++,++,1,0.0027700556,buffer[<mask>],"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator"
878,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18223,18227,ArrayAccessMutator,pos++,push,2,4.8298348E-4,buffer[<mask>],"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator"
879,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18223,18227,ArrayAccessMutator,pos++,size,3,3.6258303E-4,buffer[<mask>],"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator"
880,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18223,18227,ArrayAccessMutator,pos++,len,4,3.0921583E-4,buffer[<mask>],"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator"
881,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18216,18221,IdentifierMutator-Variable,buffer,Buffer,2,7.0293737E-4,<mask>,"ips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[line"
882,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18216,18221,IdentifierMutator-Variable,buffer,byte,3,6.3909485E-4,<mask>,"ips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[line"
883,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18216,18221,IdentifierMutator-Variable,buffer,buf,4,4.947759E-4,<mask>,"ips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[line"
884,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18216,18221,FieldReferenceMutator,buffer,Buffer,2,7.0293737E-4,<mask>,"ips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[line"
885,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18216,18221,FieldReferenceMutator,buffer,byte,3,6.3909485E-4,<mask>,"ips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[line"
886,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18216,18221,FieldReferenceMutator,buffer,buf,4,4.947759E-4,<mask>,"ips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[line"
887,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18226,18227,UnaryOperatorMutator,++,+,2,1.004603E-4,pos<mask>,"      if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator"
888,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18226,18227,UnaryOperatorMutator,++,++;,3,8.232819E-5,pos<mask>,"      if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator"
889,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18226,18227,UnaryOperatorMutator,++,--,4,4.1152925E-5,pos<mask>,"      if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator"
890,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18223,18225,IdentifierMutator-Variable,pos,len,1,6.337691E-5,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSepar"
891,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18223,18225,IdentifierMutator-Variable,pos,size,2,5.2799787E-5,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSepar"
892,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18223,18225,IdentifierMutator-Variable,pos,neg,4,4.453606E-5,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSepar"
893,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18223,18225,FieldReferenceMutator,pos,len,1,6.337691E-5,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSepar"
894,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18223,18225,FieldReferenceMutator,pos,size,2,5.2799787E-5,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSepar"
895,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18223,18225,FieldReferenceMutator,pos,neg,4,4.453606E-5,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSepar"
896,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18244,18264,ArrayAccessMutator,(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.38441837,encodeTable[<mask>]," (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
           "
897,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18244,18264,ArrayAccessMutator,(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.08012559,encodeTable[<mask>]," (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
           "
898,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18244,18264,ArrayAccessMutator,(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,2,0.06409674,encodeTable[<mask>]," (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
           "
899,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18244,18264,ArrayAccessMutator,(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,2,3,0.037403025,encodeTable[<mask>]," (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
           "
900,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18244,18264,ArrayAccessMutator,(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,pos,4,0.036803167,encodeTable[<mask>]," (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
           "
901,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18232,18242,IdentifierMutator-Variable,encodeTable,buffer,0,0.2237627,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1"
902,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18232,18242,IdentifierMutator-Variable,encodeTable,padding,1,0.088011995,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1"
903,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18232,18242,IdentifierMutator-Variable,encodeTable,encode,2,0.07721367,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1"
904,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18232,18242,IdentifierMutator-Variable,encodeTable,table,3,0.041590057,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1"
905,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18232,18242,IdentifierMutator-Variable,encodeTable,encoded,4,0.035626963,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1"
906,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18232,18242,FieldReferenceMutator,encodeTable,buffer,0,0.2237627,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1"
907,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18232,18242,FieldReferenceMutator,encodeTable,padding,1,0.088011995,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1"
908,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18232,18242,FieldReferenceMutator,encodeTable,encode,2,0.07721367,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1"
909,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18232,18242,FieldReferenceMutator,encodeTable,table,3,0.041590057,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1"
910,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18232,18242,FieldReferenceMutator,encodeTable,encoded,4,0.035626963,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1"
911,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18252,18254,BinaryOperatorMutator,&,|,2,0.00482844,(x << 2) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS," STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2)<mask>MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
     "
912,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18252,18254,BinaryOperatorMutator,&,^,3,1.6394658E-4,(x << 2) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS," STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2)<mask>MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
     "
913,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18252,18254,BinaryOperatorMutator,&,|,4,1.5880128E-4,(x << 2) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS," STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2)<mask>MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
     "
914,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18246,18249,BinaryOperatorMutator,<<,>>,0,0.45527464,x <mask> 2,"codeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
  "
915,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18246,18249,BinaryOperatorMutator,<<,>>,1,0.21071279,x <mask> 2,"codeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
  "
916,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18246,18249,BinaryOperatorMutator,<<,-,4,0.027706008,x <mask> 2,"codeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
  "
917,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18245,18245,IdentifierMutator-Variable,x,y,1,1.0687649E-4,<mask>,"encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
 "
918,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18245,18245,IdentifierMutator-Variable,x,xx,2,6.958222E-5,<mask>,"encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
 "
919,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18245,18245,IdentifierMutator-Variable,x,1,4,2.0716187E-5,<mask>,"encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
 "
920,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18245,18245,FieldReferenceMutator,x,y,1,1.0687649E-4,<mask>,"encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
 "
921,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18245,18245,FieldReferenceMutator,x,xx,2,6.958222E-5,<mask>,"encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
 "
922,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18245,18245,FieldReferenceMutator,x,1,4,2.0716187E-5,<mask>,"encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
 "
923,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18250,18250,IdentifierMutator-Literal,2,3,1,0.18725707,<mask>,"Table == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
   "
924,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18250,18250,IdentifierMutator-Literal,2,1,2,0.08505579,<mask>,"Table == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
   "
925,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18250,18250,IdentifierMutator-Literal,2,0,3,0.035663802,<mask>,"Table == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
   "
926,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18250,18250,IdentifierMutator-Literal,2,6,4,0.029766582,<mask>,"Table == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
   "
927,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18255,18264,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,0,0.26710808,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
           "
928,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18255,18264,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,1,0.1789988,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
           "
929,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18255,18264,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,2,0.09346539,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
           "
930,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18255,18264,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,3,0.057839934,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
           "
931,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18255,18264,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,255,4,0.044967238,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
           "
932,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18255,18264,FieldReferenceMutator,MASK_6BITS,mask,0,0.26710808,org.apache.commons.codec.binary.Base64.<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
           "
933,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18255,18264,FieldReferenceMutator,MASK_6BITS,1,1,0.1789988,org.apache.commons.codec.binary.Base64.<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
           "
934,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18255,18264,FieldReferenceMutator,MASK_6BITS,7,2,0.09346539,org.apache.commons.codec.binary.Base64.<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
           "
935,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18255,18264,FieldReferenceMutator,MASK_6BITS,3,3,0.057839934,org.apache.commons.codec.binary.Base64.<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
           "
936,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,462,18255,18264,FieldReferenceMutator,MASK_6BITS,255,4,0.044967238,org.apache.commons.codec.binary.Base64.<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
           "
937,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18377,18380,BinaryOperatorMutator,==,!=,2,0.09786193,encodeTable <mask> org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,"[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable<mask>STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);"
938,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18377,18380,BinaryOperatorMutator,==,.,3,0.018075863,encodeTable <mask> org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,"[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable<mask>STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);"
939,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18377,18380,BinaryOperatorMutator,==,=,4,0.016738657,encodeTable <mask> org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,"[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable<mask>STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);"
940,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18366,18376,IdentifierMutator-Variable,encodeTable,type,0,0.17578407,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);"
941,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18366,18376,IdentifierMutator-Variable,encodeTable,x,1,0.15709198,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);"
942,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18366,18376,IdentifierMutator-Variable,encodeTable,mode,2,0.101163544,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);"
943,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18366,18376,IdentifierMutator-Variable,encodeTable,format,3,0.0315364,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);"
944,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18366,18376,IdentifierMutator-Variable,encodeTable,b,4,0.021966565,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);"
945,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18366,18376,FieldReferenceMutator,encodeTable,type,0,0.17578407,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);"
946,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18366,18376,FieldReferenceMutator,encodeTable,x,1,0.15709198,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);"
947,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18366,18376,FieldReferenceMutator,encodeTable,mode,2,0.101163544,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);"
948,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18366,18376,FieldReferenceMutator,encodeTable,format,3,0.0315364,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);"
949,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18366,18376,FieldReferenceMutator,encodeTable,b,4,0.021966565,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);"
950,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18381,18401,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,null,0,0.52712524,<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
       "
951,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18381,18401,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,0,1,0.098542385,<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
       "
952,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18381,18401,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,1,2,0.07591251,<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
       "
953,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18381,18401,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,2,3,0.035101704,<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
       "
954,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18381,18401,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,nil,4,0.019541532,<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
       "
955,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18381,18401,FieldReferenceMutator,STANDARD_ENCODE_TABLE,null,0,0.52712524,org.apache.commons.codec.binary.Base64.<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
       "
956,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18381,18401,FieldReferenceMutator,STANDARD_ENCODE_TABLE,0,1,0.098542385,org.apache.commons.codec.binary.Base64.<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
       "
957,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18381,18401,FieldReferenceMutator,STANDARD_ENCODE_TABLE,1,2,0.07591251,org.apache.commons.codec.binary.Base64.<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
       "
958,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18381,18401,FieldReferenceMutator,STANDARD_ENCODE_TABLE,2,3,0.035101704,org.apache.commons.codec.binary.Base64.<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
       "
959,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,464,18381,18401,FieldReferenceMutator,STANDARD_ENCODE_TABLE,nil,4,0.019541532,org.apache.commons.codec.binary.Base64.<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
       "
960,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18443,18443,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,|,0,0.7498229,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"           break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
"
961,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18443,18443,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,^,1,0.14972508,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"           break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
"
962,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18443,18443,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,*,2,0.06848053,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"           break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
"
963,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18443,18443,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,&,3,0.011649835,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"           break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
"
964,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18443,18443,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,<<,4,0.0072465204,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"           break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
"
965,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18437,18441,ArrayAccessMutator,pos++,pos,0,0.9939487,buffer[<mask>],"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }"
966,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18437,18441,ArrayAccessMutator,pos++,++,1,5.1500427E-4,buffer[<mask>],"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }"
967,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18437,18441,ArrayAccessMutator,pos++,offset,2,3.9068158E-4,buffer[<mask>],"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }"
968,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18437,18441,ArrayAccessMutator,pos++,size,3,3.884499E-4,buffer[<mask>],"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }"
969,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18437,18441,ArrayAccessMutator,pos++,len,4,3.1160953E-4,buffer[<mask>],"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }"
970,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18430,18435,IdentifierMutator-Variable,buffer,pad,2,4.1653067E-4,<mask>,"                   }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
         "
971,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18430,18435,IdentifierMutator-Variable,buffer,buf,3,3.360046E-4,<mask>,"                   }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
         "
972,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18430,18435,IdentifierMutator-Variable,buffer,padding,4,2.740748E-4,<mask>,"                   }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
         "
973,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18430,18435,FieldReferenceMutator,buffer,pad,2,4.1653067E-4,<mask>,"                   }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
         "
974,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18430,18435,FieldReferenceMutator,buffer,buf,3,3.360046E-4,<mask>,"                   }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
         "
975,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18430,18435,FieldReferenceMutator,buffer,padding,4,2.740748E-4,<mask>,"                   }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
         "
976,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18440,18441,UnaryOperatorMutator,++,++;,2,7.4707656E-5,pos<mask>,"             break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos<mask>] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }"
977,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18440,18441,UnaryOperatorMutator,++,+,3,5.928225E-5,pos<mask>,"             break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos<mask>] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }"
978,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18440,18441,UnaryOperatorMutator,++,--,4,2.03137E-5,pos<mask>,"             break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos<mask>] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }"
979,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18437,18439,IdentifierMutator-Variable,pos,size,1,1.931059E-4,<mask>,"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
           "
980,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18437,18439,IdentifierMutator-Variable,pos,len,2,1.3607575E-4,<mask>,"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
           "
981,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18437,18439,IdentifierMutator-Variable,pos,offset,3,6.0935992E-5,<mask>,"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
           "
982,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18437,18439,FieldReferenceMutator,pos,size,1,1.931059E-4,<mask>,"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
           "
983,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18437,18439,FieldReferenceMutator,pos,len,2,1.3607575E-4,<mask>,"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
           "
984,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18437,18439,FieldReferenceMutator,pos,offset,3,6.0935992E-5,<mask>,"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
           "
985,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18446,18448,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,x,0,0.6369752,<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
   "
986,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18446,18448,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,0,1,0.1098282,<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
   "
987,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18446,18448,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,"''",2,0.042834878,<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
   "
988,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18446,18448,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,"""""",3,0.03445012,<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
   "
989,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18446,18448,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,null,4,0.025843298,<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
   "
990,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18446,18448,FieldReferenceMutator,PAD,x,0,0.6369752,org.apache.commons.codec.binary.Base64.<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
   "
991,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18446,18448,FieldReferenceMutator,PAD,0,1,0.1098282,org.apache.commons.codec.binary.Base64.<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
   "
992,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18446,18448,FieldReferenceMutator,PAD,"''",2,0.042834878,org.apache.commons.codec.binary.Base64.<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
   "
993,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18446,18448,FieldReferenceMutator,PAD,"""""",3,0.03445012,org.apache.commons.codec.binary.Base64.<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
   "
994,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,465,18446,18448,FieldReferenceMutator,PAD,null,4,0.025843298,org.apache.commons.codec.binary.Base64.<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
   "
995,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18702,ArrayAccessMutator,lineSeparator.length-1,pos,0,0.8719626,lineSeparator[<mask>],"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask>];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
   "
996,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18702,ArrayAccessMutator,lineSeparator.length-1,0,1,0.033694748,lineSeparator[<mask>],"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask>];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
   "
997,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18702,ArrayAccessMutator,lineSeparator.length-1,i,2,0.032686237,lineSeparator[<mask>],"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask>];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
   "
998,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18702,ArrayAccessMutator,lineSeparator.length-1,1,3,0.013113686,lineSeparator[<mask>],"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask>];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
   "
999,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18702,ArrayAccessMutator,lineSeparator.length-1,position,4,0.0038998248,lineSeparator[<mask>],"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask>];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
   "
1000,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18665,18677,IdentifierMutator-Variable,lineSeparator,buffer,0,0.9777476,<mask>,"        buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b =<mask>[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++mod"
1001,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18665,18677,IdentifierMutator-Variable,lineSeparator,line,1,0.005508717,<mask>,"        buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b =<mask>[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++mod"
1002,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18665,18677,IdentifierMutator-Variable,lineSeparator,buffers,2,0.0017159112,<mask>,"        buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b =<mask>[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++mod"
1003,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18665,18677,IdentifierMutator-Variable,lineSeparator,buf,3,7.895228E-4,<mask>,"        buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b =<mask>[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++mod"
1004,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18665,18677,IdentifierMutator-Variable,lineSeparator,string,4,6.2931894E-4,<mask>,"        buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b =<mask>[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++mod"
1005,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18665,18677,FieldReferenceMutator,lineSeparator,buffer,0,0.9777476,<mask>,"        buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b =<mask>[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++mod"
1006,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18665,18677,FieldReferenceMutator,lineSeparator,line,1,0.005508717,<mask>,"        buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b =<mask>[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++mod"
1007,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18665,18677,FieldReferenceMutator,lineSeparator,buffers,2,0.0017159112,<mask>,"        buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b =<mask>[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++mod"
1008,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18665,18677,FieldReferenceMutator,lineSeparator,buf,3,7.895228E-4,<mask>,"        buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b =<mask>[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++mod"
1009,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18665,18677,FieldReferenceMutator,lineSeparator,string,4,6.2931894E-4,<mask>,"        buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b =<mask>[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++mod"
1010,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18699,18701,BinaryOperatorMutator,-,)-,2,0.002263067,lineSeparator.length <mask> 1,"] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length<mask>1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
  "
1011,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18699,18701,BinaryOperatorMutator,-,+,3,5.178125E-4,lineSeparator.length <mask> 1,"] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length<mask>1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
  "
1012,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18699,18701,BinaryOperatorMutator,-,-$,4,1.9435088E-4,lineSeparator.length <mask> 1,"] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length<mask>1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
  "
1013,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18698,IdentifierMutator-Variable,lineSeparator.length,pos,0,0.9869882,<mask>,"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask> - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
 "
1014,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18698,IdentifierMutator-Variable,lineSeparator.length,position,1,0.002164099,<mask>,"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask> - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
 "
1015,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18698,IdentifierMutator-Variable,lineSeparator.length,len,2,0.0017955183,<mask>,"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask> - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
 "
1016,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18698,IdentifierMutator-Variable,lineSeparator.length,i,3,0.0016396628,<mask>,"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask> - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
 "
1017,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18698,IdentifierMutator-Variable,lineSeparator.length,Pos,4,0.001192863,<mask>,"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask> - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
 "
1018,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18691,IdentifierMutator-Variable,lineSeparator,buffer,0,0.9825522,<mask>,"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask>.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;"
1019,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18691,IdentifierMutator-Variable,lineSeparator,buffer,1,0.006055008,<mask>,"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask>.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;"
1020,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18691,IdentifierMutator-Variable,lineSeparator,Buffer,2,0.004930589,<mask>,"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask>.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;"
1021,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18691,IdentifierMutator-Variable,lineSeparator,line,3,7.663249E-4,<mask>,"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask>.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;"
1022,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18691,IdentifierMutator-Variable,lineSeparator,buf,4,6.701628E-4,<mask>,"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask>.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;"
1023,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18691,FieldReferenceMutator,lineSeparator,buffer,0,0.9825522,<mask>,"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask>.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;"
1024,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18691,FieldReferenceMutator,lineSeparator,buffer,1,0.006055008,<mask>,"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask>.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;"
1025,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18691,FieldReferenceMutator,lineSeparator,Buffer,2,0.004930589,<mask>,"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask>.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;"
1026,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18691,FieldReferenceMutator,lineSeparator,line,3,7.663249E-4,<mask>,"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask>.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;"
1027,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18679,18691,FieldReferenceMutator,lineSeparator,buf,4,6.701628E-4,<mask>,"   buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[<mask>.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;"
1028,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18693,18698,FieldReferenceMutator,length,position,1,2.1912242E-4,lineSeparator.<mask>,"++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.<mask> - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
 "
1029,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18693,18698,FieldReferenceMutator,length,size,3,2.060282E-5,lineSeparator.<mask>,"++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.<mask> - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
 "
1030,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18693,18698,FieldReferenceMutator,length,len,4,1.9201525E-5,lineSeparator.<mask>,"++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.<mask> - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
 "
1031,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18702,18702,IdentifierMutator-Literal,1,2,1,0.03240889,<mask>," = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length -<mask>];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
   "
1032,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18702,18702,IdentifierMutator-Literal,1,pos,2,0.02874814,<mask>," = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length -<mask>];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
   "
1033,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,471,18702,18702,IdentifierMutator-Literal,1,3,3,0.0016795489,<mask>," = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length -<mask>];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
   "
1034,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18747,18750,BinaryOperatorMutator,&&,||,2,0.0070492234,((lineLength > 0) && (pos > 0)) <mask> (buffer[pos - 1] != b),"              // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0<mask>buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
  "
1035,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18747,18750,BinaryOperatorMutator,&&,.,3,0.005474517,((lineLength > 0) && (pos > 0)) <mask> (buffer[pos - 1] != b),"              // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0<mask>buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
  "
1036,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18747,18750,BinaryOperatorMutator,&&,&,4,0.003580381,((lineLength > 0) && (pos > 0)) <mask> (buffer[pos - 1] != b),"              // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0<mask>buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
  "
1037,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18736,18739,BinaryOperatorMutator,&&,.,2,0.034335095,(lineLength > 0) <mask> (pos > 0),"                  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0<mask>pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++"
1038,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18736,18739,BinaryOperatorMutator,&&,?,3,0.027106514,(lineLength > 0) <mask> (pos > 0),"                  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0<mask>pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++"
1039,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18736,18739,BinaryOperatorMutator,&&,;,4,0.02353593,(lineLength > 0) <mask> (pos > 0),"                  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0<mask>pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++"
1040,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18732,18734,BinaryOperatorMutator,>,==,1,0.19588193,lineLength <mask> 0,"                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength<mask>0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[in"
1041,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18732,18734,BinaryOperatorMutator,>,!=,3,0.008534322,lineLength <mask> 0,"                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength<mask>0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[in"
1042,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18732,18734,BinaryOperatorMutator,>,==,4,0.0072041387,lineLength <mask> 0,"                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength<mask>0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[in"
1043,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18722,18731,IdentifierMutator-Variable,lineLength,b,0,0.8710875,<mask>,"];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (<mask> > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in["
1044,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18722,18731,IdentifierMutator-Variable,lineLength,buffer,1,0.036543544,<mask>,"];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (<mask> > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in["
1045,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18722,18731,IdentifierMutator-Variable,lineLength,bb,2,0.01702729,<mask>,"];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (<mask> > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in["
1046,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18722,18731,IdentifierMutator-Variable,lineLength,buf,3,0.010394983,<mask>,"];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (<mask> > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in["
1047,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18722,18731,IdentifierMutator-Variable,lineLength,i,4,0.0056576184,<mask>,"];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (<mask> > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in["
1048,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18722,18731,FieldReferenceMutator,lineLength,b,0,0.8710875,<mask>,"];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (<mask> > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in["
1049,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18722,18731,FieldReferenceMutator,lineLength,buffer,1,0.036543544,<mask>,"];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (<mask> > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in["
1050,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18722,18731,FieldReferenceMutator,lineLength,bb,2,0.01702729,<mask>,"];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (<mask> > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in["
1051,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18722,18731,FieldReferenceMutator,lineLength,buf,3,0.010394983,<mask>,"];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (<mask> > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in["
1052,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18722,18731,FieldReferenceMutator,lineLength,i,4,0.0056576184,<mask>,"];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (<mask> > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in["
1053,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18735,18735,IdentifierMutator-Literal,0,1,1,0.28254583,<mask>,"                   // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength ><mask> && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos"
1054,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18735,18735,IdentifierMutator-Literal,0,2,2,0.06657334,<mask>,"                   // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength ><mask> && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos"
1055,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18735,18735,IdentifierMutator-Literal,0,3,3,0.0045601344,<mask>,"                   // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength ><mask> && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos"
1056,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18735,18735,IdentifierMutator-Literal,0,4,4,0.0015081962,<mask>,"                   // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength ><mask> && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos"
1057,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18743,18745,BinaryOperatorMutator,>,==,2,0.04651127,pos <mask> 0,"                // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos<mask>0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
"
1058,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18743,18745,BinaryOperatorMutator,>,>=,3,0.015157509,pos <mask> 0,"                // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos<mask>0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
"
1059,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18743,18745,BinaryOperatorMutator,>,!=,4,0.009710515,pos <mask> 0,"                // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos<mask>0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
"
1060,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18740,18742,IdentifierMutator-Variable,pos,b,1,0.12710509,<mask>,"                 // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 &&<mask> > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];"
1061,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18740,18742,IdentifierMutator-Variable,pos,position,2,0.022424193,<mask>,"                 // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 &&<mask> > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];"
1062,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18740,18742,IdentifierMutator-Variable,pos,buf,3,0.008687845,<mask>,"                 // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 &&<mask> > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];"
1063,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18740,18742,IdentifierMutator-Variable,pos,offset,4,0.00586448,<mask>,"                 // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 &&<mask> > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];"
1064,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18740,18742,FieldReferenceMutator,pos,b,1,0.12710509,<mask>,"                 // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 &&<mask> > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];"
1065,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18740,18742,FieldReferenceMutator,pos,position,2,0.022424193,<mask>,"                 // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 &&<mask> > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];"
1066,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18740,18742,FieldReferenceMutator,pos,buf,3,0.008687845,<mask>,"                 // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 &&<mask> > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];"
1067,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18740,18742,FieldReferenceMutator,pos,offset,4,0.00586448,<mask>,"                 // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 &&<mask> > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];"
1068,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18746,18746,IdentifierMutator-Literal,0,1,1,0.13062055,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos ><mask> && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
 "
1069,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18746,18746,IdentifierMutator-Literal,0,pos,2,0.009851255,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos ><mask> && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
 "
1070,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18746,18746,IdentifierMutator-Literal,0,start,3,0.007995331,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos ><mask> && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
 "
1071,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18746,18746,IdentifierMutator-Literal,0,2,4,0.0036696412,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos ><mask> && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
 "
1072,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18764,18767,BinaryOperatorMutator,!=,==,0,0.844594,buffer[pos - 1] <mask> b,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1]<mask>b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
         "
1073,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18764,18767,BinaryOperatorMutator,!=,==,2,0.037554607,buffer[pos - 1] <mask> b,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1]<mask>b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
         "
1074,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18764,18767,BinaryOperatorMutator,!=,<,3,0.01463605,buffer[pos - 1] <mask> b,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1]<mask>b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
         "
1075,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18764,18767,BinaryOperatorMutator,!=,=,4,0.010906315,buffer[pos - 1] <mask> b,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1]<mask>b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
         "
1076,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18758,18762,ArrayAccessMutator,pos-1,pos,0,0.9950781,buffer[<mask>],"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[<mask>] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
       "
1077,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18758,18762,ArrayAccessMutator,pos-1,0,1,0.0013122666,buffer[<mask>],"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[<mask>] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
       "
1078,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18758,18762,ArrayAccessMutator,pos-1,pos,2,7.7054766E-4,buffer[<mask>],"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[<mask>] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
       "
1079,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18758,18762,ArrayAccessMutator,pos-1,Pos,3,6.625365E-4,buffer[<mask>],"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[<mask>] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
       "
1080,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18758,18762,ArrayAccessMutator,pos-1,position,4,2.4233366E-4,buffer[<mask>],"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[<mask>] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
       "
1081,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18751,18756,IdentifierMutator-Variable,buffer,in,1,0.18446009,<mask>,"             // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 &&<mask>[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
   "
1082,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18751,18756,IdentifierMutator-Variable,buffer,line,2,0.017862933,<mask>,"             // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 &&<mask>[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
   "
1083,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18751,18756,IdentifierMutator-Variable,buffer,out,3,0.0036373595,<mask>,"             // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 &&<mask>[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
   "
1084,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18751,18756,IdentifierMutator-Variable,buffer,buf,4,0.0035875887,<mask>,"             // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 &&<mask>[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
   "
1085,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18751,18756,FieldReferenceMutator,buffer,in,1,0.18446009,<mask>,"             // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 &&<mask>[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
   "
1086,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18751,18756,FieldReferenceMutator,buffer,line,2,0.017862933,<mask>,"             // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 &&<mask>[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
   "
1087,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18751,18756,FieldReferenceMutator,buffer,out,3,0.0036373595,<mask>,"             // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 &&<mask>[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
   "
1088,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18751,18756,FieldReferenceMutator,buffer,buf,4,0.0035875887,<mask>,"             // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 &&<mask>[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
   "
1089,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18761,18761,BinaryOperatorMutator,-,+,1,0.4310927,pos <mask> 1,"          // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos<mask>1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
      "
1090,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18761,18761,BinaryOperatorMutator,-,+,3,0.005718893,pos <mask> 1,"          // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos<mask>1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
      "
1091,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18761,18761,BinaryOperatorMutator,-,=-,4,0.0035928194,pos <mask> 1,"          // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos<mask>1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
      "
1092,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18758,18760,IdentifierMutator-Variable,pos,position,1,7.4914E-4,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[<mask>-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
     "
1093,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18758,18760,IdentifierMutator-Variable,pos,Pos,2,5.1419385E-4,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[<mask>-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
     "
1094,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18758,18760,IdentifierMutator-Variable,pos,length,3,5.1107473E-4,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[<mask>-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
     "
1095,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18758,18760,FieldReferenceMutator,pos,position,1,7.4914E-4,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[<mask>-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
     "
1096,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18758,18760,FieldReferenceMutator,pos,Pos,2,5.1419385E-4,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[<mask>-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
     "
1097,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18758,18760,FieldReferenceMutator,pos,length,3,5.1107473E-4,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[<mask>-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
     "
1098,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18762,18762,IdentifierMutator-Literal,1,pos,1,0.020292204,<mask>,"         // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-<mask>] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
       "
1099,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18762,18762,IdentifierMutator-Literal,1,2,3,0.008255549,<mask>,"         // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-<mask>] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
       "
1100,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18762,18762,IdentifierMutator-Literal,1,offset,4,0.0018014391,<mask>,"         // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-<mask>] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
       "
1101,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18768,18768,IdentifierMutator-Variable,b,0,1,0.015434038,<mask>,"      // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] !=<mask>) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
          "
1102,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18768,18768,IdentifierMutator-Variable,b,null,2,0.006525194,<mask>,"      // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] !=<mask>) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
          "
1103,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18768,18768,IdentifierMutator-Variable,b,c,3,0.0021933084,<mask>,"      // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] !=<mask>) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
          "
1104,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,472,18768,18768,IdentifierMutator-Variable,b,a,4,7.303366E-4,<mask>,"      // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] !=<mask>) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
          "
1105,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18796,18804,MethodCallMutator,arraycopy,printf,0,0.4701126,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)","                   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
         "
1106,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18796,18804,MethodCallMutator,arraycopy,copy,1,0.34113303,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)","                   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
         "
1107,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18796,18804,MethodCallMutator,arraycopy,write,2,0.050998103,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)","                   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
         "
1108,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18796,18804,MethodCallMutator,arraycopy,append,3,0.026402317,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)","                   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
         "
1109,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18796,18804,MethodCallMutator,arraycopy,replace,4,0.021148883,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)","                   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
         "
1110,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18806,18818,IdentifierMutator-Variable,lineSeparator,buffer,0,0.9387213,<mask>,"                if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1111,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18806,18818,IdentifierMutator-Variable,lineSeparator,in,1,0.030669458,<mask>,"                if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1112,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18806,18818,IdentifierMutator-Variable,lineSeparator,buf,2,0.0070914035,<mask>,"                if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1113,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18806,18818,IdentifierMutator-Variable,lineSeparator,b,3,0.0031446014,<mask>,"                if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1114,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18806,18818,IdentifierMutator-Variable,lineSeparator,Buffer,4,0.0019148972,<mask>,"                if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1115,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18806,18818,FieldReferenceMutator,lineSeparator,buffer,0,0.9387213,<mask>,"                if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1116,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18806,18818,FieldReferenceMutator,lineSeparator,in,1,0.030669458,<mask>,"                if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1117,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18806,18818,FieldReferenceMutator,lineSeparator,buf,2,0.0070914035,<mask>,"                if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1118,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18806,18818,FieldReferenceMutator,lineSeparator,b,3,0.0031446014,<mask>,"                if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1119,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18806,18818,FieldReferenceMutator,lineSeparator,Buffer,4,0.0019148972,<mask>,"                if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1120,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18821,18821,IdentifierMutator-Literal,0,1,1,0.003961576,<mask>,"           if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator,<mask>, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                "
1121,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18821,18821,IdentifierMutator-Literal,0,pos,2,0.0031825635,<mask>,"           if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator,<mask>, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                "
1122,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18821,18821,IdentifierMutator-Literal,0,start,4,4.3627844E-4,<mask>,"           if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator,<mask>, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                "
1123,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18824,18829,IdentifierMutator-Variable,buffer,buf,1,4.2377604E-4,<mask>,"         if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1124,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18824,18829,IdentifierMutator-Variable,buffer,in,3,2.3454503E-4,<mask>,"         if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1125,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18824,18829,IdentifierMutator-Variable,buffer,buffers,4,1.1006122E-4,<mask>,"         if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1126,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18824,18829,FieldReferenceMutator,buffer,buf,1,4.2377604E-4,<mask>,"         if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1127,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18824,18829,FieldReferenceMutator,buffer,in,3,2.3454503E-4,<mask>,"         if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1128,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18824,18829,FieldReferenceMutator,buffer,buffers,4,1.1006122E-4,<mask>,"         if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1129,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18832,18834,IdentifierMutator-Variable,pos,0,1,0.013671595,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b"
1130,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18832,18834,IdentifierMutator-Variable,pos,1,2,0.0032149886,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b"
1131,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18832,18834,IdentifierMutator-Variable,pos,position,4,8.455609E-4,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b"
1132,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18832,18834,FieldReferenceMutator,pos,0,1,0.013671595,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b"
1133,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18832,18834,FieldReferenceMutator,pos,1,2,0.0032149886,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b"
1134,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18832,18834,FieldReferenceMutator,pos,position,4,8.455609E-4,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b"
1135,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18837,18856,IdentifierMutator-Variable,lineSeparator.length,b,0,0.98931456,<mask>,"     if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1136,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18837,18856,IdentifierMutator-Variable,lineSeparator.length,b,1,0.0016402941,<mask>,"     if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1137,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18837,18856,IdentifierMutator-Variable,lineSeparator.length,n,2,0.0012552569,<mask>,"     if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1138,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18837,18856,IdentifierMutator-Variable,lineSeparator.length,c,3,9.88322E-4,<mask>,"     if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1139,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18837,18856,IdentifierMutator-Variable,lineSeparator.length,pos,4,5.7839893E-4,<mask>,"     if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1140,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18837,18849,IdentifierMutator-Variable,lineSeparator,buffer,0,0.99383223,<mask>,"     if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1141,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18837,18849,IdentifierMutator-Variable,lineSeparator,buffer,1,0.0017621001,<mask>,"     if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1142,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18837,18849,IdentifierMutator-Variable,lineSeparator,b,2,0.0013890141,<mask>,"     if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1143,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18837,18849,IdentifierMutator-Variable,lineSeparator,buf,3,6.1781134E-4,<mask>,"     if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1144,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18837,18849,IdentifierMutator-Variable,lineSeparator,line,4,3.713327E-4,<mask>,"     if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1145,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18837,18849,FieldReferenceMutator,lineSeparator,buffer,0,0.99383223,<mask>,"     if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1146,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18837,18849,FieldReferenceMutator,lineSeparator,buffer,1,0.0017621001,<mask>,"     if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1147,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18837,18849,FieldReferenceMutator,lineSeparator,b,2,0.0013890141,<mask>,"     if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1148,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18837,18849,FieldReferenceMutator,lineSeparator,buf,3,6.1781134E-4,<mask>,"     if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1149,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18837,18849,FieldReferenceMutator,lineSeparator,line,4,3.713327E-4,<mask>,"     if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1150,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18851,18856,FieldReferenceMutator,length,len,2,3.1360363E-5,lineSeparator.<mask>," (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1151,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18851,18856,FieldReferenceMutator,length,position,3,2.0315238E-5,lineSeparator.<mask>," (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1152,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,473,18851,18856,FieldReferenceMutator,length,count,4,7.2549174E-6,lineSeparator.<mask>," (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1153,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18879,18879,AssignmentMutator,pos+=lineSeparator.length,++,0,0.963919,pos <mask>= lineSeparator.length,"                    buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos<mask>+= lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1154,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18879,18879,AssignmentMutator,pos+=lineSeparator.length,++,1,0.007336445,pos <mask>= lineSeparator.length,"                    buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos<mask>+= lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1155,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18879,18879,AssignmentMutator,pos+=lineSeparator.length,+,2,0.0046882504,pos <mask>= lineSeparator.length,"                    buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos<mask>+= lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1156,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18879,18879,AssignmentMutator,pos+=lineSeparator.length,*,3,0.0037178798,pos <mask>= lineSeparator.length,"                    buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos<mask>+= lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1157,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18879,18879,AssignmentMutator,pos+=lineSeparator.length,//,4,0.0033601092,pos <mask>= lineSeparator.length,"                    buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos<mask>+= lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1158,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18876,18878,IdentifierMutator-Variable,pos,position,2,5.508969E-4,<mask>,"codeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1159,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18876,18878,IdentifierMutator-Variable,pos,Pos,3,1.13760136E-4,<mask>,"codeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1160,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18876,18878,IdentifierMutator-Variable,pos,offset,4,8.70114E-5,<mask>,"codeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1161,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18876,18878,FieldReferenceMutator,pos,position,2,5.508969E-4,<mask>,"codeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1162,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18876,18878,FieldReferenceMutator,pos,Pos,3,1.13760136E-4,<mask>,"codeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1163,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18876,18878,FieldReferenceMutator,pos,offset,4,8.70114E-5,<mask>,"codeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1164,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18883,18902,IdentifierMutator-Variable,lineSeparator.length,2,0,0.6591096,<mask>,"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1165,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18883,18902,IdentifierMutator-Variable,lineSeparator.length,1,1,0.15036714,<mask>,"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1166,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18883,18902,IdentifierMutator-Variable,lineSeparator.length,b,2,0.056022175,<mask>,"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1167,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18883,18902,IdentifierMutator-Variable,lineSeparator.length,n,3,0.016392639,<mask>,"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1168,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18883,18902,IdentifierMutator-Variable,lineSeparator.length,4,4,0.015331744,<mask>,"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1169,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18883,18895,IdentifierMutator-Variable,lineSeparator,buffer,0,0.75772303,<mask>,"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1170,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18883,18895,IdentifierMutator-Variable,lineSeparator,b,1,0.22565527,<mask>,"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1171,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18883,18895,IdentifierMutator-Variable,lineSeparator,buf,2,0.006270683,<mask>,"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1172,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18883,18895,IdentifierMutator-Variable,lineSeparator,line,3,0.0016827348,<mask>,"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1173,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18883,18895,IdentifierMutator-Variable,lineSeparator,byte,4,9.694294E-4,<mask>,"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1174,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18883,18895,FieldReferenceMutator,lineSeparator,buffer,0,0.75772303,<mask>,"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1175,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18883,18895,FieldReferenceMutator,lineSeparator,b,1,0.22565527,<mask>,"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1176,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18883,18895,FieldReferenceMutator,lineSeparator,buf,2,0.006270683,<mask>,"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1177,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18883,18895,FieldReferenceMutator,lineSeparator,line,3,0.0016827348,<mask>,"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1178,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18883,18895,FieldReferenceMutator,lineSeparator,byte,4,9.694294E-4,<mask>,"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1179,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18897,18902,FieldReferenceMutator,length,position,1,6.7382636E-5,lineSeparator.<mask>,"              buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1180,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18897,18902,FieldReferenceMutator,length,len,2,5.512696E-5,lineSeparator.<mask>,"              buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1181,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,474,18897,18902,FieldReferenceMutator,length,width,4,9.538806E-6,lineSeparator.<mask>,"              buffer[pos++] = PAD;
                    }
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1182,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18961,18961,IdentifierMutator-Literal,0,1,1,0.00657841,<mask>,"
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i =<mask>; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
    "
1183,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18961,18961,IdentifierMutator-Literal,0,pos,2,0.004807285,<mask>,"
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i =<mask>; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
    "
1184,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18961,18961,IdentifierMutator-Literal,0,start,3,0.001616467,<mask>,"
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i =<mask>; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
    "
1185,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18961,18961,IdentifierMutator-Literal,0,offset,4,0.0015089678,<mask>,"
                    break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i =<mask>; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
    "
1186,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18965,18967,BinaryOperatorMutator,<,++,2,0.0015606318,i <mask> inAvail,"                  break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i<mask>inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
       "
1187,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18965,18967,BinaryOperatorMutator,<,<=,3,9.852003E-4,i <mask> inAvail,"                  break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i<mask>inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
       "
1188,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18965,18967,BinaryOperatorMutator,<,==,4,7.487043E-4,i <mask> inAvail,"                  break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i<mask>inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
       "
1189,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18964,18964,IdentifierMutator-Variable,i,I,2,9.863978E-5,<mask>,"                   break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0;<mask> < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
      "
1190,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18964,18964,IdentifierMutator-Variable,i,ii,3,2.9712088E-5,<mask>,"                   break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0;<mask> < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
      "
1191,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18964,18964,IdentifierMutator-Variable,i,j,4,2.9423933E-5,<mask>,"                   break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0;<mask> < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
      "
1192,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18968,18974,IdentifierMutator-Variable,inAvail,size,0,0.15758763,<mask>,"                 break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i <<mask>; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
          "
1193,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18968,18974,IdentifierMutator-Variable,inAvail,length,1,0.085259944,<mask>,"                 break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i <<mask>; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
          "
1194,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18968,18974,IdentifierMutator-Variable,inAvail,len,2,0.07256491,<mask>,"                 break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i <<mask>; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
          "
1195,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18968,18974,IdentifierMutator-Variable,inAvail,256,3,0.06724207,<mask>,"                 break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i <<mask>; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
          "
1196,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18968,18974,IdentifierMutator-Variable,inAvail,limit,4,0.060971018,<mask>,"                 break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i <<mask>; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
          "
1197,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18978,18979,UnaryOperatorMutator,++,++),2,0.0017566433,i<mask>,"            break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i<mask>) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
            "
1198,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18978,18979,UnaryOperatorMutator,++,++;,3,3.6838243E-4,i<mask>,"            break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i<mask>) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
            "
1199,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18978,18979,UnaryOperatorMutator,++,--,4,2.2765336E-4,i<mask>,"            break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i<mask>) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
            "
1200,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18977,18977,IdentifierMutator-Variable,i,I,2,7.529971E-5,<mask>,"             break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail;<mask>++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
            "
1201,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18977,18977,IdentifierMutator-Variable,i,,3,4.0756026E-5,<mask>,"             break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail;<mask>++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
            "
1202,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,477,18977,18977,IdentifierMutator-Variable,i,j,4,3.4885685E-5,<mask>,"             break;
            }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail;<mask>++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
            "
1203,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19018,19021,BinaryOperatorMutator,||,|,2,0.010390791,(buffer == null) <mask> ((buffer.length - pos) < encodeSize),"   }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null<mask>buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK"
1204,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19018,19021,BinaryOperatorMutator,||,.,3,0.0034576186,(buffer == null) <mask> ((buffer.length - pos) < encodeSize),"   }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null<mask>buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK"
1205,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19018,19021,BinaryOperatorMutator,||,?,4,0.0019390045,(buffer == null) <mask> ((buffer.length - pos) < encodeSize),"   }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null<mask>buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK"
1206,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19010,19013,BinaryOperatorMutator,==,=,2,0.013496225,buffer <mask> null,"     }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer<mask>null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &"
1207,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19010,19013,BinaryOperatorMutator,==,===,3,0.0039609373,buffer <mask> null,"     }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer<mask>null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &"
1208,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19010,19013,BinaryOperatorMutator,==,_,4,0.0012875774,buffer <mask> null,"     }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer<mask>null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &"
1209,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19004,19009,IdentifierMutator-Variable,buffer,Buffer,2,0.003239816,<mask>,"      }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (<mask> == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)"
1210,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19004,19009,IdentifierMutator-Variable,buffer,buf,3,0.0026322643,<mask>,"      }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (<mask> == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)"
1211,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19004,19009,IdentifierMutator-Variable,buffer,in,4,0.0019830489,<mask>,"      }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (<mask> == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)"
1212,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19004,19009,FieldReferenceMutator,buffer,Buffer,2,0.003239816,<mask>,"      }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (<mask> == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)"
1213,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19004,19009,FieldReferenceMutator,buffer,buf,3,0.0026322643,<mask>,"      }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (<mask> == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)"
1214,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19004,19009,FieldReferenceMutator,buffer,in,4,0.0019830489,<mask>,"      }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (<mask> == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)"
1215,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19014,19017,IdentifierMutator-Literal,null,nil,1,0.0029843664,<mask>,"    }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer ==<mask> || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MAS"
1216,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19014,19017,IdentifierMutator-Literal,null,NULL,2,6.538662E-4,<mask>,"    }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer ==<mask> || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MAS"
1217,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19014,19017,IdentifierMutator-Literal,null,0,4,5.814253E-4,<mask>,"    }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer ==<mask> || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MAS"
1218,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19041,19043,BinaryOperatorMutator,<,>,1,0.17925353,(buffer.length - pos) <mask> encodeSize,"          // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos<mask>encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1219,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19041,19043,BinaryOperatorMutator,<,>,3,0.121492065,(buffer.length - pos) <mask> encodeSize,"          // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos<mask>encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1220,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19041,19043,BinaryOperatorMutator,<,==,4,0.092341885,(buffer.length - pos) <mask> encodeSize,"          // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos<mask>encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1221,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19035,19037,BinaryOperatorMutator,-,+,1,0.08120569,buffer.length <mask> pos,"            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length<mask>pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS"
1222,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19035,19037,BinaryOperatorMutator,-,*,2,0.060745932,buffer.length <mask> pos,"            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length<mask>pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS"
1223,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19035,19037,BinaryOperatorMutator,-,/,3,0.011655091,buffer.length <mask> pos,"            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length<mask>pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS"
1224,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19035,19037,BinaryOperatorMutator,-,_,4,0.01009174,buffer.length <mask> pos,"            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length<mask>pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS"
1225,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19022,19034,IdentifierMutator-Variable,buffer.length,i,0,0.209996,<mask>,"  }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1226,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19022,19034,IdentifierMutator-Variable,buffer.length,size,1,0.16489708,<mask>,"  }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1227,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19022,19034,IdentifierMutator-Variable,buffer.length,length,2,0.09553346,<mask>,"  }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1228,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19022,19034,IdentifierMutator-Variable,buffer.length,limit,3,0.071849115,<mask>,"  }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1229,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19022,19034,IdentifierMutator-Variable,buffer.length,end,4,0.026936995,<mask>,"  }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1230,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19022,19027,IdentifierMutator-Variable,buffer,in,1,0.0014098678,<mask>,"  }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask>.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_"
1231,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19022,19027,IdentifierMutator-Variable,buffer,buf,2,6.2758813E-4,<mask>,"  }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask>.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_"
1232,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19022,19027,IdentifierMutator-Variable,buffer,input,3,4.6391037E-4,<mask>,"  }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask>.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_"
1233,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19022,19027,FieldReferenceMutator,buffer,in,1,0.0014098678,<mask>,"  }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask>.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_"
1234,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19022,19027,FieldReferenceMutator,buffer,buf,2,6.2758813E-4,<mask>,"  }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask>.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_"
1235,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19022,19027,FieldReferenceMutator,buffer,input,3,4.6391037E-4,<mask>,"  }
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask>.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_"
1236,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19029,19034,FieldReferenceMutator,length,position,1,0.0025516856,buffer.<mask>,"
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1237,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19029,19034,FieldReferenceMutator,length,size,2,7.50162E-4,buffer.<mask>,"
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1238,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19029,19034,FieldReferenceMutator,length,len,3,4.2439363E-4,buffer.<mask>,"
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1239,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19029,19034,FieldReferenceMutator,length,capacity,4,2.8662337E-4,buffer.<mask>,"
            // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1240,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19038,19040,IdentifierMutator-Variable,pos,i,0,0.55084056,<mask>,"           // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1241,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19038,19040,IdentifierMutator-Variable,pos,1,2,0.015176508,<mask>,"           // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1242,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19038,19040,IdentifierMutator-Variable,pos,index,3,0.009277212,<mask>,"           // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1243,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19038,19040,IdentifierMutator-Variable,pos,offset,4,0.0041471077,<mask>,"           // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1244,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19038,19040,FieldReferenceMutator,pos,i,0,0.55084056,<mask>,"           // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1245,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19038,19040,FieldReferenceMutator,pos,1,2,0.015176508,<mask>,"           // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1246,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19038,19040,FieldReferenceMutator,pos,index,3,0.009277212,<mask>,"           // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1247,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19038,19040,FieldReferenceMutator,pos,offset,4,0.0041471077,<mask>,"           // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1248,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19044,19053,IdentifierMutator-Variable,encodeSize,0,0,0.24543959,<mask>,"         // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1249,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19044,19053,IdentifierMutator-Variable,encodeSize,3,1,0.067837,<mask>,"         // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1250,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19044,19053,IdentifierMutator-Variable,encodeSize,1,2,0.06660223,<mask>,"         // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1251,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19044,19053,IdentifierMutator-Variable,encodeSize,i,3,0.06419445,<mask>,"         // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1252,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19044,19053,IdentifierMutator-Variable,encodeSize,2,4,0.05358013,<mask>,"         // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1253,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19044,19053,FieldReferenceMutator,encodeSize,0,0,0.24543959,<mask>,"         // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1254,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19044,19053,FieldReferenceMutator,encodeSize,3,1,0.067837,<mask>,"         // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1255,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19044,19053,FieldReferenceMutator,encodeSize,1,2,0.06660223,<mask>,"         // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1256,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19044,19053,FieldReferenceMutator,encodeSize,i,3,0.06419445,<mask>,"         // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1257,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,478,19044,19053,FieldReferenceMutator,encodeSize,2,4,0.05358013,<mask>,"         // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1258,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,479,19078,19089,MethodCallMutator,resizeBuffer,flush,0,0.34063348,<mask>(),"     // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encode"
1259,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,479,19078,19089,MethodCallMutator,resizeBuffer,close,1,0.13142665,<mask>(),"     // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encode"
1260,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,479,19078,19089,MethodCallMutator,resizeBuffer,break,2,0.05091138,<mask>(),"     // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encode"
1261,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,479,19078,19089,MethodCallMutator,resizeBuffer,reset,3,0.02910764,<mask>(),"     // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encode"
1262,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,479,19078,19089,MethodCallMutator,resizeBuffer,encode,4,0.018402534,<mask>(),"     // Don't want to append the CRLF two times in a row, so make sure previous
            // character is not from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encode"
1263,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19135,19135,AssignmentMutator,modulus=(++modulus)%3,|,0,0.4848181,modulus <mask>= (++modulus) % 3," b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus<mask>= (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1264,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19135,19135,AssignmentMutator,modulus=(++modulus)%3,^,1,0.2947702,modulus <mask>= (++modulus) % 3," b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus<mask>= (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1265,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19135,19135,AssignmentMutator,modulus=(++modulus)%3,*,2,0.1322979,modulus <mask>= (++modulus) % 3," b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus<mask>= (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1266,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19135,19135,AssignmentMutator,modulus=(++modulus)%3,~,3,0.023359897,modulus <mask>= (++modulus) % 3," b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus<mask>= (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1267,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19135,19135,AssignmentMutator,modulus=(++modulus)%3,&,4,0.021523328,modulus <mask>= (++modulus) % 3," b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus<mask>= (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1268,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19128,19134,IdentifierMutator-Variable,modulus,mod,0,0.3699132,<mask>," from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1269,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19128,19134,IdentifierMutator-Variable,modulus,i,1,0.23197326,<mask>," from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1270,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19128,19134,IdentifierMutator-Variable,modulus,shift,2,0.034846287,<mask>," from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1271,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19128,19134,IdentifierMutator-Variable,modulus,x,3,0.034317855,<mask>," from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1272,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19128,19134,IdentifierMutator-Variable,modulus,b,4,0.031478923,<mask>," from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1273,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19128,19134,FieldReferenceMutator,modulus,mod,0,0.3699132,<mask>," from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1274,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19128,19134,FieldReferenceMutator,modulus,i,1,0.23197326,<mask>," from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1275,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19128,19134,FieldReferenceMutator,modulus,shift,2,0.034846287,<mask>," from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1276,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19128,19134,FieldReferenceMutator,modulus,x,3,0.034317855,<mask>," from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1277,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19128,19134,FieldReferenceMutator,modulus,b,4,0.031478923,<mask>," from CRLF!
            byte b = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1278,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19149,19151,BinaryOperatorMutator,%,<<,0,0.25077134,(++modulus) <mask> 3,"[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus)<mask>3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable"
1279,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19149,19151,BinaryOperatorMutator,%,>>>,1,0.11275051,(++modulus) <mask> 3,"[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus)<mask>3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable"
1280,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19149,19151,BinaryOperatorMutator,%,>>,2,0.09761336,(++modulus) <mask> 3,"[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus)<mask>3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable"
1281,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19149,19151,BinaryOperatorMutator,%,^,3,0.09612127,(++modulus) <mask> 3,"[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus)<mask>3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable"
1282,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19149,19151,BinaryOperatorMutator,%,*,4,0.0916358,(++modulus) <mask> 3,"[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus)<mask>3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable"
1283,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19138,19140,UnaryOperatorMutator,++,(,0,0.88770586,<mask>modulus," = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus =<mask>modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++"
1284,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19138,19140,UnaryOperatorMutator,++,((,1,0.043821227,<mask>modulus," = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus =<mask>modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++"
1285,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19138,19140,UnaryOperatorMutator,++,(-,2,0.020717932,<mask>modulus," = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus =<mask>modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++"
1286,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19138,19140,UnaryOperatorMutator,++,$(,3,0.01975061,<mask>modulus," = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus =<mask>modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++"
1287,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19138,19140,UnaryOperatorMutator,++,(,4,0.014665289,<mask>modulus," = lineSeparator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus =<mask>modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++"
1288,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19141,19147,IdentifierMutator-Variable,modulus,pos,0,0.2235979,<mask>,"Separator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1289,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19141,19147,IdentifierMutator-Variable,modulus,i,1,0.1436252,<mask>,"Separator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1290,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19141,19147,IdentifierMutator-Variable,modulus,x,2,0.034290373,<mask>,"Separator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1291,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19141,19147,IdentifierMutator-Variable,modulus,shift,3,0.024799755,<mask>,"Separator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1292,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19141,19147,IdentifierMutator-Variable,modulus,c,4,0.014646809,<mask>,"Separator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1293,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19141,19147,FieldReferenceMutator,modulus,pos,0,0.2235979,<mask>,"Separator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1294,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19141,19147,FieldReferenceMutator,modulus,i,1,0.1436252,<mask>,"Separator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1295,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19141,19147,FieldReferenceMutator,modulus,x,2,0.034290373,<mask>,"Separator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1296,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19141,19147,FieldReferenceMutator,modulus,shift,3,0.024799755,<mask>,"Separator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1297,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19141,19147,FieldReferenceMutator,modulus,c,4,0.014646809,<mask>,"Separator[lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1298,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19152,19152,IdentifierMutator-Literal,3,256,0,0.6175095,<mask>,"lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) %<mask>;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable["
1299,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19152,19152,IdentifierMutator-Literal,3,8,1,0.1222842,<mask>,"lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) %<mask>;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable["
1300,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19152,19152,IdentifierMutator-Literal,3,7,2,0.033795107,<mask>,"lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) %<mask>;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable["
1301,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19152,19152,IdentifierMutator-Literal,3,32,3,0.032607734,<mask>,"lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) %<mask>;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable["
1302,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,481,19152,19152,IdentifierMutator-Literal,3,4,4,0.026661975,<mask>,"lineSeparator.length - 1];
            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) %<mask>;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable["
1303,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,482,19182,19188,ArrayAccessMutator,inPos++,i,0,0.6172837,in[<mask>],"lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1304,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,482,19182,19188,ArrayAccessMutator,inPos++,pos,1,0.34610695,in[<mask>],"lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1305,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,482,19182,19188,ArrayAccessMutator,inPos++,0,2,0.002988176,in[<mask>],"lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1306,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,482,19182,19188,ArrayAccessMutator,inPos++,j,3,0.0019196484,in[<mask>],"lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1307,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,482,19182,19188,ArrayAccessMutator,inPos++,x,4,0.0018561651,in[<mask>],"lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1308,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,482,19179,19180,IdentifierMutator-Variable,in,buffer,0,0.75470465,<mask>," if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b =<mask>[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
       "
1309,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,482,19179,19180,IdentifierMutator-Variable,in,input,2,0.01825693,<mask>," if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b =<mask>[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
       "
1310,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,482,19179,19180,IdentifierMutator-Variable,in,buf,3,0.017852625,<mask>," if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b =<mask>[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
       "
1311,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,482,19179,19180,IdentifierMutator-Variable,in,bytes,4,0.014151116,<mask>," if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b =<mask>[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
       "
1312,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,482,19187,19188,UnaryOperatorMutator,++,--,2,7.4298854E-4,inPos<mask>," > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1313,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,482,19187,19188,UnaryOperatorMutator,++,x,3,7.164841E-4,inPos<mask>," > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1314,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,482,19187,19188,UnaryOperatorMutator,++,i,4,2.5297987E-4,inPos<mask>," > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1315,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,482,19182,19186,IdentifierMutator-Variable,inPos,pos,0,0.98062027,<mask>,"lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
          "
1316,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,482,19182,19186,IdentifierMutator-Variable,inPos,i,1,0.008441672,<mask>,"lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
          "
1317,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,482,19182,19186,IdentifierMutator-Variable,inPos,pos,2,0.0029290782,<mask>,"lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
          "
1318,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,482,19182,19186,IdentifierMutator-Variable,inPos,index,3,7.0824975E-4,<mask>,"lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
          "
1319,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,482,19182,19186,IdentifierMutator-Variable,inPos,offset,4,6.43281E-4,<mask>,"lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
          "
1320,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,483,19213,19215,BinaryOperatorMutator,<,>,1,0.19194485,b <mask> 0,"             System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b<mask>0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK"
1321,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,483,19213,19215,BinaryOperatorMutator,<,==,2,0.18435054,b <mask> 0,"             System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b<mask>0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK"
1322,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,483,19213,19215,BinaryOperatorMutator,<,==,4,0.060205013,b <mask> 0,"             System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b<mask>0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK"
1323,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,483,19212,19212,IdentifierMutator-Variable,b,bb,1,0.0012546774,<mask>,"              System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (<mask> < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MAS"
1324,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,483,19212,19212,IdentifierMutator-Variable,b,bc,2,0.001182256,<mask>,"              System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (<mask> < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MAS"
1325,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,483,19212,19212,IdentifierMutator-Variable,b,a,3,6.7194423E-4,<mask>,"              System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (<mask> < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MAS"
1326,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,483,19216,19216,IdentifierMutator-Literal,0,256,1,0.21156868,<mask>,"            System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b <<mask>) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_"
1327,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,483,19216,19216,IdentifierMutator-Literal,0,128,2,0.04199126,<mask>,"            System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b <<mask>) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_"
1328,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,483,19216,19216,IdentifierMutator-Literal,0,1,3,0.011147414,<mask>,"            System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b <<mask>) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_"
1329,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,483,19216,19216,IdentifierMutator-Literal,0,255,4,0.009976119,<mask>,"            System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b <<mask>) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_"
1330,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,484,19242,19242,AssignmentMutator,b+=256,*,0,0.47544602,b <mask>= 256,", pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b<mask>+= 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1331,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,484,19242,19242,AssignmentMutator,b+=256,&,1,0.17089388,b <mask>= 256,", pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b<mask>+= 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1332,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,484,19242,19242,AssignmentMutator,b+=256,|,2,0.09240969,b <mask>= 256,", pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b<mask>+= 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1333,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,484,19242,19242,AssignmentMutator,b+=256,>>>,3,0.055562455,b <mask>= 256,", pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b<mask>+= 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1334,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,484,19242,19242,AssignmentMutator,b+=256,/,4,0.039260786,b <mask>= 256,", pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b<mask>+= 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1335,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,484,19241,19241,IdentifierMutator-Variable,b,x,2,0.0023339507,<mask>,"         System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {<mask> += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1336,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,484,19241,19241,IdentifierMutator-Variable,b,a,3,6.8368885E-4,<mask>,"         System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {<mask> += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1337,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,484,19241,19241,IdentifierMutator-Variable,b,x,4,3.4877277E-4,<mask>,"         System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {<mask> += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1338,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,484,19246,19248,IdentifierMutator-Literal,256,b,0,0.5066582,<mask>," pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b +=<mask>;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    current"
1339,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,484,19246,19248,IdentifierMutator-Literal,256,1,1,0.18218191,<mask>," pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b +=<mask>;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    current"
1340,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,484,19246,19248,IdentifierMutator-Literal,256,3,2,0.057953328,<mask>," pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b +=<mask>;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    current"
1341,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,484,19246,19248,IdentifierMutator-Literal,256,a,3,0.03459489,<mask>," pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b +=<mask>;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    current"
1342,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,484,19246,19248,IdentifierMutator-Literal,256,4,4,0.018121801,<mask>," pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b +=<mask>;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    current"
1343,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19286,19286,AssignmentMutator,x=(x<<8)+b,^,0,0.64949256,x <mask>= (x << 8) + b,"           }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x<mask>= (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1344,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19286,19286,AssignmentMutator,x=(x<<8)+b,|,1,0.1648105,x <mask>= (x << 8) + b,"           }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x<mask>= (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1345,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19286,19286,AssignmentMutator,x=(x<<8)+b,*,2,0.063775286,x <mask>= (x << 8) + b,"           }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x<mask>= (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1346,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19286,19286,AssignmentMutator,x=(x<<8)+b,>>,3,0.023959793,x <mask>= (x << 8) + b,"           }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x<mask>= (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1347,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19286,19286,AssignmentMutator,x=(x<<8)+b,&,4,0.013052157,x <mask>= (x << 8) + b,"           }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x<mask>= (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1348,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19285,19285,IdentifierMutator-Variable,x,xx,2,0.0056569874,<mask>,"       pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }<mask> = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1349,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19285,19285,IdentifierMutator-Variable,x,b,3,0.005582003,<mask>,"       pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }<mask> = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1350,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19285,19285,IdentifierMutator-Variable,x,pos,4,0.003914058,<mask>,"       pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }<mask> = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1351,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19285,19285,FieldReferenceMutator,x,xx,2,0.0056569874,<mask>,"       pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }<mask> = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1352,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19285,19285,FieldReferenceMutator,x,b,3,0.005582003,<mask>,"       pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }<mask> = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1353,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19285,19285,FieldReferenceMutator,x,pos,4,0.003914058,<mask>,"       pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }<mask> = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1354,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19297,19299,BinaryOperatorMutator,+,|,0,0.4727424,(x << 8) <mask> b,"     }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8)<mask>b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
 "
1355,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19297,19299,BinaryOperatorMutator,+,^,1,0.24300185,(x << 8) <mask> b,"     }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8)<mask>b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
 "
1356,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19297,19299,BinaryOperatorMutator,+,^,2,0.06435483,(x << 8) <mask> b,"     }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8)<mask>b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
 "
1357,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19297,19299,BinaryOperatorMutator,+,*,4,0.03675517,(x << 8) <mask> b,"     }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8)<mask>b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
 "
1358,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19291,19294,BinaryOperatorMutator,<<,*,2,0.052197065,x <mask> 8,"        }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x<mask>8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos)"
1359,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19291,19294,BinaryOperatorMutator,<<,*,3,0.04134577,x <mask> 8,"        }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x<mask>8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos)"
1360,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19291,19294,BinaryOperatorMutator,<<,>>,4,0.039283052,x <mask> 8,"        }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x<mask>8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos)"
1361,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19290,19290,IdentifierMutator-Variable,x,1,1,0.02460696,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1362,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19290,19290,IdentifierMutator-Variable,x,a,2,0.018948747,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1363,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19290,19290,IdentifierMutator-Variable,x,0,3,0.0052235285,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1364,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19290,19290,IdentifierMutator-Variable,x,i,4,0.004632921,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1365,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19290,19290,FieldReferenceMutator,x,1,1,0.02460696,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1366,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19290,19290,FieldReferenceMutator,x,a,2,0.018948747,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1367,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19290,19290,FieldReferenceMutator,x,0,3,0.0052235285,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1368,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19290,19290,FieldReferenceMutator,x,i,4,0.004632921,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1369,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19295,19295,IdentifierMutator-Literal,8,3,0,0.487876,<mask>,"       }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x <<<mask>) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {"
1370,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19295,19295,IdentifierMutator-Literal,8,6,1,0.09101585,<mask>,"       }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x <<<mask>) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {"
1371,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19295,19295,IdentifierMutator-Literal,8,7,2,0.068030104,<mask>,"       }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x <<<mask>) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {"
1372,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19295,19295,IdentifierMutator-Literal,8,4,3,0.06388681,<mask>,"       }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x <<<mask>) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {"
1373,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19295,19295,IdentifierMutator-Literal,8,1,4,0.058835242,<mask>,"       }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x <<<mask>) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {"
1374,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19300,19300,IdentifierMutator-Variable,b,1,1,0.06379104,<mask>,"    }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) +<mask>;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
  "
1375,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19300,19300,IdentifierMutator-Variable,b,0,2,0.003952813,<mask>,"    }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) +<mask>;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
  "
1376,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19300,19300,IdentifierMutator-Variable,b,2,3,0.0034723906,<mask>,"    }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) +<mask>;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
  "
1377,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,486,19300,19300,IdentifierMutator-Variable,b,a,4,0.0033479622,<mask>,"    }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) +<mask>;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
  "
1378,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,487,19324,19327,BinaryOperatorMutator,==,<,0,0.26369897,0 <mask> modulus,"       for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0<mask>modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                       "
1379,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,487,19324,19327,BinaryOperatorMutator,==,<,3,0.16148953,0 <mask> modulus,"       for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0<mask>modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                       "
1380,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,487,19324,19327,BinaryOperatorMutator,==,!=,4,0.076652415,0 <mask> modulus,"       for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0<mask>modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                       "
1381,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,487,19323,19323,IdentifierMutator-Literal,0,b,0,0.7616199,<mask>,"        for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (<mask> == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                      "
1382,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,487,19323,19323,IdentifierMutator-Literal,0,x,1,0.09502475,<mask>,"        for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (<mask> == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                      "
1383,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,487,19323,19323,IdentifierMutator-Literal,0,a,2,0.027436377,<mask>,"        for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (<mask> == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                      "
1384,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,487,19323,19323,IdentifierMutator-Literal,0,3,4,0.012158273,<mask>,"        for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (<mask> == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                      "
1385,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,487,19328,19334,IdentifierMutator-Variable,modulus,x,0,0.47359556,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1386,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,487,19328,19334,IdentifierMutator-Variable,modulus,b,1,0.41289622,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1387,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,487,19328,19334,IdentifierMutator-Variable,modulus,c,2,0.0117913615,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1388,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,487,19328,19334,IdentifierMutator-Variable,modulus,f,3,0.0065254415,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1389,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,487,19328,19334,IdentifierMutator-Variable,modulus,i,4,0.006065281,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1390,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,487,19328,19334,FieldReferenceMutator,modulus,x,0,0.47359556,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1391,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,487,19328,19334,FieldReferenceMutator,modulus,b,1,0.41289622,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1392,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,487,19328,19334,FieldReferenceMutator,modulus,c,2,0.0117913615,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1393,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,487,19328,19334,FieldReferenceMutator,modulus,f,3,0.0065254415,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1394,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,487,19328,19334,FieldReferenceMutator,modulus,i,4,0.006065281,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1395,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19372,19372,AssignmentMutator,buffer[pos++]=encodeTable[(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.58595383,buffer[pos++] <mask>= encodeTable[(x >> 18) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"         if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++]<mask>= encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
     "
1396,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19372,19372,AssignmentMutator,buffer[pos++]=encodeTable[(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.2882388,buffer[pos++] <mask>= encodeTable[(x >> 18) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"         if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++]<mask>= encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
     "
1397,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19372,19372,AssignmentMutator,buffer[pos++]=encodeTable[(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.043555997,buffer[pos++] <mask>= encodeTable[(x >> 18) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"         if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++]<mask>= encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
     "
1398,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19372,19372,AssignmentMutator,buffer[pos++]=encodeTable[(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.015775343,buffer[pos++] <mask>= encodeTable[(x >> 18) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"         if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++]<mask>= encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
     "
1399,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19372,19372,AssignmentMutator,buffer[pos++]=encodeTable[(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS],+,4,0.007666908,buffer[pos++] <mask>= encodeTable[(x >> 18) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"         if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++]<mask>= encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
     "
1400,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19366,19370,ArrayAccessMutator,pos++,pos,0,0.9988036,buffer[<mask>],"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1401,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19366,19370,ArrayAccessMutator,pos++,++,1,1.4204906E-4,buffer[<mask>],"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1402,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19366,19370,ArrayAccessMutator,pos++,0,2,1.1054925E-4,buffer[<mask>],"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1403,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19366,19370,ArrayAccessMutator,pos++,neg,3,7.330352E-5,buffer[<mask>],"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1404,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19366,19370,ArrayAccessMutator,pos++,position,4,6.649292E-5,buffer[<mask>],"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1405,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19359,19364,IdentifierMutator-Variable,buffer,Buffer,2,5.7525554E-4,<mask>,"  for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {<mask>[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
 "
1406,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19359,19364,IdentifierMutator-Variable,buffer,byte,3,3.3002844E-4,<mask>,"  for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {<mask>[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
 "
1407,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19359,19364,IdentifierMutator-Variable,buffer,byte,4,2.2382181E-4,<mask>,"  for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {<mask>[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
 "
1408,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19359,19364,FieldReferenceMutator,buffer,Buffer,2,5.7525554E-4,<mask>,"  for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {<mask>[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
 "
1409,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19359,19364,FieldReferenceMutator,buffer,byte,3,3.3002844E-4,<mask>,"  for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {<mask>[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
 "
1410,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19359,19364,FieldReferenceMutator,buffer,byte,4,2.2382181E-4,<mask>,"  for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {<mask>[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
 "
1411,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19369,19370,UnaryOperatorMutator,++,+,1,1.0852303E-4,pos<mask>,"           if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1412,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19369,19370,UnaryOperatorMutator,++,++;,3,4.3012962E-5,pos<mask>,"           if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1413,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19369,19370,UnaryOperatorMutator,++,--,4,3.441421E-5,pos<mask>,"           if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1414,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19366,19368,IdentifierMutator-Variable,pos,len,1,2.4805724E-5,<mask>,"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
   "
1415,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19366,19368,IdentifierMutator-Variable,pos,neg,2,2.326667E-5,<mask>,"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
   "
1416,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19366,19368,IdentifierMutator-Variable,pos,size,3,1.9429799E-5,<mask>,"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
   "
1417,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19366,19368,FieldReferenceMutator,pos,len,1,2.4805724E-5,<mask>,"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
   "
1418,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19366,19368,FieldReferenceMutator,pos,neg,2,2.326667E-5,<mask>,"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
   "
1419,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19366,19368,FieldReferenceMutator,pos,size,3,1.9429799E-5,<mask>,"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
   "
1420,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19387,19408,ArrayAccessMutator,(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.88661486,encodeTable[<mask>],"     if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1421,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19387,19408,ArrayAccessMutator,(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.020588694,encodeTable[<mask>],"     if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1422,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19387,19408,ArrayAccessMutator,(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,2,0.0059377034,encodeTable[<mask>],"     if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1423,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19387,19408,ArrayAccessMutator,(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS,xx,3,0.004727886,encodeTable[<mask>],"     if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1424,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19387,19408,ArrayAccessMutator,(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS,i,4,0.004462088,encodeTable[<mask>],"     if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1425,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19375,19385,IdentifierMutator-Variable,encodeTable,table,0,0.28265503,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1426,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19375,19385,IdentifierMutator-Variable,encodeTable,encode,1,0.143001,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1427,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19375,19385,IdentifierMutator-Variable,encodeTable,decode,2,0.039326105,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1428,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19375,19385,IdentifierMutator-Variable,encodeTable,byte,3,0.031816043,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1429,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19375,19385,IdentifierMutator-Variable,encodeTable,buffer,4,0.027764978,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1430,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19375,19385,FieldReferenceMutator,encodeTable,table,0,0.28265503,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1431,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19375,19385,FieldReferenceMutator,encodeTable,encode,1,0.143001,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1432,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19375,19385,FieldReferenceMutator,encodeTable,decode,2,0.039326105,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1433,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19375,19385,FieldReferenceMutator,encodeTable,byte,3,0.031816043,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1434,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19375,19385,FieldReferenceMutator,encodeTable,buffer,4,0.027764978,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1435,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19396,19398,BinaryOperatorMutator,&,|,2,7.0039235E-4,(x >> 18) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS," (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
               "
1436,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19396,19398,BinaryOperatorMutator,&,^,3,8.209885E-5,(x >> 18) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS," (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
               "
1437,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19396,19398,BinaryOperatorMutator,&,~,4,2.6727665E-5,(x >> 18) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS," (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
               "
1438,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19389,19392,BinaryOperatorMutator,>>,>>>,2,0.014077157,x <mask> 18,"   if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x<mask>18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1439,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19389,19392,BinaryOperatorMutator,>>,<<,3,0.011360025,x <mask> 18,"   if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x<mask>18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1440,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19389,19392,BinaryOperatorMutator,>>,>>>,4,0.0023995826,x <mask> 18,"   if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x<mask>18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1441,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19388,19388,IdentifierMutator-Variable,x,y,1,2.184737E-5,<mask>,"    if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(<mask> >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
           "
1442,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19388,19388,IdentifierMutator-Variable,x,b,3,6.949012E-6,<mask>,"    if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(<mask> >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
           "
1443,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19388,19388,IdentifierMutator-Variable,x,xx,4,6.0042985E-6,<mask>,"    if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(<mask> >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
           "
1444,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19388,19388,FieldReferenceMutator,x,y,1,2.184737E-5,<mask>,"    if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(<mask> >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
           "
1445,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19388,19388,FieldReferenceMutator,x,b,3,6.949012E-6,<mask>,"    if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(<mask> >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
           "
1446,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19388,19388,FieldReferenceMutator,x,xx,4,6.0042985E-6,<mask>,"    if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(<mask> >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
           "
1447,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19393,19394,IdentifierMutator-Literal,18,6,0,0.30219615,<mask>,"  if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1448,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19393,19394,IdentifierMutator-Literal,18,14,2,0.15861839,<mask>,"  if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1449,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19393,19394,IdentifierMutator-Literal,18,16,3,0.12405489,<mask>,"  if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1450,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19393,19394,IdentifierMutator-Literal,18,13,4,0.044997454,<mask>,"  if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1451,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19399,19408,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,0,0.10203409,<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1452,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19399,19408,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,63,1,0.07741652,<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1453,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19399,19408,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,2,0.07146262,<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1454,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19399,19408,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,bits,3,0.06290492,<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1455,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19399,19408,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,6,4,0.056504957,<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1456,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19399,19408,FieldReferenceMutator,MASK_6BITS,7,0,0.10203409,org.apache.commons.codec.binary.Base64.<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1457,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19399,19408,FieldReferenceMutator,MASK_6BITS,63,1,0.07741652,org.apache.commons.codec.binary.Base64.<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1458,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19399,19408,FieldReferenceMutator,MASK_6BITS,mask,2,0.07146262,org.apache.commons.codec.binary.Base64.<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1459,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19399,19408,FieldReferenceMutator,MASK_6BITS,bits,3,0.06290492,org.apache.commons.codec.binary.Base64.<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1460,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,488,19399,19408,FieldReferenceMutator,MASK_6BITS,6,4,0.056504957,org.apache.commons.codec.binary.Base64.<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1461,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19445,19445,AssignmentMutator,buffer[pos++]=encodeTable[(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.6265021,buffer[pos++] <mask>= encodeTable[(x >> 12) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"   resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
              "
1462,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19445,19445,AssignmentMutator,buffer[pos++]=encodeTable[(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.20987435,buffer[pos++] <mask>= encodeTable[(x >> 12) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"   resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
              "
1463,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19445,19445,AssignmentMutator,buffer[pos++]=encodeTable[(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.05411837,buffer[pos++] <mask>= encodeTable[(x >> 12) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"   resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
              "
1464,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19445,19445,AssignmentMutator,buffer[pos++]=encodeTable[(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.024408977,buffer[pos++] <mask>= encodeTable[(x >> 12) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"   resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
              "
1465,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19445,19445,AssignmentMutator,buffer[pos++]=encodeTable[(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS],+,4,0.00917603,buffer[pos++] <mask>= encodeTable[(x >> 12) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"   resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
              "
1466,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19439,19443,ArrayAccessMutator,pos++,pos,0,0.99518543,buffer[<mask>],"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1467,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19439,19443,ArrayAccessMutator,pos++,++,1,0.0020608834,buffer[<mask>],"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1468,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19439,19443,ArrayAccessMutator,pos++,push,2,2.4151117E-4,buffer[<mask>],"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1469,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19439,19443,ArrayAccessMutator,pos++,+,3,1.6428687E-4,buffer[<mask>],"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1470,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19439,19443,ArrayAccessMutator,pos++,position,4,1.6262548E-4,buffer[<mask>],"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1471,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19432,19437,IdentifierMutator-Variable,buffer,Buffer,2,0.0017264769,<mask>," - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
          "
1472,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19432,19437,IdentifierMutator-Variable,buffer,byte,3,0.0013109291,<mask>," - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
          "
1473,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19432,19437,IdentifierMutator-Variable,buffer,byte,4,5.684142E-4,<mask>," - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
          "
1474,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19432,19437,FieldReferenceMutator,buffer,Buffer,2,0.0017264769,<mask>," - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
          "
1475,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19432,19437,FieldReferenceMutator,buffer,byte,3,0.0013109291,<mask>," - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
          "
1476,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19432,19437,FieldReferenceMutator,buffer,byte,4,5.684142E-4,<mask>," - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
          "
1477,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19442,19443,UnaryOperatorMutator,++,+,1,1.08531625E-4,pos<mask>,"     resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1478,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19442,19443,UnaryOperatorMutator,++,++;,3,5.0732004E-5,pos<mask>,"     resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1479,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19442,19443,UnaryOperatorMutator,++,--,4,3.8721104E-5,pos<mask>,"     resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1480,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19439,19441,IdentifierMutator-Variable,pos,len,1,3.1099207E-5,<mask>,"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
            "
1481,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19439,19441,IdentifierMutator-Variable,pos,size,3,2.2258011E-5,<mask>,"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
            "
1482,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19439,19441,IdentifierMutator-Variable,pos,neg,4,1.7419106E-5,<mask>,"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
            "
1483,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19439,19441,FieldReferenceMutator,pos,len,1,3.1099207E-5,<mask>,"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
            "
1484,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19439,19441,FieldReferenceMutator,pos,size,3,2.2258011E-5,<mask>,"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
            "
1485,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19439,19441,FieldReferenceMutator,pos,neg,4,1.7419106E-5,<mask>,"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
            "
1486,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19460,19481,ArrayAccessMutator,(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.95328385,encodeTable[<mask>],"();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1487,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19460,19481,ArrayAccessMutator,(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.008241688,encodeTable[<mask>],"();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1488,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19460,19481,ArrayAccessMutator,(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS,16,2,0.0026908512,encodeTable[<mask>],"();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1489,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19460,19481,ArrayAccessMutator,(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,3,0.0022774427,encodeTable[<mask>],"();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1490,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19460,19481,ArrayAccessMutator,(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS,xx,4,0.0016143019,encodeTable[<mask>],"();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1491,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19448,19458,IdentifierMutator-Variable,encodeTable,table,0,0.48148024,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1492,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19448,19458,IdentifierMutator-Variable,encodeTable,encode,1,0.14044945,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1493,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19448,19458,IdentifierMutator-Variable,encodeTable,decode,2,0.03432762,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1494,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19448,19458,IdentifierMutator-Variable,encodeTable,buffer,3,0.027771132,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1495,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19448,19458,IdentifierMutator-Variable,encodeTable,encoded,4,0.01158907,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1496,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19448,19458,FieldReferenceMutator,encodeTable,table,0,0.48148024,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1497,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19448,19458,FieldReferenceMutator,encodeTable,encode,1,0.14044945,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1498,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19448,19458,FieldReferenceMutator,encodeTable,decode,2,0.03432762,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1499,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19448,19458,FieldReferenceMutator,encodeTable,buffer,3,0.027771132,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1500,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19448,19458,FieldReferenceMutator,encodeTable,encoded,4,0.01158907,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1501,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19469,19471,BinaryOperatorMutator,&,|,2,0.0011354018,(x >> 12) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"             }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        current"
1502,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19469,19471,BinaryOperatorMutator,&,^,3,1.1328529E-4,(x >> 12) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"             }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        current"
1503,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19469,19471,BinaryOperatorMutator,&,~,4,3.3629418E-5,(x >> 12) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"             }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        current"
1504,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19462,19465,BinaryOperatorMutator,>>,<<,2,0.052085314,x <mask> 12,"                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                     "
1505,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19462,19465,BinaryOperatorMutator,>>,>>>,3,0.011910077,x <mask> 12,"                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                     "
1506,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19462,19465,BinaryOperatorMutator,>>,<<,4,0.00887428,x <mask> 12,"                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                     "
1507,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19461,19461,IdentifierMutator-Variable,x,y,1,1.0916224E-5,<mask>,"
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                    "
1508,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19461,19461,IdentifierMutator-Variable,x,xx,3,3.9245033E-6,<mask>,"
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                    "
1509,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19461,19461,IdentifierMutator-Variable,x,X,4,2.8354457E-6,<mask>,"
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                    "
1510,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19461,19461,FieldReferenceMutator,x,y,1,1.0916224E-5,<mask>,"
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                    "
1511,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19461,19461,FieldReferenceMutator,x,xx,3,3.9245033E-6,<mask>,"
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                    "
1512,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19461,19461,FieldReferenceMutator,x,X,4,2.8354457E-6,<mask>,"
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                    "
1513,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19466,19467,IdentifierMutator-Literal,12,6,1,0.17941055,<mask>,"               }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                      "
1514,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19466,19467,IdentifierMutator-Literal,12,14,2,0.06264525,<mask>,"               }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                      "
1515,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19466,19467,IdentifierMutator-Literal,12,7,3,0.060345404,<mask>,"               }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                      "
1516,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19466,19467,IdentifierMutator-Literal,12,16,4,0.046771787,<mask>,"               }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                      "
1517,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19472,19481,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,0,0.13090064,<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1518,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19472,19481,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,1,0.07710009,<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1519,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19472,19481,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,2,0.07468237,<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1520,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19472,19481,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,63,3,0.07388949,<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1521,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19472,19481,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,4,0.056199297,<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1522,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19472,19481,FieldReferenceMutator,MASK_6BITS,7,0,0.13090064,org.apache.commons.codec.binary.Base64.<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1523,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19472,19481,FieldReferenceMutator,MASK_6BITS,3,1,0.07710009,org.apache.commons.codec.binary.Base64.<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1524,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19472,19481,FieldReferenceMutator,MASK_6BITS,mask,2,0.07468237,org.apache.commons.codec.binary.Base64.<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1525,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19472,19481,FieldReferenceMutator,MASK_6BITS,63,3,0.07388949,org.apache.commons.codec.binary.Base64.<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1526,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,489,19472,19481,FieldReferenceMutator,MASK_6BITS,1,4,0.056199297,org.apache.commons.codec.binary.Base64.<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1527,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19518,19518,AssignmentMutator,buffer[pos++]=encodeTable[(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.65121436,buffer[pos++] <mask>= encodeTable[(x >> 6) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
     "
1528,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19518,19518,AssignmentMutator,buffer[pos++]=encodeTable[(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.21317977,buffer[pos++] <mask>= encodeTable[(x >> 6) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
     "
1529,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19518,19518,AssignmentMutator,buffer[pos++]=encodeTable[(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.04482653,buffer[pos++] <mask>= encodeTable[(x >> 6) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
     "
1530,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19518,19518,AssignmentMutator,buffer[pos++]=encodeTable[(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.019286197,buffer[pos++] <mask>= encodeTable[(x >> 6) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
     "
1531,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19518,19518,AssignmentMutator,buffer[pos++]=encodeTable[(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS],||,4,0.007369323,buffer[pos++] <mask>= encodeTable[(x >> 6) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
     "
1532,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19512,19516,ArrayAccessMutator,pos++,pos,0,0.98372895,buffer[<mask>],"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1533,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19512,19516,ArrayAccessMutator,pos++,++,1,0.010866406,buffer[<mask>],"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1534,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19512,19516,ArrayAccessMutator,pos++,push,2,5.2627426E-4,buffer[<mask>],"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1535,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19512,19516,ArrayAccessMutator,pos++,+,3,4.1251088E-4,buffer[<mask>],"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1536,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19512,19516,ArrayAccessMutator,pos++,position,4,2.7012572E-4,buffer[<mask>],"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1537,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19505,19510,IdentifierMutator-Variable,buffer,Buffer,2,0.0017312749,<mask>,"     }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
 "
1538,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19505,19510,IdentifierMutator-Variable,buffer,byte,3,0.0016420389,<mask>,"     }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
 "
1539,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19505,19510,IdentifierMutator-Variable,buffer,byte,4,9.167108E-4,<mask>,"     }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
 "
1540,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19505,19510,FieldReferenceMutator,buffer,Buffer,2,0.0017312749,<mask>,"     }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
 "
1541,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19505,19510,FieldReferenceMutator,buffer,byte,3,0.0016420389,<mask>,"     }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
 "
1542,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19505,19510,FieldReferenceMutator,buffer,byte,4,9.167108E-4,<mask>,"     }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
 "
1543,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19515,19516,UnaryOperatorMutator,++,+,1,1.7133576E-4,pos<mask>," = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1544,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19515,19516,UnaryOperatorMutator,++,--,3,7.310897E-5,pos<mask>," = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1545,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19515,19516,UnaryOperatorMutator,++,++;,4,7.2908304E-5,pos<mask>," = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1546,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19512,19514,IdentifierMutator-Variable,pos,len,1,5.3808442E-5,<mask>,"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
   "
1547,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19512,19514,IdentifierMutator-Variable,pos,neg,3,2.9870067E-5,<mask>,"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
   "
1548,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19512,19514,IdentifierMutator-Variable,pos,size,4,2.5797883E-5,<mask>,"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
   "
1549,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19512,19514,FieldReferenceMutator,pos,len,1,5.3808442E-5,<mask>,"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
   "
1550,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19512,19514,FieldReferenceMutator,pos,neg,3,2.9870067E-5,<mask>,"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
   "
1551,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19512,19514,FieldReferenceMutator,pos,size,4,2.5797883E-5,<mask>,"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
   "
1552,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19533,19553,ArrayAccessMutator,(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.95006937,encodeTable[<mask>]," % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1553,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19533,19553,ArrayAccessMutator,(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.007493759,encodeTable[<mask>]," % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1554,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19533,19553,ArrayAccessMutator,(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS,xx,2,0.0029070026,encodeTable[<mask>]," % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1555,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19533,19553,ArrayAccessMutator,(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,3,0.0026921376,encodeTable[<mask>]," % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1556,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19533,19553,ArrayAccessMutator,(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS,i,4,0.0020907486,encodeTable[<mask>]," % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1557,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19521,19531,IdentifierMutator-Variable,encodeTable,table,0,0.4588444,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1558,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19521,19531,IdentifierMutator-Variable,encodeTable,encode,1,0.08936572,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1559,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19521,19531,IdentifierMutator-Variable,encodeTable,buffer,2,0.06389635,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1560,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19521,19531,IdentifierMutator-Variable,encodeTable,decode,3,0.030876225,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1561,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19521,19531,IdentifierMutator-Variable,encodeTable,code,4,0.010733704,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1562,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19521,19531,FieldReferenceMutator,encodeTable,table,0,0.4588444,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1563,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19521,19531,FieldReferenceMutator,encodeTable,encode,1,0.08936572,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1564,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19521,19531,FieldReferenceMutator,encodeTable,buffer,2,0.06389635,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1565,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19521,19531,FieldReferenceMutator,encodeTable,decode,3,0.030876225,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1566,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19521,19531,FieldReferenceMutator,encodeTable,code,4,0.010733704,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1567,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19541,19543,BinaryOperatorMutator,&,|,2,0.0015251794,(x >> 6) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"               int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
               "
1568,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19541,19543,BinaryOperatorMutator,&,^,3,1.3367423E-4,(x >> 6) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"               int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
               "
1569,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19541,19543,BinaryOperatorMutator,&,~,4,4.563869E-5,(x >> 6) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"               int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
               "
1570,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19535,19538,BinaryOperatorMutator,>>,>>>,2,0.014577287,x <mask> 6,";
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
            "
1571,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19535,19538,BinaryOperatorMutator,>>,<<,3,0.005326201,x <mask> 6,";
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
            "
1572,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19535,19538,BinaryOperatorMutator,>>,<<,4,0.0021441604,x <mask> 6,";
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
            "
1573,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19534,19534,IdentifierMutator-Variable,x,y,1,1.4756923E-5,<mask>," 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
           "
1574,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19534,19534,IdentifierMutator-Variable,x,xx,2,8.941584E-6,<mask>," 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
           "
1575,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19534,19534,IdentifierMutator-Variable,x,X,4,4.0363348E-6,<mask>," 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
           "
1576,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19534,19534,FieldReferenceMutator,x,y,1,1.4756923E-5,<mask>," 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
           "
1577,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19534,19534,FieldReferenceMutator,x,xx,2,8.941584E-6,<mask>," 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
           "
1578,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19534,19534,FieldReferenceMutator,x,X,4,4.0363348E-6,<mask>," 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
           "
1579,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19539,19539,IdentifierMutator-Literal,6,8,1,0.16930921,<mask>,"
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
             "
1580,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19539,19539,IdentifierMutator-Literal,6,7,2,0.07269451,<mask>,"
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
             "
1581,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19539,19539,IdentifierMutator-Literal,6,4,3,0.05644892,<mask>,"
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
             "
1582,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19539,19539,IdentifierMutator-Literal,6,5,4,0.04977193,<mask>,"
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
             "
1583,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19544,19553,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,0,0.20099264,<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1584,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19544,19553,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,1,0.091443405,<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1585,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19544,19553,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,2,0.08155483,<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1586,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19544,19553,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,63,3,0.08051241,<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1587,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19544,19553,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,6,4,0.06678464,<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1588,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19544,19553,FieldReferenceMutator,MASK_6BITS,7,0,0.20099264,org.apache.commons.codec.binary.Base64.<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1589,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19544,19553,FieldReferenceMutator,MASK_6BITS,1,1,0.091443405,org.apache.commons.codec.binary.Base64.<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1590,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19544,19553,FieldReferenceMutator,MASK_6BITS,3,2,0.08155483,org.apache.commons.codec.binary.Base64.<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1591,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19544,19553,FieldReferenceMutator,MASK_6BITS,63,3,0.08051241,org.apache.commons.codec.binary.Base64.<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1592,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,490,19544,19553,FieldReferenceMutator,MASK_6BITS,6,4,0.06678464,org.apache.commons.codec.binary.Base64.<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1593,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19590,19590,AssignmentMutator,buffer[pos++]=encodeTable[x&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.64512175,buffer[pos++] <mask>= encodeTable[x & org.apache.commons.codec.binary.Base64.MASK_6BITS],"       if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1594,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19590,19590,AssignmentMutator,buffer[pos++]=encodeTable[x&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.21509565,buffer[pos++] <mask>= encodeTable[x & org.apache.commons.codec.binary.Base64.MASK_6BITS],"       if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1595,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19590,19590,AssignmentMutator,buffer[pos++]=encodeTable[x&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.05649529,buffer[pos++] <mask>= encodeTable[x & org.apache.commons.codec.binary.Base64.MASK_6BITS],"       if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1596,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19590,19590,AssignmentMutator,buffer[pos++]=encodeTable[x&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.012102621,buffer[pos++] <mask>= encodeTable[x & org.apache.commons.codec.binary.Base64.MASK_6BITS],"       if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1597,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19590,19590,AssignmentMutator,buffer[pos++]=encodeTable[x&org.apache.commons.codec.binary.Base64.MASK_6BITS],||,4,0.008375433,buffer[pos++] <mask>= encodeTable[x & org.apache.commons.codec.binary.Base64.MASK_6BITS],"       if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1598,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19584,19588,ArrayAccessMutator,pos++,pos,0,0.9776703,buffer[<mask>],"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1599,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19584,19588,ArrayAccessMutator,pos++,++,1,0.008991658,buffer[<mask>],"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1600,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19584,19588,ArrayAccessMutator,pos++,len,2,9.916008E-4,buffer[<mask>],"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1601,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19584,19588,ArrayAccessMutator,pos++,push,3,6.236473E-4,buffer[<mask>],"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1602,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19584,19588,ArrayAccessMutator,pos++,size,4,5.041644E-4,buffer[<mask>],"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1603,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19577,19582,IdentifierMutator-Variable,buffer,in,2,0.0036895804,<mask>,"       int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];<mask>[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1604,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19577,19582,IdentifierMutator-Variable,buffer,out,3,0.0026296019,<mask>,"       int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];<mask>[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1605,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19577,19582,IdentifierMutator-Variable,buffer,Buffer,4,0.0021281603,<mask>,"       int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];<mask>[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1606,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19577,19582,FieldReferenceMutator,buffer,in,2,0.0036895804,<mask>,"       int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];<mask>[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1607,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19577,19582,FieldReferenceMutator,buffer,out,3,0.0026296019,<mask>,"       int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];<mask>[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1608,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19577,19582,FieldReferenceMutator,buffer,Buffer,4,0.0021281603,<mask>,"       int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];<mask>[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1609,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19587,19588,UnaryOperatorMutator,++,+,2,1.21851E-4,pos<mask>,"         if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1610,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19587,19588,UnaryOperatorMutator,++,++;,3,8.960821E-5,pos<mask>,"         if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1611,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19587,19588,UnaryOperatorMutator,++,--,4,6.255811E-5,pos<mask>,"         if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1612,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19584,19586,IdentifierMutator-Variable,pos,len,1,1.621372E-4,<mask>,"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1613,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19584,19586,IdentifierMutator-Variable,pos,neg,2,5.3722943E-5,<mask>,"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1614,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19584,19586,IdentifierMutator-Variable,pos,size,3,5.3070828E-5,<mask>,"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1615,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19584,19586,FieldReferenceMutator,pos,len,1,1.621372E-4,<mask>,"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1616,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19584,19586,FieldReferenceMutator,pos,neg,2,5.3722943E-5,<mask>,"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1617,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19584,19586,FieldReferenceMutator,pos,size,3,5.3070828E-5,<mask>,"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1618,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19605,19618,ArrayAccessMutator,x&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.24399617,encodeTable[<mask>],"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1619,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19605,19618,ArrayAccessMutator,x&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.11902633,encodeTable[<mask>],"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1620,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19605,19618,ArrayAccessMutator,x&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,2,0.046845116,encodeTable[<mask>],"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1621,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19605,19618,ArrayAccessMutator,x&org.apache.commons.codec.binary.Base64.MASK_6BITS,6,3,0.044247672,encodeTable[<mask>],"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1622,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19605,19618,ArrayAccessMutator,x&org.apache.commons.codec.binary.Base64.MASK_6BITS,4,4,0.0390516,encodeTable[<mask>],"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1623,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19593,19603,IdentifierMutator-Variable,encodeTable,table,0,0.34797645,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1624,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19593,19603,IdentifierMutator-Variable,encodeTable,buffer,1,0.14833394,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1625,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19593,19603,IdentifierMutator-Variable,encodeTable,code,2,0.021642365,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1626,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19593,19603,IdentifierMutator-Variable,encodeTable,encode,3,0.018327847,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1627,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19593,19603,IdentifierMutator-Variable,encodeTable,alphabet,4,0.016969493,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1628,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19593,19603,FieldReferenceMutator,encodeTable,table,0,0.34797645,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1629,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19593,19603,FieldReferenceMutator,encodeTable,buffer,1,0.14833394,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1630,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19593,19603,FieldReferenceMutator,encodeTable,code,2,0.021642365,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1631,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19593,19603,FieldReferenceMutator,encodeTable,encode,3,0.018327847,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1632,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19593,19603,FieldReferenceMutator,encodeTable,alphabet,4,0.016969493,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1633,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19606,19608,BinaryOperatorMutator,&,-,2,0.012634097,x <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"  if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x<mask>MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1634,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19606,19608,BinaryOperatorMutator,&,+,3,0.0102019785,x <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"  if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x<mask>MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1635,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19606,19608,BinaryOperatorMutator,&,<<,4,0.009637333,x <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"  if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x<mask>MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1636,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19605,19605,IdentifierMutator-Variable,x,xx,1,7.230686E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1637,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19605,19605,IdentifierMutator-Variable,x,1,2,6.211949E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1638,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19605,19605,IdentifierMutator-Variable,x,y,3,4.0198036E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1639,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19605,19605,IdentifierMutator-Variable,x,0,4,3.4021927E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1640,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19605,19605,FieldReferenceMutator,x,xx,1,7.230686E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1641,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19605,19605,FieldReferenceMutator,x,1,2,6.211949E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1642,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19605,19605,FieldReferenceMutator,x,y,3,4.0198036E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1643,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19605,19605,FieldReferenceMutator,x,0,4,3.4021927E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1644,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19609,19618,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,0,0.23924552,<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1645,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19609,19618,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,63,1,0.16866417,<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1646,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19609,19618,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,2,0.13106935,<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1647,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19609,19618,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,3,0.057394836,<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1648,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19609,19618,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,6,4,0.05220101,<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1649,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19609,19618,FieldReferenceMutator,MASK_6BITS,7,0,0.23924552,org.apache.commons.codec.binary.Base64.<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1650,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19609,19618,FieldReferenceMutator,MASK_6BITS,63,1,0.16866417,org.apache.commons.codec.binary.Base64.<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1651,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19609,19618,FieldReferenceMutator,MASK_6BITS,3,2,0.13106935,org.apache.commons.codec.binary.Base64.<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1652,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19609,19618,FieldReferenceMutator,MASK_6BITS,1,3,0.057394836,org.apache.commons.codec.binary.Base64.<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1653,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,491,19609,19618,FieldReferenceMutator,MASK_6BITS,6,4,0.05220101,org.apache.commons.codec.binary.Base64.<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1654,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19656,19656,AssignmentMutator,currentLinePos+=4,*,0,0.34029716,currentLinePos <mask>= 4,";
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos<mask>+= 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1655,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19656,19656,AssignmentMutator,currentLinePos+=4,++,1,0.18653326,currentLinePos <mask>= 4,";
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos<mask>+= 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1656,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19656,19656,AssignmentMutator,currentLinePos+=4,*,2,0.12206475,currentLinePos <mask>= 4,";
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos<mask>+= 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1657,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19656,19656,AssignmentMutator,currentLinePos+=4,//,3,0.04192252,currentLinePos <mask>= 4,";
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos<mask>+= 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1658,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19656,19656,AssignmentMutator,currentLinePos+=4,|,4,0.03014381,currentLinePos <mask>= 4,";
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos<mask>+= 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1659,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19642,19655,IdentifierMutator-Variable,currentLinePos,pos,0,0.5798388,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1660,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19642,19655,IdentifierMutator-Variable,currentLinePos,pos,1,0.40308696,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1661,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19642,19655,IdentifierMutator-Variable,currentLinePos,x,2,0.0028060998,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1662,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19642,19655,IdentifierMutator-Variable,currentLinePos,Pos,3,0.0018321931,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1663,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19642,19655,IdentifierMutator-Variable,currentLinePos,position,4,0.0013593595,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1664,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19642,19655,FieldReferenceMutator,currentLinePos,pos,0,0.5798388,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1665,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19642,19655,FieldReferenceMutator,currentLinePos,pos,1,0.40308696,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1666,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19642,19655,FieldReferenceMutator,currentLinePos,x,2,0.0028060998,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1667,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19642,19655,FieldReferenceMutator,currentLinePos,Pos,3,0.0018321931,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1668,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19642,19655,FieldReferenceMutator,currentLinePos,position,4,0.0013593595,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1669,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19660,19660,IdentifierMutator-Literal,4,pos,0,0.45371884,<mask>,"
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos +=<mask>;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1670,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19660,19660,IdentifierMutator-Literal,4,1,1,0.22995412,<mask>,"
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos +=<mask>;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1671,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19660,19660,IdentifierMutator-Literal,4,2,2,0.07983624,<mask>,"
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos +=<mask>;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1672,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,492,19660,19660,IdentifierMutator-Literal,4,length,4,0.017705763,<mask>,"
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos +=<mask>;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1673,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19701,19704,BinaryOperatorMutator,&&,&,2,0.02042675,(lineLength > 0) <mask> (lineLength <= currentLinePos),"      x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0<mask>lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1674,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19701,19704,BinaryOperatorMutator,&&,AND,3,0.0021275724,(lineLength > 0) <mask> (lineLength <= currentLinePos),"      x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0<mask>lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1675,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19701,19704,BinaryOperatorMutator,&&,and,4,8.8561187E-4,(lineLength > 0) <mask> (lineLength <= currentLinePos),"      x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0<mask>lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1676,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19697,19699,BinaryOperatorMutator,>,!=,2,0.03354259,lineLength <mask> 0,"        x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength<mask>0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1677,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19697,19699,BinaryOperatorMutator,>,==,3,0.023923254,lineLength <mask> 0,"        x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength<mask>0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1678,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19697,19699,BinaryOperatorMutator,>,>=,4,0.009211616,lineLength <mask> 0,"        x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength<mask>0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1679,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19687,19696,IdentifierMutator-Variable,lineLength,pos,0,0.8061634,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1680,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19687,19696,IdentifierMutator-Variable,lineLength,length,1,0.081273995,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1681,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19687,19696,IdentifierMutator-Variable,lineLength,position,2,0.03991801,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1682,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19687,19696,IdentifierMutator-Variable,lineLength,offset,3,0.008178057,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1683,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19687,19696,IdentifierMutator-Variable,lineLength,len,4,0.0050431336,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1684,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19687,19696,FieldReferenceMutator,lineLength,pos,0,0.8061634,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1685,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19687,19696,FieldReferenceMutator,lineLength,length,1,0.081273995,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1686,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19687,19696,FieldReferenceMutator,lineLength,position,2,0.03991801,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1687,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19687,19696,FieldReferenceMutator,lineLength,offset,3,0.008178057,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1688,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19687,19696,FieldReferenceMutator,lineLength,len,4,0.0050431336,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1689,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19700,19700,IdentifierMutator-Literal,0,1,1,0.036307774,<mask>,"       x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength ><mask> && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1690,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19700,19700,IdentifierMutator-Literal,0,2,2,0.005767462,<mask>,"       x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength ><mask> && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1691,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19700,19700,IdentifierMutator-Literal,0,4,3,0.0027120064,<mask>,"       x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength ><mask> && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1692,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19700,19700,IdentifierMutator-Literal,0,pos,4,0.0024671396,<mask>,"       x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength ><mask> && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1693,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19715,19718,BinaryOperatorMutator,<=,<,0,0.39389122,lineLength <mask> currentLinePos,"   x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength<mask>currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1694,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19715,19718,BinaryOperatorMutator,<=,==,1,0.27772817,lineLength <mask> currentLinePos,"   x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength<mask>currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1695,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19715,19718,BinaryOperatorMutator,<=,>,2,0.09517997,lineLength <mask> currentLinePos,"   x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength<mask>currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1696,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19715,19718,BinaryOperatorMutator,<=,<,3,0.07151448,lineLength <mask> currentLinePos,"   x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength<mask>currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1697,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19705,19714,IdentifierMutator-Variable,lineLength,pos,0,0.95054585,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1698,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19705,19714,IdentifierMutator-Variable,lineLength,0,1,0.029080542,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1699,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19705,19714,IdentifierMutator-Variable,lineLength,position,2,0.0041239043,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1700,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19705,19714,IdentifierMutator-Variable,lineLength,start,3,0.0018849447,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1701,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19705,19714,IdentifierMutator-Variable,lineLength,1,4,0.0018175166,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1702,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19705,19714,FieldReferenceMutator,lineLength,pos,0,0.95054585,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1703,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19705,19714,FieldReferenceMutator,lineLength,0,1,0.029080542,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1704,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19705,19714,FieldReferenceMutator,lineLength,position,2,0.0041239043,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1705,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19705,19714,FieldReferenceMutator,lineLength,start,3,0.0018849447,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1706,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19705,19714,FieldReferenceMutator,lineLength,1,4,0.0018175166,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1707,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19719,19732,IdentifierMutator-Variable,currentLinePos,256,0,0.08368058,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1708,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19719,19732,IdentifierMutator-Variable,currentLinePos,255,1,0.05682104,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1709,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19719,19732,IdentifierMutator-Variable,currentLinePos,1,2,0.044809103,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1710,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19719,19732,IdentifierMutator-Variable,currentLinePos,127,3,0.03487211,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1711,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19719,19732,IdentifierMutator-Variable,currentLinePos,4,4,0.030467179,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1712,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19719,19732,FieldReferenceMutator,currentLinePos,256,0,0.08368058,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1713,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19719,19732,FieldReferenceMutator,currentLinePos,255,1,0.05682104,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1714,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19719,19732,FieldReferenceMutator,currentLinePos,1,2,0.044809103,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1715,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19719,19732,FieldReferenceMutator,currentLinePos,127,3,0.03487211,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1716,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,493,19719,19732,FieldReferenceMutator,currentLinePos,4,4,0.030467179,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1717,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19768,19776,MethodCallMutator,arraycopy,copy,0,0.44838908,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)"," modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1718,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19768,19776,MethodCallMutator,arraycopy,printf,1,0.27453634,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)"," modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1719,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19768,19776,MethodCallMutator,arraycopy,format,2,0.103110895,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)"," modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1720,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19768,19776,MethodCallMutator,arraycopy,write,3,0.034942545,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)"," modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1721,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19768,19776,MethodCallMutator,arraycopy,replace,4,0.014357003,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)"," modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1722,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19778,19790,IdentifierMutator-Variable,lineSeparator,buffer,0,0.8169459,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1723,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19778,19790,IdentifierMutator-Variable,lineSeparator,line,1,0.04690348,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1724,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19778,19790,IdentifierMutator-Variable,lineSeparator,lines,2,0.021744726,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1725,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19778,19790,IdentifierMutator-Variable,lineSeparator,buf,3,0.009267252,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1726,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19778,19790,IdentifierMutator-Variable,lineSeparator,string,4,0.008680807,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1727,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19778,19790,FieldReferenceMutator,lineSeparator,buffer,0,0.8169459,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1728,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19778,19790,FieldReferenceMutator,lineSeparator,line,1,0.04690348,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1729,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19778,19790,FieldReferenceMutator,lineSeparator,lines,2,0.021744726,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1730,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19778,19790,FieldReferenceMutator,lineSeparator,buf,3,0.009267252,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1731,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19778,19790,FieldReferenceMutator,lineSeparator,string,4,0.008680807,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1732,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19793,19793,IdentifierMutator-Literal,0,1,2,0.0038664232,<mask>,"                 buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator,<mask>, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1733,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19793,19793,IdentifierMutator-Literal,0,pos,3,0.0010919744,<mask>,"                 buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator,<mask>, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1734,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19793,19793,IdentifierMutator-Literal,0,4,4,0.0010349891,<mask>,"                 buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator,<mask>, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1735,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19796,19801,IdentifierMutator-Variable,buffer,line,2,3.8841917E-4,<mask>,"               buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1736,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19796,19801,IdentifierMutator-Variable,buffer,buf,3,1.9171674E-4,<mask>,"               buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1737,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19796,19801,IdentifierMutator-Variable,buffer,source,4,1.4794039E-4,<mask>,"               buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1738,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19796,19801,FieldReferenceMutator,buffer,line,2,3.8841917E-4,<mask>,"               buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1739,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19796,19801,FieldReferenceMutator,buffer,buf,3,1.9171674E-4,<mask>,"               buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1740,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19796,19801,FieldReferenceMutator,buffer,source,4,1.4794039E-4,<mask>,"               buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1741,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19804,19806,IdentifierMutator-Variable,pos,0,1,0.01524594,<mask>,"             buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1742,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19804,19806,IdentifierMutator-Variable,pos,1,3,0.001386155,<mask>,"             buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1743,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19804,19806,IdentifierMutator-Variable,pos,position,4,7.9083163E-4,<mask>,"             buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1744,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19804,19806,FieldReferenceMutator,pos,0,1,0.01524594,<mask>,"             buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1745,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19804,19806,FieldReferenceMutator,pos,1,3,0.001386155,<mask>,"             buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1746,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19804,19806,FieldReferenceMutator,pos,position,4,7.9083163E-4,<mask>,"             buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1747,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19809,19828,IdentifierMutator-Variable,lineSeparator.length,len,0,0.40724584,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1748,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19809,19828,IdentifierMutator-Variable,lineSeparator.length,length,1,0.1738978,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1749,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19809,19828,IdentifierMutator-Variable,lineSeparator.length,4,2,0.07947996,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1750,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19809,19828,IdentifierMutator-Variable,lineSeparator.length,n,3,0.040844593,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1751,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19809,19828,IdentifierMutator-Variable,lineSeparator.length,line,4,0.025696028,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1752,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19809,19821,IdentifierMutator-Variable,lineSeparator,buffer,0,0.9938554,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1753,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19809,19821,IdentifierMutator-Variable,lineSeparator,buffer,1,0.002136814,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1754,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19809,19821,IdentifierMutator-Variable,lineSeparator,line,2,0.0013068112,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1755,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19809,19821,IdentifierMutator-Variable,lineSeparator,buf,3,3.138145E-4,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1756,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19809,19821,IdentifierMutator-Variable,lineSeparator,text,4,1.8696343E-4,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1757,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19809,19821,FieldReferenceMutator,lineSeparator,buffer,0,0.9938554,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1758,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19809,19821,FieldReferenceMutator,lineSeparator,buffer,1,0.002136814,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1759,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19809,19821,FieldReferenceMutator,lineSeparator,line,2,0.0013068112,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1760,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19809,19821,FieldReferenceMutator,lineSeparator,buf,3,3.138145E-4,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1761,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19809,19821,FieldReferenceMutator,lineSeparator,text,4,1.8696343E-4,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1762,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19823,19828,FieldReferenceMutator,length,len,1,2.4772357E-4,lineSeparator.<mask>,"      buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1763,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19823,19828,FieldReferenceMutator,length,position,2,4.939695E-5,lineSeparator.<mask>,"      buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1764,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,494,19823,19828,FieldReferenceMutator,length,count,3,2.6590738E-5,lineSeparator.<mask>,"      buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1765,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19859,19859,AssignmentMutator,pos+=lineSeparator.length,++,0,0.9640786,pos <mask>= lineSeparator.length,"
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos<mask>+= lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1766,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19859,19859,AssignmentMutator,pos+=lineSeparator.length,+,1,0.008239496,pos <mask>= lineSeparator.length,"
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos<mask>+= lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1767,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19859,19859,AssignmentMutator,pos+=lineSeparator.length,++,2,0.0036510515,pos <mask>= lineSeparator.length,"
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos<mask>+= lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1768,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19859,19859,AssignmentMutator,pos+=lineSeparator.length,*,3,0.003487082,pos <mask>= lineSeparator.length,"
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos<mask>+= lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1769,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19859,19859,AssignmentMutator,pos+=lineSeparator.length,+,4,0.0025446527,pos <mask>= lineSeparator.length,"
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos<mask>+= lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1770,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19856,19858,IdentifierMutator-Variable,pos,position,2,0.0014238023,<mask>,"    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1771,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19856,19858,IdentifierMutator-Variable,pos,Pos,3,4.3400706E-4,<mask>,"    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1772,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19856,19858,IdentifierMutator-Variable,pos,offset,4,8.658397E-5,<mask>,"    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1773,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19856,19858,FieldReferenceMutator,pos,position,2,0.0014238023,<mask>,"    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1774,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19856,19858,FieldReferenceMutator,pos,Pos,3,4.3400706E-4,<mask>,"    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1775,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19856,19858,FieldReferenceMutator,pos,offset,4,8.658397E-5,<mask>,"    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1776,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19863,19882,IdentifierMutator-Variable,lineSeparator.length,4,0,0.79304135,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1777,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19863,19882,IdentifierMutator-Variable,lineSeparator.length,2,1,0.054201618,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1778,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19863,19882,IdentifierMutator-Variable,lineSeparator.length,5,2,0.023471013,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1779,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19863,19882,IdentifierMutator-Variable,lineSeparator.length,1,3,0.022097014,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1780,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19863,19882,IdentifierMutator-Variable,lineSeparator.length,3,4,0.020625181,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1781,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19863,19875,IdentifierMutator-Variable,lineSeparator,buffer,0,0.97794867,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1782,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19863,19875,IdentifierMutator-Variable,lineSeparator,line,1,0.007852801,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1783,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19863,19875,IdentifierMutator-Variable,lineSeparator,buf,2,0.0023001505,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1784,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19863,19875,IdentifierMutator-Variable,lineSeparator,text,3,0.0010461648,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1785,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19863,19875,IdentifierMutator-Variable,lineSeparator,code,4,3.7937233E-4,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1786,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19863,19875,FieldReferenceMutator,lineSeparator,buffer,0,0.97794867,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1787,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19863,19875,FieldReferenceMutator,lineSeparator,line,1,0.007852801,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1788,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19863,19875,FieldReferenceMutator,lineSeparator,buf,2,0.0023001505,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1789,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19863,19875,FieldReferenceMutator,lineSeparator,text,3,0.0010461648,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1790,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19863,19875,FieldReferenceMutator,lineSeparator,code,4,3.7937233E-4,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1791,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19877,19882,FieldReferenceMutator,length,position,1,1.9497819E-4,lineSeparator.<mask>,"               buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1792,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19877,19882,FieldReferenceMutator,length,len,2,1.6991064E-4,lineSeparator.<mask>,"               buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1793,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,495,19877,19882,FieldReferenceMutator,length,width,4,2.8037513E-5,lineSeparator.<mask>,"               buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1794,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19923,19923,AssignmentMutator,currentLinePos=0,*,0,0.4809754,currentLinePos <mask>= 0," MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos<mask>= 0;
                    }
                }
            }
        }
   "
1795,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19923,19923,AssignmentMutator,currentLinePos=0,||,1,0.19663772,currentLinePos <mask>= 0," MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos<mask>= 0;
                    }
                }
            }
        }
   "
1796,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19923,19923,AssignmentMutator,currentLinePos=0,^,2,0.08168908,currentLinePos <mask>= 0," MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos<mask>= 0;
                    }
                }
            }
        }
   "
1797,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19923,19923,AssignmentMutator,currentLinePos=0,|,3,0.079475954,currentLinePos <mask>= 0," MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos<mask>= 0;
                    }
                }
            }
        }
   "
1798,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19923,19923,AssignmentMutator,currentLinePos=0,>>,4,0.02047174,currentLinePos <mask>= 0," MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos<mask>= 0;
                    }
                }
            }
        }
   "
1799,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19909,19922,IdentifierMutator-Variable,currentLinePos,buffer,0,0.2174502,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1800,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19909,19922,IdentifierMutator-Variable,currentLinePos,line,1,0.09240584,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1801,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19909,19922,IdentifierMutator-Variable,currentLinePos,pos,2,0.078489065,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1802,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19909,19922,IdentifierMutator-Variable,currentLinePos,buf,3,0.03820603,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1803,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19909,19922,IdentifierMutator-Variable,currentLinePos,length,4,0.03634959,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1804,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19909,19922,FieldReferenceMutator,currentLinePos,buffer,0,0.2174502,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1805,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19909,19922,FieldReferenceMutator,currentLinePos,line,1,0.09240584,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1806,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19909,19922,FieldReferenceMutator,currentLinePos,pos,2,0.078489065,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1807,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19909,19922,FieldReferenceMutator,currentLinePos,buf,3,0.03820603,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1808,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19909,19922,FieldReferenceMutator,currentLinePos,length,4,0.03634959,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1809,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19926,19926,IdentifierMutator-Literal,0,pos,0,0.9606277,<mask>,"K_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos =<mask>;
                    }
                }
            }
        }
   "
1810,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19926,19926,IdentifierMutator-Literal,0,position,2,0.0030007649,<mask>,"K_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos =<mask>;
                    }
                }
            }
        }
   "
1811,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19926,19926,IdentifierMutator-Literal,0,index,3,9.940353E-4,<mask>,"K_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos =<mask>;
                    }
                }
            }
        }
   "
1812,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",437,496,19926,19926,IdentifierMutator-Literal,0,i,4,7.2437775E-4,<mask>,"K_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos =<mask>;
                    }
                }
            }
        }
   "
1813,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,527,21204,21206,IdentifierMutator-Variable,eof,done,0,0.30600673,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1814,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,527,21204,21206,IdentifierMutator-Variable,eof,finished,1,0.1257539,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1815,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,527,21204,21206,IdentifierMutator-Variable,eof,stop,2,0.07442391,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1816,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,527,21204,21206,IdentifierMutator-Variable,eof,exit,3,0.050556906,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1817,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,527,21204,21206,IdentifierMutator-Variable,eof,end,4,0.04960955,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1818,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,527,21204,21206,FieldReferenceMutator,eof,done,0,0.30600673,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1819,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,527,21204,21206,FieldReferenceMutator,eof,finished,1,0.1257539,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1820,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,527,21204,21206,FieldReferenceMutator,eof,stop,2,0.07442391,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1821,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,527,21204,21206,FieldReferenceMutator,eof,exit,3,0.050556906,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1822,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,527,21204,21206,FieldReferenceMutator,eof,end,4,0.04960955,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1823,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,530,21260,21262,BinaryOperatorMutator,<,==,0,0.223451,inAvail <mask> 0,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail<mask>0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1824,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,530,21260,21262,BinaryOperatorMutator,<,==,1,0.21845761,inAvail <mask> 0,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail<mask>0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1825,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,530,21260,21262,BinaryOperatorMutator,<,>,2,0.21460688,inAvail <mask> 0,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail<mask>0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1826,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,530,21260,21262,BinaryOperatorMutator,<,<=,4,0.08764514,inAvail <mask> 0,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail<mask>0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1827,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,530,21253,21259,IdentifierMutator-Variable,inAvail,pos,0,0.6025664,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (<mask> < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1828,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,530,21253,21259,IdentifierMutator-Variable,inAvail,i,1,0.060962595,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (<mask> < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1829,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,530,21253,21259,IdentifierMutator-Variable,inAvail,offset,2,0.01839406,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (<mask> < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1830,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,530,21253,21259,IdentifierMutator-Variable,inAvail,position,3,0.013375317,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (<mask> < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1831,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,530,21253,21259,IdentifierMutator-Variable,inAvail,b,4,0.012427245,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (<mask> < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1832,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,530,21263,21263,IdentifierMutator-Literal,0,1,1,0.04096003,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail <<mask>) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1833,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,530,21263,21263,IdentifierMutator-Literal,0,pos,2,0.017515754,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail <<mask>) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1834,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,530,21263,21263,IdentifierMutator-Literal,0,2,3,0.0140517065,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail <<mask>) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1835,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,530,21263,21263,IdentifierMutator-Literal,0,i,4,0.012964744,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail <<mask>) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1836,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,531,21283,21283,AssignmentMutator,eof=true,|,0,0.9368005,eof <mask>= true,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof<mask>= true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1837,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,531,21283,21283,AssignmentMutator,eof=true,&,1,0.03523596,eof <mask>= true,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof<mask>= true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1838,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,531,21283,21283,AssignmentMutator,eof=true,||,2,0.0063775703,eof <mask>= true,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof<mask>= true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1839,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,531,21283,21283,AssignmentMutator,eof=true,^,3,0.0046112183,eof <mask>= true,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof<mask>= true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1840,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,531,21283,21283,AssignmentMutator,eof=true,!,4,0.0037213026,eof <mask>= true,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof<mask>= true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1841,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,531,21280,21282,IdentifierMutator-Variable,eof,done,0,0.5852882,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1842,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,531,21280,21282,IdentifierMutator-Variable,eof,finished,1,0.081278555,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1843,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,531,21280,21282,IdentifierMutator-Variable,eof,end,2,0.034523726,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1844,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,531,21280,21282,IdentifierMutator-Variable,eof,ended,3,0.029406138,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1845,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,531,21280,21282,IdentifierMutator-Variable,eof,closed,4,0.027027369,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1846,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,531,21280,21282,FieldReferenceMutator,eof,done,0,0.5852882,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1847,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,531,21280,21282,FieldReferenceMutator,eof,finished,1,0.081278555,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1848,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,531,21280,21282,FieldReferenceMutator,eof,end,2,0.034523726,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1849,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,531,21280,21282,FieldReferenceMutator,eof,ended,3,0.029406138,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1850,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,531,21280,21282,FieldReferenceMutator,eof,closed,4,0.027027369,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1851,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,531,21286,21289,IdentifierMutator-Literal,true,false,1,0.028067522,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof =<mask>;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1852,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,531,21286,21289,IdentifierMutator-Literal,true,TRUE,3,1.3249651E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof =<mask>;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1853,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,531,21286,21289,IdentifierMutator-Literal,true,1,4,9.629265E-5,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof =<mask>;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1854,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21323,21323,IdentifierMutator-Literal,0,pos,1,0.08268388,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i =<mask>; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1855,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21323,21323,IdentifierMutator-Literal,0,1,2,0.006390756,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i =<mask>; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1856,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21323,21323,IdentifierMutator-Literal,0,offset,4,0.001435486,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i =<mask>; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1857,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21327,21329,BinaryOperatorMutator,<,<=,2,0.0032129693,i <mask> inAvail,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i<mask>inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1858,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21327,21329,BinaryOperatorMutator,<,++,3,0.0017119371,i <mask> inAvail,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i<mask>inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1859,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21327,21329,BinaryOperatorMutator,<,+,4,4.137092E-4,i <mask> inAvail,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i<mask>inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1860,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21326,21326,IdentifierMutator-Variable,i,pos,2,0.0014674164,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0;<mask> < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1861,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21326,21326,IdentifierMutator-Variable,i,j,3,1.1250476E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0;<mask> < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1862,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21326,21326,IdentifierMutator-Variable,i,0,4,1.07833E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0;<mask> < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1863,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21330,21336,IdentifierMutator-Variable,inAvail,n,0,0.14292932,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i <<mask>; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1864,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21330,21336,IdentifierMutator-Variable,inAvail,size,1,0.115542,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i <<mask>; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1865,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21330,21336,IdentifierMutator-Variable,inAvail,len,2,0.1027158,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i <<mask>; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1866,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21330,21336,IdentifierMutator-Variable,inAvail,pos,3,0.07468494,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i <<mask>; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1867,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21330,21336,IdentifierMutator-Variable,inAvail,limit,4,0.072005756,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i <<mask>; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1868,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21340,21341,UnaryOperatorMutator,++,++),2,0.0037155217,i<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i<mask>) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1869,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21340,21341,UnaryOperatorMutator,++,++;,3,3.471651E-4,i<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i<mask>) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1870,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21340,21341,UnaryOperatorMutator,++,--,4,2.0901115E-4,i<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i<mask>) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1871,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21339,21339,IdentifierMutator-Variable,i,++,2,1.087855E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail;<mask>++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1872,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21339,21339,IdentifierMutator-Variable,i,I,3,5.2334315E-5,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail;<mask>++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1873,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,533,21339,21339,IdentifierMutator-Variable,i,j,4,5.0137125E-5,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail;<mask>++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1874,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21376,21379,BinaryOperatorMutator,||,|,2,0.009832157,(buffer == null) <mask> ((buffer.length - pos) < decodeSize),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null<mask>buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1875,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21376,21379,BinaryOperatorMutator,||,.,3,0.008927607,(buffer == null) <mask> ((buffer.length - pos) < decodeSize),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null<mask>buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1876,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21376,21379,BinaryOperatorMutator,||,?,4,0.0031648385,(buffer == null) <mask> ((buffer.length - pos) < decodeSize),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null<mask>buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1877,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21368,21371,BinaryOperatorMutator,==,=,2,0.009059136,buffer <mask> null,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer<mask>null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1878,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21368,21371,BinaryOperatorMutator,==,===,3,0.0014111465,buffer <mask> null,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer<mask>null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1879,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21368,21371,BinaryOperatorMutator,==,!=,4,6.824041E-4,buffer <mask> null,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer<mask>null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1880,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21362,21367,IdentifierMutator-Variable,buffer,Buffer,2,0.0018047302,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1881,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21362,21367,IdentifierMutator-Variable,buffer,buf,3,9.906832E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1882,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21362,21367,IdentifierMutator-Variable,buffer,queue,4,5.849453E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1883,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21362,21367,FieldReferenceMutator,buffer,Buffer,2,0.0018047302,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1884,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21362,21367,FieldReferenceMutator,buffer,buf,3,9.906832E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1885,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21362,21367,FieldReferenceMutator,buffer,queue,4,5.849453E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1886,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21372,21375,IdentifierMutator-Literal,null,nil,1,0.0012571932,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer ==<mask> || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1887,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21372,21375,IdentifierMutator-Literal,null,NULL,2,0.0010901536,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer ==<mask> || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1888,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21372,21375,IdentifierMutator-Literal,null,undefined,4,2.1016036E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer ==<mask> || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1889,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21399,21401,BinaryOperatorMutator,<,>,1,0.2302898,(buffer.length - pos) <mask> decodeSize,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos<mask>decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1890,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21399,21401,BinaryOperatorMutator,<,>,3,0.09603589,(buffer.length - pos) <mask> decodeSize,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos<mask>decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1891,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21399,21401,BinaryOperatorMutator,<,>=,4,0.0836145,(buffer.length - pos) <mask> decodeSize,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos<mask>decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1892,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21393,21395,BinaryOperatorMutator,-,*,1,0.19134657,buffer.length <mask> pos,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1893,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21393,21395,BinaryOperatorMutator,-,+,2,0.15388948,buffer.length <mask> pos,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1894,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21393,21395,BinaryOperatorMutator,-,_,3,0.052787326,buffer.length <mask> pos,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1895,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21393,21395,BinaryOperatorMutator,-,/,4,0.035744138,buffer.length <mask> pos,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1896,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21380,21392,IdentifierMutator-Variable,buffer.length,i,0,0.5350913,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1897,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21380,21392,IdentifierMutator-Variable,buffer.length,size,1,0.09398828,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1898,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21380,21392,IdentifierMutator-Variable,buffer.length,limit,2,0.040866785,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1899,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21380,21392,IdentifierMutator-Variable,buffer.length,length,3,0.03957807,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1900,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21380,21392,IdentifierMutator-Variable,buffer.length,buffer,4,0.020405691,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1901,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21380,21385,IdentifierMutator-Variable,buffer,in,1,0.06961245,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1902,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21380,21385,IdentifierMutator-Variable,buffer,buf,2,0.0075013856,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1903,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21380,21385,IdentifierMutator-Variable,buffer,input,3,0.002350563,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1904,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21380,21385,IdentifierMutator-Variable,buffer,out,4,0.0018378728,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1905,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21380,21385,FieldReferenceMutator,buffer,in,1,0.06961245,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1906,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21380,21385,FieldReferenceMutator,buffer,buf,2,0.0075013856,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1907,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21380,21385,FieldReferenceMutator,buffer,input,3,0.002350563,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1908,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21380,21385,FieldReferenceMutator,buffer,out,4,0.0018378728,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1909,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21387,21392,FieldReferenceMutator,length,position,1,0.002160781,buffer.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1910,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21387,21392,FieldReferenceMutator,length,size,2,0.0020418996,buffer.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1911,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21387,21392,FieldReferenceMutator,length,len,3,0.0015271057,buffer.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1912,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21387,21392,FieldReferenceMutator,length,read,4,8.278441E-4,buffer.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1913,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21396,21398,IdentifierMutator-Variable,pos,i,0,0.9898303,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1914,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21396,21398,IdentifierMutator-Variable,pos,1,1,0.0022602202,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1915,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21396,21398,IdentifierMutator-Variable,pos,i,2,9.841333E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1916,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21396,21398,IdentifierMutator-Variable,pos,8,3,9.110976E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1917,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21396,21398,IdentifierMutator-Variable,pos,index,4,5.5149256E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1918,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21396,21398,FieldReferenceMutator,pos,i,0,0.9898303,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1919,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21396,21398,FieldReferenceMutator,pos,1,1,0.0022602202,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1920,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21396,21398,FieldReferenceMutator,pos,i,2,9.841333E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1921,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21396,21398,FieldReferenceMutator,pos,8,3,9.110976E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1922,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21396,21398,FieldReferenceMutator,pos,index,4,5.5149256E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1923,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21402,21411,IdentifierMutator-Variable,decodeSize,0,0,0.38190857,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1924,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21402,21411,IdentifierMutator-Variable,decodeSize,limit,1,0.1105233,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1925,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21402,21411,IdentifierMutator-Variable,decodeSize,i,2,0.11033225,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1926,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21402,21411,IdentifierMutator-Variable,decodeSize,len,3,0.047684494,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1927,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21402,21411,IdentifierMutator-Variable,decodeSize,size,4,0.026908359,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1928,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21402,21411,FieldReferenceMutator,decodeSize,0,0,0.38190857,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1929,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21402,21411,FieldReferenceMutator,decodeSize,limit,1,0.1105233,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1930,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21402,21411,FieldReferenceMutator,decodeSize,i,2,0.11033225,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1931,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21402,21411,FieldReferenceMutator,decodeSize,len,3,0.047684494,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1932,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,534,21402,21411,FieldReferenceMutator,decodeSize,size,4,0.026908359,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1933,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,535,21432,21443,MethodCallMutator,resizeBuffer,close,0,0.3517236,<mask>(),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1934,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,535,21432,21443,MethodCallMutator,resizeBuffer,flush,1,0.14769296,<mask>(),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1935,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,535,21432,21443,MethodCallMutator,resizeBuffer,decode,2,0.052173354,<mask>(),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1936,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,535,21432,21443,MethodCallMutator,resizeBuffer,break,3,0.038577206,<mask>(),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1937,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,535,21432,21443,MethodCallMutator,resizeBuffer,complete,4,0.028946027,<mask>(),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1938,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,537,21486,21492,ArrayAccessMutator,inPos++,i,0,0.6254486,in[<mask>],"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1939,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,537,21486,21492,ArrayAccessMutator,inPos++,pos,1,0.35539037,in[<mask>],"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1940,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,537,21486,21492,ArrayAccessMutator,inPos++,0,2,0.0029729423,in[<mask>],"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1941,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,537,21486,21492,ArrayAccessMutator,inPos++,p,3,9.37085E-4,in[<mask>],"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1942,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,537,21486,21492,ArrayAccessMutator,inPos++,Pos,4,8.155088E-4,in[<mask>],"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1943,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,537,21483,21484,IdentifierMutator-Variable,in,buffer,1,0.037988707,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b =<mask>[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1944,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,537,21483,21484,IdentifierMutator-Variable,in,bytes,2,0.023616761,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b =<mask>[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1945,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,537,21483,21484,IdentifierMutator-Variable,in,input,3,0.016035194,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b =<mask>[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1946,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,537,21483,21484,IdentifierMutator-Variable,in,data,4,0.012918302,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b =<mask>[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1947,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,537,21491,21492,UnaryOperatorMutator,++,--,2,9.3166454E-4,inPos<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1948,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,537,21491,21492,UnaryOperatorMutator,++,*/,3,3.0580416E-4,inPos<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1949,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,537,21491,21492,UnaryOperatorMutator,++,+,4,2.5941827E-4,inPos<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1950,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,537,21486,21490,IdentifierMutator-Variable,inPos,pos,0,0.783149,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1951,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,537,21486,21490,IdentifierMutator-Variable,inPos,i,1,0.1898064,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1952,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,537,21486,21490,IdentifierMutator-Variable,inPos,pos,2,0.00396269,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1953,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,537,21486,21490,IdentifierMutator-Variable,inPos,Pos,3,0.0024369045,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1954,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,537,21486,21490,IdentifierMutator-Variable,inPos,offset,4,0.0014244992,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1955,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,538,21513,21516,BinaryOperatorMutator,==,<,0,0.33759326,b <mask> org.apache.commons.codec.binary.Base64.PAD,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b<mask>PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1956,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,538,21513,21516,BinaryOperatorMutator,==,<,2,0.059361983,b <mask> org.apache.commons.codec.binary.Base64.PAD,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b<mask>PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1957,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,538,21513,21516,BinaryOperatorMutator,==,>=,4,0.032735188,b <mask> org.apache.commons.codec.binary.Base64.PAD,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b<mask>PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1958,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,538,21512,21512,IdentifierMutator-Variable,b,bc,1,0.0010331722,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (<mask> == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1959,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,538,21512,21512,IdentifierMutator-Variable,b,a,3,4.8363625E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (<mask> == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1960,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,538,21512,21512,IdentifierMutator-Variable,b,sb,4,3.881319E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (<mask> == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1961,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,538,21517,21519,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,0,0,0.8472015,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1962,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,538,21517,21519,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,127,1,0.049700234,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1963,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,538,21517,21519,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,b,2,0.020087166,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1964,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,538,21517,21519,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,255,3,0.010305227,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1965,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,538,21517,21519,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,null,4,0.009432046,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1966,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,538,21517,21519,FieldReferenceMutator,PAD,0,0,0.8472015,org.apache.commons.codec.binary.Base64.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1967,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,538,21517,21519,FieldReferenceMutator,PAD,127,1,0.049700234,org.apache.commons.codec.binary.Base64.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1968,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,538,21517,21519,FieldReferenceMutator,PAD,b,2,0.020087166,org.apache.commons.codec.binary.Base64.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1969,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,538,21517,21519,FieldReferenceMutator,PAD,255,3,0.010305227,org.apache.commons.codec.binary.Base64.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1970,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,538,21517,21519,FieldReferenceMutator,PAD,null,4,0.009432046,org.apache.commons.codec.binary.Base64.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1971,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,540,21574,21574,AssignmentMutator,eof=true,|,0,0.90622437,eof <mask>= true,", int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof<mask>= true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                          "
1972,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,540,21574,21574,AssignmentMutator,eof=true,&,1,0.0685714,eof <mask>= true,", int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof<mask>= true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                          "
1973,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,540,21574,21574,AssignmentMutator,eof=true,*,2,0.010431921,eof <mask>= true,", int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof<mask>= true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                          "
1974,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,540,21574,21574,AssignmentMutator,eof=true,||,3,0.0045410474,eof <mask>= true,", int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof<mask>= true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                          "
1975,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,540,21574,21574,AssignmentMutator,eof=true,^,4,0.0031841302,eof <mask>= true,", int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof<mask>= true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                          "
1976,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,540,21571,21573,IdentifierMutator-Variable,eof,done,0,0.5822251,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1977,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,540,21571,21573,IdentifierMutator-Variable,eof,finished,1,0.0749867,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1978,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,540,21571,21573,IdentifierMutator-Variable,eof,completed,2,0.0207111,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1979,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,540,21571,21573,IdentifierMutator-Variable,eof,complete,3,0.019147605,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1980,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,540,21571,21573,IdentifierMutator-Variable,eof,ok,4,0.016916098,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1981,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,540,21571,21573,FieldReferenceMutator,eof,done,0,0.5822251,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1982,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,540,21571,21573,FieldReferenceMutator,eof,finished,1,0.0749867,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1983,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,540,21571,21573,FieldReferenceMutator,eof,completed,2,0.0207111,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1984,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,540,21571,21573,FieldReferenceMutator,eof,complete,3,0.019147605,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1985,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,540,21571,21573,FieldReferenceMutator,eof,ok,4,0.016916098,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1986,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,540,21577,21580,IdentifierMutator-Literal,true,false,1,0.022653628,<mask>," int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof =<mask>;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer"
1987,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,540,21577,21580,IdentifierMutator-Literal,true,True,2,1.2616171E-4,<mask>," int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof =<mask>;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer"
1988,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,540,21577,21580,IdentifierMutator-Literal,true,1,4,4.7072164E-5,<mask>," int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof =<mask>;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer"
1989,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21653,21656,BinaryOperatorMutator,&&,&,2,0.019086072,(b >= 0) <mask> (b < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)," (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0<mask>b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = ("
1990,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21653,21656,BinaryOperatorMutator,&&,&,3,0.0019726616,(b >= 0) <mask> (b < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)," (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0<mask>b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = ("
1991,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21653,21656,BinaryOperatorMutator,&&,AND,4,0.0017750916,(b >= 0) <mask> (b < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)," (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0<mask>b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = ("
1992,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21648,21651,BinaryOperatorMutator,>=,>,1,0.21913998,b <mask> 0,"  if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b<mask>0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]"
1993,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21648,21651,BinaryOperatorMutator,>=,>,2,0.1036691,b <mask> 0,"  if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b<mask>0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]"
1994,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21648,21651,BinaryOperatorMutator,>=,!=,3,0.044702142,b <mask> 0,"  if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b<mask>0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]"
1995,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21648,21651,BinaryOperatorMutator,>=,==,4,0.010695067,b <mask> 0,"  if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b<mask>0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]"
1996,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21647,21647,IdentifierMutator-Variable,b,result,1,0.021446548,<mask>,"   if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (<mask> >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++"
1997,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21647,21647,IdentifierMutator-Variable,b,bc,2,0.002022709,<mask>,"   if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (<mask> >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++"
1998,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21647,21647,IdentifierMutator-Variable,b,a,4,7.179882E-4,<mask>,"   if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (<mask> >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++"
1999,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21652,21652,IdentifierMutator-Literal,0,1,1,0.004490776,<mask>," if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >=<mask> && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] ="
2000,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21652,21652,IdentifierMutator-Literal,0,offset,2,0.0039863857,<mask>," if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >=<mask> && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] ="
2001,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21652,21652,IdentifierMutator-Literal,0,pos,3,0.0029801773,<mask>," if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >=<mask> && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] ="
2002,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21652,21652,IdentifierMutator-Literal,0,32,4,0.0020950756,<mask>," if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >=<mask> && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] ="
2003,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21658,21660,BinaryOperatorMutator,<,<=,2,0.01899425,b <mask> org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,"Avail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b<mask>DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte)"
2004,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21658,21660,BinaryOperatorMutator,<,!=,3,0.00610453,b <mask> org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,"Avail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b<mask>DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte)"
2005,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21658,21660,BinaryOperatorMutator,<,>=,4,0.0019163891,b <mask> org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,"Avail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b<mask>DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte)"
2006,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21657,21657,IdentifierMutator-Variable,b,bi,2,7.3170377E-4,<mask>,"inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 &&<mask> < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte"
2007,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21657,21657,IdentifierMutator-Variable,b,result,3,2.5595404E-4,<mask>,"inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 &&<mask> < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte"
2008,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21657,21657,IdentifierMutator-Variable,b,a,4,2.4868533E-4,<mask>,"inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 &&<mask> < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte"
2009,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21661,21679,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,256,0,0.21313636,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2010,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21661,21679,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,127,1,0.17466232,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2011,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21661,21679,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,255,2,0.05645742,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2012,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21661,21679,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,32,3,0.03200671,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2013,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21661,21679,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,128,4,0.028498704,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2014,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21661,21672,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,in,0,0.4893274,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2015,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21661,21672,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,buffer,1,0.37093952,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2016,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21661,21672,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,table,2,0.022430008,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2017,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21661,21672,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,buf,3,0.01231022,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2018,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21661,21672,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,out,4,0.010743957,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2019,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21661,21672,FieldReferenceMutator,DECODE_TABLE,in,0,0.4893274,org.apache.commons.codec.binary.Base64.<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2020,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21661,21672,FieldReferenceMutator,DECODE_TABLE,buffer,1,0.37093952,org.apache.commons.codec.binary.Base64.<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2021,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21661,21672,FieldReferenceMutator,DECODE_TABLE,table,2,0.022430008,org.apache.commons.codec.binary.Base64.<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2022,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21661,21672,FieldReferenceMutator,DECODE_TABLE,buf,3,0.01231022,org.apache.commons.codec.binary.Base64.<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2023,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21661,21672,FieldReferenceMutator,DECODE_TABLE,out,4,0.010743957,org.apache.commons.codec.binary.Base64.<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2024,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21674,21679,FieldReferenceMutator,length,size,1,0.012956805,org.apache.commons.codec.binary.Base64.DECODE_TABLE.<mask>,"
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2025,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21674,21679,FieldReferenceMutator,length,SIZE,3,6.2544533E-4,org.apache.commons.codec.binary.Base64.DECODE_TABLE.<mask>,"
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2026,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,543,21674,21679,FieldReferenceMutator,length,len,4,3.5875774E-4,org.apache.commons.codec.binary.Base64.DECODE_TABLE.<mask>,"
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2027,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,544,21730,21730,ArrayAccessMutator,b,sb,1,4.0137925E-4,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"    for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[<mask>];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                       "
2028,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,544,21730,21730,ArrayAccessMutator,b,bc,3,1.6075248E-4,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"    for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[<mask>];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                       "
2029,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,544,21730,21730,ArrayAccessMutator,b,bb,4,1.241853E-4,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"    for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[<mask>];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                       "
2030,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,544,21717,21728,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,out,0,0.161933,<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2031,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,544,21717,21728,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,result,1,0.16134569,<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2032,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,544,21717,21728,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,table,2,0.122663885,<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2033,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,544,21717,21728,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,decode,3,0.10492258,<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2034,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,544,21717,21728,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,in,4,0.06700945,<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2035,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,544,21717,21728,FieldReferenceMutator,DECODE_TABLE,out,0,0.161933,org.apache.commons.codec.binary.Base64.<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2036,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,544,21717,21728,FieldReferenceMutator,DECODE_TABLE,result,1,0.16134569,org.apache.commons.codec.binary.Base64.<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2037,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,544,21717,21728,FieldReferenceMutator,DECODE_TABLE,table,2,0.122663885,org.apache.commons.codec.binary.Base64.<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2038,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,544,21717,21728,FieldReferenceMutator,DECODE_TABLE,decode,3,0.10492258,org.apache.commons.codec.binary.Base64.<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2039,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,544,21717,21728,FieldReferenceMutator,DECODE_TABLE,in,4,0.06700945,org.apache.commons.codec.binary.Base64.<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2040,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,544,21730,21730,IdentifierMutator-Variable,b,sb,1,4.0137925E-4,<mask>,"    for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[<mask>];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                       "
2041,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,544,21730,21730,IdentifierMutator-Variable,b,bc,3,1.6075248E-4,<mask>,"    for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[<mask>];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                       "
2042,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,544,21730,21730,IdentifierMutator-Variable,b,bb,4,1.241853E-4,<mask>,"    for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[<mask>];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                       "
2043,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,545,21764,21767,BinaryOperatorMutator,>=,==,0,0.19789413,result <mask> 0,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result<mask>0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
 "
2044,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,545,21764,21767,BinaryOperatorMutator,>=,<,1,0.18820265,result <mask> 0,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result<mask>0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
 "
2045,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,545,21764,21767,BinaryOperatorMutator,>=,==,2,0.17100784,result <mask> 0,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result<mask>0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
 "
2046,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,545,21764,21767,BinaryOperatorMutator,>=,>,3,0.12228257,result <mask> 0,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result<mask>0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
 "
2047,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,545,21764,21767,BinaryOperatorMutator,>=,!=,4,0.083168045,result <mask> 0,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result<mask>0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
 "
2048,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,545,21758,21763,IdentifierMutator-Variable,result,b,1,0.0020867772,<mask>,"        if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (<mask> >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
"
2049,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,545,21758,21763,IdentifierMutator-Variable,result,x,3,5.300513E-4,<mask>,"        if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (<mask> >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
"
2050,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,545,21758,21763,IdentifierMutator-Variable,result,Result,4,3.0898253E-4,<mask>,"        if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (<mask> >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
"
2051,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,545,21768,21768,IdentifierMutator-Literal,0,result,1,0.047678776,<mask>,"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >=<mask>) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
  "
2052,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,545,21768,21768,IdentifierMutator-Literal,0,1,2,0.01506779,<mask>,"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >=<mask>) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
  "
2053,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,545,21768,21768,IdentifierMutator-Literal,0,4,3,0.014520599,<mask>,"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >=<mask>) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
  "
2054,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,545,21768,21768,IdentifierMutator-Literal,0,b,4,0.010874171,<mask>,"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >=<mask>) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
  "
2055,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21804,21804,AssignmentMutator,modulus=(++modulus)%4,|,0,0.65899664,modulus <mask>= (++modulus) % 4,"         resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus<mask>= (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2056,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21804,21804,AssignmentMutator,modulus=(++modulus)%4,^,1,0.14296398,modulus <mask>= (++modulus) % 4,"         resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus<mask>= (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2057,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21804,21804,AssignmentMutator,modulus=(++modulus)%4,*,2,0.12800941,modulus <mask>= (++modulus) % 4,"         resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus<mask>= (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2058,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21804,21804,AssignmentMutator,modulus=(++modulus)%4,~,3,0.016311442,modulus <mask>= (++modulus) % 4,"         resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus<mask>= (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2059,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21804,21804,AssignmentMutator,modulus=(++modulus)%4,&,4,0.015128292,modulus <mask>= (++modulus) % 4,"         resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus<mask>= (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2060,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21797,21803,IdentifierMutator-Variable,modulus,result,0,0.9300049,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2061,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21797,21803,IdentifierMutator-Variable,modulus,result,1,0.02841901,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2062,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21797,21803,IdentifierMutator-Variable,modulus,x,2,0.010010788,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2063,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21797,21803,IdentifierMutator-Variable,modulus,b,3,0.0047685863,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2064,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21797,21803,IdentifierMutator-Variable,modulus,r,4,0.002740545,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2065,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21797,21803,FieldReferenceMutator,modulus,result,0,0.9300049,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2066,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21797,21803,FieldReferenceMutator,modulus,result,1,0.02841901,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2067,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21797,21803,FieldReferenceMutator,modulus,x,2,0.010010788,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2068,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21797,21803,FieldReferenceMutator,modulus,b,3,0.0047685863,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2069,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21797,21803,FieldReferenceMutator,modulus,r,4,0.002740545,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2070,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21818,21820,BinaryOperatorMutator,%,<<,0,0.3310226,(++modulus) <mask> 4,"   resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus)<mask>4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
            "
2071,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21818,21820,BinaryOperatorMutator,%,<<,1,0.19898808,(++modulus) <mask> 4,"   resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus)<mask>4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
            "
2072,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21818,21820,BinaryOperatorMutator,%,>>>,2,0.1163094,(++modulus) <mask> 4,"   resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus)<mask>4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
            "
2073,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21818,21820,BinaryOperatorMutator,%,>>,3,0.10253956,(++modulus) <mask> 4,"   resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus)<mask>4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
            "
2074,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21818,21820,BinaryOperatorMutator,%,*,4,0.086625755,(++modulus) <mask> 4,"   resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus)<mask>4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
            "
2075,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21807,21809,UnaryOperatorMutator,++,(,0,0.89622533,<mask>modulus,"        resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus =<mask>modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
        "
2076,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21807,21809,UnaryOperatorMutator,++,((,1,0.062281184,<mask>modulus,"        resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus =<mask>modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
        "
2077,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21807,21809,UnaryOperatorMutator,++,(-,2,0.02788103,<mask>modulus,"        resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus =<mask>modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
        "
2078,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21807,21809,UnaryOperatorMutator,++,(+,3,0.0044850786,<mask>modulus,"        resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus =<mask>modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
        "
2079,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21807,21809,UnaryOperatorMutator,++,$(,4,0.003222266,<mask>modulus,"        resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus =<mask>modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
        "
2080,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21810,21816,IdentifierMutator-Variable,modulus,result,0,0.90665376,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2081,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21810,21816,IdentifierMutator-Variable,modulus,result,1,0.044579715,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2082,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21810,21816,IdentifierMutator-Variable,modulus,x,2,0.006188522,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2083,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21810,21816,IdentifierMutator-Variable,modulus,b,3,0.0058603315,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2084,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21810,21816,IdentifierMutator-Variable,modulus,Result,4,0.0017172208,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2085,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21810,21816,FieldReferenceMutator,modulus,result,0,0.90665376,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2086,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21810,21816,FieldReferenceMutator,modulus,result,1,0.044579715,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2087,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21810,21816,FieldReferenceMutator,modulus,x,2,0.006188522,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2088,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21810,21816,FieldReferenceMutator,modulus,b,3,0.0058603315,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2089,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21810,21816,FieldReferenceMutator,modulus,Result,4,0.0017172208,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2090,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21821,21821,IdentifierMutator-Literal,4,6,0,0.23011923,<mask>,"  resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) %<mask>;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
             "
2091,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21821,21821,IdentifierMutator-Literal,4,7,1,0.17289494,<mask>,"  resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) %<mask>;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
             "
2092,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21821,21821,IdentifierMutator-Literal,4,8,2,0.11898011,<mask>,"  resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) %<mask>;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
             "
2093,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21821,21821,IdentifierMutator-Literal,4,16,3,0.06912174,<mask>,"  resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) %<mask>;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
             "
2094,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,546,21821,21821,IdentifierMutator-Literal,4,2,4,0.060726397,<mask>,"  resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) %<mask>;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
             "
2095,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21849,21849,AssignmentMutator,x=(x<<6)+result,^,0,0.4999693,x <mask>= (x << 6) + result,"   byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x<mask>= (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2096,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21849,21849,AssignmentMutator,x=(x<<6)+result,|,1,0.322209,x <mask>= (x << 6) + result,"   byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x<mask>= (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2097,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21849,21849,AssignmentMutator,x=(x<<6)+result,*,2,0.08955514,x <mask>= (x << 6) + result,"   byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x<mask>= (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2098,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21849,21849,AssignmentMutator,x=(x<<6)+result,&,3,0.016634347,x <mask>= (x << 6) + result,"   byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x<mask>= (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2099,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21849,21849,AssignmentMutator,x=(x<<6)+result,>>,4,0.016120763,x <mask>= (x << 6) + result,"   byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x<mask>= (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2100,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21848,21848,IdentifierMutator-Variable,x,result,1,0.0640868,<mask>,"Buffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;<mask> = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2101,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21848,21848,IdentifierMutator-Variable,x,b,3,0.012007701,<mask>,"Buffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;<mask> = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2102,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21848,21848,IdentifierMutator-Variable,x,byte,4,0.0016528858,<mask>,"Buffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;<mask> = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2103,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21848,21848,FieldReferenceMutator,x,result,1,0.0640868,<mask>,"Buffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;<mask> = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2104,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21848,21848,FieldReferenceMutator,x,b,3,0.012007701,<mask>,"Buffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;<mask> = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2105,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21848,21848,FieldReferenceMutator,x,byte,4,0.0016528858,<mask>,"Buffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;<mask> = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2106,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21860,21862,BinaryOperatorMutator,+,|,0,0.6570313,(x << 6) <mask> result,"[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6)<mask>result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
        "
2107,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21860,21862,BinaryOperatorMutator,+,^,1,0.12923063,(x << 6) <mask> result,"[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6)<mask>result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
        "
2108,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21860,21862,BinaryOperatorMutator,+,^,3,0.025890976,(x << 6) <mask> result,"[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6)<mask>result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
        "
2109,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21860,21862,BinaryOperatorMutator,+,|,4,0.023562854,(x << 6) <mask> result,"[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6)<mask>result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
        "
2110,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21854,21857,BinaryOperatorMutator,<<,>>,2,0.084258474,x <mask> 6," b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x<mask>6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
     "
2111,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21854,21857,BinaryOperatorMutator,<<,>>>,3,0.051838107,x <mask> 6," b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x<mask>6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
     "
2112,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21854,21857,BinaryOperatorMutator,<<,*,4,0.031752646,x <mask> 6," b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x<mask>6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
     "
2113,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21853,21853,IdentifierMutator-Variable,x,result,1,0.015783014,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2114,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21853,21853,IdentifierMutator-Variable,x,1,2,0.0072304574,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2115,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21853,21853,IdentifierMutator-Variable,x,b,3,0.006456256,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2116,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21853,21853,IdentifierMutator-Variable,x,0,4,0.005090533,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2117,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21853,21853,FieldReferenceMutator,x,result,1,0.015783014,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2118,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21853,21853,FieldReferenceMutator,x,1,2,0.0072304574,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2119,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21853,21853,FieldReferenceMutator,x,b,3,0.006456256,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2120,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21853,21853,FieldReferenceMutator,x,0,4,0.005090533,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2121,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21858,21858,IdentifierMutator-Literal,6,4,0,0.44843903,<mask>," = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x <<<mask>) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
      "
2122,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21858,21858,IdentifierMutator-Literal,6,1,1,0.09024653,<mask>," = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x <<<mask>) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
      "
2123,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21858,21858,IdentifierMutator-Literal,6,3,2,0.08693968,<mask>," = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x <<<mask>) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
      "
2124,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21858,21858,IdentifierMutator-Literal,6,8,3,0.07948491,<mask>," = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x <<<mask>) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
      "
2125,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21858,21858,IdentifierMutator-Literal,6,2,4,0.069562554,<mask>," = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x <<<mask>) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
      "
2126,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21863,21868,IdentifierMutator-Variable,result,1,1,0.05820676,<mask>,"inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) +<mask>;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
         "
2127,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21863,21868,IdentifierMutator-Variable,result,b,2,0.015669588,<mask>,"inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) +<mask>;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
         "
2128,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21863,21868,IdentifierMutator-Variable,result,x,3,0.0086542955,<mask>,"inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) +<mask>;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
         "
2129,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,547,21863,21868,IdentifierMutator-Variable,result,y,4,0.004624361,<mask>,"inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) +<mask>;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
         "
2130,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,548,21906,21909,BinaryOperatorMutator,==,>,1,0.29054463,modulus <mask> 0,"           // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus<mask>0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base"
2131,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,548,21906,21909,BinaryOperatorMutator,==,>,2,0.08662433,modulus <mask> 0,"           // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus<mask>0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base"
2132,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,548,21906,21909,BinaryOperatorMutator,==,=,3,0.034526546,modulus <mask> 0,"           // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus<mask>0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base"
2133,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,548,21899,21905,IdentifierMutator-Variable,modulus,result,0,0.88740814,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2134,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,548,21899,21905,IdentifierMutator-Variable,modulus,x,1,0.05656922,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2135,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,548,21899,21905,IdentifierMutator-Variable,modulus,b,2,0.011772414,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2136,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,548,21899,21905,IdentifierMutator-Variable,modulus,i,3,0.0038203106,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2137,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,548,21899,21905,IdentifierMutator-Variable,modulus,bit,4,0.0012361062,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2138,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,548,21899,21905,FieldReferenceMutator,modulus,result,0,0.88740814,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2139,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,548,21899,21905,FieldReferenceMutator,modulus,x,1,0.05656922,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2140,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,548,21899,21905,FieldReferenceMutator,modulus,b,2,0.011772414,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2141,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,548,21899,21905,FieldReferenceMutator,modulus,i,3,0.0038203106,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2142,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,548,21899,21905,FieldReferenceMutator,modulus,bit,4,0.0012361062,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2143,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,548,21910,21910,IdentifierMutator-Literal,0,4,1,0.10988745,<mask>,"          // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus ==<mask>) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64"
2144,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,548,21910,21910,IdentifierMutator-Literal,0,1,2,0.08169701,<mask>,"          // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus ==<mask>) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64"
2145,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,548,21910,21910,IdentifierMutator-Literal,0,2,3,0.02699835,<mask>,"          // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus ==<mask>) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64"
2146,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,548,21910,21910,IdentifierMutator-Literal,0,7,4,0.024858033,<mask>,"          // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus ==<mask>) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64"
2147,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21956,21956,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),|,0,0.7883253,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
   "
2148,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21956,21956,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),^,1,0.15358827,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
   "
2149,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21956,21956,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),*,2,0.016799748,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
   "
2150,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21956,21956,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),&,3,0.011472154,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
   "
2151,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21956,21956,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),<<,4,0.0063417032,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
   "
2152,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21950,21954,ArrayAccessMutator,pos++,pos,0,0.9990188,buffer[<mask>]," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2153,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21950,21954,ArrayAccessMutator,pos++,++,1,1.1636751E-4,buffer[<mask>]," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2154,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21950,21954,ArrayAccessMutator,pos++,push,2,8.2507315E-5,buffer[<mask>]," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2155,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21950,21954,ArrayAccessMutator,pos++,offset,3,6.0640832E-5,buffer[<mask>]," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2156,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21950,21954,ArrayAccessMutator,pos++,neg,4,4.973425E-5,buffer[<mask>]," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2157,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21943,21948,IdentifierMutator-Variable,buffer,byte,2,1.990669E-4,<mask>,"       // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream."
2158,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21943,21948,IdentifierMutator-Variable,buffer,buf,3,9.610359E-5,<mask>,"       // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream."
2159,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21943,21948,IdentifierMutator-Variable,buffer,Buffer,4,8.506287E-5,<mask>,"       // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream."
2160,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21943,21948,FieldReferenceMutator,buffer,byte,2,1.990669E-4,<mask>,"       // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream."
2161,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21943,21948,FieldReferenceMutator,buffer,buf,3,9.610359E-5,<mask>,"       // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream."
2162,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21943,21948,FieldReferenceMutator,buffer,Buffer,4,8.506287E-5,<mask>,"       // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream."
2163,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21953,21954,UnaryOperatorMutator,++,+,1,1.15085466E-4,pos<mask>,";
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2164,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21953,21954,UnaryOperatorMutator,++,++;,3,3.9837236E-5,pos<mask>,";
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2165,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21953,21954,UnaryOperatorMutator,++,--,4,3.7068556E-5,pos<mask>,";
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2166,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21950,21952,IdentifierMutator-Variable,pos,size,1,2.9646139E-5,<mask>," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
 "
2167,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21950,21952,IdentifierMutator-Variable,pos,len,2,1.6531529E-5,<mask>," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
 "
2168,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21950,21952,IdentifierMutator-Variable,pos,offset,3,1.652951E-5,<mask>," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
 "
2169,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21950,21952,FieldReferenceMutator,pos,size,1,2.9646139E-5,<mask>," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
 "
2170,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21950,21952,FieldReferenceMutator,pos,len,2,1.6531529E-5,<mask>," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
 "
2171,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21950,21952,FieldReferenceMutator,pos,offset,3,1.652951E-5,<mask>," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
 "
2172,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21976,21978,BinaryOperatorMutator,&,|,1,0.0027280087,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"       break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '"
2173,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21976,21978,BinaryOperatorMutator,&,^,3,2.0136025E-4,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"       break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '"
2174,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21976,21978,BinaryOperatorMutator,&,+,4,8.5965905E-5,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"       break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '"
2175,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21969,21972,BinaryOperatorMutator,>>,<<,2,0.033759512,x <mask> 16,"          break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach"
2176,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21969,21972,BinaryOperatorMutator,>>,<<,3,0.025514338,x <mask> 16,"          break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach"
2177,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21969,21972,BinaryOperatorMutator,>>,>>>,4,0.015062867,x <mask> 16,"          break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach"
2178,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21968,21968,IdentifierMutator-Variable,x,X,2,4.5287445E-5,<mask>,"           break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This"
2179,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21968,21968,IdentifierMutator-Variable,x,xx,3,4.1739215E-5,<mask>,"           break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This"
2180,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21968,21968,IdentifierMutator-Variable,x,y,4,3.968694E-5,<mask>,"           break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This"
2181,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21968,21968,FieldReferenceMutator,x,X,2,4.5287445E-5,<mask>,"           break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This"
2182,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21968,21968,FieldReferenceMutator,x,xx,3,4.1739215E-5,<mask>,"           break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This"
2183,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21968,21968,FieldReferenceMutator,x,y,4,3.968694E-5,<mask>,"           break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This"
2184,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21973,21974,IdentifierMutator-Literal,16,8,0,0.75472903,<mask>,"         break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes"
2185,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21973,21974,IdentifierMutator-Literal,16,6,2,0.036264252,<mask>,"         break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes"
2186,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21973,21974,IdentifierMutator-Literal,16,4,3,0.03212222,<mask>,"         break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes"
2187,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21973,21974,IdentifierMutator-Literal,16,7,4,0.028541556,<mask>,"         break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes"
2188,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21979,21988,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,255,0,0.14948566,<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2189,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21979,21988,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,mask,1,0.08499066,<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2190,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21979,21988,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,7,2,0.08133535,<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2191,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21979,21988,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,1,3,0.066104494,<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2192,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21979,21988,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,bits,4,0.0607781,<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2193,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21979,21988,FieldReferenceMutator,MASK_8BITS,255,0,0.14948566,org.apache.commons.codec.binary.Base64.<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2194,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21979,21988,FieldReferenceMutator,MASK_8BITS,mask,1,0.08499066,org.apache.commons.codec.binary.Base64.<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2195,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21979,21988,FieldReferenceMutator,MASK_8BITS,7,2,0.08133535,org.apache.commons.codec.binary.Base64.<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2196,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21979,21988,FieldReferenceMutator,MASK_8BITS,1,3,0.066104494,org.apache.commons.codec.binary.Base64.<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2197,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,549,21979,21988,FieldReferenceMutator,MASK_8BITS,bits,4,0.0607781,org.apache.commons.codec.binary.Base64.<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2198,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22033,22033,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),|,0,0.84377605,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer"
2199,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22033,22033,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),^,1,0.11779102,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer"
2200,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22033,22033,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),&,2,0.013100316,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer"
2201,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22033,22033,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),*,3,0.009379746,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer"
2202,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22033,22033,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),>>>,4,0.0031888855,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer"
2203,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22027,22031,ArrayAccessMutator,pos++,pos,0,0.9834669,buffer[<mask>],"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if ("
2204,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22027,22031,ArrayAccessMutator,pos++,++,1,0.006718165,buffer[<mask>],"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if ("
2205,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22027,22031,ArrayAccessMutator,pos++,push,2,0.0011382556,buffer[<mask>],"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if ("
2206,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22027,22031,ArrayAccessMutator,pos++,neg,3,7.127295E-4,buffer[<mask>],"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if ("
2207,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22027,22031,ArrayAccessMutator,pos++,next,4,6.296928E-4,buffer[<mask>],"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if ("
2208,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22020,22025,IdentifierMutator-Variable,buffer,Buffer,2,8.9295744E-4,<mask>,"
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
          "
2209,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22020,22025,IdentifierMutator-Variable,buffer,byte,3,3.595063E-4,<mask>,"
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
          "
2210,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22020,22025,IdentifierMutator-Variable,buffer,Buffer,4,3.2872977E-4,<mask>,"
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
          "
2211,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22020,22025,FieldReferenceMutator,buffer,Buffer,2,8.9295744E-4,<mask>,"
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
          "
2212,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22020,22025,FieldReferenceMutator,buffer,byte,3,3.595063E-4,<mask>,"
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
          "
2213,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22020,22025,FieldReferenceMutator,buffer,Buffer,4,3.2872977E-4,<mask>,"
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
          "
2214,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22030,22031,UnaryOperatorMutator,++,--,2,1.0629602E-4,pos<mask>," if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if ("
2215,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22030,22031,UnaryOperatorMutator,++,+,3,9.762443E-5,pos<mask>," if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if ("
2216,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22030,22031,UnaryOperatorMutator,++,++;,4,5.836285E-5,pos<mask>," if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if ("
2217,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22027,22029,IdentifierMutator-Variable,pos,size,1,6.545053E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if"
2218,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22027,22029,IdentifierMutator-Variable,pos,len,2,6.0663024E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if"
2219,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22027,22029,IdentifierMutator-Variable,pos,neg,3,3.9211613E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if"
2220,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22027,22029,FieldReferenceMutator,pos,size,1,6.545053E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if"
2221,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22027,22029,FieldReferenceMutator,pos,len,2,6.0663024E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if"
2222,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22027,22029,FieldReferenceMutator,pos,neg,3,3.9211613E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if"
2223,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22052,22054,BinaryOperatorMutator,&,|,1,0.0030781173,(x >> 8) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8)<mask>MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decode"
2224,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22052,22054,BinaryOperatorMutator,&,^,3,1.7818132E-4,(x >> 8) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8)<mask>MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decode"
2225,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22052,22054,BinaryOperatorMutator,&,~,4,5.2539155E-5,(x >> 8) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8)<mask>MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decode"
2226,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22046,22049,BinaryOperatorMutator,>>,>>>,1,0.0057276003,x <mask> 8," DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x<mask>8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -"
2227,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22046,22049,BinaryOperatorMutator,>>,<<,2,0.0034407824,x <mask> 8," DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x<mask>8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -"
2228,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22046,22049,BinaryOperatorMutator,>>,<<,4,3.2703442E-4,x <mask> 8," DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x<mask>8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -"
2229,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22045,22045,IdentifierMutator-Variable,x,y,1,4.8968854E-5,<mask>," < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length"
2230,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22045,22045,IdentifierMutator-Variable,x,xx,3,1.2466716E-5,<mask>," < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length"
2231,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22045,22045,IdentifierMutator-Variable,x,X,4,1.2094731E-5,<mask>," < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length"
2232,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22045,22045,FieldReferenceMutator,x,y,1,4.8968854E-5,<mask>," < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length"
2233,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22045,22045,FieldReferenceMutator,x,xx,3,1.2466716E-5,<mask>," < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length"
2234,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22045,22045,FieldReferenceMutator,x,X,4,1.2094731E-5,<mask>," < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length"
2235,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22050,22050,IdentifierMutator-Literal,8,16,1,0.0700611,<mask>,"ODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos"
2236,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22050,22050,IdentifierMutator-Literal,8,6,2,0.038927842,<mask>,"ODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos"
2237,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22050,22050,IdentifierMutator-Literal,8,24,3,0.02497605,<mask>,"ODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos"
2238,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22050,22050,IdentifierMutator-Literal,8,12,4,0.017248644,<mask>,"ODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos"
2239,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22055,22064,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,mask,0,0.2678655,<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2240,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22055,22064,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,7,1,0.106067866,<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2241,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22055,22064,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,255,2,0.09560945,<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2242,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22055,22064,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,1,3,0.07435307,<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2243,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22055,22064,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,bits,4,0.065667495,<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2244,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22055,22064,FieldReferenceMutator,MASK_8BITS,mask,0,0.2678655,org.apache.commons.codec.binary.Base64.<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2245,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22055,22064,FieldReferenceMutator,MASK_8BITS,7,1,0.106067866,org.apache.commons.codec.binary.Base64.<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2246,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22055,22064,FieldReferenceMutator,MASK_8BITS,255,2,0.09560945,org.apache.commons.codec.binary.Base64.<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2247,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22055,22064,FieldReferenceMutator,MASK_8BITS,1,3,0.07435307,org.apache.commons.codec.binary.Base64.<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2248,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,550,22055,22064,FieldReferenceMutator,MASK_8BITS,bits,4,0.065667495,org.apache.commons.codec.binary.Base64.<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2249,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22109,22109,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),|,0,0.75222784,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"               if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
    "
2250,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22109,22109,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),^,1,0.22104852,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"               if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
    "
2251,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22109,22109,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),&,2,0.009466009,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"               if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
    "
2252,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22109,22109,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),*,3,0.0067352336,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"               if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
    "
2253,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22109,22109,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),<<,4,0.0019554717,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"               if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
    "
2254,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22103,22107,ArrayAccessMutator,pos++,pos,0,0.98453265,buffer[<mask>],"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
   "
2255,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22103,22107,ArrayAccessMutator,pos++,++,1,0.005643638,buffer[<mask>],"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
   "
2256,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22103,22107,ArrayAccessMutator,pos++,len,2,8.365135E-4,buffer[<mask>],"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
   "
2257,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22103,22107,ArrayAccessMutator,pos++,neg,3,7.98241E-4,buffer[<mask>],"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
   "
2258,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22103,22107,ArrayAccessMutator,pos++,next,4,4.2224152E-4,buffer[<mask>],"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
   "
2259,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22096,22101,IdentifierMutator-Variable,buffer,byte,2,5.705932E-4,<mask>,"                  int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
"
2260,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22096,22101,IdentifierMutator-Variable,buffer,Buffer,3,4.703385E-4,<mask>,"                  int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
"
2261,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22096,22101,IdentifierMutator-Variable,buffer,buf,4,3.2684923E-4,<mask>,"                  int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
"
2262,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22096,22101,FieldReferenceMutator,buffer,byte,2,5.705932E-4,<mask>,"                  int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
"
2263,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22096,22101,FieldReferenceMutator,buffer,Buffer,3,4.703385E-4,<mask>,"                  int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
"
2264,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22096,22101,FieldReferenceMutator,buffer,buf,4,3.2684923E-4,<mask>,"                  int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
"
2265,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22106,22107,UnaryOperatorMutator,++,--,2,9.577099E-5,pos<mask>,"                 if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
   "
2266,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22106,22107,UnaryOperatorMutator,++,++;,3,9.177502E-5,pos<mask>,"                 if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
   "
2267,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22106,22107,UnaryOperatorMutator,++,+,4,6.779041E-5,pos<mask>,"                 if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
   "
2268,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22103,22105,IdentifierMutator-Variable,pos,len,1,2.4209244E-4,<mask>,"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
  "
2269,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22103,22105,IdentifierMutator-Variable,pos,size,2,1.16159885E-4,<mask>,"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
  "
2270,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22103,22105,IdentifierMutator-Variable,pos,neg,3,9.629809E-5,<mask>,"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
  "
2271,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22103,22105,FieldReferenceMutator,pos,len,1,2.4209244E-4,<mask>,"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
  "
2272,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22103,22105,FieldReferenceMutator,pos,size,2,1.16159885E-4,<mask>,"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
  "
2273,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22103,22105,FieldReferenceMutator,pos,neg,3,9.629809E-5,<mask>,"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
  "
2274,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22121,22123,BinaryOperatorMutator,&,<<,2,0.02608974,x <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"         if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x<mask>MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
           "
2275,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22121,22123,BinaryOperatorMutator,&,|,3,0.015976517,x <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"         if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x<mask>MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
           "
2276,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22121,22123,BinaryOperatorMutator,&,>>,4,0.011088139,x <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"         if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x<mask>MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
           "
2277,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22120,22120,IdentifierMutator-Variable,x,result,1,8.005851E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
          "
2278,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22120,22120,IdentifierMutator-Variable,x,y,2,6.595817E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
          "
2279,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22120,22120,IdentifierMutator-Variable,x,xx,3,5.451774E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
          "
2280,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22120,22120,IdentifierMutator-Variable,x,rx,4,2.9773425E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
          "
2281,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22120,22120,FieldReferenceMutator,x,result,1,8.005851E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
          "
2282,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22120,22120,FieldReferenceMutator,x,y,2,6.595817E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
          "
2283,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22120,22120,FieldReferenceMutator,x,xx,3,5.451774E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
          "
2284,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22120,22120,FieldReferenceMutator,x,rx,4,2.9773425E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
          "
2285,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22124,22133,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,7,0,0.2014504,<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2286,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22124,22133,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,255,1,0.14482085,<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2287,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22124,22133,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,1,2,0.13607307,<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2288,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22124,22133,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,mask,3,0.11543218,<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2289,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22124,22133,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,63,4,0.11482765,<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2290,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22124,22133,FieldReferenceMutator,MASK_8BITS,7,0,0.2014504,org.apache.commons.codec.binary.Base64.<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2291,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22124,22133,FieldReferenceMutator,MASK_8BITS,255,1,0.14482085,org.apache.commons.codec.binary.Base64.<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2292,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22124,22133,FieldReferenceMutator,MASK_8BITS,1,2,0.13607307,org.apache.commons.codec.binary.Base64.<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2293,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22124,22133,FieldReferenceMutator,MASK_8BITS,mask,3,0.11543218,org.apache.commons.codec.binary.Base64.<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2294,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,551,22124,22133,FieldReferenceMutator,MASK_8BITS,63,4,0.11482765,org.apache.commons.codec.binary.Base64.<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2295,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22471,22474,BinaryOperatorMutator,&&,_,0,0.28576976,eof <mask> (modulus != 0),"                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof<mask>modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                "
2296,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22471,22474,BinaryOperatorMutator,&&,.,1,0.113051236,eof <mask> (modulus != 0),"                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof<mask>modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                "
2297,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22471,22474,BinaryOperatorMutator,&&,-,2,0.11280656,eof <mask> (modulus != 0),"                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof<mask>modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                "
2298,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22471,22474,BinaryOperatorMutator,&&,/,3,0.10943496,eof <mask> (modulus != 0),"                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof<mask>modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                "
2299,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22468,22470,IdentifierMutator-Variable,eof,enabled,0,0.03830287,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
               "
2300,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22468,22470,IdentifierMutator-Variable,eof,complete,1,0.037303496,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
               "
2301,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22468,22470,IdentifierMutator-Variable,eof,raw,2,0.03371212,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
               "
2302,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22468,22470,IdentifierMutator-Variable,eof,buffer,3,0.03242446,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
               "
2303,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22468,22470,IdentifierMutator-Variable,eof,true,4,0.026167635,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
               "
2304,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22468,22470,FieldReferenceMutator,eof,enabled,0,0.03830287,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
               "
2305,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22468,22470,FieldReferenceMutator,eof,complete,1,0.037303496,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
               "
2306,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22468,22470,FieldReferenceMutator,eof,raw,2,0.03371212,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
               "
2307,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22468,22470,FieldReferenceMutator,eof,buffer,3,0.03242446,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
               "
2308,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22468,22470,FieldReferenceMutator,eof,true,4,0.026167635,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
               "
2309,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22482,22485,BinaryOperatorMutator,!=,==,0,0.721256,modulus <mask> 0,"                 buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus<mask>0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                   "
2310,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22482,22485,BinaryOperatorMutator,!=,==,1,0.081483044,modulus <mask> 0,"                 buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus<mask>0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                   "
2311,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22482,22485,BinaryOperatorMutator,!=,>,2,0.08096128,modulus <mask> 0,"                 buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus<mask>0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                   "
2312,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22482,22485,BinaryOperatorMutator,!=,>,3,0.04236753,modulus <mask> 0,"                 buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus<mask>0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                   "
2313,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22475,22481,IdentifierMutator-Variable,modulus,pos,0,0.91965395,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                  "
2314,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22475,22481,IdentifierMutator-Variable,modulus,offset,1,0.007640459,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                  "
2315,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22475,22481,IdentifierMutator-Variable,modulus,len,2,0.005430172,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                  "
2316,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22475,22481,IdentifierMutator-Variable,modulus,length,3,0.0036845612,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                  "
2317,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22475,22481,IdentifierMutator-Variable,modulus,bytes,4,0.0032971327,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                  "
2318,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22475,22481,FieldReferenceMutator,modulus,pos,0,0.91965395,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                  "
2319,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22475,22481,FieldReferenceMutator,modulus,offset,1,0.007640459,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                  "
2320,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22475,22481,FieldReferenceMutator,modulus,len,2,0.005430172,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                  "
2321,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22475,22481,FieldReferenceMutator,modulus,length,3,0.0036845612,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                  "
2322,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22475,22481,FieldReferenceMutator,modulus,bytes,4,0.0032971327,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                  "
2323,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22486,22486,IdentifierMutator-Literal,0,1,1,0.24176455,<mask>,"                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus !=<mask>) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer"
2324,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22486,22486,IdentifierMutator-Literal,0,2,2,0.114201695,<mask>,"                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus !=<mask>) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer"
2325,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22486,22486,IdentifierMutator-Literal,0,3,3,0.023240414,<mask>,"                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus !=<mask>) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer"
2326,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,561,22486,22486,IdentifierMutator-Literal,0,6,4,0.015746305,<mask>,"                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus !=<mask>) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer"
2327,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22521,22524,BinaryOperatorMutator,||,|,2,0.011472712,(buffer == null) <mask> ((buffer.length - pos) < decodeSize)," = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null<mask>buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
"
2328,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22521,22524,BinaryOperatorMutator,||,.,3,0.0032521083,(buffer == null) <mask> ((buffer.length - pos) < decodeSize)," = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null<mask>buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
"
2329,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22521,22524,BinaryOperatorMutator,||,?,4,0.0019161857,(buffer == null) <mask> ((buffer.length - pos) < decodeSize)," = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null<mask>buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
"
2330,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22513,22516,BinaryOperatorMutator,==,===,2,0.021419361,buffer <mask> null,"++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer<mask>null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS"
2331,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22513,22516,BinaryOperatorMutator,==,=,3,0.006404011,buffer <mask> null,"++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer<mask>null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS"
2332,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22513,22516,BinaryOperatorMutator,==,===,4,0.0014135067,buffer <mask> null,"++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer<mask>null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS"
2333,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22507,22512,IdentifierMutator-Variable,buffer,buf,2,0.002234724,<mask>,"pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BIT"
2334,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22507,22512,IdentifierMutator-Variable,buffer,Buffer,3,0.0018895699,<mask>,"pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BIT"
2335,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22507,22512,IdentifierMutator-Variable,buffer,queue,4,0.0010589018,<mask>,"pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BIT"
2336,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22507,22512,FieldReferenceMutator,buffer,buf,2,0.002234724,<mask>,"pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BIT"
2337,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22507,22512,FieldReferenceMutator,buffer,Buffer,3,0.0018895699,<mask>,"pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BIT"
2338,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22507,22512,FieldReferenceMutator,buffer,queue,4,0.0010589018,<mask>,"pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BIT"
2339,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22517,22520,IdentifierMutator-Literal,null,nil,1,0.0036010672,<mask>,"] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer ==<mask> || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);"
2340,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22517,22520,IdentifierMutator-Literal,null,NULL,2,0.0010813436,<mask>,"] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer ==<mask> || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);"
2341,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22517,22520,IdentifierMutator-Literal,null,undefined,3,6.382672E-4,<mask>,"] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer ==<mask> || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);"
2342,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22544,22546,BinaryOperatorMutator,<,>,1,0.1614741,(buffer.length - pos) <mask> decodeSize," >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos<mask>decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
     "
2343,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22544,22546,BinaryOperatorMutator,<,==,3,0.087021224,(buffer.length - pos) <mask> decodeSize," >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos<mask>decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
     "
2344,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22544,22546,BinaryOperatorMutator,<,!=,4,0.081299424,(buffer.length - pos) <mask> decodeSize," >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos<mask>decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
     "
2345,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22538,22540,BinaryOperatorMutator,-,*,1,0.103416,buffer.length <mask> pos," ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
    "
2346,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22538,22540,BinaryOperatorMutator,-,+,2,0.10051239,buffer.length <mask> pos," ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
    "
2347,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22538,22540,BinaryOperatorMutator,-,_,3,0.022755902,buffer.length <mask> pos," ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
    "
2348,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22538,22540,BinaryOperatorMutator,-,/,4,0.021725228,buffer.length <mask> pos," ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
    "
2349,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22525,22537,IdentifierMutator-Variable,buffer.length,limit,0,0.20327602,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
   "
2350,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22525,22537,IdentifierMutator-Variable,buffer.length,size,1,0.17853779,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
   "
2351,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22525,22537,IdentifierMutator-Variable,buffer.length,end,2,0.16260917,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
   "
2352,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22525,22537,IdentifierMutator-Variable,buffer.length,length,3,0.09631933,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
   "
2353,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22525,22537,IdentifierMutator-Variable,buffer.length,bytes,4,0.029657846,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
   "
2354,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22525,22530,IdentifierMutator-Variable,buffer,stream,1,5.479211E-4,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
 "
2355,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22525,22530,IdentifierMutator-Variable,buffer,buffers,2,4.2780975E-4,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
 "
2356,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22525,22530,IdentifierMutator-Variable,buffer,buf,3,3.6065275E-4,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
 "
2357,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22525,22530,IdentifierMutator-Variable,buffer,input,4,3.3922802E-4,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
 "
2358,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22525,22530,FieldReferenceMutator,buffer,stream,1,5.479211E-4,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
 "
2359,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22525,22530,FieldReferenceMutator,buffer,buffers,2,4.2780975E-4,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
 "
2360,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22525,22530,FieldReferenceMutator,buffer,buf,3,3.6065275E-4,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
 "
2361,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22525,22530,FieldReferenceMutator,buffer,input,4,3.3922802E-4,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
 "
2362,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22532,22537,FieldReferenceMutator,length,position,1,0.00641409,buffer.<mask>,") ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
   "
2363,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22532,22537,FieldReferenceMutator,length,size,2,0.0032312784,buffer.<mask>,") ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
   "
2364,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22532,22537,FieldReferenceMutator,length,len,3,0.0020816394,buffer.<mask>,") ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
   "
2365,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22532,22537,FieldReferenceMutator,length,limit,4,0.0012167064,buffer.<mask>,") ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
   "
2366,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22541,22543,IdentifierMutator-Variable,pos,1,1,0.04106568,<mask>,"x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
     "
2367,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22541,22543,IdentifierMutator-Variable,pos,remaining,2,0.039631095,<mask>,"x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
     "
2368,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22541,22543,IdentifierMutator-Variable,pos,offset,3,0.017047983,<mask>,"x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
     "
2369,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22541,22543,IdentifierMutator-Variable,pos,size,4,0.009821533,<mask>,"x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
     "
2370,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22541,22543,FieldReferenceMutator,pos,1,1,0.04106568,<mask>,"x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
     "
2371,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22541,22543,FieldReferenceMutator,pos,remaining,2,0.039631095,<mask>,"x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
     "
2372,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22541,22543,FieldReferenceMutator,pos,offset,3,0.017047983,<mask>,"x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
     "
2373,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22541,22543,FieldReferenceMutator,pos,size,4,0.009821533,<mask>,"x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
     "
2374,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22547,22556,IdentifierMutator-Variable,decodeSize,8,0,0.34915626,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
        "
2375,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22547,22556,IdentifierMutator-Variable,decodeSize,2,1,0.08162746,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
        "
2376,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22547,22556,IdentifierMutator-Variable,decodeSize,0,2,0.06629889,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
        "
2377,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22547,22556,IdentifierMutator-Variable,decodeSize,4,3,0.062485036,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
        "
2378,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22547,22556,IdentifierMutator-Variable,decodeSize,limit,4,0.0401775,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
        "
2379,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22547,22556,FieldReferenceMutator,decodeSize,8,0,0.34915626,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
        "
2380,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22547,22556,FieldReferenceMutator,decodeSize,2,1,0.08162746,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
        "
2381,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22547,22556,FieldReferenceMutator,decodeSize,0,2,0.06629889,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
        "
2382,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22547,22556,FieldReferenceMutator,decodeSize,4,3,0.062485036,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
        "
2383,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,562,22547,22556,FieldReferenceMutator,decodeSize,limit,4,0.0401775,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
        "
2384,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,563,22577,22588,MethodCallMutator,resizeBuffer,close,0,0.326941,<mask>(),"K_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
      "
2385,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,563,22577,22588,MethodCallMutator,resizeBuffer,flush,1,0.15893705,<mask>(),"K_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
      "
2386,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,563,22577,22588,MethodCallMutator,resizeBuffer,end,2,0.05947177,<mask>(),"K_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
      "
2387,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,563,22577,22588,MethodCallMutator,resizeBuffer,reset,3,0.046280585,<mask>(),"K_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
      "
2388,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,563,22577,22588,MethodCallMutator,resizeBuffer,break,4,0.046210513,<mask>(),"K_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
      "
2389,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,568,22761,22767,IdentifierMutator-Variable,modulus,bits,0,0.11033491,<mask>,"             }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (<mask>) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2390,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,568,22761,22767,IdentifierMutator-Variable,modulus,pos,1,0.0884631,<mask>,"             }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (<mask>) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2391,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,568,22761,22767,IdentifierMutator-Variable,modulus,size,2,0.038512338,<mask>,"             }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (<mask>) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2392,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,568,22761,22767,IdentifierMutator-Variable,modulus,i,3,0.03209423,<mask>,"             }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (<mask>) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2393,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,568,22761,22767,IdentifierMutator-Variable,modulus,type,4,0.026740242,<mask>,"             }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (<mask>) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2394,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,568,22761,22767,FieldReferenceMutator,modulus,bits,0,0.11033491,<mask>,"             }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (<mask>) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2395,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,568,22761,22767,FieldReferenceMutator,modulus,pos,1,0.0884631,<mask>,"             }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (<mask>) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2396,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,568,22761,22767,FieldReferenceMutator,modulus,size,2,0.038512338,<mask>,"             }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (<mask>) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2397,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,568,22761,22767,FieldReferenceMutator,modulus,i,3,0.03209423,<mask>,"             }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (<mask>) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2398,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,568,22761,22767,FieldReferenceMutator,modulus,type,4,0.026740242,<mask>,"             }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (<mask>) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2399,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,571,22872,22872,IdentifierMutator-Literal,2,4,1,0.001186164,<mask>,"     // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case<mask> : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break"
2400,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,571,22872,22872,IdentifierMutator-Literal,2,1,2,8.701365E-4,<mask>,"     // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case<mask> : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break"
2401,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,571,22872,22872,IdentifierMutator-Literal,2,6,3,6.9653883E-4,<mask>,"     // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case<mask> : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break"
2402,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,571,22872,22872,IdentifierMutator-Literal,2,0,4,4.3253947E-4,<mask>,"     // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case<mask> : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break"
2403,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22916,22916,AssignmentMutator,x=x>>4,^,0,0.5347379,x <mask>= x >> 4," This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x<mask>= x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2404,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22916,22916,AssignmentMutator,x=x>>4,|,1,0.3305055,x <mask>= x >> 4," This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x<mask>= x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2405,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22916,22916,AssignmentMutator,x=x>>4,*,2,0.04260601,x <mask>= x >> 4," This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x<mask>= x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2406,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22916,22916,AssignmentMutator,x=x>>4,&,3,0.021985956,x <mask>= x >> 4," This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x<mask>= x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2407,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22916,22916,AssignmentMutator,x=x>>4,<<,4,0.020294646,x <mask>= x >> 4," This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x<mask>= x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2408,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22915,22915,IdentifierMutator-Variable,x,y,2,9.678502E-4,<mask>,") and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4<mask> = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2409,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22915,22915,IdentifierMutator-Variable,x,xx,3,1.8004004E-4,<mask>,") and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4<mask> = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2410,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22915,22915,IdentifierMutator-Variable,x,z,4,9.921859E-5,<mask>,") and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4<mask> = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2411,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22915,22915,FieldReferenceMutator,x,y,2,9.678502E-4,<mask>,") and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4<mask> = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2412,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22915,22915,FieldReferenceMutator,x,xx,3,1.8004004E-4,<mask>,") and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4<mask> = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2413,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22915,22915,FieldReferenceMutator,x,z,4,9.921859E-5,<mask>,") and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4<mask> = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2414,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22920,22923,BinaryOperatorMutator,>>,<<,1,0.31322402,x <mask> 4," makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x<mask>4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2415,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22920,22923,BinaryOperatorMutator,>>,<<,3,0.030971758,x <mask> 4," makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x<mask>4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2416,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22920,22923,BinaryOperatorMutator,>>,>>>,4,0.017238412,x <mask> 4," makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x<mask>4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2417,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22919,22919,IdentifierMutator-Variable,x,y,2,2.0590048E-4,<mask>," approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x =<mask> >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2418,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22919,22919,IdentifierMutator-Variable,x,X,3,1.5844744E-5,<mask>," approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x =<mask> >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2419,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22919,22919,IdentifierMutator-Variable,x,z,4,1.2712889E-5,<mask>," approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x =<mask> >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2420,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22919,22919,FieldReferenceMutator,x,y,2,2.0590048E-4,<mask>," approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x =<mask> >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2421,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22919,22919,FieldReferenceMutator,x,X,3,1.5844744E-5,<mask>," approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x =<mask> >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2422,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22919,22919,FieldReferenceMutator,x,z,4,1.2712889E-5,<mask>," approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x =<mask> >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2423,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22924,22924,IdentifierMutator-Literal,4,2,1,0.14376846,<mask>," the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >><mask>;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2424,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22924,22924,IdentifierMutator-Literal,4,8,2,0.08978834,<mask>," the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >><mask>;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2425,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22924,22924,IdentifierMutator-Literal,4,6,3,0.07184293,<mask>," the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >><mask>;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2426,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,572,22924,22924,IdentifierMutator-Literal,4,3,4,0.04549896,<mask>," the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >><mask>;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2427,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22960,22960,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),|,0,0.70148003,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++]<mask>= (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2428,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22960,22960,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),^,1,0.2477502,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++]<mask>= (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2429,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22960,22960,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),&,2,0.019359896,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++]<mask>= (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2430,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22960,22960,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),*,3,0.0100423265,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++]<mask>= (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2431,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22960,22960,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),<<,4,0.0040954207,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++]<mask>= (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2432,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22954,22958,ArrayAccessMutator,pos++,pos,0,0.9966456,buffer[<mask>]," 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[<mask>] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2433,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22954,22958,ArrayAccessMutator,pos++,++,1,3.2936683E-4,buffer[<mask>]," 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[<mask>] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2434,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22954,22958,ArrayAccessMutator,pos++,0,2,2.7278974E-4,buffer[<mask>]," 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[<mask>] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2435,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22954,22958,ArrayAccessMutator,pos++,i,3,1.964988E-4,buffer[<mask>]," 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[<mask>] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2436,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22954,22958,ArrayAccessMutator,pos++,position,4,1.540307E-4,buffer[<mask>]," 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[<mask>] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2437,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22947,22952,IdentifierMutator-Variable,buffer,buf,2,2.7927847E-4,<mask>,"=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;<mask>[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2438,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22947,22952,IdentifierMutator-Variable,buffer,byte,3,2.3292414E-4,<mask>,"=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;<mask>[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2439,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22947,22952,IdentifierMutator-Variable,buffer,source,4,1.8431459E-4,<mask>,"=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;<mask>[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2440,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22947,22952,FieldReferenceMutator,buffer,buf,2,2.7927847E-4,<mask>,"=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;<mask>[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2441,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22947,22952,FieldReferenceMutator,buffer,byte,3,2.3292414E-4,<mask>,"=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;<mask>[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2442,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22947,22952,FieldReferenceMutator,buffer,source,4,1.8431459E-4,<mask>,"=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;<mask>[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2443,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22957,22958,UnaryOperatorMutator,++,+,2,9.928565E-5,pos<mask>,") {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos<mask>] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2444,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22957,22958,UnaryOperatorMutator,++,++;,3,8.0849175E-5,pos<mask>,") {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos<mask>] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2445,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22957,22958,UnaryOperatorMutator,++,--,4,2.351275E-5,pos<mask>,") {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos<mask>] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2446,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22954,22956,IdentifierMutator-Variable,pos,len,1,1.2218102E-4,<mask>," 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[<mask>++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2447,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22954,22956,IdentifierMutator-Variable,pos,size,2,9.509988E-5,<mask>," 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[<mask>++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2448,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22954,22956,IdentifierMutator-Variable,pos,offset,3,5.1063114E-5,<mask>," 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[<mask>++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2449,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22954,22956,IdentifierMutator-Variable,pos,i,4,5.0669318E-5,<mask>," 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[<mask>++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2450,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22954,22956,FieldReferenceMutator,pos,len,1,1.2218102E-4,<mask>," 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[<mask>++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2451,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22954,22956,FieldReferenceMutator,pos,size,2,9.509988E-5,<mask>," 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[<mask>++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2452,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22954,22956,FieldReferenceMutator,pos,offset,3,5.1063114E-5,<mask>," 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[<mask>++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2453,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22954,22956,FieldReferenceMutator,pos,i,4,5.0669318E-5,<mask>," 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[<mask>++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2454,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22974,22976,BinaryOperatorMutator,&,~,2,0.0059985784,x <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x)<mask>MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2455,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22974,22976,BinaryOperatorMutator,&,|,3,0.004699053,x <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x)<mask>MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2456,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22974,22976,BinaryOperatorMutator,&,~,4,0.0032371078,x <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x)<mask>MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2457,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22971,22973,IdentifierMutator-Variable,x,xx,1,9.0174435E-4,<mask>,"        if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2458,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22971,22973,IdentifierMutator-Variable,x,xxx,3,3.347862E-4,<mask>,"        if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2459,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22971,22973,IdentifierMutator-Variable,x,y,4,3.227391E-4,<mask>,"        if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2460,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22973,22973,FieldReferenceMutator,x,),0,0.9997422,<mask>,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x<mask> & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2461,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22973,22973,FieldReferenceMutator,x,)),1,2.235421E-4,<mask>,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x<mask> & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2462,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22973,22973,FieldReferenceMutator,x,),2,1.0261746E-5,<mask>,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x<mask> & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2463,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22973,22973,FieldReferenceMutator,x,",)",3,4.4614267E-6,<mask>,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x<mask> & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2464,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22973,22973,FieldReferenceMutator,x,()),4,3.1238708E-6,<mask>,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x<mask> & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2465,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22977,22986,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,7,0,0.16564125,<mask>,"     if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2466,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22977,22986,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,3,1,0.12491625,<mask>,"     if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2467,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22977,22986,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,255,2,0.12286495,<mask>,"     if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2468,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22977,22986,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,4,3,0.11464391,<mask>,"     if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2469,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22977,22986,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,63,4,0.09023021,<mask>,"     if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2470,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22977,22986,FieldReferenceMutator,MASK_8BITS,7,0,0.16564125,org.apache.commons.codec.binary.Base64.<mask>,"     if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2471,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22977,22986,FieldReferenceMutator,MASK_8BITS,3,1,0.12491625,org.apache.commons.codec.binary.Base64.<mask>,"     if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2472,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22977,22986,FieldReferenceMutator,MASK_8BITS,255,2,0.12286495,org.apache.commons.codec.binary.Base64.<mask>,"     if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2473,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22977,22986,FieldReferenceMutator,MASK_8BITS,4,3,0.11464391,org.apache.commons.codec.binary.Base64.<mask>,"     if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2474,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,573,22977,22986,FieldReferenceMutator,MASK_8BITS,63,4,0.09023021,org.apache.commons.codec.binary.Base64.<mask>,"     if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2475,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,575,23038,23038,IdentifierMutator-Literal,3,4,1,0.108966365,<mask>,"      }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case<mask> : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2476,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,575,23038,23038,IdentifierMutator-Literal,3,1,2,0.05736114,<mask>,"      }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case<mask> : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2477,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,575,23038,23038,IdentifierMutator-Literal,3,5,3,0.03191295,<mask>,"      }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case<mask> : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2478,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,575,23038,23038,IdentifierMutator-Literal,3,6,4,0.020779187,<mask>,"      }
            
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case<mask> : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2479,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23086,23086,AssignmentMutator,x=x>>2,^,0,0.48145887,x <mask>= x >> 2," We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x<mask>= x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2480,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23086,23086,AssignmentMutator,x=x>>2,|,1,0.41123277,x <mask>= x >> 2," We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x<mask>= x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2481,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23086,23086,AssignmentMutator,x=x>>2,&,2,0.040585667,x <mask>= x >> 2," We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x<mask>= x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2482,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23086,23086,AssignmentMutator,x=x>>2,*,3,0.027753036,x <mask>= x >> 2," We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x<mask>= x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2483,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23086,23086,AssignmentMutator,x=x>>2,<<,4,0.0066189547,x <mask>= x >> 2," We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x<mask>= x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2484,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23085,23085,IdentifierMutator-Variable,x,y,2,0.001577241,<mask>,"        
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2<mask> = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2485,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23085,23085,IdentifierMutator-Variable,x,xx,3,2.1690695E-4,<mask>,"        
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2<mask> = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2486,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23085,23085,IdentifierMutator-Variable,x,b,4,1.8341554E-4,<mask>,"        
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2<mask> = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2487,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23085,23085,FieldReferenceMutator,x,y,2,0.001577241,<mask>,"        
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2<mask> = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2488,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23085,23085,FieldReferenceMutator,x,xx,3,2.1690695E-4,<mask>,"        
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2<mask> = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2489,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23085,23085,FieldReferenceMutator,x,b,4,1.8341554E-4,<mask>,"        
            // We have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2<mask> = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2490,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23090,23093,BinaryOperatorMutator,>>,<<,1,0.20504944,x <mask> 2," some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x<mask>2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2491,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23090,23093,BinaryOperatorMutator,>>,<<,3,0.06260171,x <mask> 2," some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x<mask>2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2492,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23090,23093,BinaryOperatorMutator,>>,>>>,4,0.012150127,x <mask> 2," some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x<mask>2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2493,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23089,23089,IdentifierMutator-Variable,x,y,2,1.0475132E-4,<mask>," have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x =<mask> >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2494,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23089,23089,IdentifierMutator-Variable,x,X,3,9.825308E-6,<mask>," have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x =<mask> >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2495,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23089,23089,IdentifierMutator-Variable,x,z,4,6.292498E-6,<mask>," have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x =<mask> >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2496,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23089,23089,FieldReferenceMutator,x,y,2,1.0475132E-4,<mask>," have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x =<mask> >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2497,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23089,23089,FieldReferenceMutator,x,X,3,9.825308E-6,<mask>," have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x =<mask> >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2498,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23089,23089,FieldReferenceMutator,x,z,4,6.292498E-6,<mask>," have some spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x =<mask> >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2499,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23094,23094,IdentifierMutator-Literal,2,8,1,0.27726018,<mask>," spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >><mask>;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2500,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23094,23094,IdentifierMutator-Literal,2,6,2,0.11260592,<mask>," spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >><mask>;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2501,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23094,23094,IdentifierMutator-Literal,2,4,3,0.067378975,<mask>," spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >><mask>;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2502,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,576,23094,23094,IdentifierMutator-Literal,2,7,4,0.043982368,<mask>," spare bits remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >><mask>;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2503,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23130,23130,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),|,0,0.78296673,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS))," rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2504,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23130,23130,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),^,1,0.16401203,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS))," rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2505,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23130,23130,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),*,2,0.013193166,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS))," rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2506,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23130,23130,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),&,3,0.010346689,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS))," rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2507,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23130,23130,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),<<,4,0.009136426,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS))," rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2508,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23124,23128,ArrayAccessMutator,pos++,pos,0,0.9920368,buffer[<mask>]," and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2509,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23124,23128,ArrayAccessMutator,pos++,++,1,0.0020448556,buffer[<mask>]," and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2510,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23124,23128,ArrayAccessMutator,pos++,push,2,6.953928E-4,buffer[<mask>]," and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2511,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23124,23128,ArrayAccessMutator,pos++,neg,3,2.919258E-4,buffer[<mask>]," and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2512,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23124,23128,ArrayAccessMutator,pos++,position,4,2.6428842E-4,buffer[<mask>]," and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2513,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23117,23122,IdentifierMutator-Variable,buffer,Buffer,2,4.124368E-4,<mask>," remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2514,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23117,23122,IdentifierMutator-Variable,buffer,byte,3,3.9372E-4,<mask>," remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2515,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23117,23122,IdentifierMutator-Variable,buffer,buf,4,1.6977653E-4,<mask>," remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2516,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23117,23122,FieldReferenceMutator,buffer,Buffer,2,4.124368E-4,<mask>," remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2517,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23117,23122,FieldReferenceMutator,buffer,byte,3,3.9372E-4,<mask>," remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2518,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23117,23122,FieldReferenceMutator,buffer,buf,4,1.6977653E-4,<mask>," remaining
            // Output all whole multiples of 8 bits and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2519,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23127,23128,UnaryOperatorMutator,++,+,1,1.5513028E-4,pos<mask>," ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2520,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23127,23128,UnaryOperatorMutator,++,--,3,9.329977E-5,pos<mask>," ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2521,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23127,23128,UnaryOperatorMutator,++,++;,4,6.0204282E-5,pos<mask>," ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2522,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23124,23126,IdentifierMutator-Variable,pos,len,1,5.9416972E-5,<mask>," and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2523,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23124,23126,IdentifierMutator-Variable,pos,size,2,2.9237006E-5,<mask>," and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2524,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23124,23126,IdentifierMutator-Variable,pos,neg,3,2.8162254E-5,<mask>," and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2525,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23124,23126,IdentifierMutator-Variable,pos,offset,4,2.3469798E-5,<mask>," and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2526,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23124,23126,FieldReferenceMutator,pos,len,1,5.9416972E-5,<mask>," and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2527,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23124,23126,FieldReferenceMutator,pos,size,2,2.9237006E-5,<mask>," and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2528,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23124,23126,FieldReferenceMutator,pos,neg,3,2.8162254E-5,<mask>," and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2529,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23124,23126,FieldReferenceMutator,pos,offset,4,2.3469798E-5,<mask>," and ignore the rest
            switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2530,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23149,23151,BinaryOperatorMutator,&,|,2,0.053922426,(x >> 8) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"     switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8)<mask>MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2531,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23149,23151,BinaryOperatorMutator,&,^,3,0.012030319,(x >> 8) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"     switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8)<mask>MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2532,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23149,23151,BinaryOperatorMutator,&,|,4,0.0017687075,(x >> 8) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"     switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8)<mask>MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2533,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23143,23146,BinaryOperatorMutator,>>,<<,2,0.0500962,x <mask> 8,"        switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x<mask>8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2534,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23143,23146,BinaryOperatorMutator,>>,>>>,3,0.028643267,x <mask> 8,"        switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x<mask>8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2535,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23143,23146,BinaryOperatorMutator,>>,<<,4,0.003957589,x <mask> 8,"        switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x<mask>8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2536,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23142,23142,IdentifierMutator-Variable,x,y,2,4.7619138E-5,<mask>,"         switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2537,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23142,23142,IdentifierMutator-Variable,x,X,3,4.0213377E-5,<mask>,"         switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2538,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23142,23142,IdentifierMutator-Variable,x,xx,4,3.3377764E-5,<mask>,"         switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2539,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23142,23142,FieldReferenceMutator,x,y,2,4.7619138E-5,<mask>,"         switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2540,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23142,23142,FieldReferenceMutator,x,X,3,4.0213377E-5,<mask>,"         switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2541,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23142,23142,FieldReferenceMutator,x,xx,4,3.3377764E-5,<mask>,"         switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2542,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23147,23147,IdentifierMutator-Literal,8,2,0,0.8530865,<mask>,"       switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2543,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23147,23147,IdentifierMutator-Literal,8,1,1,0.0848327,<mask>,"       switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2544,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23147,23147,IdentifierMutator-Literal,8,4,2,0.020016802,<mask>,"       switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2545,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23147,23147,IdentifierMutator-Literal,8,3,3,0.01662128,<mask>,"       switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2546,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23152,23161,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,7,0,0.1268528,<mask>,"    switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2547,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23152,23161,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,255,1,0.1266833,<mask>,"    switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2548,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23152,23161,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,1,2,0.10635013,<mask>,"    switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2549,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23152,23161,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,3,3,0.07988437,<mask>,"    switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2550,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23152,23161,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,63,4,0.06395468,<mask>,"    switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2551,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23152,23161,FieldReferenceMutator,MASK_8BITS,7,0,0.1268528,org.apache.commons.codec.binary.Base64.<mask>,"    switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2552,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23152,23161,FieldReferenceMutator,MASK_8BITS,255,1,0.1266833,org.apache.commons.codec.binary.Base64.<mask>,"    switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2553,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23152,23161,FieldReferenceMutator,MASK_8BITS,1,2,0.10635013,org.apache.commons.codec.binary.Base64.<mask>,"    switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2554,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23152,23161,FieldReferenceMutator,MASK_8BITS,3,3,0.07988437,org.apache.commons.codec.binary.Base64.<mask>,"    switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2555,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,577,23152,23161,FieldReferenceMutator,MASK_8BITS,63,4,0.06395468,org.apache.commons.codec.binary.Base64.<mask>,"    switch (modulus) {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2556,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23198,23198,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),|,0,0.694204,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++]<mask>= (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2557,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23198,23198,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),^,1,0.2565003,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++]<mask>= (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2558,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23198,23198,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),&,2,0.024548352,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++]<mask>= (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2559,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23198,23198,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),*,3,0.010006733,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++]<mask>= (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2560,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23198,23198,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),>>>,4,0.003981876,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++]<mask>= (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2561,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23192,23196,ArrayAccessMutator,pos++,pos,0,0.9824059,buffer[<mask>]," - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[<mask>] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2562,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23192,23196,ArrayAccessMutator,pos++,++,1,0.0024141404,buffer[<mask>]," - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[<mask>] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2563,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23192,23196,ArrayAccessMutator,pos++,neg,2,0.0020082796,buffer[<mask>]," - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[<mask>] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2564,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23192,23196,ArrayAccessMutator,pos++,len,3,0.0012604462,buffer[<mask>]," - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[<mask>] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2565,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23192,23196,ArrayAccessMutator,pos++,size,4,0.0011095386,buffer[<mask>]," - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[<mask>] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2566,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23185,23190,IdentifierMutator-Variable,buffer,mask,2,0.0065159504,<mask>,") {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2567,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23185,23190,IdentifierMutator-Variable,buffer,buf,3,0.0022345283,<mask>,") {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2568,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23185,23190,IdentifierMutator-Variable,buffer,byte,4,0.0020120451,<mask>,") {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2569,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23185,23190,FieldReferenceMutator,buffer,mask,2,0.0065159504,<mask>,") {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2570,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23185,23190,FieldReferenceMutator,buffer,buf,3,0.0022345283,<mask>,") {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2571,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23185,23190,FieldReferenceMutator,buffer,byte,4,0.0020120451,<mask>,") {
           //   case 1: // 6 bits - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2572,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23195,23196,UnaryOperatorMutator,++,--,2,4.270864E-4,pos<mask>," ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos<mask>] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2573,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23195,23196,UnaryOperatorMutator,++,++;,3,1.8653789E-4,pos<mask>," ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos<mask>] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2574,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23195,23196,UnaryOperatorMutator,++,+,4,4.692463E-5,pos<mask>," ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos<mask>] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2575,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23192,23194,IdentifierMutator-Variable,pos,neg,1,6.632629E-4,<mask>," - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2576,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23192,23194,IdentifierMutator-Variable,pos,len,2,5.407966E-4,<mask>," - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2577,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23192,23194,IdentifierMutator-Variable,pos,size,3,3.33808E-4,<mask>," - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2578,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23192,23194,IdentifierMutator-Variable,pos,offset,4,1.0576631E-4,<mask>," - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2579,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23192,23194,FieldReferenceMutator,pos,neg,1,6.632629E-4,<mask>," - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2580,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23192,23194,FieldReferenceMutator,pos,len,2,5.407966E-4,<mask>," - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2581,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23192,23194,FieldReferenceMutator,pos,size,3,3.33808E-4,<mask>," - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2582,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23192,23194,FieldReferenceMutator,pos,offset,4,1.0576631E-4,<mask>," - ignore entirely
           //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x) & MASK_8BITS);
                    break;
            }
        }
   "
2583,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23212,23214,BinaryOperatorMutator,&,|,1,0.009782006,x <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"     //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x)<mask>MASK_8BITS);
                    break;
            }
        }
   "
2584,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23212,23214,BinaryOperatorMutator,&,^,3,0.004759764,x <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"     //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x)<mask>MASK_8BITS);
                    break;
            }
        }
   "
2585,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23212,23214,BinaryOperatorMutator,&,~,4,0.004011871,x <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"     //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x)<mask>MASK_8BITS);
                    break;
            }
        }
   "
2586,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23209,23211,IdentifierMutator-Variable,x,y,1,5.363567E-4,<mask>,"       //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                    break;
            }
        }
   "
2587,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23209,23211,IdentifierMutator-Variable,x,xx,2,3.394594E-4,<mask>,"       //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                    break;
            }
        }
   "
2588,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23209,23211,IdentifierMutator-Variable,x,rx,3,1.1863916E-4,<mask>,"       //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                    break;
            }
        }
   "
2589,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23209,23211,IdentifierMutator-Variable,x,X,4,1.0831288E-4,<mask>,"       //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                    break;
            }
        }
   "
2590,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23211,23211,FieldReferenceMutator,x,),0,0.99926907,<mask>,"      //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x<mask> & MASK_8BITS);
                    break;
            }
        }
   "
2591,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23211,23211,FieldReferenceMutator,x,)),1,5.400359E-4,<mask>,"      //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x<mask> & MASK_8BITS);
                    break;
            }
        }
   "
2592,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23211,23211,FieldReferenceMutator,x,),2,6.637574E-5,<mask>,"      //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x<mask> & MASK_8BITS);
                    break;
            }
        }
   "
2593,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23211,23211,FieldReferenceMutator,x,(),3,2.699008E-5,<mask>,"      //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x<mask> & MASK_8BITS);
                    break;
            }
        }
   "
2594,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23211,23211,FieldReferenceMutator,x,($),4,1.8500523E-5,<mask>,"      //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x<mask> & MASK_8BITS);
                    break;
            }
        }
   "
2595,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23215,23224,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,mask,0,0.17040844,<mask>,"    //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
            }
        }
   "
2596,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23215,23224,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,255,1,0.1461244,<mask>,"    //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
            }
        }
   "
2597,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23215,23224,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,7,2,0.09925258,<mask>,"    //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
            }
        }
   "
2598,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23215,23224,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,1,3,0.07855802,<mask>,"    //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
            }
        }
   "
2599,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23215,23224,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,127,4,0.06016306,<mask>,"    //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
            }
        }
   "
2600,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23215,23224,FieldReferenceMutator,MASK_8BITS,mask,0,0.17040844,org.apache.commons.codec.binary.Base64.<mask>,"    //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
            }
        }
   "
2601,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23215,23224,FieldReferenceMutator,MASK_8BITS,255,1,0.1461244,org.apache.commons.codec.binary.Base64.<mask>,"    //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
            }
        }
   "
2602,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23215,23224,FieldReferenceMutator,MASK_8BITS,7,2,0.09925258,org.apache.commons.codec.binary.Base64.<mask>,"    //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
            }
        }
   "
2603,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23215,23224,FieldReferenceMutator,MASK_8BITS,1,3,0.07855802,org.apache.commons.codec.binary.Base64.<mask>,"    //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
            }
        }
   "
2604,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",526,578,23215,23224,FieldReferenceMutator,MASK_8BITS,127,4,0.06016306,org.apache.commons.codec.binary.Base64.<mask>,"    //       break;
                case 2 : // 12 bits = 8 + 4
                    x = x >> 4;
                    buffer[pos++] = (byte) ((x) & MASK_8BITS);
                    break;
                case 3 : // 18 bits = 8 + 8 + 2
                    x = x >> 2;
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x) &<mask>);
                    break;
            }
        }
   "
2605,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23657,23660,BinaryOperatorMutator,||,OR,1,0.023899864,(octet == org.apache.commons.codec.binary.Base64.PAD) <mask> (((octet >= 0) && (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)) && (org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] != (-1))),"boolean isBase64(byte octet) {
        return octet == PAD<mask>(octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2606,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23657,23660,BinaryOperatorMutator,||,^,3,0.002628525,(octet == org.apache.commons.codec.binary.Base64.PAD) <mask> (((octet >= 0) && (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)) && (org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] != (-1))),"boolean isBase64(byte octet) {
        return octet == PAD<mask>(octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2607,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23657,23660,BinaryOperatorMutator,||,OR,4,0.0026178379,(octet == org.apache.commons.codec.binary.Base64.PAD) <mask> (((octet >= 0) && (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)) && (org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] != (-1))),"boolean isBase64(byte octet) {
        return octet == PAD<mask>(octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2608,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23650,23653,BinaryOperatorMutator,==,<,1,0.07549561,octet <mask> org.apache.commons.codec.binary.Base64.PAD,"boolean isBase64(byte octet) {
        return octet<mask>PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2609,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23650,23653,BinaryOperatorMutator,==,<,3,0.056596793,octet <mask> org.apache.commons.codec.binary.Base64.PAD,"boolean isBase64(byte octet) {
        return octet<mask>PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2610,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23650,23653,BinaryOperatorMutator,==,>=,4,0.042312745,octet <mask> org.apache.commons.codec.binary.Base64.PAD,"boolean isBase64(byte octet) {
        return octet<mask>PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2611,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23645,23649,IdentifierMutator-Variable,octet,mode,0,0.118902214,<mask>,"boolean isBase64(byte octet) {
        return<mask> == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2612,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23645,23649,IdentifierMutator-Variable,octet,padding,1,0.082646616,<mask>,"boolean isBase64(byte octet) {
        return<mask> == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2613,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23645,23649,IdentifierMutator-Variable,octet,type,2,0.07587567,<mask>,"boolean isBase64(byte octet) {
        return<mask> == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2614,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23645,23649,IdentifierMutator-Variable,octet,pad,3,0.0528352,<mask>,"boolean isBase64(byte octet) {
        return<mask> == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2615,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23645,23649,IdentifierMutator-Variable,octet,modifier,4,0.0295703,<mask>,"boolean isBase64(byte octet) {
        return<mask> == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2616,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23654,23656,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,0,0,0.6760146,<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2617,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23654,23656,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,127,1,0.12894018,<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2618,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23654,23656,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,1,2,0.050043073,<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2619,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23654,23656,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,128,3,0.015066694,<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2620,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23654,23656,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,8,4,0.012161313,<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2621,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23654,23656,FieldReferenceMutator,PAD,0,0,0.6760146,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2622,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23654,23656,FieldReferenceMutator,PAD,127,1,0.12894018,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2623,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23654,23656,FieldReferenceMutator,PAD,1,2,0.050043073,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2624,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23654,23656,FieldReferenceMutator,PAD,128,3,0.015066694,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2625,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23654,23656,FieldReferenceMutator,PAD,8,4,0.012161313,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2626,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23703,23706,BinaryOperatorMutator,&&,),2,0.015546207,((octet >= 0) && (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)) <mask> (org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] != (-1)),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length<mask>DECODE_TABLE[octet] != -1);
    }"
2627,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23703,23706,BinaryOperatorMutator,&&,&,3,0.009839209,((octet >= 0) && (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)) <mask> (org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] != (-1)),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length<mask>DECODE_TABLE[octet] != -1);
    }"
2628,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23703,23706,BinaryOperatorMutator,&&,)(,4,0.0053272173,((octet >= 0) && (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)) <mask> (org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] != (-1)),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length<mask>DECODE_TABLE[octet] != -1);
    }"
2629,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23672,23675,BinaryOperatorMutator,&&,&,1,0.007764951,(octet >= 0) <mask> (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0<mask>octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2630,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23672,23675,BinaryOperatorMutator,&&,;,2,0.0037008193,(octet >= 0) <mask> (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0<mask>octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2631,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23672,23675,BinaryOperatorMutator,&&,x,4,6.8869506E-4,(octet >= 0) <mask> (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0<mask>octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2632,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23667,23670,BinaryOperatorMutator,>=,>,1,0.26759663,octet <mask> 0,"boolean isBase64(byte octet) {
        return octet == PAD || (octet<mask>0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2633,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23667,23670,BinaryOperatorMutator,>=,>,2,0.11323387,octet <mask> 0,"boolean isBase64(byte octet) {
        return octet == PAD || (octet<mask>0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2634,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23667,23670,BinaryOperatorMutator,>=,!=,3,0.037270978,octet <mask> 0,"boolean isBase64(byte octet) {
        return octet == PAD || (octet<mask>0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2635,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23667,23670,BinaryOperatorMutator,>=,==,4,0.003949202,octet <mask> 0,"boolean isBase64(byte octet) {
        return octet == PAD || (octet<mask>0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2636,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23662,23666,IdentifierMutator-Variable,octet,offset,0,0.34123796,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (<mask> >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2637,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23662,23666,IdentifierMutator-Variable,octet,oct,1,0.031099137,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (<mask> >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2638,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23662,23666,IdentifierMutator-Variable,octet,byte,2,0.03070193,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (<mask> >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2639,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23662,23666,IdentifierMutator-Variable,octet,length,3,0.026934959,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (<mask> >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2640,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23662,23666,IdentifierMutator-Variable,octet,token,4,0.026479842,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (<mask> >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2641,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23671,23671,IdentifierMutator-Literal,0,65,1,0.05318131,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >=<mask> && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2642,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23671,23671,IdentifierMutator-Literal,0,91,2,0.032727174,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >=<mask> && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2643,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23671,23671,IdentifierMutator-Literal,0,128,3,0.024104824,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >=<mask> && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2644,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23671,23671,IdentifierMutator-Literal,0,32,4,0.023525674,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >=<mask> && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2645,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23681,23683,BinaryOperatorMutator,<,<=,2,0.015910402,octet <mask> org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet<mask>DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2646,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23681,23683,BinaryOperatorMutator,<,!=,3,0.0011444645,octet <mask> org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet<mask>DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2647,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23681,23683,BinaryOperatorMutator,<,</,4,2.0202502E-4,octet <mask> org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet<mask>DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2648,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23676,23680,IdentifierMutator-Variable,octet,offset,0,0.20411907,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 &&<mask> < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2649,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23676,23680,IdentifierMutator-Variable,octet,0,1,0.085765444,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 &&<mask> < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2650,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23676,23680,IdentifierMutator-Variable,octet,oct,2,0.071607515,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 &&<mask> < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2651,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23676,23680,IdentifierMutator-Variable,octet,it,3,0.058209114,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 &&<mask> < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2652,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23676,23680,IdentifierMutator-Variable,octet,index,4,0.035735756,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 &&<mask> < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2653,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23684,23702,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,127,0,0.27685216,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask> && DECODE_TABLE[octet] != -1);
    }"
2654,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23684,23702,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,256,1,0.13589524,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask> && DECODE_TABLE[octet] != -1);
    }"
2655,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23684,23702,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,255,2,0.13157357,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask> && DECODE_TABLE[octet] != -1);
    }"
2656,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23684,23702,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,128,3,0.04964197,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask> && DECODE_TABLE[octet] != -1);
    }"
2657,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23684,23702,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,9,4,0.04771063,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask> && DECODE_TABLE[octet] != -1);
    }"
2658,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23684,23695,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,bytes,0,0.159239,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2659,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23684,23695,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,decode,1,0.077534094,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2660,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23684,23695,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,alphabet,2,0.07610612,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2661,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23684,23695,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,code,3,0.038576912,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2662,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23684,23695,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,encoded,4,0.036381837,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2663,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23684,23695,FieldReferenceMutator,DECODE_TABLE,bytes,0,0.159239,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2664,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23684,23695,FieldReferenceMutator,DECODE_TABLE,decode,1,0.077534094,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2665,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23684,23695,FieldReferenceMutator,DECODE_TABLE,alphabet,2,0.07610612,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2666,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23684,23695,FieldReferenceMutator,DECODE_TABLE,code,3,0.038576912,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2667,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23684,23695,FieldReferenceMutator,DECODE_TABLE,encoded,4,0.036381837,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2668,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23697,23702,FieldReferenceMutator,length,SIZE,2,0.0028505826,org.apache.commons.codec.binary.Base64.DECODE_TABLE.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.<mask> && DECODE_TABLE[octet] != -1);
    }"
2669,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23697,23702,FieldReferenceMutator,length,Length,3,0.0016526881,org.apache.commons.codec.binary.Base64.DECODE_TABLE.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.<mask> && DECODE_TABLE[octet] != -1);
    }"
2670,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23697,23702,FieldReferenceMutator,length,size,4,8.5723493E-4,org.apache.commons.codec.binary.Base64.DECODE_TABLE.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.<mask> && DECODE_TABLE[octet] != -1);
    }"
2671,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23726,23729,BinaryOperatorMutator,!=,==,1,0.23318279,org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] <mask> (-1),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet]<mask>-1);
    }"
2672,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23726,23729,BinaryOperatorMutator,!=,==,2,0.119848505,org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] <mask> (-1),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet]<mask>-1);
    }"
2673,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23726,23729,BinaryOperatorMutator,!=,>,3,0.058224294,org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] <mask> (-1),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet]<mask>-1);
    }"
2674,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23726,23729,BinaryOperatorMutator,!=,>,4,0.043894295,org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] <mask> (-1),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet]<mask>-1);
    }"
2675,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23720,23724,ArrayAccessMutator,octet,oct,0,0.5286201,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2676,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23720,23724,ArrayAccessMutator,octet,offset,1,0.07834759,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2677,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23720,23724,ArrayAccessMutator,octet,letter,2,0.02860076,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2678,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23720,23724,ArrayAccessMutator,octet,0,3,0.027785495,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2679,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23720,23724,ArrayAccessMutator,octet,et,4,0.026095012,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2680,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23707,23718,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,table,0,0.19627516,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2681,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23707,23718,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,bytes,1,0.09361875,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2682,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23707,23718,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,decode,2,0.07034788,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2683,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23707,23718,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,codes,3,0.045413338,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2684,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23707,23718,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,alphabet,4,0.038723953,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2685,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23707,23718,FieldReferenceMutator,DECODE_TABLE,table,0,0.19627516,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2686,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23707,23718,FieldReferenceMutator,DECODE_TABLE,bytes,1,0.09361875,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2687,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23707,23718,FieldReferenceMutator,DECODE_TABLE,decode,2,0.07034788,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2688,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23707,23718,FieldReferenceMutator,DECODE_TABLE,codes,3,0.045413338,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2689,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23707,23718,FieldReferenceMutator,DECODE_TABLE,alphabet,4,0.038723953,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2690,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23720,23724,IdentifierMutator-Variable,octet,oct,0,0.5286201,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2691,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23720,23724,IdentifierMutator-Variable,octet,offset,1,0.07834759,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2692,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23720,23724,IdentifierMutator-Variable,octet,letter,2,0.02860076,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2693,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23720,23724,IdentifierMutator-Variable,octet,0,3,0.027785495,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2694,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23720,23724,IdentifierMutator-Variable,octet,et,4,0.026095012,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2695,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23730,23730,UnaryOperatorMutator,-,$,1,0.22919798,<mask>1,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] !=<mask>1);
    }"
2696,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23730,23730,UnaryOperatorMutator,-,B,2,0.03972629,<mask>1,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] !=<mask>1);
    }"
2697,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23730,23730,UnaryOperatorMutator,-,SHA,3,0.03684826,<mask>1,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] !=<mask>1);
    }"
2698,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23730,23730,UnaryOperatorMutator,-,D,4,0.025036473,<mask>1,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] !=<mask>1);
    }"
2699,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23731,23731,IdentifierMutator-Literal,1,127,2,0.012477205,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -<mask>);
    }"
2700,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23731,23731,IdentifierMutator-Literal,1,2,3,0.0048761726,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -<mask>);
    }"
2701,Base64.java,isBase64,boolean isBase64(byte octet),592,593,23731,23731,IdentifierMutator-Literal,1,xff,4,0.004373362,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -<mask>);
    }"
2702,Base64.java,isBase64,boolean isBase64(String base64),606,607,24243,24250,MethodCallMutator,isBase64,is,0,0.57443154,<mask>(StringUtils.getBytesUtf8(base64)),"boolean isBase64(String base64) {
        return<mask>(StringUtils.getBytesUtf8(base64));
    }"
2703,Base64.java,isBase64,boolean isBase64(String base64),606,607,24243,24250,MethodCallMutator,isBase64,check,1,0.06551033,<mask>(StringUtils.getBytesUtf8(base64)),"boolean isBase64(String base64) {
        return<mask>(StringUtils.getBytesUtf8(base64));
    }"
2704,Base64.java,isBase64,boolean isBase64(String base64),606,607,24243,24250,MethodCallMutator,isBase64,encode,2,0.052277077,<mask>(StringUtils.getBytesUtf8(base64)),"boolean isBase64(String base64) {
        return<mask>(StringUtils.getBytesUtf8(base64));
    }"
2705,Base64.java,isBase64,boolean isBase64(String base64),606,607,24243,24250,MethodCallMutator,isBase64,decode,3,0.031205056,<mask>(StringUtils.getBytesUtf8(base64)),"boolean isBase64(String base64) {
        return<mask>(StringUtils.getBytesUtf8(base64));
    }"
2706,Base64.java,isBase64,boolean isBase64(String base64),606,607,24243,24250,MethodCallMutator,isBase64,contains,4,0.03103352,<mask>(StringUtils.getBytesUtf8(base64)),"boolean isBase64(String base64) {
        return<mask>(StringUtils.getBytesUtf8(base64));
    }"
2707,Base64.java,isBase64,boolean isBase64(String base64),606,607,24264,24275,MethodCallMutator,getBytesUtf8,escape,0,0.46502343,StringUtils.<mask>(base64),"boolean isBase64(String base64) {
        return isBase64(StringUtils.<mask>(base64));
    }"
2708,Base64.java,isBase64,boolean isBase64(String base64),606,607,24264,24275,MethodCallMutator,getBytesUtf8,copy,1,0.07099391,StringUtils.<mask>(base64),"boolean isBase64(String base64) {
        return isBase64(StringUtils.<mask>(base64));
    }"
2709,Base64.java,isBase64,boolean isBase64(String base64),606,607,24264,24275,MethodCallMutator,getBytesUtf8,bytes,2,0.06738731,StringUtils.<mask>(base64),"boolean isBase64(String base64) {
        return isBase64(StringUtils.<mask>(base64));
    }"
2710,Base64.java,isBase64,boolean isBase64(String base64),606,607,24264,24275,MethodCallMutator,getBytesUtf8,quote,3,0.048047878,StringUtils.<mask>(base64),"boolean isBase64(String base64) {
        return isBase64(StringUtils.<mask>(base64));
    }"
2711,Base64.java,isBase64,boolean isBase64(String base64),606,607,24264,24275,MethodCallMutator,getBytesUtf8,split,4,0.02463439,StringUtils.<mask>(base64),"boolean isBase64(String base64) {
        return isBase64(StringUtils.<mask>(base64));
    }"
2712,Base64.java,isBase64,boolean isBase64(String base64),606,607,24277,24282,IdentifierMutator-Variable,base64,base,0,0.24754769,<mask>,"boolean isBase64(String base64) {
        return isBase64(StringUtils.getBytesUtf8(<mask>));
    }"
2713,Base64.java,isBase64,boolean isBase64(String base64),606,607,24277,24282,IdentifierMutator-Variable,base64,string,1,0.1820195,<mask>,"boolean isBase64(String base64) {
        return isBase64(StringUtils.getBytesUtf8(<mask>));
    }"
2714,Base64.java,isBase64,boolean isBase64(String base64),606,607,24277,24282,IdentifierMutator-Variable,base64,bytes,2,0.08156486,<mask>,"boolean isBase64(String base64) {
        return isBase64(StringUtils.getBytesUtf8(<mask>));
    }"
2715,Base64.java,isBase64,boolean isBase64(String base64),606,607,24277,24282,IdentifierMutator-Variable,base64,input,3,0.06280392,<mask>,"boolean isBase64(String base64) {
        return isBase64(StringUtils.getBytesUtf8(<mask>));
    }"
2716,Base64.java,isBase64,boolean isBase64(String base64),606,607,24277,24282,IdentifierMutator-Variable,base64,raw,4,0.032259695,<mask>,"boolean isBase64(String base64) {
        return isBase64(StringUtils.getBytesUtf8(<mask>));
    }"
2717,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),620,621,24839,24846,MethodCallMutator,isBase64,is,0,0.39329723,<mask>(arrayOctet),"boolean isArrayByteBase64(byte[] arrayOctet) {
        return<mask>(arrayOctet);
    }"
2718,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),620,621,24839,24846,MethodCallMutator,isBase64,contains,1,0.15340832,<mask>(arrayOctet),"boolean isArrayByteBase64(byte[] arrayOctet) {
        return<mask>(arrayOctet);
    }"
2719,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),620,621,24839,24846,MethodCallMutator,isBase64,equals,2,0.11976107,<mask>(arrayOctet),"boolean isArrayByteBase64(byte[] arrayOctet) {
        return<mask>(arrayOctet);
    }"
2720,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),620,621,24839,24846,MethodCallMutator,isBase64,check,3,0.036356516,<mask>(arrayOctet),"boolean isArrayByteBase64(byte[] arrayOctet) {
        return<mask>(arrayOctet);
    }"
2721,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),620,621,24839,24846,MethodCallMutator,isBase64,array,4,0.024637144,<mask>(arrayOctet),"boolean isArrayByteBase64(byte[] arrayOctet) {
        return<mask>(arrayOctet);
    }"
2722,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),620,621,24848,24857,IdentifierMutator-Variable,arrayOctet,array,0,0.86841244,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        return isBase64(<mask>);
    }"
2723,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),620,621,24848,24857,IdentifierMutator-Variable,arrayOctet,Array,1,0.028000018,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        return isBase64(<mask>);
    }"
2724,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),620,621,24848,24857,IdentifierMutator-Variable,arrayOctet,data,2,0.011366193,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        return isBase64(<mask>);
    }"
2725,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),620,621,24848,24857,IdentifierMutator-Variable,arrayOctet,byte,3,0.0071414514,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        return isBase64(<mask>);
    }"
2726,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),620,621,24848,24857,IdentifierMutator-Variable,arrayOctet,buffer,4,0.0064990236,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        return isBase64(<mask>);
    }"
2727,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25383,25383,IdentifierMutator-Literal,0,1,2,0.004251584,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i =<mask>; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2728,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25383,25383,IdentifierMutator-Literal,0,2,3,2.7803585E-4,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i =<mask>; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2729,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25383,25383,IdentifierMutator-Literal,0,1,4,1.8122735E-4,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i =<mask>; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2730,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25387,25389,BinaryOperatorMutator,<,++,2,0.0031474172,i <mask> arrayOctet.length,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i<mask>arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2731,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25387,25389,BinaryOperatorMutator,<,==,3,0.002968988,i <mask> arrayOctet.length,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i<mask>arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2732,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25387,25389,BinaryOperatorMutator,<,+=,4,0.0010031546,i <mask> arrayOctet.length,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i<mask>arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2733,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25386,25386,IdentifierMutator-Variable,i,I,2,4.598509E-5,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0;<mask> < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2734,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25386,25386,IdentifierMutator-Variable,i,0,3,2.064041E-5,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0;<mask> < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2735,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25386,25386,IdentifierMutator-Variable,i,I,4,1.650222E-5,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0;<mask> < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2736,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25390,25406,IdentifierMutator-Variable,arrayOctet.length,256,0,0.12553363,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2737,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25390,25406,IdentifierMutator-Variable,arrayOctet.length,8,1,0.09303989,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2738,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25390,25406,IdentifierMutator-Variable,arrayOctet.length,length,2,0.08983556,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2739,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25390,25406,IdentifierMutator-Variable,arrayOctet.length,4,3,0.08472841,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2740,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25390,25406,IdentifierMutator-Variable,arrayOctet.length,16,4,0.049165487,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2741,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25390,25399,IdentifierMutator-Variable,arrayOctet,array,0,0.5447916,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2742,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25390,25399,IdentifierMutator-Variable,arrayOctet,string,1,0.08986023,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2743,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25390,25399,IdentifierMutator-Variable,arrayOctet,Array,2,0.041963287,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2744,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25390,25399,IdentifierMutator-Variable,arrayOctet,array,3,0.037026186,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2745,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25390,25399,IdentifierMutator-Variable,arrayOctet,byte,4,0.036285803,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2746,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25401,25406,FieldReferenceMutator,length,size,1,1.8393791E-4,arrayOctet.<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2747,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25401,25406,FieldReferenceMutator,length,Length,3,1.2189782E-4,arrayOctet.<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2748,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25401,25406,FieldReferenceMutator,length,count,4,3.3807024E-5,arrayOctet.<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2749,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25410,25411,UnaryOperatorMutator,++,++),2,0.007302918,i<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i<mask>) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2750,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25410,25411,UnaryOperatorMutator,++,++;,3,3.792617E-4,i<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i<mask>) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2751,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25410,25411,UnaryOperatorMutator,++,*/,4,3.2167515E-4,i<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i<mask>) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2752,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25409,25409,IdentifierMutator-Variable,i,,2,4.0753308E-5,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length;<mask>++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2753,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25409,25409,IdentifierMutator-Variable,i,I,3,3.8101563E-5,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length;<mask>++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2754,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,635,25409,25409,IdentifierMutator-Variable,i,I,4,2.2535884E-5,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length;<mask>++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2755,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25456,25459,BinaryOperatorMutator,&&,||,2,0.00788298,(!org.apache.commons.codec.binary.Base64.isBase64(arrayOctet[i])) <mask> (!org.apache.commons.codec.binary.Base64.isWhiteSpace(arrayOctet[i])),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i])<mask>!isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2756,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25456,25459,BinaryOperatorMutator,&&,&,3,0.0021538048,(!org.apache.commons.codec.binary.Base64.isBase64(arrayOctet[i])) <mask> (!org.apache.commons.codec.binary.Base64.isWhiteSpace(arrayOctet[i])),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i])<mask>!isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2757,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25456,25459,BinaryOperatorMutator,&&,(,4,0.0018782236,(!org.apache.commons.codec.binary.Base64.isBase64(arrayOctet[i])) <mask> (!org.apache.commons.codec.binary.Base64.isWhiteSpace(arrayOctet[i])),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i])<mask>!isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2758,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25432,25432,UnaryOperatorMutator,!,(!,2,2.038644E-4,<mask>org.apache.commons.codec.binary.Base64.isBase64(arrayOctet[i]),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2759,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25432,25432,UnaryOperatorMutator,!,!!,3,1.576824E-4,<mask>org.apache.commons.codec.binary.Base64.isBase64(arrayOctet[i]),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2760,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25432,25432,UnaryOperatorMutator,!,?!,4,1.0746465E-4,<mask>org.apache.commons.codec.binary.Base64.isBase64(arrayOctet[i]),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2761,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25433,25440,MethodCallMutator,isBase64,empty,0,0.1822089,<mask>(arrayOctet[i]),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!<mask>(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2762,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25433,25440,MethodCallMutator,isBase64,is,1,0.14064123,<mask>(arrayOctet[i]),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!<mask>(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2763,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25433,25440,MethodCallMutator,isBase64,space,2,0.1139395,<mask>(arrayOctet[i]),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!<mask>(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2764,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25433,25440,MethodCallMutator,isBase64,alpha,3,0.10201964,<mask>(arrayOctet[i]),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!<mask>(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2765,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25433,25440,MethodCallMutator,isBase64,blank,4,0.086053304,<mask>(arrayOctet[i]),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!<mask>(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2766,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25453,25453,ArrayAccessMutator,i,0,1,1.4548992E-4,arrayOctet[<mask>],"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[<mask>]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2767,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25453,25453,ArrayAccessMutator,i,I,3,3.3652104E-5,arrayOctet[<mask>],"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[<mask>]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2768,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25453,25453,ArrayAccessMutator,i,j,4,2.0468266E-5,arrayOctet[<mask>],"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[<mask>]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2769,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25442,25451,IdentifierMutator-Variable,arrayOctet,string,0,0.17260168,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(<mask>[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2770,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25442,25451,IdentifierMutator-Variable,arrayOctet,array,1,0.11244009,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(<mask>[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2771,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25442,25451,IdentifierMutator-Variable,arrayOctet,bytes,2,0.1074168,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(<mask>[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2772,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25442,25451,IdentifierMutator-Variable,arrayOctet,data,3,0.07898243,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(<mask>[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2773,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25442,25451,IdentifierMutator-Variable,arrayOctet,buffer,4,0.069979355,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(<mask>[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2774,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25453,25453,IdentifierMutator-Variable,i,0,1,1.4548992E-4,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[<mask>]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2775,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25453,25453,IdentifierMutator-Variable,i,I,3,3.3652104E-5,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[<mask>]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2776,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25453,25453,IdentifierMutator-Variable,i,j,4,2.0468266E-5,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[<mask>]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2777,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25460,25460,UnaryOperatorMutator,!,(!,1,0.4725375,<mask>org.apache.commons.codec.binary.Base64.isWhiteSpace(arrayOctet[i]),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) &&<mask>isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2778,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25460,25460,UnaryOperatorMutator,!,(,2,0.0030296927,<mask>org.apache.commons.codec.binary.Base64.isWhiteSpace(arrayOctet[i]),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) &&<mask>isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2779,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25460,25460,UnaryOperatorMutator,!,!!,4,4.945156E-5,<mask>org.apache.commons.codec.binary.Base64.isWhiteSpace(arrayOctet[i]),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) &&<mask>isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2780,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25461,25472,MethodCallMutator,isWhiteSpace,is,0,0.12211186,<mask>(arrayOctet[i]),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !<mask>(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2781,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25461,25472,MethodCallMutator,isWhiteSpace,empty,1,0.08954315,<mask>(arrayOctet[i]),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !<mask>(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2782,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25461,25472,MethodCallMutator,isWhiteSpace,print,2,0.077137664,<mask>(arrayOctet[i]),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !<mask>(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2783,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25461,25472,MethodCallMutator,isWhiteSpace,valid,3,0.05793024,<mask>(arrayOctet[i]),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !<mask>(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2784,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25461,25472,MethodCallMutator,isWhiteSpace,alpha,4,0.03985708,<mask>(arrayOctet[i]),"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !<mask>(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2785,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25485,25485,ArrayAccessMutator,i,j,1,1.136854E-4,arrayOctet[<mask>],"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[<mask>])) {
                return false;
            }
        }
        return true;
    }"
2786,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25485,25485,ArrayAccessMutator,i,I,3,9.3412375E-5,arrayOctet[<mask>],"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[<mask>])) {
                return false;
            }
        }
        return true;
    }"
2787,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25485,25485,ArrayAccessMutator,i,0,4,6.546559E-5,arrayOctet[<mask>],"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[<mask>])) {
                return false;
            }
        }
        return true;
    }"
2788,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25474,25483,IdentifierMutator-Variable,arrayOctet,string,0,0.23243855,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(<mask>[i])) {
                return false;
            }
        }
        return true;
    }"
2789,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25474,25483,IdentifierMutator-Variable,arrayOctet,array,1,0.099240854,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(<mask>[i])) {
                return false;
            }
        }
        return true;
    }"
2790,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25474,25483,IdentifierMutator-Variable,arrayOctet,bytes,2,0.06528167,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(<mask>[i])) {
                return false;
            }
        }
        return true;
    }"
2791,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25474,25483,IdentifierMutator-Variable,arrayOctet,data,3,0.062057868,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(<mask>[i])) {
                return false;
            }
        }
        return true;
    }"
2792,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25474,25483,IdentifierMutator-Variable,arrayOctet,buffer,4,0.056876943,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(<mask>[i])) {
                return false;
            }
        }
        return true;
    }"
2793,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25485,25485,IdentifierMutator-Variable,i,j,1,1.136854E-4,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[<mask>])) {
                return false;
            }
        }
        return true;
    }"
2794,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25485,25485,IdentifierMutator-Variable,i,I,3,9.3412375E-5,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[<mask>])) {
                return false;
            }
        }
        return true;
    }"
2795,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,636,25485,25485,IdentifierMutator-Variable,i,0,4,6.546559E-5,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[<mask>])) {
                return false;
            }
        }
        return true;
    }"
2796,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,637,25515,25519,IdentifierMutator-Literal,false,true,1,0.028133048,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return<mask>;
            }
        }
        return true;
    }"
2797,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,637,25515,25519,IdentifierMutator-Literal,false,FALSE,2,2.0867403E-4,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return<mask>;
            }
        }
        return true;
    }"
2798,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,637,25515,25519,IdentifierMutator-Literal,false,0,3,1.9070532E-4,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return<mask>;
            }
        }
        return true;
    }"
2799,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,637,25515,25519,IdentifierMutator-Literal,false,False,4,1.7224929E-4,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return<mask>;
            }
        }
        return true;
    }"
2800,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,640,25561,25564,IdentifierMutator-Literal,true,false,1,0.02443298,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return<mask>;
    }"
2801,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,640,25561,25564,IdentifierMutator-Literal,true,1,2,1.471644E-4,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return<mask>;
    }"
2802,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,640,25561,25564,IdentifierMutator-Literal,true,result,3,1.3070686E-4,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return<mask>;
    }"
2803,Base64.java,isBase64,boolean isBase64(byte[] arrayOctet),634,640,25561,25564,IdentifierMutator-Literal,true,0,4,1.3040779E-4,<mask>,"boolean isBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return<mask>;
    }"
2804,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25967,25967,IdentifierMutator-Literal,0,1,2,0.003959158,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i =<mask>; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2805,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25967,25967,IdentifierMutator-Literal,0,2,3,2.262098E-4,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i =<mask>; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2806,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25967,25967,IdentifierMutator-Literal,0,1,4,1.558296E-4,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i =<mask>; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2807,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25971,25973,BinaryOperatorMutator,<,++,2,0.0026359782,i <mask> arrayOctet.length,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i<mask>arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2808,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25971,25973,BinaryOperatorMutator,<,==,3,0.0019484478,i <mask> arrayOctet.length,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i<mask>arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2809,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25971,25973,BinaryOperatorMutator,<,+=,4,9.264703E-4,i <mask> arrayOctet.length,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i<mask>arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2810,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25970,25970,IdentifierMutator-Variable,i,I,2,3.6854744E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0;<mask> < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2811,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25970,25970,IdentifierMutator-Variable,i,0,3,1.640468E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0;<mask> < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2812,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25970,25970,IdentifierMutator-Variable,i,j,4,1.3535984E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0;<mask> < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2813,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25974,25990,IdentifierMutator-Variable,arrayOctet.length,256,0,0.14680465,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2814,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25974,25990,IdentifierMutator-Variable,arrayOctet.length,8,1,0.11345136,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2815,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25974,25990,IdentifierMutator-Variable,arrayOctet.length,length,2,0.087559626,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2816,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25974,25990,IdentifierMutator-Variable,arrayOctet.length,4,3,0.07424522,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2817,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25974,25990,IdentifierMutator-Variable,arrayOctet.length,32,4,0.046386782,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2818,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25974,25983,IdentifierMutator-Variable,arrayOctet,array,0,0.72395766,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2819,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25974,25983,IdentifierMutator-Variable,arrayOctet,byte,1,0.044849873,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2820,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25974,25983,IdentifierMutator-Variable,arrayOctet,string,2,0.023763862,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2821,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25974,25983,IdentifierMutator-Variable,arrayOctet,Array,3,0.019308094,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2822,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25974,25983,IdentifierMutator-Variable,arrayOctet,buffer,4,0.019216686,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2823,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25985,25990,FieldReferenceMutator,length,size,1,1.707799E-4,arrayOctet.<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2824,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25985,25990,FieldReferenceMutator,length,Length,3,9.1871945E-5,arrayOctet.<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2825,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25985,25990,FieldReferenceMutator,length,count,4,3.4216948E-5,arrayOctet.<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2826,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25994,25995,UnaryOperatorMutator,++,++),2,0.0064816885,i<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i<mask>) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2827,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25994,25995,UnaryOperatorMutator,++,*/,3,3.7730436E-4,i<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i<mask>) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2828,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25994,25995,UnaryOperatorMutator,++,++;,4,3.5322306E-4,i<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i<mask>) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2829,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25993,25993,IdentifierMutator-Variable,i,I,2,3.095618E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length;<mask>++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2830,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25993,25993,IdentifierMutator-Variable,i,,3,1.6567137E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length;<mask>++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2831,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,651,25993,25993,IdentifierMutator-Variable,i,j,4,1.5247159E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length;<mask>++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2832,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,652,26016,26023,MethodCallMutator,isBase64,bytes,0,0.05634457,<mask>(arrayOctet[i]),"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2833,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,652,26016,26023,MethodCallMutator,isBase64,check,1,0.051514942,<mask>(arrayOctet[i]),"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2834,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,652,26016,26023,MethodCallMutator,isBase64,match,2,0.0469116,<mask>(arrayOctet[i]),"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2835,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,652,26016,26023,MethodCallMutator,isBase64,is,3,0.045205876,<mask>(arrayOctet[i]),"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2836,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,652,26016,26023,MethodCallMutator,isBase64,contains,4,0.043610103,<mask>(arrayOctet[i]),"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2837,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,652,26036,26036,ArrayAccessMutator,i,0,2,1.6736319E-4,arrayOctet[<mask>],"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[<mask>])) {
                return true;
            }
        }
        return false;
    }"
2838,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,652,26036,26036,ArrayAccessMutator,i,I,3,1.6114512E-4,arrayOctet[<mask>],"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[<mask>])) {
                return true;
            }
        }
        return false;
    }"
2839,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,652,26036,26036,ArrayAccessMutator,i,j,4,2.1005095E-5,arrayOctet[<mask>],"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[<mask>])) {
                return true;
            }
        }
        return false;
    }"
2840,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,652,26025,26034,IdentifierMutator-Variable,arrayOctet,array,0,0.24167866,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(<mask>[i])) {
                return true;
            }
        }
        return false;
    }"
2841,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,652,26025,26034,IdentifierMutator-Variable,arrayOctet,byte,1,0.2171457,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(<mask>[i])) {
                return true;
            }
        }
        return false;
    }"
2842,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,652,26025,26034,IdentifierMutator-Variable,arrayOctet,data,2,0.076957785,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(<mask>[i])) {
                return true;
            }
        }
        return false;
    }"
2843,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,652,26025,26034,IdentifierMutator-Variable,arrayOctet,buffer,3,0.0666544,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(<mask>[i])) {
                return true;
            }
        }
        return false;
    }"
2844,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,652,26025,26034,IdentifierMutator-Variable,arrayOctet,string,4,0.05060413,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(<mask>[i])) {
                return true;
            }
        }
        return false;
    }"
2845,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,652,26036,26036,IdentifierMutator-Variable,i,0,2,1.6736319E-4,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[<mask>])) {
                return true;
            }
        }
        return false;
    }"
2846,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,652,26036,26036,IdentifierMutator-Variable,i,I,3,1.6114512E-4,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[<mask>])) {
                return true;
            }
        }
        return false;
    }"
2847,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,652,26036,26036,IdentifierMutator-Variable,i,j,4,2.1005095E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[<mask>])) {
                return true;
            }
        }
        return false;
    }"
2848,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,653,26066,26069,IdentifierMutator-Literal,true,i,1,0.0021050747,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return<mask>;
            }
        }
        return false;
    }"
2849,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,653,26066,26069,IdentifierMutator-Literal,true,false,2,0.0015918087,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return<mask>;
            }
        }
        return false;
    }"
2850,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,653,26066,26069,IdentifierMutator-Literal,true,1,3,9.919776E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return<mask>;
            }
        }
        return false;
    }"
2851,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,653,26066,26069,IdentifierMutator-Literal,true,True,4,9.051935E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return<mask>;
            }
        }
        return false;
    }"
2852,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,656,26111,26115,IdentifierMutator-Literal,false,true,1,0.005027194,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return<mask>;
    }"
2853,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,656,26111,26115,IdentifierMutator-Literal,false,False,2,2.1422916E-4,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return<mask>;
    }"
2854,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,656,26111,26115,IdentifierMutator-Literal,false,null,3,1.6523841E-4,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return<mask>;
    }"
2855,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),650,656,26111,26115,IdentifierMutator-Literal,false,undefined,4,8.806465E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return<mask>;
    }"
2856,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),666,667,26455,26466,MethodCallMutator,encodeBase64,encode,0,0.94405687,"<mask>(binaryData, false)","byte[] encodeBase64(byte[] binaryData) {
        return<mask>(binaryData, false);
    }"
2857,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),666,667,26455,26466,MethodCallMutator,encodeBase64,decode,1,0.039374847,"<mask>(binaryData, false)","byte[] encodeBase64(byte[] binaryData) {
        return<mask>(binaryData, false);
    }"
2858,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),666,667,26455,26466,MethodCallMutator,encodeBase64,encrypt,2,0.0022694818,"<mask>(binaryData, false)","byte[] encodeBase64(byte[] binaryData) {
        return<mask>(binaryData, false);
    }"
2859,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),666,667,26455,26466,MethodCallMutator,encodeBase64,write,3,0.0014574287,"<mask>(binaryData, false)","byte[] encodeBase64(byte[] binaryData) {
        return<mask>(binaryData, false);
    }"
2860,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),666,667,26455,26466,MethodCallMutator,encodeBase64,convert,4,0.0012849576,"<mask>(binaryData, false)","byte[] encodeBase64(byte[] binaryData) {
        return<mask>(binaryData, false);
    }"
2861,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),666,667,26468,26477,IdentifierMutator-Variable,binaryData,data,0,0.56965536,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(<mask>, false);
    }"
2862,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),666,667,26468,26477,IdentifierMutator-Variable,binaryData,binary,1,0.34878767,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(<mask>, false);
    }"
2863,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),666,667,26468,26477,IdentifierMutator-Variable,binaryData,bin,2,0.014435808,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(<mask>, false);
    }"
2864,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),666,667,26468,26477,IdentifierMutator-Variable,binaryData,bytes,3,0.011640079,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(<mask>, false);
    }"
2865,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),666,667,26468,26477,IdentifierMutator-Variable,binaryData,input,4,0.006641374,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(<mask>, false);
    }"
2866,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),666,667,26480,26484,IdentifierMutator-Literal,false,true,0,0.41194126,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2867,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),666,667,26480,26484,IdentifierMutator-Literal,false,encoding,1,0.18011749,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2868,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),666,667,26480,26484,IdentifierMutator-Literal,false,enc,3,0.026365332,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2869,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),666,667,26480,26484,IdentifierMutator-Literal,false,null,4,0.02244457,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2870,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27053,27065,MethodCallMutator,newStringUtf8,escape,0,0.23385602,"StringUtils.<mask>(encodeBase64(binaryData, false))","String encodeBase64String(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false));
    }"
2871,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27053,27065,MethodCallMutator,newStringUtf8,strip,1,0.107515045,"StringUtils.<mask>(encodeBase64(binaryData, false))","String encodeBase64String(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false));
    }"
2872,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27053,27065,MethodCallMutator,newStringUtf8,format,2,0.0642058,"StringUtils.<mask>(encodeBase64(binaryData, false))","String encodeBase64String(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false));
    }"
2873,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27053,27065,MethodCallMutator,newStringUtf8,str,3,0.057990506,"StringUtils.<mask>(encodeBase64(binaryData, false))","String encodeBase64String(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false));
    }"
2874,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27053,27065,MethodCallMutator,newStringUtf8,copy,4,0.057060964,"StringUtils.<mask>(encodeBase64(binaryData, false))","String encodeBase64String(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false));
    }"
2875,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27067,27078,MethodCallMutator,encodeBase64,append,0,0.12281522,"<mask>(binaryData, false)","String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false));
    }"
2876,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27067,27078,MethodCallMutator,encodeBase64,string,1,0.11252674,"<mask>(binaryData, false)","String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false));
    }"
2877,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27067,27078,MethodCallMutator,encodeBase64,escape,2,0.07781235,"<mask>(binaryData, false)","String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false));
    }"
2878,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27067,27078,MethodCallMutator,encodeBase64,write,3,0.06607993,"<mask>(binaryData, false)","String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false));
    }"
2879,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27067,27078,MethodCallMutator,encodeBase64,binary,4,0.06031722,"<mask>(binaryData, false)","String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false));
    }"
2880,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27080,27089,IdentifierMutator-Variable,binaryData,data,0,0.70177454,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false));
    }"
2881,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27080,27089,IdentifierMutator-Variable,binaryData,binary,1,0.20574424,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false));
    }"
2882,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27080,27089,IdentifierMutator-Variable,binaryData,bytes,2,0.016056625,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false));
    }"
2883,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27080,27089,IdentifierMutator-Variable,binaryData,bin,3,0.0116743045,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false));
    }"
2884,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27080,27089,IdentifierMutator-Variable,binaryData,input,4,0.0068338863,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false));
    }"
2885,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27092,27096,IdentifierMutator-Literal,false,true,0,0.3419416,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>));
    }"
2886,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27092,27096,IdentifierMutator-Literal,false,encoding,1,0.30814728,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>));
    }"
2887,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27092,27096,IdentifierMutator-Literal,false,16,3,0.023923935,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>));
    }"
2888,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),681,682,27092,27096,IdentifierMutator-Literal,false,null,4,0.018529011,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>));
    }"
2889,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),694,695,27566,27577,MethodCallMutator,encodeBase64,encode,0,0.9291539,"<mask>(binaryData, false, true)","byte[] encodeBase64URLSafe(byte[] binaryData) {
        return<mask>(binaryData, false, true);
    }"
2890,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),694,695,27566,27577,MethodCallMutator,encodeBase64,decode,1,0.04959106,"<mask>(binaryData, false, true)","byte[] encodeBase64URLSafe(byte[] binaryData) {
        return<mask>(binaryData, false, true);
    }"
2891,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),694,695,27566,27577,MethodCallMutator,encodeBase64,encrypt,2,0.0033817214,"<mask>(binaryData, false, true)","byte[] encodeBase64URLSafe(byte[] binaryData) {
        return<mask>(binaryData, false, true);
    }"
2892,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),694,695,27566,27577,MethodCallMutator,encodeBase64,escape,3,0.0017478258,"<mask>(binaryData, false, true)","byte[] encodeBase64URLSafe(byte[] binaryData) {
        return<mask>(binaryData, false, true);
    }"
2893,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),694,695,27566,27577,MethodCallMutator,encodeBase64,convert,4,0.001501609,"<mask>(binaryData, false, true)","byte[] encodeBase64URLSafe(byte[] binaryData) {
        return<mask>(binaryData, false, true);
    }"
2894,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),694,695,27579,27588,IdentifierMutator-Variable,binaryData,data,0,0.57694554,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(<mask>, false, true);
    }"
2895,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),694,695,27579,27588,IdentifierMutator-Variable,binaryData,binary,1,0.35582703,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(<mask>, false, true);
    }"
2896,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),694,695,27579,27588,IdentifierMutator-Variable,binaryData,bin,2,0.010326671,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(<mask>, false, true);
    }"
2897,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),694,695,27579,27588,IdentifierMutator-Variable,binaryData,bytes,3,0.00878207,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(<mask>, false, true);
    }"
2898,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),694,695,27579,27588,IdentifierMutator-Variable,binaryData,input,4,0.007093513,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(<mask>, false, true);
    }"
2899,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),694,695,27591,27595,IdentifierMutator-Literal,false,true,0,0.33701757,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>, true);
    }"
2900,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),694,695,27591,27595,IdentifierMutator-Literal,false,null,2,0.077673286,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>, true);
    }"
2901,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),694,695,27591,27595,IdentifierMutator-Literal,false,encoding,3,0.064455956,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>, true);
    }"
2902,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),694,695,27591,27595,IdentifierMutator-Literal,false,0,4,0.026886055,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>, true);
    }"
2903,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),694,695,27598,27601,IdentifierMutator-Literal,true,false,1,0.2752255,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData, false,<mask>);
    }"
2904,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),694,695,27598,27601,IdentifierMutator-Literal,true,encoding,2,0.037517346,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData, false,<mask>);
    }"
2905,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),694,695,27598,27601,IdentifierMutator-Literal,true,null,3,0.028304271,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData, false,<mask>);
    }"
2906,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),694,695,27598,27601,IdentifierMutator-Literal,true,0,4,0.02069018,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData, false,<mask>);
    }"
2907,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28056,28068,MethodCallMutator,newStringUtf8,escape,0,0.27712065,"StringUtils.<mask>(encodeBase64(binaryData, false, true))","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false, true));
    }"
2908,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28056,28068,MethodCallMutator,newStringUtf8,strip,1,0.15997787,"StringUtils.<mask>(encodeBase64(binaryData, false, true))","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false, true));
    }"
2909,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28056,28068,MethodCallMutator,newStringUtf8,String,2,0.051742323,"StringUtils.<mask>(encodeBase64(binaryData, false, true))","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false, true));
    }"
2910,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28056,28068,MethodCallMutator,newStringUtf8,str,3,0.039697804,"StringUtils.<mask>(encodeBase64(binaryData, false, true))","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false, true));
    }"
2911,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28056,28068,MethodCallMutator,newStringUtf8,copy,4,0.03933654,"StringUtils.<mask>(encodeBase64(binaryData, false, true))","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false, true));
    }"
2912,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28070,28081,MethodCallMutator,encodeBase64,append,0,0.13126743,"<mask>(binaryData, false, true)","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false, true));
    }"
2913,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28070,28081,MethodCallMutator,encodeBase64,escape,1,0.101710126,"<mask>(binaryData, false, true)","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false, true));
    }"
2914,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28070,28081,MethodCallMutator,encodeBase64,string,2,0.07036338,"<mask>(binaryData, false, true)","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false, true));
    }"
2915,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28070,28081,MethodCallMutator,encodeBase64,copy,3,0.0588506,"<mask>(binaryData, false, true)","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false, true));
    }"
2916,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28070,28081,MethodCallMutator,encodeBase64,bytes,4,0.053650454,"<mask>(binaryData, false, true)","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false, true));
    }"
2917,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28083,28092,IdentifierMutator-Variable,binaryData,data,0,0.7014834,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false, true));
    }"
2918,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28083,28092,IdentifierMutator-Variable,binaryData,binary,1,0.21778993,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false, true));
    }"
2919,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28083,28092,IdentifierMutator-Variable,binaryData,bytes,2,0.01396412,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false, true));
    }"
2920,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28083,28092,IdentifierMutator-Variable,binaryData,bin,3,0.006630474,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false, true));
    }"
2921,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28083,28092,IdentifierMutator-Variable,binaryData,input,4,0.005561476,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false, true));
    }"
2922,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28095,28099,IdentifierMutator-Literal,false,true,0,0.5513804,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>, true));
    }"
2923,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28095,28099,IdentifierMutator-Literal,false,encoding,2,0.04882754,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>, true));
    }"
2924,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28095,28099,IdentifierMutator-Literal,false,null,3,0.04679208,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>, true));
    }"
2925,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28095,28099,IdentifierMutator-Literal,false,16,4,0.013512293,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>, true));
    }"
2926,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28102,28105,IdentifierMutator-Literal,true,false,0,0.40773466,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData, false,<mask>));
    }"
2927,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28102,28105,IdentifierMutator-Literal,true,encoding,2,0.04217342,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData, false,<mask>));
    }"
2928,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28102,28105,IdentifierMutator-Literal,true,null,3,0.032313563,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData, false,<mask>));
    }"
2929,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),707,708,28102,28105,IdentifierMutator-Literal,true,0,4,0.016010568,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData, false,<mask>));
    }"
2930,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),718,719,28464,28475,MethodCallMutator,encodeBase64,encode,0,0.82261014,"<mask>(binaryData, true)","byte[] encodeBase64Chunked(byte[] binaryData) {
        return<mask>(binaryData, true);
    }"
2931,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),718,719,28464,28475,MethodCallMutator,encodeBase64,decode,1,0.09652989,"<mask>(binaryData, true)","byte[] encodeBase64Chunked(byte[] binaryData) {
        return<mask>(binaryData, true);
    }"
2932,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),718,719,28464,28475,MethodCallMutator,encodeBase64,chunk,2,0.022350585,"<mask>(binaryData, true)","byte[] encodeBase64Chunked(byte[] binaryData) {
        return<mask>(binaryData, true);
    }"
2933,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),718,719,28464,28475,MethodCallMutator,encodeBase64,write,3,0.006138433,"<mask>(binaryData, true)","byte[] encodeBase64Chunked(byte[] binaryData) {
        return<mask>(binaryData, true);
    }"
2934,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),718,719,28464,28475,MethodCallMutator,encodeBase64,compress,4,0.0039744885,"<mask>(binaryData, true)","byte[] encodeBase64Chunked(byte[] binaryData) {
        return<mask>(binaryData, true);
    }"
2935,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),718,719,28477,28486,IdentifierMutator-Variable,binaryData,data,0,0.6595072,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(<mask>, true);
    }"
2936,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),718,719,28477,28486,IdentifierMutator-Variable,binaryData,binary,1,0.26427338,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(<mask>, true);
    }"
2937,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),718,719,28477,28486,IdentifierMutator-Variable,binaryData,bin,2,0.013548699,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(<mask>, true);
    }"
2938,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),718,719,28477,28486,IdentifierMutator-Variable,binaryData,bytes,3,0.011362956,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(<mask>, true);
    }"
2939,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),718,719,28477,28486,IdentifierMutator-Variable,binaryData,input,4,0.005645278,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(<mask>, true);
    }"
2940,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),718,719,28489,28492,IdentifierMutator-Literal,true,chunk,1,0.22533223,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2941,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),718,719,28489,28492,IdentifierMutator-Literal,true,false,2,0.14861713,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2942,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),718,719,28489,28492,IdentifierMutator-Literal,true,chunks,3,0.067457154,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2943,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),718,719,28489,28492,IdentifierMutator-Literal,true,encoding,4,0.027869578,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2944,Base64.java,decode,byte[] decode(String pArray),750,751,29765,29770,MethodCallMutator,decode,encode,1,0.004830821,<mask>(StringUtils.getBytesUtf8(pArray)),"byte[] decode(String pArray) {
        return<mask>(StringUtils.getBytesUtf8(pArray));
    }"
2945,Base64.java,decode,byte[] decode(String pArray),750,751,29765,29770,MethodCallMutator,decode,parse,2,1.7826313E-4,<mask>(StringUtils.getBytesUtf8(pArray)),"byte[] decode(String pArray) {
        return<mask>(StringUtils.getBytesUtf8(pArray));
    }"
2946,Base64.java,decode,byte[] decode(String pArray),750,751,29765,29770,MethodCallMutator,decode,dec,3,1.3111597E-4,<mask>(StringUtils.getBytesUtf8(pArray)),"byte[] decode(String pArray) {
        return<mask>(StringUtils.getBytesUtf8(pArray));
    }"
2947,Base64.java,decode,byte[] decode(String pArray),750,751,29765,29770,MethodCallMutator,decode,convert,4,9.6891796E-5,<mask>(StringUtils.getBytesUtf8(pArray)),"byte[] decode(String pArray) {
        return<mask>(StringUtils.getBytesUtf8(pArray));
    }"
2948,Base64.java,decode,byte[] decode(String pArray),750,751,29784,29795,MethodCallMutator,getBytesUtf8,split,0,0.28131217,StringUtils.<mask>(pArray),"byte[] decode(String pArray) {
        return decode(StringUtils.<mask>(pArray));
    }"
2949,Base64.java,decode,byte[] decode(String pArray),750,751,29784,29795,MethodCallMutator,getBytesUtf8,escape,1,0.15086763,StringUtils.<mask>(pArray),"byte[] decode(String pArray) {
        return decode(StringUtils.<mask>(pArray));
    }"
2950,Base64.java,decode,byte[] decode(String pArray),750,751,29784,29795,MethodCallMutator,getBytesUtf8,copy,2,0.09991636,StringUtils.<mask>(pArray),"byte[] decode(String pArray) {
        return decode(StringUtils.<mask>(pArray));
    }"
2951,Base64.java,decode,byte[] decode(String pArray),750,751,29784,29795,MethodCallMutator,getBytesUtf8,bytes,3,0.07844052,StringUtils.<mask>(pArray),"byte[] decode(String pArray) {
        return decode(StringUtils.<mask>(pArray));
    }"
2952,Base64.java,decode,byte[] decode(String pArray),750,751,29784,29795,MethodCallMutator,getBytesUtf8,strip,4,0.056334697,StringUtils.<mask>(pArray),"byte[] decode(String pArray) {
        return decode(StringUtils.<mask>(pArray));
    }"
2953,Base64.java,decode,byte[] decode(String pArray),750,751,29797,29802,IdentifierMutator-Variable,pArray,Array,0,0.48545185,<mask>,"byte[] decode(String pArray) {
        return decode(StringUtils.getBytesUtf8(<mask>));
    }"
2954,Base64.java,decode,byte[] decode(String pArray),750,751,29797,29802,IdentifierMutator-Variable,pArray,array,1,0.47099465,<mask>,"byte[] decode(String pArray) {
        return decode(StringUtils.getBytesUtf8(<mask>));
    }"
2955,Base64.java,decode,byte[] decode(String pArray),750,751,29797,29802,IdentifierMutator-Variable,pArray,string,2,0.017953781,<mask>,"byte[] decode(String pArray) {
        return decode(StringUtils.getBytesUtf8(<mask>));
    }"
2956,Base64.java,decode,byte[] decode(String pArray),750,751,29797,29802,IdentifierMutator-Variable,pArray,arr,3,0.0070915967,<mask>,"byte[] decode(String pArray) {
        return decode(StringUtils.getBytesUtf8(<mask>));
    }"
2957,Base64.java,decode,byte[] decode(String pArray),750,751,29797,29802,IdentifierMutator-Variable,pArray,p,4,0.0027387305,<mask>,"byte[] decode(String pArray) {
        return decode(StringUtils.getBytesUtf8(<mask>));
    }"
2958,Base64.java,decode,byte[] decode(byte[] pArray),761,762,30094,30098,MethodCallMutator,reset,close,0,0.28981656,<mask>(),"byte[] decode(byte[] pArray) {<mask>();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2959,Base64.java,decode,byte[] decode(byte[] pArray),761,762,30094,30098,MethodCallMutator,reset,flush,1,0.13729948,<mask>(),"byte[] decode(byte[] pArray) {<mask>();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2960,Base64.java,decode,byte[] decode(byte[] pArray),761,762,30094,30098,MethodCallMutator,reset,cleanup,2,0.04266185,<mask>(),"byte[] decode(byte[] pArray) {<mask>();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2961,Base64.java,decode,byte[] decode(byte[] pArray),761,762,30094,30098,MethodCallMutator,reset,wait,3,0.034746874,<mask>(),"byte[] decode(byte[] pArray) {<mask>();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2962,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30129,30132,BinaryOperatorMutator,||,|,2,0.0022881355,(pArray == null) <mask> (pArray.length == 0),"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null<mask>pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2963,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30129,30132,BinaryOperatorMutator,||,/,3,0.0011592875,(pArray == null) <mask> (pArray.length == 0),"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null<mask>pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2964,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30129,30132,BinaryOperatorMutator,||,.,4,6.3190307E-4,(pArray == null) <mask> (pArray.length == 0),"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null<mask>pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2965,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30121,30124,BinaryOperatorMutator,==,=,2,0.0063601867,pArray <mask> null,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray<mask>null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2966,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30121,30124,BinaryOperatorMutator,==,===,3,8.1404176E-4,pArray <mask> null,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray<mask>null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2967,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30121,30124,BinaryOperatorMutator,==,||,4,5.5915787E-4,pArray <mask> null,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray<mask>null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2968,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30115,30120,IdentifierMutator-Variable,pArray,array,0,0.62316984,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2969,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30115,30120,IdentifierMutator-Variable,pArray,Array,1,0.07683179,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2970,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30115,30120,IdentifierMutator-Variable,pArray,p,2,0.029546808,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2971,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30115,30120,IdentifierMutator-Variable,pArray,result,3,0.02785201,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2972,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30115,30120,IdentifierMutator-Variable,pArray,null,4,0.018327422,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2973,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30125,30128,IdentifierMutator-Literal,null,nil,1,3.513418E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2974,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30125,30128,IdentifierMutator-Literal,null,NULL,2,3.0494697E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2975,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30125,30128,IdentifierMutator-Literal,null,undefined,3,7.5809716E-5,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2976,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30146,30149,BinaryOperatorMutator,==,>,2,0.019367289,pArray.length <mask> 0,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length<mask>0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2977,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30146,30149,BinaryOperatorMutator,==,<=,3,0.012512048,pArray.length <mask> 0,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length<mask>0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2978,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30146,30149,BinaryOperatorMutator,==,=,4,0.012142786,pArray.length <mask> 0,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length<mask>0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2979,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30133,30145,IdentifierMutator-Variable,pArray.length,pos,0,0.8833265,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2980,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30133,30145,IdentifierMutator-Variable,pArray.length,len,1,0.01839501,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2981,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30133,30145,IdentifierMutator-Variable,pArray.length,position,2,0.016328236,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2982,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30133,30145,IdentifierMutator-Variable,pArray.length,length,3,0.014746395,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2983,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30133,30145,IdentifierMutator-Variable,pArray.length,index,4,0.0085182795,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2984,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30133,30138,IdentifierMutator-Variable,pArray,array,0,0.6998715,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2985,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30133,30138,IdentifierMutator-Variable,pArray,Array,1,0.12698701,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2986,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30133,30138,IdentifierMutator-Variable,pArray,Array,2,0.10282839,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2987,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30133,30138,IdentifierMutator-Variable,pArray,p,3,0.033613313,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2988,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30133,30138,IdentifierMutator-Variable,pArray,arr,4,0.0066679805,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2989,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30140,30145,FieldReferenceMutator,length,size,2,4.488633E-5,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.<mask> == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2990,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30140,30145,FieldReferenceMutator,length,count,3,3.1752286E-5,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.<mask> == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2991,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30140,30145,FieldReferenceMutator,length,Length,4,2.2881353E-5,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.<mask> == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2992,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30150,30150,IdentifierMutator-Literal,0,1,1,0.0018777887,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2993,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30150,30150,IdentifierMutator-Literal,0,pos,2,0.0011529664,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2994,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30150,30150,IdentifierMutator-Literal,0,size,3,3.8540212E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2995,Base64.java,decode,byte[] decode(byte[] pArray),761,763,30150,30150,IdentifierMutator-Literal,0,null,4,3.3472377E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2996,Base64.java,decode,byte[] decode(byte[] pArray),761,764,30174,30179,IdentifierMutator-Variable,pArray,null,0,0.89440036,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2997,Base64.java,decode,byte[] decode(byte[] pArray),761,764,30174,30179,IdentifierMutator-Variable,pArray,"""""",1,0.022288568,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2998,Base64.java,decode,byte[] decode(byte[] pArray),761,764,30174,30179,IdentifierMutator-Variable,pArray,result,2,0.011873561,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2999,Base64.java,decode,byte[] decode(byte[] pArray),761,764,30174,30179,IdentifierMutator-Variable,pArray,array,3,0.008962472,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3000,Base64.java,decode,byte[] decode(byte[] pArray),761,764,30174,30179,IdentifierMutator-Variable,pArray,[],4,0.008848751,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3001,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30200,30205,MethodCallMutator,decode,encode,1,0.07144779,"<mask>(pArray, 0, pArray.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }<mask>(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3002,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30200,30205,MethodCallMutator,decode,read,2,0.03354815,"<mask>(pArray, 0, pArray.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }<mask>(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3003,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30200,30205,MethodCallMutator,decode,write,3,0.031407528,"<mask>(pArray, 0, pArray.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }<mask>(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3004,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30200,30205,MethodCallMutator,decode,copy,4,0.012811704,"<mask>(pArray, 0, pArray.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }<mask>(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3005,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30207,30212,IdentifierMutator-Variable,pArray,array,0,0.39416337,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(<mask>, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3006,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30207,30212,IdentifierMutator-Variable,pArray,Array,1,0.17934696,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(<mask>, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3007,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30207,30212,IdentifierMutator-Variable,pArray,result,2,0.048385993,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(<mask>, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3008,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30207,30212,IdentifierMutator-Variable,pArray,buffer,3,0.042022042,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(<mask>, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3009,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30207,30212,IdentifierMutator-Variable,pArray,p,4,0.030800562,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(<mask>, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3010,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30215,30215,IdentifierMutator-Literal,0,pos,1,0.050282065,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray,<mask>, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3011,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30215,30215,IdentifierMutator-Literal,0,1,2,0.011870728,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray,<mask>, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3012,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30215,30215,IdentifierMutator-Literal,0,2,3,0.0016541835,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray,<mask>, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3013,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30218,30230,IdentifierMutator-Variable,pArray.length,pos,0,0.5698809,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0,<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3014,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30218,30230,IdentifierMutator-Variable,pArray.length,0,1,0.2632951,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0,<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3015,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30218,30230,IdentifierMutator-Variable,pArray.length,1,2,0.09718545,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0,<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3016,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30218,30230,IdentifierMutator-Variable,pArray.length,position,3,0.0084748985,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0,<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3017,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30218,30230,IdentifierMutator-Variable,pArray.length,2,4,0.0054953964,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0,<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3018,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30218,30223,IdentifierMutator-Variable,pArray,array,0,0.4219871,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0,<mask>.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3019,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30218,30223,IdentifierMutator-Variable,pArray,result,1,0.20195422,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0,<mask>.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3020,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30218,30223,IdentifierMutator-Variable,pArray,p,2,0.06337426,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0,<mask>.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3021,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30218,30223,IdentifierMutator-Variable,pArray,Array,3,0.0506605,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0,<mask>.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3022,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30218,30223,IdentifierMutator-Variable,pArray,Array,4,0.044367768,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0,<mask>.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3023,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30225,30230,FieldReferenceMutator,length,position,1,2.3744428E-4,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3024,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30225,30230,FieldReferenceMutator,length,size,3,7.687338E-5,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3025,Base64.java,decode,byte[] decode(byte[] pArray),761,766,30225,30230,FieldReferenceMutator,length,count,4,7.4159456E-5,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3026,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30242,30247,MethodCallMutator,decode,reset,1,0.05608826,"<mask>(pArray, 0, -1)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3027,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30242,30247,MethodCallMutator,decode,encode,2,0.046047274,"<mask>(pArray, 0, -1)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3028,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30242,30247,MethodCallMutator,decode,write,3,0.044644088,"<mask>(pArray, 0, -1)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3029,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30242,30247,MethodCallMutator,decode,read,4,0.038964633,"<mask>(pArray, 0, -1)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3030,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30249,30254,IdentifierMutator-Variable,pArray,result,0,0.36147627,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(<mask>, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3031,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30249,30254,IdentifierMutator-Variable,pArray,null,1,0.0818544,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(<mask>, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3032,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30249,30254,IdentifierMutator-Variable,pArray,pos,2,0.061304945,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(<mask>, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3033,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30249,30254,IdentifierMutator-Variable,pArray,array,3,0.04462851,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(<mask>, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3034,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30249,30254,IdentifierMutator-Variable,pArray,buf,4,0.0243139,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(<mask>, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3035,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30257,30257,IdentifierMutator-Literal,0,pos,0,0.49773574,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray,<mask>, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3036,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30257,30257,IdentifierMutator-Literal,0,1,2,0.030814543,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray,<mask>, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3037,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30257,30257,IdentifierMutator-Literal,0,position,3,0.007213716,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray,<mask>, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3038,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30257,30257,IdentifierMutator-Literal,0,2,4,0.0027137636,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray,<mask>, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3039,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30260,30260,UnaryOperatorMutator,-,pos,1,0.27890968,<mask>1,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0,<mask>1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3040,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30260,30260,UnaryOperatorMutator,-,+,2,0.016065534,<mask>1,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0,<mask>1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3041,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30260,30260,UnaryOperatorMutator,-,position,3,0.0075639947,<mask>1,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0,<mask>1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3042,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30261,30261,IdentifierMutator-Literal,1,pos,1,0.30701843,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -<mask>); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3043,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30261,30261,IdentifierMutator-Literal,1,2,3,0.012492666,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -<mask>); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3044,Base64.java,decode,byte[] decode(byte[] pArray),761,767,30261,30261,IdentifierMutator-Literal,1,len,4,0.0047168615,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -<mask>); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3045,Base64.java,decode,byte[] decode(byte[] pArray),761,768,30324,30326,IdentifierMutator-Variable,pos,0,0,0.2318117,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3046,Base64.java,decode,byte[] decode(byte[] pArray),761,768,30324,30326,IdentifierMutator-Variable,pos,size,1,0.09228979,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3047,Base64.java,decode,byte[] decode(byte[] pArray),761,768,30324,30326,IdentifierMutator-Variable,pos,1,2,0.089146644,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3048,Base64.java,decode,byte[] decode(byte[] pArray),761,768,30324,30326,IdentifierMutator-Variable,pos,1024,3,0.061897475,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3049,Base64.java,decode,byte[] decode(byte[] pArray),761,768,30324,30326,IdentifierMutator-Variable,pos,10000,4,0.031855498,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3050,Base64.java,decode,byte[] decode(byte[] pArray),761,768,30324,30326,FieldReferenceMutator,pos,0,0,0.2318117,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3051,Base64.java,decode,byte[] decode(byte[] pArray),761,768,30324,30326,FieldReferenceMutator,pos,size,1,0.09228979,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3052,Base64.java,decode,byte[] decode(byte[] pArray),761,768,30324,30326,FieldReferenceMutator,pos,1,2,0.089146644,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3053,Base64.java,decode,byte[] decode(byte[] pArray),761,768,30324,30326,FieldReferenceMutator,pos,1024,3,0.061897475,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3054,Base64.java,decode,byte[] decode(byte[] pArray),761,768,30324,30326,FieldReferenceMutator,pos,10000,4,0.031855498,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3055,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30338,30348,MethodCallMutator,readResults,decode,0,0.97229296,"<mask>(result, 0, result.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];<mask>(result, 0, result.length);
        return result;
    }"
3056,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30338,30348,MethodCallMutator,readResults,encode,1,0.011218324,"<mask>(result, 0, result.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];<mask>(result, 0, result.length);
        return result;
    }"
3057,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30338,30348,MethodCallMutator,readResults,write,2,0.0037927565,"<mask>(result, 0, result.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];<mask>(result, 0, result.length);
        return result;
    }"
3058,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30338,30348,MethodCallMutator,readResults,read,3,0.001176898,"<mask>(result, 0, result.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];<mask>(result, 0, result.length);
        return result;
    }"
3059,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30338,30348,MethodCallMutator,readResults,copy,4,9.81045E-4,"<mask>(result, 0, result.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];<mask>(result, 0, result.length);
        return result;
    }"
3060,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30350,30355,IdentifierMutator-Variable,result,Result,1,0.0027772991,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(<mask>, 0, result.length);
        return result;
    }"
3061,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30350,30355,IdentifierMutator-Variable,result,results,3,3.8895087E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(<mask>, 0, result.length);
        return result;
    }"
3062,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30350,30355,IdentifierMutator-Variable,result,response,4,3.08347E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(<mask>, 0, result.length);
        return result;
    }"
3063,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30358,30358,IdentifierMutator-Literal,0,pos,0,0.54778343,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result,<mask>, result.length);
        return result;
    }"
3064,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30358,30358,IdentifierMutator-Literal,0,start,2,0.0058387867,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result,<mask>, result.length);
        return result;
    }"
3065,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30358,30358,IdentifierMutator-Literal,0,position,3,0.005662169,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result,<mask>, result.length);
        return result;
    }"
3066,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30358,30358,IdentifierMutator-Literal,0,offset,4,0.0040769465,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result,<mask>, result.length);
        return result;
    }"
3067,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30361,30373,IdentifierMutator-Variable,result.length,pos,0,0.93298924,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0,<mask>);
        return result;
    }"
3068,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30361,30373,IdentifierMutator-Variable,result.length,0,1,0.010566497,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0,<mask>);
        return result;
    }"
3069,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30361,30373,IdentifierMutator-Variable,result.length,position,2,0.0064336387,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0,<mask>);
        return result;
    }"
3070,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30361,30373,IdentifierMutator-Variable,result.length,1,3,0.0052332906,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0,<mask>);
        return result;
    }"
3071,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30361,30373,IdentifierMutator-Variable,result.length,len,4,0.0035458135,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0,<mask>);
        return result;
    }"
3072,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30361,30366,IdentifierMutator-Variable,result,Result,2,0.005120656,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0,<mask>.length);
        return result;
    }"
3073,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30361,30366,IdentifierMutator-Variable,result,Result,3,0.0029086631,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0,<mask>.length);
        return result;
    }"
3074,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30361,30366,IdentifierMutator-Variable,result,results,4,0.0013837768,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0,<mask>.length);
        return result;
    }"
3075,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30368,30373,FieldReferenceMutator,length,position,2,2.4755398E-5,result.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.<mask>);
        return result;
    }"
3076,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30368,30373,FieldReferenceMutator,length,size,3,1.25915485E-5,result.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.<mask>);
        return result;
    }"
3077,Base64.java,decode,byte[] decode(byte[] pArray),761,769,30368,30373,FieldReferenceMutator,length,class,4,1.1337091E-5,result.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.<mask>);
        return result;
    }"
3078,Base64.java,decode,byte[] decode(byte[] pArray),761,770,30392,30397,IdentifierMutator-Variable,result,null,1,9.859485E-5,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return<mask>;
    }"
3079,Base64.java,decode,byte[] decode(byte[] pArray),761,770,30392,30397,IdentifierMutator-Variable,result,Result,3,3.8365295E-5,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return<mask>;
    }"
3080,Base64.java,decode,byte[] decode(byte[] pArray),761,770,30392,30397,IdentifierMutator-Variable,result,true,4,3.775908E-5,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.
        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return<mask>;
    }"
3081,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31032,31043,MethodCallMutator,encodeBase64,encode,0,0.96945983,"<mask>(binaryData, isChunked, false)","byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return<mask>(binaryData, isChunked, false);
    }"
3082,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31032,31043,MethodCallMutator,encodeBase64,decode,1,0.017711729,"<mask>(binaryData, isChunked, false)","byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return<mask>(binaryData, isChunked, false);
    }"
3083,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31032,31043,MethodCallMutator,encodeBase64,convert,2,0.0014596981,"<mask>(binaryData, isChunked, false)","byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return<mask>(binaryData, isChunked, false);
    }"
3084,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31032,31043,MethodCallMutator,encodeBase64,encrypt,3,0.0013073772,"<mask>(binaryData, isChunked, false)","byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return<mask>(binaryData, isChunked, false);
    }"
3085,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31032,31043,MethodCallMutator,encodeBase64,write,4,7.6936977E-4,"<mask>(binaryData, isChunked, false)","byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return<mask>(binaryData, isChunked, false);
    }"
3086,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31045,31054,IdentifierMutator-Variable,binaryData,data,0,0.6559646,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(<mask>, isChunked, false);
    }"
3087,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31045,31054,IdentifierMutator-Variable,binaryData,binary,1,0.2709676,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(<mask>, isChunked, false);
    }"
3088,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31045,31054,IdentifierMutator-Variable,binaryData,bytes,2,0.011036762,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(<mask>, isChunked, false);
    }"
3089,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31045,31054,IdentifierMutator-Variable,binaryData,bin,3,0.00727332,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(<mask>, isChunked, false);
    }"
3090,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31045,31054,IdentifierMutator-Variable,binaryData,null,4,0.006988416,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(<mask>, isChunked, false);
    }"
3091,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31057,31065,IdentifierMutator-Variable,isChunked,true,0,0.3742739,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData,<mask>, false);
    }"
3092,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31057,31065,IdentifierMutator-Variable,isChunked,false,1,0.21662262,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData,<mask>, false);
    }"
3093,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31057,31065,IdentifierMutator-Variable,isChunked,chunk,2,0.067907944,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData,<mask>, false);
    }"
3094,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31057,31065,IdentifierMutator-Variable,isChunked,null,3,0.051294964,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData,<mask>, false);
    }"
3095,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31057,31065,IdentifierMutator-Variable,isChunked,encoding,4,0.037491746,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData,<mask>, false);
    }"
3096,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31068,31072,IdentifierMutator-Literal,false,true,0,0.41044897,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData, isChunked,<mask>);
    }"
3097,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31068,31072,IdentifierMutator-Literal,false,null,2,0.05827159,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData, isChunked,<mask>);
    }"
3098,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31068,31072,IdentifierMutator-Literal,false,encoding,3,0.040970728,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData, isChunked,<mask>);
    }"
3099,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",784,785,31068,31072,IdentifierMutator-Literal,false,0,4,0.02338439,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData, isChunked,<mask>);
    }"
3100,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31876,31887,MethodCallMutator,encodeBase64,encode,0,0.97584516,"<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3101,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31876,31887,MethodCallMutator,encodeBase64,decode,1,0.013778917,"<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3102,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31876,31887,MethodCallMutator,encodeBase64,encrypt,2,0.0018567225,"<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3103,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31876,31887,MethodCallMutator,encodeBase64,convert,3,9.6652255E-4,"<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3104,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31876,31887,MethodCallMutator,encodeBase64,encoded,4,6.6856673E-4,"<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3105,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31889,31898,IdentifierMutator-Variable,binaryData,binary,0,0.4719807,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(<mask>, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3106,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31889,31898,IdentifierMutator-Variable,binaryData,data,1,0.46579558,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(<mask>, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3107,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31889,31898,IdentifierMutator-Variable,binaryData,bytes,2,0.010550368,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(<mask>, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3108,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31889,31898,IdentifierMutator-Variable,binaryData,this,3,0.008777915,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(<mask>, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3109,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31889,31898,IdentifierMutator-Variable,binaryData,bin,4,0.0063010533,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(<mask>, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3110,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31901,31909,IdentifierMutator-Variable,isChunked,chunk,0,0.33446503,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData,<mask>, urlSafe, Integer.MAX_VALUE);
    }"
3111,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31901,31909,IdentifierMutator-Variable,isChunked,true,1,0.20736079,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData,<mask>, urlSafe, Integer.MAX_VALUE);
    }"
3112,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31901,31909,IdentifierMutator-Variable,isChunked,false,2,0.19937013,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData,<mask>, urlSafe, Integer.MAX_VALUE);
    }"
3113,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31901,31909,IdentifierMutator-Variable,isChunked,chunks,3,0.04113835,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData,<mask>, urlSafe, Integer.MAX_VALUE);
    }"
3114,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31901,31909,IdentifierMutator-Variable,isChunked,encoded,4,0.021251934,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData,<mask>, urlSafe, Integer.MAX_VALUE);
    }"
3115,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31912,31918,IdentifierMutator-Variable,urlSafe,url,0,0.3277066,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked,<mask>, Integer.MAX_VALUE);
    }"
3116,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31912,31918,IdentifierMutator-Variable,urlSafe,false,1,0.29387927,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked,<mask>, Integer.MAX_VALUE);
    }"
3117,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31912,31918,IdentifierMutator-Variable,urlSafe,true,2,0.25466722,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked,<mask>, Integer.MAX_VALUE);
    }"
3118,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31912,31918,IdentifierMutator-Variable,urlSafe,null,3,0.05202581,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked,<mask>, Integer.MAX_VALUE);
    }"
3119,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31912,31918,IdentifierMutator-Variable,urlSafe,0,4,0.011407451,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked,<mask>, Integer.MAX_VALUE);
    }"
3120,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31921,31937,IdentifierMutator-Variable,java.lang.Integer.MAX_VALUE,true,0,0.46313015,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe,<mask>);
    }"
3121,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31921,31937,IdentifierMutator-Variable,java.lang.Integer.MAX_VALUE,false,1,0.30426246,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe,<mask>);
    }"
3122,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31921,31937,IdentifierMutator-Variable,java.lang.Integer.MAX_VALUE,null,2,0.05156211,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe,<mask>);
    }"
3123,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31921,31937,IdentifierMutator-Variable,java.lang.Integer.MAX_VALUE,encoding,3,0.046732217,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe,<mask>);
    }"
3124,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31921,31937,IdentifierMutator-Variable,java.lang.Integer.MAX_VALUE,0,4,0.012317601,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe,<mask>);
    }"
3125,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31929,31937,FieldReferenceMutator,MAX_VALUE,MAX,0,0.81098574,java.lang.Integer.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe, Integer.<mask>);
    }"
3126,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31929,31937,FieldReferenceMutator,MAX_VALUE,class,1,0.040453304,java.lang.Integer.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe, Integer.<mask>);
    }"
3127,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31929,31937,FieldReferenceMutator,MAX_VALUE,MIN,2,0.035998788,java.lang.Integer.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe, Integer.<mask>);
    }"
3128,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31929,31937,FieldReferenceMutator,MAX_VALUE,VALUE,3,0.026722755,java.lang.Integer.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe, Integer.<mask>);
    }"
3129,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",802,803,31929,31937,FieldReferenceMutator,MAX_VALUE,SIZE,4,0.0136624,java.lang.Integer.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe, Integer.<mask>);
    }"
3130,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32844,32847,BinaryOperatorMutator,||,/,2,0.005309622,(binaryData == null) <mask> (binaryData.length == 0),"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null<mask>binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3131,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32844,32847,BinaryOperatorMutator,||,|,3,0.0048899413,(binaryData == null) <mask> (binaryData.length == 0),"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null<mask>binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3132,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32844,32847,BinaryOperatorMutator,||,.,4,9.871376E-4,(binaryData == null) <mask> (binaryData.length == 0),"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null<mask>binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3133,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32836,32839,BinaryOperatorMutator,==,=,2,0.0023550172,binaryData <mask> null,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData<mask>null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3134,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32836,32839,BinaryOperatorMutator,==,===,3,2.6785064E-4,binaryData <mask> null,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData<mask>null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3135,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32836,32839,BinaryOperatorMutator,==,!=,4,1.8707657E-4,binaryData <mask> null,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData<mask>null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3136,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32826,32835,IdentifierMutator-Variable,binaryData,data,0,0.67936295,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (<mask> == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3137,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32826,32835,IdentifierMutator-Variable,binaryData,binary,1,0.068766445,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (<mask> == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3138,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32826,32835,IdentifierMutator-Variable,binaryData,input,2,0.032262478,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (<mask> == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3139,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32826,32835,IdentifierMutator-Variable,binaryData,bytes,3,0.017555062,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (<mask> == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3140,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32826,32835,IdentifierMutator-Variable,binaryData,array,4,0.013655113,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (<mask> == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3141,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32840,32843,IdentifierMutator-Literal,null,NULL,1,2.669973E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData ==<mask> || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3142,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32840,32843,IdentifierMutator-Literal,null,nil,2,1.06297E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData ==<mask> || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3143,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32840,32843,IdentifierMutator-Literal,null,undefined,4,2.394984E-5,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData ==<mask> || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3144,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32865,32868,BinaryOperatorMutator,==,>,2,0.047776166,binaryData.length <mask> 0,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length<mask>0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3145,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32865,32868,BinaryOperatorMutator,==,<=,3,0.013993981,binaryData.length <mask> 0,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length<mask>0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3146,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32865,32868,BinaryOperatorMutator,==,=,4,0.012012753,binaryData.length <mask> 0,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length<mask>0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3147,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32848,32864,IdentifierMutator-Variable,binaryData.length,len,0,0.7633599,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3148,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32848,32864,IdentifierMutator-Variable,binaryData.length,length,1,0.14966008,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3149,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32848,32864,IdentifierMutator-Variable,binaryData.length,size,2,0.028107533,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3150,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32848,32864,IdentifierMutator-Variable,binaryData.length,count,3,0.007536229,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3151,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32848,32864,IdentifierMutator-Variable,binaryData.length,0,4,0.0070413123,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3152,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32848,32857,IdentifierMutator-Variable,binaryData,data,0,0.60867274,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask>.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3153,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32848,32857,IdentifierMutator-Variable,binaryData,bytes,1,0.10986657,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask>.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3154,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32848,32857,IdentifierMutator-Variable,binaryData,arguments,2,0.046536848,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask>.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3155,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32848,32857,IdentifierMutator-Variable,binaryData,buffer,3,0.044988465,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask>.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3156,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32848,32857,IdentifierMutator-Variable,binaryData,input,4,0.042564705,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask>.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3157,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32859,32864,FieldReferenceMutator,length,len,2,1.1712308E-4,binaryData.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3158,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32859,32864,FieldReferenceMutator,length,size,3,6.567366E-5,binaryData.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3159,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32859,32864,FieldReferenceMutator,length,Length,4,3.7577785E-5,binaryData.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3160,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32869,32869,IdentifierMutator-Literal,0,1,1,0.0023176249,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length ==<mask>) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3161,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32869,32869,IdentifierMutator-Literal,0,length,2,6.4359163E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length ==<mask>) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3162,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32869,32869,IdentifierMutator-Literal,0,512,3,6.382964E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length ==<mask>) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3163,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,823,32869,32869,IdentifierMutator-Literal,0,size,4,5.372668E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length ==<mask>) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3164,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,824,32893,32902,IdentifierMutator-Variable,binaryData,null,0,0.8820098,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return<mask>;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3165,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,824,32893,32902,IdentifierMutator-Variable,binaryData,"""""",1,0.059664775,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return<mask>;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3166,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,824,32893,32902,IdentifierMutator-Variable,binaryData,bytes,2,0.008040699,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return<mask>;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3167,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,824,32893,32902,IdentifierMutator-Variable,binaryData,"''",3,0.0051728585,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return<mask>;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3168,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,824,32893,32902,IdentifierMutator-Variable,binaryData,NULL,4,0.005101975,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return<mask>;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3169,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32935,32949,MethodCallMutator,getEncodeLength,encode,0,0.41392827,"<mask>(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len =<mask>(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3170,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32935,32949,MethodCallMutator,getEncodeLength,decode,1,0.10630558,"<mask>(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len =<mask>(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3171,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32935,32949,MethodCallMutator,getEncodeLength,len,2,0.09657693,"<mask>(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len =<mask>(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3172,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32935,32949,MethodCallMutator,getEncodeLength,length,3,0.065397725,"<mask>(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len =<mask>(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3173,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32935,32949,MethodCallMutator,getEncodeLength,read,4,0.04596563,"<mask>(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len =<mask>(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3174,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32951,32960,IdentifierMutator-Variable,binaryData,data,0,0.3766122,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(<mask>, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3175,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32951,32960,IdentifierMutator-Variable,binaryData,input,1,0.22583191,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(<mask>, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3176,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32951,32960,IdentifierMutator-Variable,binaryData,bytes,2,0.03910122,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(<mask>, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3177,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32951,32960,IdentifierMutator-Variable,binaryData,binary,3,0.03250378,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(<mask>, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3178,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32951,32960,IdentifierMutator-Variable,binaryData,array,4,0.030689143,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(<mask>, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3179,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32963,32993,IdentifierMutator-Conditional,isChunked?org.apache.commons.codec.binary.Base64.MIME_CHUNK_SIZE:0,0,0,0.58408165,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3180,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32963,32993,IdentifierMutator-Conditional,isChunked?org.apache.commons.codec.binary.Base64.MIME_CHUNK_SIZE:0,true,1,0.079815425,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3181,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32963,32993,IdentifierMutator-Conditional,isChunked?org.apache.commons.codec.binary.Base64.MIME_CHUNK_SIZE:0,false,2,0.06417632,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3182,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32963,32993,IdentifierMutator-Conditional,isChunked?org.apache.commons.codec.binary.Base64.MIME_CHUNK_SIZE:0,null,3,0.015368145,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3183,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32963,32993,IdentifierMutator-Conditional,isChunked?org.apache.commons.codec.binary.Base64.MIME_CHUNK_SIZE:0,encoding,4,0.009270011,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3184,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32963,32971,IdentifierMutator-Variable,isChunked,chunk,0,0.76236564,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask> ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3185,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32963,32971,IdentifierMutator-Variable,isChunked,chunks,1,0.08171874,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask> ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3186,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32963,32971,IdentifierMutator-Variable,isChunked,compress,2,0.008456761,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask> ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3187,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32963,32971,IdentifierMutator-Variable,isChunked,compressed,3,0.008208284,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask> ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3188,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32963,32971,IdentifierMutator-Variable,isChunked,multi,4,0.007103671,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask> ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3189,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32975,32989,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MIME_CHUNK_SIZE,1,0,0.651733,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ?<mask> : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3190,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32975,32989,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MIME_CHUNK_SIZE,2,1,0.055070452,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ?<mask> : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3191,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32975,32989,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MIME_CHUNK_SIZE,255,2,0.03442381,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ?<mask> : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3192,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32975,32989,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MIME_CHUNK_SIZE,512,3,0.022570712,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ?<mask> : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3193,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32975,32989,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MIME_CHUNK_SIZE,4096,4,0.020544402,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ?<mask> : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3194,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32975,32989,FieldReferenceMutator,MIME_CHUNK_SIZE,1,0,0.651733,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ?<mask> : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3195,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32975,32989,FieldReferenceMutator,MIME_CHUNK_SIZE,2,1,0.055070452,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ?<mask> : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3196,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32975,32989,FieldReferenceMutator,MIME_CHUNK_SIZE,255,2,0.03442381,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ?<mask> : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3197,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32975,32989,FieldReferenceMutator,MIME_CHUNK_SIZE,512,3,0.022570712,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ?<mask> : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3198,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32975,32989,FieldReferenceMutator,MIME_CHUNK_SIZE,4096,4,0.020544402,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ?<mask> : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3199,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32993,32993,IdentifierMutator-Literal,0,1,1,0.049814258,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE :<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3200,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32993,32993,IdentifierMutator-Literal,0,512,2,0.015015706,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE :<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3201,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32993,32993,IdentifierMutator-Literal,0,2,3,0.008154514,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE :<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3202,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32993,32993,IdentifierMutator-Literal,0,4,4,0.007481604,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE :<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3203,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32996,33010,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,true,0,0.3820909,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3204,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32996,33010,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,false,1,0.22584982,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3205,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32996,33010,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,encoding,2,0.073619716,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3206,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32996,33010,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,0,3,0.032460537,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3207,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32996,33010,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,null,4,0.018707033,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3208,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32996,33010,FieldReferenceMutator,CHUNK_SEPARATOR,true,0,0.3820909,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3209,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32996,33010,FieldReferenceMutator,CHUNK_SEPARATOR,false,1,0.22584982,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3210,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32996,33010,FieldReferenceMutator,CHUNK_SEPARATOR,encoding,2,0.073619716,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3211,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32996,33010,FieldReferenceMutator,CHUNK_SEPARATOR,0,3,0.032460537,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3212,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,827,32996,33010,FieldReferenceMutator,CHUNK_SEPARATOR,null,4,0.018707033,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3213,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,828,33029,33031,BinaryOperatorMutator,>,<,2,0.03254904,len <mask> maxResultSize,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len<mask>maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3214,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,828,33029,33031,BinaryOperatorMutator,>,>=,3,0.019213585,len <mask> maxResultSize,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len<mask>maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3215,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,828,33029,33031,BinaryOperatorMutator,>,<=,4,0.0056498237,len <mask> maxResultSize,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len<mask>maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3216,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,828,33026,33028,IdentifierMutator-Variable,len,Len,1,3.60373E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (<mask> > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3217,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,828,33026,33028,IdentifierMutator-Variable,len,length,3,1.0666329E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (<mask> > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3218,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,828,33026,33028,IdentifierMutator-Variable,len,en,4,2.7596509E-5,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (<mask> > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3219,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,828,33032,33044,IdentifierMutator-Variable,maxResultSize,max,0,0.3056564,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len ><mask>) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3220,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,828,33032,33044,IdentifierMutator-Variable,maxResultSize,limit,1,0.05891111,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len ><mask>) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3221,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,828,33032,33044,IdentifierMutator-Variable,maxResultSize,1024,2,0.050403617,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len ><mask>) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3222,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,828,33032,33044,IdentifierMutator-Variable,maxResultSize,64,3,0.05036153,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len ><mask>) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3223,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,828,33032,33044,IdentifierMutator-Variable,maxResultSize,255,4,0.047965378,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len ><mask>) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3224,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,831,33232,33250,BinaryOperatorMutator,+,"""+",2,0.18151037,"((""Input array too big, the output array would be bigger ("" + len) + "") than the specified maxium size of "") <mask> maxResultSize","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of ""<mask>maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3225,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,831,33232,33250,BinaryOperatorMutator,+,+(,3,0.0033165868,"((""Input array too big, the output array would be bigger ("" + len) + "") than the specified maxium size of "") <mask> maxResultSize","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of ""<mask>maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3226,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,831,33232,33250,BinaryOperatorMutator,+,//,4,5.3367455E-4,"((""Input array too big, the output array would be bigger ("" + len) + "") than the specified maxium size of "") <mask> maxResultSize","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of ""<mask>maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3227,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,830,33175,33193,BinaryOperatorMutator,+,"\",2,0.0054147304,"(""Input array too big, the output array would be bigger ("" + len) <mask> "") than the specified maxium size of ""","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len<mask>"") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3228,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,830,33175,33193,BinaryOperatorMutator,+,)+,3,0.00415546,"(""Input array too big, the output array would be bigger ("" + len) <mask> "") than the specified maxium size of ""","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len<mask>"") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3229,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,830,33175,33193,BinaryOperatorMutator,+,"\",4,0.0022241154,"(""Input array too big, the output array would be bigger ("" + len) <mask> "") than the specified maxium size of ""","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len<mask>"") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3230,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,829,33153,33171,BinaryOperatorMutator,+,+(,2,0.0022819203,"""Input array too big, the output array would be bigger ("" <mask> len","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger (""<mask>len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3231,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,829,33153,33171,BinaryOperatorMutator,+,"""+",3,6.9036975E-4,"""Input array too big, the output array would be bigger ("" <mask> len","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger (""<mask>len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3232,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,829,33153,33171,BinaryOperatorMutator,+,*,4,8.184622E-5,"""Input array too big, the output array would be bigger ("" <mask> len","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger (""<mask>len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3233,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,829,33096,33152,IdentifierMutator-Literal,"""Inputarraytoobig,theoutputarraywouldbebigger(""","(""",0,0.6273974,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(<mask> +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3234,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,829,33096,33152,IdentifierMutator-Literal,"""Inputarraytoobig,theoutputarraywouldbebigger(""","{""",1,0.04020679,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(<mask> +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3235,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,829,33096,33152,IdentifierMutator-Literal,"""Inputarraytoobig,theoutputarraywouldbebigger(""","""",2,0.038641278,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(<mask> +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3236,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,829,33096,33152,IdentifierMutator-Literal,"""Inputarraytoobig,theoutputarraywouldbebigger(""","""""",3,0.031289257,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(<mask> +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3237,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,829,33096,33152,IdentifierMutator-Literal,"""Inputarraytoobig,theoutputarraywouldbebigger(""",(,4,0.025082877,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(<mask> +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3238,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,830,33172,33174,IdentifierMutator-Variable,len,length,1,9.1571326E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +<mask> +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3239,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,830,33172,33174,IdentifierMutator-Variable,len,str,2,4.6965963E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +<mask> +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3240,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,830,33172,33174,IdentifierMutator-Variable,len,lang,4,2.980792E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +<mask> +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3241,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,831,33194,33231,IdentifierMutator-Literal,""")thanthespecifiedmaxiumsizeof""",//,0,0.43135762,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +<mask> +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3242,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,831,33194,33231,IdentifierMutator-Literal,""")thanthespecifiedmaxiumsizeof""","""",1,0.11089723,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +<mask> +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3243,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,831,33194,33231,IdentifierMutator-Literal,""")thanthespecifiedmaxiumsizeof""",,2,0.06556516,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +<mask> +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3244,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,831,33194,33231,IdentifierMutator-Literal,""")thanthespecifiedmaxiumsizeof""","""""",3,0.044239014,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +<mask> +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3245,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,831,33194,33231,IdentifierMutator-Literal,""")thanthespecifiedmaxiumsizeof""",),4,0.03470612,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +<mask> +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3246,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,832,33251,33263,IdentifierMutator-Variable,maxResultSize,len,0,0.21829683,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +<mask>);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3247,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,832,33251,33263,IdentifierMutator-Variable,maxResultSize,size,1,0.15003836,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +<mask>);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3248,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,832,33251,33263,IdentifierMutator-Variable,maxResultSize,max,2,0.11210711,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +<mask>);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3249,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,832,33251,33263,IdentifierMutator-Variable,maxResultSize,1,3,0.044151686,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +<mask>);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3250,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,832,33251,33263,IdentifierMutator-Variable,maxResultSize,limit,4,0.041108552,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +<mask>);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3251,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33315,33387,IdentifierMutator-Conditional,"(isChunked)?neworg.apache.commons.codec.binary.Base64(urlSafe):neworg.apache.commons.codec.binary.Base64(0,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,urlSafe)",null,0,0.8546949,<mask>,", boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask>;
        return b64.encode(binaryData);
    }"
3252,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33315,33387,IdentifierMutator-Conditional,"(isChunked)?neworg.apache.commons.codec.binary.Base64(urlSafe):neworg.apache.commons.codec.binary.Base64(0,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,urlSafe)",this,1,0.067007855,<mask>,", boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask>;
        return b64.encode(binaryData);
    }"
3253,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33315,33387,IdentifierMutator-Conditional,"(isChunked)?neworg.apache.commons.codec.binary.Base64(urlSafe):neworg.apache.commons.codec.binary.Base64(0,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,urlSafe)",NULL,2,0.019104088,<mask>,", boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask>;
        return b64.encode(binaryData);
    }"
3254,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33315,33387,IdentifierMutator-Conditional,"(isChunked)?neworg.apache.commons.codec.binary.Base64(urlSafe):neworg.apache.commons.codec.binary.Base64(0,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,urlSafe)","""""",3,0.009262083,<mask>,", boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask>;
        return b64.encode(binaryData);
    }"
3255,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33315,33387,IdentifierMutator-Conditional,"(isChunked)?neworg.apache.commons.codec.binary.Base64(urlSafe):neworg.apache.commons.codec.binary.Base64(0,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,urlSafe)",64,4,0.0027631926,<mask>,", boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask>;
        return b64.encode(binaryData);
    }"
3256,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33315,33323,IdentifierMutator-Variable,isChunked,secure,0,0.3023744,<mask>,", boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask> ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3257,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33315,33323,IdentifierMutator-Variable,isChunked,safe,1,0.23257548,<mask>,", boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask> ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3258,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33315,33323,IdentifierMutator-Variable,isChunked,strict,2,0.029161332,<mask>,", boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask> ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3259,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33315,33323,IdentifierMutator-Variable,isChunked,encode,3,0.022454845,<mask>,", boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask> ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3260,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33315,33323,IdentifierMutator-Variable,isChunked,encoded,4,0.019849315,<mask>,", boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask> ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3261,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33338,33344,IdentifierMutator-Variable,urlSafe,0,0,0.08833909,<mask>,") {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(<mask>) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3262,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33338,33344,IdentifierMutator-Variable,urlSafe,data,1,0.084962815,<mask>,") {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(<mask>) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3263,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33338,33344,IdentifierMutator-Variable,urlSafe,bytes,2,0.08392349,<mask>,") {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(<mask>) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3264,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33338,33344,IdentifierMutator-Variable,urlSafe,64,3,0.052587893,<mask>,") {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(<mask>) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3265,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33338,33344,IdentifierMutator-Variable,urlSafe,512,4,0.05152867,<mask>,") {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(<mask>) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3266,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33360,33360,IdentifierMutator-Literal,0,data,0,0.18061318,<mask>,"   if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(<mask>, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3267,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33360,33360,IdentifierMutator-Literal,0,bytes,1,0.09420245,<mask>,"   if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(<mask>, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3268,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33360,33360,IdentifierMutator-Literal,0,null,3,0.0568446,<mask>,"   if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(<mask>, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3269,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33360,33360,IdentifierMutator-Literal,0,"''",4,0.033317965,<mask>,"   if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(<mask>, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3270,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33363,33377,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,len,0,0.7097721,<mask>," if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3271,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33363,33377,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,0,1,0.09873282,<mask>," if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3272,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33363,33377,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,length,2,0.015173707,<mask>," if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3273,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33363,33377,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,"''",3,0.013476328,<mask>," if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3274,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33363,33377,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,null,4,0.013018552,<mask>," if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3275,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33363,33377,FieldReferenceMutator,CHUNK_SEPARATOR,len,0,0.7097721,org.apache.commons.codec.binary.Base64.<mask>," if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3276,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33363,33377,FieldReferenceMutator,CHUNK_SEPARATOR,0,1,0.09873282,org.apache.commons.codec.binary.Base64.<mask>," if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3277,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33363,33377,FieldReferenceMutator,CHUNK_SEPARATOR,length,2,0.015173707,org.apache.commons.codec.binary.Base64.<mask>," if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3278,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33363,33377,FieldReferenceMutator,CHUNK_SEPARATOR,"''",3,0.013476328,org.apache.commons.codec.binary.Base64.<mask>," if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3279,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33363,33377,FieldReferenceMutator,CHUNK_SEPARATOR,null,4,0.013018552,org.apache.commons.codec.binary.Base64.<mask>," if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3280,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33380,33386,IdentifierMutator-Variable,urlSafe,len,0,0.20378347,<mask>,"Data.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR,<mask>);
        return b64.encode(binaryData);
    }"
3281,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33380,33386,IdentifierMutator-Variable,urlSafe,0,1,0.10632348,<mask>,"Data.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR,<mask>);
        return b64.encode(binaryData);
    }"
3282,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33380,33386,IdentifierMutator-Variable,urlSafe,"''",2,0.058992147,<mask>,"Data.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR,<mask>);
        return b64.encode(binaryData);
    }"
3283,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33380,33386,IdentifierMutator-Variable,urlSafe,true,3,0.055474788,<mask>,"Data.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR,<mask>);
        return b64.encode(binaryData);
    }"
3284,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,835,33380,33386,IdentifierMutator-Variable,urlSafe,encoded,4,0.044722576,<mask>,"Data.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR,<mask>);
        return b64.encode(binaryData);
    }"
3285,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,836,33409,33414,MethodCallMutator,encode,write,0,0.45642254,b64.<mask>(binaryData),"     return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.<mask>(binaryData);
    }"
3286,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,836,33409,33414,MethodCallMutator,encode,code,1,0.19168545,b64.<mask>(binaryData),"     return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.<mask>(binaryData);
    }"
3287,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,836,33409,33414,MethodCallMutator,encode,copy,3,0.034652248,b64.<mask>(binaryData),"     return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.<mask>(binaryData);
    }"
3288,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,836,33409,33414,MethodCallMutator,encode,replace,4,0.031840447,b64.<mask>(binaryData),"     return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.<mask>(binaryData);
    }"
3289,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,836,33405,33407,IdentifierMutator-Variable,b64,enc,0,0.3864982,<mask>,"        return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return<mask>.encode(binaryData);
    }"
3290,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,836,33405,33407,IdentifierMutator-Variable,b64,codec,1,0.16667545,<mask>,"        return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return<mask>.encode(binaryData);
    }"
3291,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,836,33405,33407,IdentifierMutator-Variable,b64,super,2,0.07220589,<mask>,"        return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return<mask>.encode(binaryData);
    }"
3292,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,836,33405,33407,IdentifierMutator-Variable,b64,bos,3,0.032487974,<mask>,"        return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return<mask>.encode(binaryData);
    }"
3293,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,836,33405,33407,IdentifierMutator-Variable,b64,this,4,0.023423629,<mask>,"        return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return<mask>.encode(binaryData);
    }"
3294,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,836,33416,33425,IdentifierMutator-Variable,binaryData,output,0,0.15265374,<mask>,"  return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(<mask>);
    }"
3295,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,836,33416,33425,IdentifierMutator-Variable,binaryData,data,1,0.11899075,<mask>,"  return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(<mask>);
    }"
3296,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,836,33416,33425,IdentifierMutator-Variable,binaryData,bytes,2,0.07933829,<mask>,"  return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(<mask>);
    }"
3297,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,836,33416,33425,IdentifierMutator-Variable,binaryData,null,3,0.059829455,<mask>,"  return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(<mask>);
    }"
3298,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",822,836,33416,33425,IdentifierMutator-Variable,binaryData,string,4,0.05024058,<mask>,"  return binaryData;
        }

        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(<mask>);
    }"
3299,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),847,848,33730,33735,MethodCallMutator,decode,read,0,0.23005044,new Base64().<mask>(base64String),"byte[] decodeBase64(String base64String) {
        return new Base64().<mask>(base64String);
    }"
3300,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),847,848,33730,33735,MethodCallMutator,decode,ode,2,0.13044131,new Base64().<mask>(base64String),"byte[] decodeBase64(String base64String) {
        return new Base64().<mask>(base64String);
    }"
3301,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),847,848,33730,33735,MethodCallMutator,decode,load,3,0.113766424,new Base64().<mask>(base64String),"byte[] decodeBase64(String base64String) {
        return new Base64().<mask>(base64String);
    }"
3302,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),847,848,33730,33735,MethodCallMutator,decode,dec,4,0.08550016,new Base64().<mask>(base64String),"byte[] decodeBase64(String base64String) {
        return new Base64().<mask>(base64String);
    }"
3303,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),847,848,33737,33748,IdentifierMutator-Variable,base64String,string,0,0.51462966,<mask>,"byte[] decodeBase64(String base64String) {
        return new Base64().decode(<mask>);
    }"
3304,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),847,848,33737,33748,IdentifierMutator-Variable,base64String,bytes,1,0.14441289,<mask>,"byte[] decodeBase64(String base64String) {
        return new Base64().decode(<mask>);
    }"
3305,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),847,848,33737,33748,IdentifierMutator-Variable,base64String,input,2,0.050064214,<mask>,"byte[] decodeBase64(String base64String) {
        return new Base64().decode(<mask>);
    }"
3306,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),847,848,33737,33748,IdentifierMutator-Variable,base64String,data,3,0.043782957,<mask>,"byte[] decodeBase64(String base64String) {
        return new Base64().decode(<mask>);
    }"
3307,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),847,848,33737,33748,IdentifierMutator-Variable,base64String,str,4,0.033860866,<mask>,"byte[] decodeBase64(String base64String) {
        return new Base64().decode(<mask>);
    }"
3308,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),858,859,34032,34037,MethodCallMutator,decode,read,0,0.16027991,new Base64().<mask>(base64Data),"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().<mask>(base64Data);
    }"
3309,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),858,859,34032,34037,MethodCallMutator,decode,split,2,0.117556654,new Base64().<mask>(base64Data),"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().<mask>(base64Data);
    }"
3310,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),858,859,34032,34037,MethodCallMutator,decode,load,3,0.0880729,new Base64().<mask>(base64Data),"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().<mask>(base64Data);
    }"
3311,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),858,859,34032,34037,MethodCallMutator,decode,ode,4,0.08669638,new Base64().<mask>(base64Data),"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().<mask>(base64Data);
    }"
3312,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),858,859,34039,34048,IdentifierMutator-Variable,base64Data,data,0,0.84126043,<mask>,"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().decode(<mask>);
    }"
3313,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),858,859,34039,34048,IdentifierMutator-Variable,base64Data,bytes,1,0.039528534,<mask>,"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().decode(<mask>);
    }"
3314,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),858,859,34039,34048,IdentifierMutator-Variable,base64Data,input,2,0.023998328,<mask>,"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().decode(<mask>);
    }"
3315,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),858,859,34039,34048,IdentifierMutator-Variable,base64Data,buffer,3,0.013202573,<mask>,"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().decode(<mask>);
    }"
3316,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),858,859,34039,34048,IdentifierMutator-Variable,base64Data,raw,4,0.008954871,<mask>,"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().decode(<mask>);
    }"
3317,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,871,34435,34445,IdentifierMutator-Variable,data.length,size,0,0.088934466,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3318,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,871,34435,34445,IdentifierMutator-Variable,data.length,0,1,0.07688801,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3319,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,871,34435,34445,IdentifierMutator-Variable,data.length,1024,2,0.07662493,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3320,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,871,34435,34445,IdentifierMutator-Variable,data.length,1,3,0.038702115,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3321,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,871,34435,34445,IdentifierMutator-Variable,data.length,16,4,0.037849266,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3322,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,871,34435,34438,IdentifierMutator-Variable,data,Data,2,7.707885E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3323,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,871,34435,34438,IdentifierMutator-Variable,data,DATA,3,1.8118248E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3324,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,871,34435,34438,IdentifierMutator-Variable,data,string,4,1.207517E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3325,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,871,34440,34445,FieldReferenceMutator,length,size,1,4.4816086E-5,data.<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3326,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,871,34440,34445,FieldReferenceMutator,length,len,3,1.0469613E-5,data.<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3327,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,871,34440,34445,FieldReferenceMutator,length,count,4,6.2486515E-6,data.<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3328,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,872,34475,34475,IdentifierMutator-Literal,0,1,1,0.037395295,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied =<mask>;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3329,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,872,34475,34475,IdentifierMutator-Literal,0,2,2,0.0011831039,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied =<mask>;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3330,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,872,34475,34475,IdentifierMutator-Literal,0,4,3,4.8331072E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied =<mask>;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3331,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34499,34499,IdentifierMutator-Literal,0,1,1,0.0064545837,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i =<mask>; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3332,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34499,34499,IdentifierMutator-Literal,0,i,3,2.7148053E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i =<mask>; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3333,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34499,34499,IdentifierMutator-Literal,0,2,4,2.3112416E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i =<mask>; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3334,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34503,34505,BinaryOperatorMutator,<,++,2,0.0012738135,i <mask> data.length,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i<mask>data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3335,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34503,34505,BinaryOperatorMutator,<,==,3,6.527805E-4,i <mask> data.length,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i<mask>data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3336,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34503,34505,BinaryOperatorMutator,<,.<,4,5.5742805E-4,i <mask> data.length,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i<mask>data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3337,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34502,34502,IdentifierMutator-Variable,i,I,2,8.1750586E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0;<mask> < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3338,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34502,34502,IdentifierMutator-Variable,i,0,3,4.6001685E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0;<mask> < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3339,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34502,34502,IdentifierMutator-Variable,i,I,4,3.5065892E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0;<mask> < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3340,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34506,34516,IdentifierMutator-Variable,data.length,length,0,0.20823966,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3341,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34506,34516,IdentifierMutator-Variable,data.length,size,1,0.14010033,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3342,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34506,34516,IdentifierMutator-Variable,data.length,len,2,0.10720097,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3343,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34506,34516,IdentifierMutator-Variable,data.length,n,3,0.046964757,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3344,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34506,34516,IdentifierMutator-Variable,data.length,256,4,0.04154463,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3345,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34506,34509,IdentifierMutator-Variable,data,buffer,2,1.7749013E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3346,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34506,34509,IdentifierMutator-Variable,data,Data,3,1.2010338E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3347,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34506,34509,IdentifierMutator-Variable,data,input,4,9.787504E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3348,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34511,34516,FieldReferenceMutator,length,size,2,1.1294446E-5,data.<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3349,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34511,34516,FieldReferenceMutator,length,Length,3,5.3892527E-6,data.<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3350,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34511,34516,FieldReferenceMutator,length,position,4,4.986031E-6,data.<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3351,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34520,34521,UnaryOperatorMutator,++,++),2,0.004225447,i<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i<mask>) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3352,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34520,34521,UnaryOperatorMutator,++,++;,3,2.2569772E-4,i<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i<mask>) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3353,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34520,34521,UnaryOperatorMutator,++,--,4,1.2584057E-4,i<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i<mask>) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3354,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34519,34519,IdentifierMutator-Variable,i,I,2,2.4985928E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length;<mask>++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3355,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34519,34519,IdentifierMutator-Variable,i,++,3,1.842373E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length;<mask>++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3356,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,873,34519,34519,IdentifierMutator-Variable,i,,4,1.6523276E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length;<mask>++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3357,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,874,34551,34551,ArrayAccessMutator,i,I,2,4.016381E-5,data[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[<mask>]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3358,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,874,34551,34551,ArrayAccessMutator,i,0,3,2.2881375E-5,data[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[<mask>]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3359,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,874,34551,34551,ArrayAccessMutator,i,j,4,9.057474E-6,data[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[<mask>]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3360,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,874,34546,34549,IdentifierMutator-Variable,data,input,2,1.8172493E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (<mask>[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3361,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,874,34546,34549,IdentifierMutator-Variable,data,string,3,1.7926209E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (<mask>[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3362,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,874,34546,34549,IdentifierMutator-Variable,data,Data,4,1.5542985E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (<mask>[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3363,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,874,34551,34551,IdentifierMutator-Variable,i,I,2,4.016381E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[<mask>]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3364,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,874,34551,34551,IdentifierMutator-Variable,i,0,3,2.2881375E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[<mask>]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3365,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,874,34551,34551,IdentifierMutator-Variable,i,j,4,9.057474E-6,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[<mask>]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3366,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,875,34578,34580,IdentifierMutator-Literal,"''",0,1,0.08244818,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case<mask> :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3367,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,875,34578,34580,IdentifierMutator-Literal,"''",127,2,0.06145017,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case<mask> :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3368,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,875,34578,34580,IdentifierMutator-Literal,"''",null,3,0.0526348,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case<mask> :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3369,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,875,34578,34580,IdentifierMutator-Literal,"''","'",4,0.041249163,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case<mask> :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3370,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,876,34605,34608,IdentifierMutator-Literal,"'\n'","''",0,0.28521597,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case<mask> :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3371,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,876,34605,34608,IdentifierMutator-Literal,"'\n'",0,1,0.089137726,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case<mask> :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3372,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,876,34605,34608,IdentifierMutator-Literal,"'\n'",null,2,0.04380775,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case<mask> :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3373,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,876,34605,34608,IdentifierMutator-Literal,"'\n'","'",3,0.029761141,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case<mask> :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3374,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,876,34605,34608,IdentifierMutator-Literal,"'\n'",32,4,0.029639969,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case<mask> :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3375,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,877,34633,34636,IdentifierMutator-Literal,"'\r'","''",0,0.5357186,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case<mask> :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3376,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,877,34633,34636,IdentifierMutator-Literal,"'\r'",0,1,0.065153934,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case<mask> :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3377,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,877,34633,34636,IdentifierMutator-Literal,"'\r'",null,2,0.048696417,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case<mask> :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3378,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,877,34633,34636,IdentifierMutator-Literal,"'\r'",undefined,3,0.012858429,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case<mask> :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3379,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,877,34633,34636,IdentifierMutator-Literal,"'\r'",2,4,0.01121744,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case<mask> :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3380,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,878,34661,34664,IdentifierMutator-Literal,"'\t'","''",0,0.6441391,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case<mask> :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3381,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,878,34661,34664,IdentifierMutator-Literal,"'\t'",null,1,0.116853796,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case<mask> :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3382,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,878,34661,34664,IdentifierMutator-Literal,"'\t'",undefined,2,0.038914785,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case<mask> :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3383,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,878,34661,34664,IdentifierMutator-Literal,"'\t'",0,3,0.022741282,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case<mask> :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3384,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,878,34661,34664,IdentifierMutator-Literal,"'\t'",false,4,0.015436804,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case<mask> :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3385,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34767,34767,AssignmentMutator,groomedData[bytesCopied++]=data[i],^,0,0.6197974,groomedData[bytesCopied++] <mask>= data[i],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++]<mask>= data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3386,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34767,34767,AssignmentMutator,groomedData[bytesCopied++]=data[i],|,1,0.33990026,groomedData[bytesCopied++] <mask>= data[i],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++]<mask>= data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3387,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34767,34767,AssignmentMutator,groomedData[bytesCopied++]=data[i],*,2,0.012758829,groomedData[bytesCopied++] <mask>= data[i],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++]<mask>= data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3388,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34767,34767,AssignmentMutator,groomedData[bytesCopied++]=data[i],&,3,0.0063087577,groomedData[bytesCopied++] <mask>= data[i],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++]<mask>= data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3389,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34767,34767,AssignmentMutator,groomedData[bytesCopied++]=data[i],.,4,0.0041533955,groomedData[bytesCopied++] <mask>= data[i],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++]<mask>= data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3390,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34753,34765,ArrayAccessMutator,bytesCopied++,i,0,0.99585956,groomedData[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3391,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34753,34765,ArrayAccessMutator,bytesCopied++,i,1,7.5192103E-4,groomedData[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3392,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34753,34765,ArrayAccessMutator,bytesCopied++,0,2,5.581337E-4,groomedData[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3393,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34753,34765,ArrayAccessMutator,bytesCopied++,j,3,5.111515E-4,groomedData[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3394,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34753,34765,ArrayAccessMutator,bytesCopied++,1,4,1.2407721E-4,groomedData[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3395,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34741,34751,IdentifierMutator-Variable,groomedData,data,0,0.5821798,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :<mask>[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3396,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34741,34751,IdentifierMutator-Variable,groomedData,buffer,1,0.035347022,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :<mask>[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3397,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34741,34751,IdentifierMutator-Variable,groomedData,data,2,0.028639225,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :<mask>[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3398,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34741,34751,IdentifierMutator-Variable,groomedData,bytes,3,0.025771677,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :<mask>[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3399,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34741,34751,IdentifierMutator-Variable,groomedData,byte,4,0.025038369,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :<mask>[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3400,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34764,34765,UnaryOperatorMutator,++,][,2,0.053754125,bytesCopied<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3401,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34764,34765,UnaryOperatorMutator,++,Index,3,0.0029078415,bytesCopied<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3402,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34764,34765,UnaryOperatorMutator,++,:,4,0.0018770318,bytesCopied<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3403,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34753,34763,IdentifierMutator-Variable,bytesCopied,i,0,0.9793088,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3404,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34753,34763,IdentifierMutator-Variable,bytesCopied,j,1,0.0033990694,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3405,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34753,34763,IdentifierMutator-Variable,bytesCopied,c,2,0.0017561538,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3406,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34753,34763,IdentifierMutator-Variable,bytesCopied,i,3,0.0016460998,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3407,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34753,34763,IdentifierMutator-Variable,bytesCopied,d,4,0.0010722802,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3408,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34775,34775,ArrayAccessMutator,i,j,2,1.691398E-4,data[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[<mask>];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3409,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34775,34775,ArrayAccessMutator,i,I,3,1.0576023E-4,data[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[<mask>];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3410,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34775,34775,ArrayAccessMutator,i,c,4,3.8448088E-5,data[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[<mask>];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3411,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34770,34773,IdentifierMutator-Variable,data,buffer,2,9.732032E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] =<mask>[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3412,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34770,34773,IdentifierMutator-Variable,data,text,3,9.033422E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] =<mask>[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3413,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34770,34773,IdentifierMutator-Variable,data,input,4,4.8283306E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] =<mask>[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3414,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34775,34775,IdentifierMutator-Variable,i,j,2,1.691398E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[<mask>];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3415,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34775,34775,IdentifierMutator-Variable,i,I,3,1.0576023E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[<mask>];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3416,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,881,34775,34775,IdentifierMutator-Variable,i,c,4,3.8448088E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[<mask>];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3417,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,884,34840,34850,IdentifierMutator-Variable,bytesCopied,0,0,0.16547705,<mask>,"        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[<mask>];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3418,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,884,34840,34850,IdentifierMutator-Variable,bytesCopied,1024,1,0.08230046,<mask>,"        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[<mask>];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3419,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,884,34840,34850,IdentifierMutator-Variable,bytesCopied,size,2,0.075461954,<mask>,"        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[<mask>];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3420,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,884,34840,34850,IdentifierMutator-Variable,bytesCopied,1,3,0.044450767,<mask>,"        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[<mask>];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3421,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,884,34840,34850,IdentifierMutator-Variable,bytesCopied,64,4,0.03297563,<mask>,"        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[<mask>];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3422,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34869,34877,MethodCallMutator,arraycopy,copy,0,0.98436165,"System.<mask>(groomedData, 0, packedData, 0, bytesCopied)","
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.<mask>(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3423,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34869,34877,MethodCallMutator,arraycopy,dump,1,0.0050194873,"System.<mask>(groomedData, 0, packedData, 0, bytesCopied)","
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.<mask>(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3424,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34869,34877,MethodCallMutator,arraycopy,printf,2,0.0035116472,"System.<mask>(groomedData, 0, packedData, 0, bytesCopied)","
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.<mask>(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3425,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34869,34877,MethodCallMutator,arraycopy,array,3,0.002767085,"System.<mask>(groomedData, 0, packedData, 0, bytesCopied)","
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.<mask>(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3426,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34869,34877,MethodCallMutator,arraycopy,write,4,5.26446E-4,"System.<mask>(groomedData, 0, packedData, 0, bytesCopied)","
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.<mask>(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3427,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34879,34889,IdentifierMutator-Variable,groomedData,data,0,0.98286706,<mask>,"      for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(<mask>, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3428,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34879,34889,IdentifierMutator-Variable,groomedData,buffer,1,0.0033180923,<mask>,"      for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(<mask>, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3429,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34879,34889,IdentifierMutator-Variable,groomedData,bytes,2,0.0025030847,<mask>,"      for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(<mask>, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3430,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34879,34889,IdentifierMutator-Variable,groomedData,DATA,3,7.962062E-4,<mask>,"      for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(<mask>, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3431,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34879,34889,IdentifierMutator-Variable,groomedData,buf,4,5.89633E-4,<mask>,"      for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(<mask>, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3432,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34892,34892,IdentifierMutator-Literal,0,1,1,0.011507818,<mask>," for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData,<mask>, packedData, 0, bytesCopied);
        return packedData;
    }"
3433,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34892,34892,IdentifierMutator-Literal,0,i,3,0.0029997528,<mask>," for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData,<mask>, packedData, 0, bytesCopied);
        return packedData;
    }"
3434,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34892,34892,IdentifierMutator-Literal,0,2,4,0.0010386878,<mask>," for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData,<mask>, packedData, 0, bytesCopied);
        return packedData;
    }"
3435,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34895,34904,IdentifierMutator-Variable,packedData,data,0,0.89924085,<mask>,"int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0,<mask>, 0, bytesCopied);
        return packedData;
    }"
3436,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34895,34904,IdentifierMutator-Variable,packedData,packed,1,0.033504687,<mask>,"int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0,<mask>, 0, bytesCopied);
        return packedData;
    }"
3437,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34895,34904,IdentifierMutator-Variable,packedData,array,2,0.007896026,<mask>,"int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0,<mask>, 0, bytesCopied);
        return packedData;
    }"
3438,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34895,34904,IdentifierMutator-Variable,packedData,tmp,3,0.0047962023,<mask>,"int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0,<mask>, 0, bytesCopied);
        return packedData;
    }"
3439,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34895,34904,IdentifierMutator-Variable,packedData,buf,4,0.0030134527,<mask>,"int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0,<mask>, 0, bytesCopied);
        return packedData;
    }"
3440,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34907,34907,IdentifierMutator-Literal,0,1,1,0.011871785,<mask>," 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData,<mask>, bytesCopied);
        return packedData;
    }"
3441,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34907,34907,IdentifierMutator-Literal,0,i,3,7.7413017E-4,<mask>," 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData,<mask>, bytesCopied);
        return packedData;
    }"
3442,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34907,34907,IdentifierMutator-Literal,0,2,4,7.4331305E-4,<mask>," 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData,<mask>, bytesCopied);
        return packedData;
    }"
3443,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34910,34920,IdentifierMutator-Variable,bytesCopied,length,0,0.16044208,<mask>," i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0,<mask>);
        return packedData;
    }"
3444,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34910,34920,IdentifierMutator-Variable,bytesCopied,len,1,0.1513442,<mask>," i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0,<mask>);
        return packedData;
    }"
3445,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34910,34920,IdentifierMutator-Variable,bytesCopied,n,2,0.10035997,<mask>," i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0,<mask>);
        return packedData;
    }"
3446,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34910,34920,IdentifierMutator-Variable,bytesCopied,count,3,0.07970854,<mask>," i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0,<mask>);
        return packedData;
    }"
3447,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,885,34910,34920,IdentifierMutator-Variable,bytesCopied,bytes,4,0.07962785,<mask>," i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0,<mask>);
        return packedData;
    }"
3448,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,886,34939,34948,IdentifierMutator-Variable,packedData,0,0,0.1298416,<mask>,"         switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return<mask>;
    }"
3449,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,886,34939,34948,IdentifierMutator-Variable,packedData,data,1,0.11107518,<mask>,"         switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return<mask>;
    }"
3450,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,886,34939,34948,IdentifierMutator-Variable,packedData,true,2,0.099648565,<mask>,"         switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return<mask>;
    }"
3451,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,886,34939,34948,IdentifierMutator-Variable,packedData,null,3,0.08064939,<mask>,"         switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return<mask>;
    }"
3452,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),870,886,34939,34948,IdentifierMutator-Variable,packedData,"""""",4,0.0639,<mask>,"         switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return<mask>;
    }"
3453,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,897,35231,35241,IdentifierMutator-Variable,byteToCheck,byte,0,0.87689835,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (<mask>) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3454,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,897,35231,35241,IdentifierMutator-Variable,byteToCheck,char,1,0.041675314,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (<mask>) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3455,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,897,35231,35241,IdentifierMutator-Variable,byteToCheck,token,2,0.011559272,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (<mask>) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3456,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,897,35231,35241,IdentifierMutator-Variable,byteToCheck,character,3,0.0059702797,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (<mask>) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3457,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,897,35231,35241,IdentifierMutator-Variable,byteToCheck,letter,4,0.0045639197,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (<mask>) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3458,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,898,35263,35265,IdentifierMutator-Literal,"''",127,1,0.11638416,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case<mask> :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3459,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,898,35263,35265,IdentifierMutator-Literal,"''","'",2,0.100291535,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case<mask> :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3460,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,898,35263,35265,IdentifierMutator-Literal,"''",0,3,0.07361801,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case<mask> :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3461,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,898,35263,35265,IdentifierMutator-Literal,"''",null,4,0.030010344,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case<mask> :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3462,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,899,35286,35289,IdentifierMutator-Literal,"'\n'","''",0,0.31404096,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case<mask> :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3463,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,899,35286,35289,IdentifierMutator-Literal,"'\n'",0,1,0.06704349,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case<mask> :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3464,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,899,35286,35289,IdentifierMutator-Literal,"'\n'","'",2,0.048901446,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case<mask> :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3465,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,899,35286,35289,IdentifierMutator-Literal,"'\n'",null,3,0.04076971,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case<mask> :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3466,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,899,35286,35289,IdentifierMutator-Literal,"'\n'",127,4,0.030773241,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case<mask> :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3467,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,900,35310,35313,IdentifierMutator-Literal,"'\r'","''",0,0.31427732,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case<mask> :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3468,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,900,35310,35313,IdentifierMutator-Literal,"'\r'",0,1,0.070253536,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case<mask> :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3469,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,900,35310,35313,IdentifierMutator-Literal,"'\r'",127,2,0.041286614,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case<mask> :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3470,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,900,35310,35313,IdentifierMutator-Literal,"'\r'",null,3,0.0325793,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case<mask> :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3471,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,900,35310,35313,IdentifierMutator-Literal,"'\r'",13,4,0.030142767,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case<mask> :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3472,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,901,35334,35337,IdentifierMutator-Literal,"'\t'","''",0,0.3427563,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case<mask> :
                return true;
            default :
                return false;
        }
    }"
3473,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,901,35334,35337,IdentifierMutator-Literal,"'\t'",0,1,0.13208826,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case<mask> :
                return true;
            default :
                return false;
        }
    }"
3474,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,901,35334,35337,IdentifierMutator-Literal,"'\t'",127,2,0.042970426,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case<mask> :
                return true;
            default :
                return false;
        }
    }"
3475,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,901,35334,35337,IdentifierMutator-Literal,"'\t'",null,3,0.040649995,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case<mask> :
                return true;
            default :
                return false;
        }
    }"
3476,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,901,35334,35337,IdentifierMutator-Literal,"'\t'",128,4,0.03007783,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case<mask> :
                return true;
            default :
                return false;
        }
    }"
3477,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,902,35364,35367,IdentifierMutator-Literal,true,false,1,0.228241,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return<mask>;
            default :
                return false;
        }
    }"
3478,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,902,35364,35367,IdentifierMutator-Literal,true,1,2,3.5760348E-4,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return<mask>;
            default :
                return false;
        }
    }"
3479,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,902,35364,35367,IdentifierMutator-Literal,true,0,3,2.4162118E-4,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return<mask>;
            default :
                return false;
        }
    }"
3480,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,902,35364,35367,IdentifierMutator-Literal,true,null,4,1.45996E-4,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return<mask>;
            default :
                return false;
        }
    }"
3481,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,904,35415,35419,IdentifierMutator-Literal,false,true,1,0.34868783,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return<mask>;
        }
    }"
3482,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,904,35415,35419,IdentifierMutator-Literal,false,null,2,4.913496E-4,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return<mask>;
        }
    }"
3483,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,904,35415,35419,IdentifierMutator-Literal,false,0,3,1.580537E-4,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return<mask>;
        }
    }"
3484,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),896,904,35415,35419,IdentifierMutator-Literal,false,undefined,4,1.2972756E-4,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return<mask>;
        }
    }"
3485,Base64.java,encodeToString,String encodeToString(byte[] pArray),935,936,36676,36688,MethodCallMutator,newStringUtf8,escape,0,0.32738858,StringUtils.<mask>(encode(pArray)),"String encodeToString(byte[] pArray) {
        return StringUtils.<mask>(encode(pArray));
    }"
3486,Base64.java,encodeToString,String encodeToString(byte[] pArray),935,936,36676,36688,MethodCallMutator,newStringUtf8,format,1,0.12487902,StringUtils.<mask>(encode(pArray)),"String encodeToString(byte[] pArray) {
        return StringUtils.<mask>(encode(pArray));
    }"
3487,Base64.java,encodeToString,String encodeToString(byte[] pArray),935,936,36676,36688,MethodCallMutator,newStringUtf8,str,2,0.06766904,StringUtils.<mask>(encode(pArray)),"String encodeToString(byte[] pArray) {
        return StringUtils.<mask>(encode(pArray));
    }"
3488,Base64.java,encodeToString,String encodeToString(byte[] pArray),935,936,36676,36688,MethodCallMutator,newStringUtf8,string,3,0.051101003,StringUtils.<mask>(encode(pArray)),"String encodeToString(byte[] pArray) {
        return StringUtils.<mask>(encode(pArray));
    }"
3489,Base64.java,encodeToString,String encodeToString(byte[] pArray),935,936,36676,36688,MethodCallMutator,newStringUtf8,strip,4,0.043724347,StringUtils.<mask>(encode(pArray)),"String encodeToString(byte[] pArray) {
        return StringUtils.<mask>(encode(pArray));
    }"
3490,Base64.java,encodeToString,String encodeToString(byte[] pArray),935,936,36690,36695,MethodCallMutator,encode,string,0,0.22253141,<mask>(pArray),"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(<mask>(pArray));
    }"
3491,Base64.java,encodeToString,String encodeToString(byte[] pArray),935,936,36690,36695,MethodCallMutator,encode,append,1,0.08873156,<mask>(pArray),"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(<mask>(pArray));
    }"
3492,Base64.java,encodeToString,String encodeToString(byte[] pArray),935,936,36690,36695,MethodCallMutator,encode,format,2,0.07343348,<mask>(pArray),"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(<mask>(pArray));
    }"
3493,Base64.java,encodeToString,String encodeToString(byte[] pArray),935,936,36690,36695,MethodCallMutator,encode,bytes,3,0.04928849,<mask>(pArray),"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(<mask>(pArray));
    }"
3494,Base64.java,encodeToString,String encodeToString(byte[] pArray),935,936,36690,36695,MethodCallMutator,encode,code,4,0.03977998,<mask>(pArray),"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(<mask>(pArray));
    }"
3495,Base64.java,encodeToString,String encodeToString(byte[] pArray),935,936,36697,36702,IdentifierMutator-Variable,pArray,array,0,0.53259575,<mask>,"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(encode(<mask>));
    }"
3496,Base64.java,encodeToString,String encodeToString(byte[] pArray),935,936,36697,36702,IdentifierMutator-Variable,pArray,Array,1,0.43346334,<mask>,"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(encode(<mask>));
    }"
3497,Base64.java,encodeToString,String encodeToString(byte[] pArray),935,936,36697,36702,IdentifierMutator-Variable,pArray,arr,2,0.009440454,<mask>,"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(encode(<mask>));
    }"
3498,Base64.java,encodeToString,String encodeToString(byte[] pArray),935,936,36697,36702,IdentifierMutator-Variable,pArray,p,3,0.0037139037,<mask>,"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(encode(<mask>));
    }"
3499,Base64.java,encodeToString,String encodeToString(byte[] pArray),935,936,36697,36702,IdentifierMutator-Variable,pArray,[],4,0.0021142324,<mask>,"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(encode(<mask>));
    }"
3500,Base64.java,encode,byte[] encode(byte[] pArray),946,947,37037,37041,MethodCallMutator,reset,close,0,0.34351456,<mask>(),"byte[] encode(byte[] pArray) {<mask>();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3501,Base64.java,encode,byte[] encode(byte[] pArray),946,947,37037,37041,MethodCallMutator,reset,flush,1,0.07260073,<mask>(),"byte[] encode(byte[] pArray) {<mask>();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3502,Base64.java,encode,byte[] encode(byte[] pArray),946,947,37037,37041,MethodCallMutator,reset,read,3,0.027984498,<mask>(),"byte[] encode(byte[] pArray) {<mask>();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3503,Base64.java,encode,byte[] encode(byte[] pArray),946,947,37037,37041,MethodCallMutator,reset,cleanup,4,0.026668536,<mask>(),"byte[] encode(byte[] pArray) {<mask>();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3504,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37080,37083,BinaryOperatorMutator,||,|,2,0.0022912438,(pArray == null) <mask> (pArray.length == 0),"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null<mask>pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3505,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37080,37083,BinaryOperatorMutator,||,/,3,0.0015060445,(pArray == null) <mask> (pArray.length == 0),"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null<mask>pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3506,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37080,37083,BinaryOperatorMutator,||,.,4,9.266789E-4,(pArray == null) <mask> (pArray.length == 0),"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null<mask>pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3507,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37072,37075,BinaryOperatorMutator,==,=,2,0.008088386,pArray <mask> null,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray<mask>null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3508,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37072,37075,BinaryOperatorMutator,==,===,3,0.0013527882,pArray <mask> null,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray<mask>null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3509,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37072,37075,BinaryOperatorMutator,==,||,4,5.738421E-4,pArray <mask> null,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray<mask>null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3510,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37066,37071,IdentifierMutator-Variable,pArray,array,0,0.6227661,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3511,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37066,37071,IdentifierMutator-Variable,pArray,Array,1,0.14877442,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3512,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37066,37071,IdentifierMutator-Variable,pArray,null,2,0.021249104,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3513,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37066,37071,IdentifierMutator-Variable,pArray,p,3,0.015885245,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3514,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37066,37071,IdentifierMutator-Variable,pArray,buffer,4,0.009973168,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3515,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37076,37079,IdentifierMutator-Literal,null,nil,1,4.8451222E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3516,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37076,37079,IdentifierMutator-Literal,null,NULL,2,3.6206463E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3517,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37076,37079,IdentifierMutator-Literal,null,undefined,3,7.250075E-5,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3518,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37097,37100,BinaryOperatorMutator,==,>,2,0.019448422,pArray.length <mask> 0,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length<mask>0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3519,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37097,37100,BinaryOperatorMutator,==,=,3,0.015178779,pArray.length <mask> 0,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length<mask>0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3520,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37097,37100,BinaryOperatorMutator,==,<=,4,0.012627361,pArray.length <mask> 0,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length<mask>0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3521,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37084,37096,IdentifierMutator-Variable,pArray.length,pos,0,0.33352798,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3522,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37084,37096,IdentifierMutator-Variable,pArray.length,length,1,0.17889434,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3523,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37084,37096,IdentifierMutator-Variable,pArray.length,len,2,0.13992383,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3524,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37084,37096,IdentifierMutator-Variable,pArray.length,size,3,0.07049084,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3525,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37084,37096,IdentifierMutator-Variable,pArray.length,position,4,0.029070012,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3526,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37084,37089,IdentifierMutator-Variable,pArray,array,0,0.66187257,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3527,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37084,37089,IdentifierMutator-Variable,pArray,Array,1,0.14832906,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3528,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37084,37089,IdentifierMutator-Variable,pArray,Array,2,0.14491846,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3529,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37084,37089,IdentifierMutator-Variable,pArray,p,3,0.019042986,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3530,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37084,37089,IdentifierMutator-Variable,pArray,arr,4,0.0042695533,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3531,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37091,37096,FieldReferenceMutator,length,size,2,3.470346E-5,pArray.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.<mask> == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3532,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37091,37096,FieldReferenceMutator,length,count,3,2.06301E-5,pArray.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.<mask> == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3533,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37091,37096,FieldReferenceMutator,length,Length,4,1.8027695E-5,pArray.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.<mask> == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3534,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37101,37101,IdentifierMutator-Literal,0,1,1,0.0029457621,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3535,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37101,37101,IdentifierMutator-Literal,0,size,2,6.448163E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3536,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37101,37101,IdentifierMutator-Literal,0,length,3,4.9329386E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3537,Base64.java,encode,byte[] encode(byte[] pArray),946,948,37101,37101,IdentifierMutator-Literal,0,zero,4,2.1093721E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3538,Base64.java,encode,byte[] encode(byte[] pArray),946,949,37125,37130,IdentifierMutator-Variable,pArray,null,0,0.9031735,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3539,Base64.java,encode,byte[] encode(byte[] pArray),946,949,37125,37130,IdentifierMutator-Variable,pArray,"""""",1,0.028232746,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3540,Base64.java,encode,byte[] encode(byte[] pArray),946,949,37125,37130,IdentifierMutator-Variable,pArray,[],2,0.0081749065,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3541,Base64.java,encode,byte[] encode(byte[] pArray),946,949,37125,37130,IdentifierMutator-Variable,pArray,array,3,0.00645876,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3542,Base64.java,encode,byte[] encode(byte[] pArray),946,949,37125,37130,IdentifierMutator-Variable,pArray,"''",4,0.006363552,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3543,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37151,37156,MethodCallMutator,encode,decode,1,0.14867638,"<mask>(pArray, 0, pArray.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }<mask>(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3544,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37151,37156,MethodCallMutator,encode,write,2,0.02353241,"<mask>(pArray, 0, pArray.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }<mask>(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3545,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37151,37156,MethodCallMutator,encode,copy,3,0.0046696556,"<mask>(pArray, 0, pArray.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }<mask>(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3546,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37151,37156,MethodCallMutator,encode,read,4,0.004224975,"<mask>(pArray, 0, pArray.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }<mask>(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3547,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37158,37163,IdentifierMutator-Variable,pArray,array,0,0.2659091,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(<mask>, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3548,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37158,37163,IdentifierMutator-Variable,pArray,Array,1,0.19115269,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(<mask>, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3549,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37158,37163,IdentifierMutator-Variable,pArray,buf,2,0.06609174,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(<mask>, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3550,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37158,37163,IdentifierMutator-Variable,pArray,buffer,3,0.061906047,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(<mask>, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3551,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37158,37163,IdentifierMutator-Variable,pArray,null,4,0.050174467,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(<mask>, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3552,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37166,37166,IdentifierMutator-Literal,0,1,1,0.01654821,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray,<mask>, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3553,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37166,37166,IdentifierMutator-Literal,0,pos,2,0.0028050393,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray,<mask>, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3554,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37166,37166,IdentifierMutator-Literal,0,2,4,0.0022517254,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray,<mask>, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3555,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37169,37181,IdentifierMutator-Variable,pArray.length,0,0,0.6706006,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0,<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3556,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37169,37181,IdentifierMutator-Variable,pArray.length,1,1,0.23511733,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0,<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3557,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37169,37181,IdentifierMutator-Variable,pArray.length,pos,2,0.015128584,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0,<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3558,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37169,37181,IdentifierMutator-Variable,pArray.length,2,3,0.008743687,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0,<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3559,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37169,37181,IdentifierMutator-Variable,pArray.length,index,4,0.003449787,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0,<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3560,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37169,37174,IdentifierMutator-Variable,pArray,array,0,0.49350697,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0,<mask>.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3561,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37169,37174,IdentifierMutator-Variable,pArray,Array,1,0.09741724,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0,<mask>.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3562,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37169,37174,IdentifierMutator-Variable,pArray,Array,2,0.07260439,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0,<mask>.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3563,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37169,37174,IdentifierMutator-Variable,pArray,buf,3,0.06481915,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0,<mask>.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3564,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37169,37174,IdentifierMutator-Variable,pArray,arr,4,0.040313046,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0,<mask>.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3565,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37176,37181,FieldReferenceMutator,length,position,1,1.8196652E-4,pArray.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3566,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37176,37181,FieldReferenceMutator,length,size,2,1.2953859E-4,pArray.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3567,Base64.java,encode,byte[] encode(byte[] pArray),946,951,37176,37181,FieldReferenceMutator,length,count,3,1.1044344E-4,pArray.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3568,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37193,37198,MethodCallMutator,encode,decode,0,0.31561977,"<mask>(pArray, 0, -1)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3569,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37193,37198,MethodCallMutator,encode,write,2,0.05586145,"<mask>(pArray, 0, -1)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3570,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37193,37198,MethodCallMutator,encode,read,3,0.021047186,"<mask>(pArray, 0, -1)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3571,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37193,37198,MethodCallMutator,encode,append,4,0.020042498,"<mask>(pArray, 0, -1)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3572,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37200,37205,IdentifierMutator-Variable,pArray,buf,0,0.25345194,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(<mask>, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3573,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37200,37205,IdentifierMutator-Variable,pArray,null,1,0.1346484,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(<mask>, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3574,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37200,37205,IdentifierMutator-Variable,pArray,buffer,2,0.066909075,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(<mask>, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3575,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37200,37205,IdentifierMutator-Variable,pArray,array,3,0.050747365,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(<mask>, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3576,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37200,37205,IdentifierMutator-Variable,pArray,result,4,0.034397792,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(<mask>, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3577,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37208,37208,IdentifierMutator-Literal,0,1,1,0.05238277,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray,<mask>, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3578,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37208,37208,IdentifierMutator-Literal,0,pos,2,0.04727238,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray,<mask>, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3579,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37208,37208,IdentifierMutator-Literal,0,2,3,0.0050915787,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray,<mask>, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3580,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37208,37208,IdentifierMutator-Literal,0,size,4,0.0040680417,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray,<mask>, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3581,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37211,37211,UnaryOperatorMutator,-,pos,1,0.028512293,<mask>1,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0,<mask>1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3582,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37211,37211,UnaryOperatorMutator,-,+,2,0.022554649,<mask>1,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0,<mask>1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3583,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37211,37211,UnaryOperatorMutator,-,length,3,0.019015284,<mask>1,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0,<mask>1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3584,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37212,37212,IdentifierMutator-Literal,1,pos,2,0.014656902,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -<mask>); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3585,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37212,37212,IdentifierMutator-Literal,1,2,3,0.008054415,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -<mask>); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3586,Base64.java,encode,byte[] encode(byte[] pArray),946,952,37212,37212,IdentifierMutator-Literal,1,len,4,0.0032623473,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -<mask>); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3587,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37275,37277,BinaryOperatorMutator,-,+,0,0.29174143,pos <mask> readPos,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos<mask>readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3588,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37275,37277,BinaryOperatorMutator,-,..,2,0.12505879,pos <mask> readPos,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos<mask>readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3589,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37275,37277,BinaryOperatorMutator,-,.,3,0.08609052,pos <mask> readPos,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos<mask>readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3590,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37275,37277,BinaryOperatorMutator,-,*,4,0.048091475,pos <mask> readPos,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos<mask>readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3591,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37272,37274,IdentifierMutator-Variable,pos,size,0,0.16728821,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[<mask> - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3592,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37272,37274,IdentifierMutator-Variable,pos,10000,1,0.08300937,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[<mask> - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3593,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37272,37274,IdentifierMutator-Variable,pos,length,2,0.050471134,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[<mask> - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3594,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37272,37274,IdentifierMutator-Variable,pos,1000,3,0.037334736,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[<mask> - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3595,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37272,37274,IdentifierMutator-Variable,pos,n,4,0.032667764,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[<mask> - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3596,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37272,37274,FieldReferenceMutator,pos,size,0,0.16728821,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[<mask> - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3597,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37272,37274,FieldReferenceMutator,pos,10000,1,0.08300937,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[<mask> - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3598,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37272,37274,FieldReferenceMutator,pos,length,2,0.050471134,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[<mask> - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3599,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37272,37274,FieldReferenceMutator,pos,1000,3,0.037334736,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[<mask> - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3600,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37272,37274,FieldReferenceMutator,pos,n,4,0.032667764,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[<mask> - readPos];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3601,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37278,37284,IdentifierMutator-Variable,readPos,1,0,0.7158919,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos -<mask>];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3602,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37278,37284,IdentifierMutator-Variable,readPos,start,1,0.06821307,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos -<mask>];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3603,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37278,37284,IdentifierMutator-Variable,readPos,2,2,0.041911982,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos -<mask>];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3604,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37278,37284,IdentifierMutator-Variable,readPos,pos,3,0.030591695,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos -<mask>];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3605,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37278,37284,IdentifierMutator-Variable,readPos,offset,4,0.015182613,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos -<mask>];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3606,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37278,37284,FieldReferenceMutator,readPos,1,0,0.7158919,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos -<mask>];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3607,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37278,37284,FieldReferenceMutator,readPos,start,1,0.06821307,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos -<mask>];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3608,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37278,37284,FieldReferenceMutator,readPos,2,2,0.041911982,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos -<mask>];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3609,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37278,37284,FieldReferenceMutator,readPos,pos,3,0.030591695,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos -<mask>];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3610,Base64.java,encode,byte[] encode(byte[] pArray),946,953,37278,37284,FieldReferenceMutator,readPos,offset,4,0.015182613,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos -<mask>];
        readResults(buf, 0, buf.length);
        return buf;
    }"
3611,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37296,37306,MethodCallMutator,readResults,encode,0,0.9578057,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];<mask>(buf, 0, buf.length);
        return buf;
    }"
3612,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37296,37306,MethodCallMutator,readResults,decode,1,0.029307399,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];<mask>(buf, 0, buf.length);
        return buf;
    }"
3613,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37296,37306,MethodCallMutator,readResults,write,2,0.0072574113,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];<mask>(buf, 0, buf.length);
        return buf;
    }"
3614,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37296,37306,MethodCallMutator,readResults,append,3,6.74433E-4,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];<mask>(buf, 0, buf.length);
        return buf;
    }"
3615,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37296,37306,MethodCallMutator,readResults,read,4,6.3082436E-4,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];<mask>(buf, 0, buf.length);
        return buf;
    }"
3616,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37308,37310,IdentifierMutator-Variable,buf,buffer,1,0.014996953,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(<mask>, 0, buf.length);
        return buf;
    }"
3617,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37308,37310,IdentifierMutator-Variable,buf,uf,3,0.011890775,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(<mask>, 0, buf.length);
        return buf;
    }"
3618,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37308,37310,IdentifierMutator-Variable,buf,buff,4,0.0036437386,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(<mask>, 0, buf.length);
        return buf;
    }"
3619,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37313,37313,IdentifierMutator-Literal,0,pos,1,0.021189295,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf,<mask>, buf.length);
        return buf;
    }"
3620,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37313,37313,IdentifierMutator-Literal,0,start,2,0.00969057,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf,<mask>, buf.length);
        return buf;
    }"
3621,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37313,37313,IdentifierMutator-Literal,0,buf,3,0.00578048,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf,<mask>, buf.length);
        return buf;
    }"
3622,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37313,37313,IdentifierMutator-Literal,0,offset,4,0.0054362277,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf,<mask>, buf.length);
        return buf;
    }"
3623,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37316,37325,IdentifierMutator-Variable,buf.length,pos,0,0.2568138,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0,<mask>);
        return buf;
    }"
3624,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37316,37325,IdentifierMutator-Variable,buf.length,0,1,0.13779762,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0,<mask>);
        return buf;
    }"
3625,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37316,37325,IdentifierMutator-Variable,buf.length,1,2,0.07925376,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0,<mask>);
        return buf;
    }"
3626,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37316,37325,IdentifierMutator-Variable,buf.length,true,3,0.04996156,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0,<mask>);
        return buf;
    }"
3627,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37316,37325,IdentifierMutator-Variable,buf.length,buf,4,0.036642496,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0,<mask>);
        return buf;
    }"
3628,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37316,37318,IdentifierMutator-Variable,buf,buffer,1,0.010492315,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0,<mask>.length);
        return buf;
    }"
3629,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37316,37318,IdentifierMutator-Variable,buf,result,3,0.004764617,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0,<mask>.length);
        return buf;
    }"
3630,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37316,37318,IdentifierMutator-Variable,buf,Buffer,4,5.1873224E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0,<mask>.length);
        return buf;
    }"
3631,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37320,37325,FieldReferenceMutator,length,limit,2,4.4647226E-5,buf.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.<mask>);
        return buf;
    }"
3632,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37320,37325,FieldReferenceMutator,length,read,3,3.7884165E-5,buf.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.<mask>);
        return buf;
    }"
3633,Base64.java,encode,byte[] encode(byte[] pArray),946,954,37320,37325,FieldReferenceMutator,length,position,4,2.1652548E-5,buf.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.<mask>);
        return buf;
    }"
3634,Base64.java,encode,byte[] encode(byte[] pArray),946,955,37344,37346,IdentifierMutator-Variable,buf,buffer,1,0.0022607427,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return<mask>;
    }"
3635,Base64.java,encode,byte[] encode(byte[] pArray),946,955,37344,37346,IdentifierMutator-Variable,buf,result,2,4.8238767E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return<mask>;
    }"
3636,Base64.java,encode,byte[] encode(byte[] pArray),946,955,37344,37346,IdentifierMutator-Variable,buf,null,3,3.6166847E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        byte[] buf = new byte[pos - readPos];
        readResults(buf, 0, buf.length);
        return<mask>;
    }"
3637,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38086,38086,AssignmentMutator,chunkSize=(chunkSize/4)*4,*,0,0.757699,chunkSize <mask>= (chunkSize / 4) * 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize<mask>= (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3638,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38086,38086,AssignmentMutator,chunkSize=(chunkSize/4)*4,/,1,0.084082216,chunkSize <mask>= (chunkSize / 4) * 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize<mask>= (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3639,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38086,38086,AssignmentMutator,chunkSize=(chunkSize/4)*4,//,2,0.03792095,chunkSize <mask>= (chunkSize / 4) * 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize<mask>= (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3640,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38086,38086,AssignmentMutator,chunkSize=(chunkSize/4)*4,|,3,0.025838248,chunkSize <mask>= (chunkSize / 4) * 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize<mask>= (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3641,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38086,38086,AssignmentMutator,chunkSize=(chunkSize/4)*4,^,4,0.01236561,chunkSize <mask>= (chunkSize / 4) * 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize<mask>= (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3642,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38077,38085,IdentifierMutator-Variable,chunkSize,len,0,0.28523907,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.<mask> = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3643,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38077,38085,IdentifierMutator-Variable,chunkSize,int,1,0.11599006,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.<mask> = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3644,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38077,38085,IdentifierMutator-Variable,chunkSize,len,2,0.054348,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.<mask> = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3645,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38077,38085,IdentifierMutator-Variable,chunkSize,div,3,0.04248994,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.<mask> = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3646,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38077,38085,IdentifierMutator-Variable,chunkSize,//,4,0.03864612,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.<mask> = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3647,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38104,38106,BinaryOperatorMutator,*,/,2,0.095027745,(chunkSize / 4) <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4)<mask>4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3648,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38104,38106,BinaryOperatorMutator,*,/,3,0.04321274,(chunkSize / 4) <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4)<mask>4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3649,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38104,38106,BinaryOperatorMutator,*,%,4,0.04270596,(chunkSize / 4) <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4)<mask>4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3650,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38099,38101,BinaryOperatorMutator,/,*,1,0.08277949,chunkSize <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize<mask>4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3651,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38099,38101,BinaryOperatorMutator,/,*,3,0.03368062,chunkSize <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize<mask>4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3652,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38099,38101,BinaryOperatorMutator,/,)/,4,0.019451067,chunkSize <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize<mask>4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3653,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38090,38098,IdentifierMutator-Variable,chunkSize,4,0,0.15232132,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (<mask> / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3654,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38090,38098,IdentifierMutator-Variable,chunkSize,3,1,0.12016192,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (<mask> / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3655,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38090,38098,IdentifierMutator-Variable,chunkSize,1,2,0.05391293,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (<mask> / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3656,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38090,38098,IdentifierMutator-Variable,chunkSize,bytes,3,0.05169963,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (<mask> / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3657,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38090,38098,IdentifierMutator-Variable,chunkSize,32,4,0.04886875,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (<mask> / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3658,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38102,38102,IdentifierMutator-Literal,4,3,1,0.30965114,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize /<mask>) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3659,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38102,38102,IdentifierMutator-Literal,4,2,2,0.08291702,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize /<mask>) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3660,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38102,38102,IdentifierMutator-Literal,4,8,3,0.019172817,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize /<mask>) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3661,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38102,38102,IdentifierMutator-Literal,4,5,4,0.010471348,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize /<mask>) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3662,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38107,38107,IdentifierMutator-Literal,4,3,1,0.26828933,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) *<mask>;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3663,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38107,38107,IdentifierMutator-Literal,4,2,2,0.09560742,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) *<mask>;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3664,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38107,38107,IdentifierMutator-Literal,4,8,3,0.016020432,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) *<mask>;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3665,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,971,38107,38107,IdentifierMutator-Literal,4,5,4,0.0140400315,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) *<mask>;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3666,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38149,38151,BinaryOperatorMutator,/,*,0,0.4006437,(pArray.length * 4) <mask> 3,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4)<mask>3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3667,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38149,38151,BinaryOperatorMutator,/,*,1,0.20103638,(pArray.length * 4) <mask> 3,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4)<mask>3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3668,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38149,38151,BinaryOperatorMutator,/,**,4,0.031025715,(pArray.length * 4) <mask> 3,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4)<mask>3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3669,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38144,38146,BinaryOperatorMutator,*,/,1,0.25892794,pArray.length <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length<mask>4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3670,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38144,38146,BinaryOperatorMutator,*,**,3,0.030127496,pArray.length <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length<mask>4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3671,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38144,38146,BinaryOperatorMutator,*,-,4,0.012048614,pArray.length <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length<mask>4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3672,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38131,38143,IdentifierMutator-Variable,pArray.length,len,0,0.33022672,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3673,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38131,38143,IdentifierMutator-Variable,pArray.length,4,1,0.09437993,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3674,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38131,38143,IdentifierMutator-Variable,pArray.length,length,2,0.03643782,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3675,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38131,38143,IdentifierMutator-Variable,pArray.length,32,3,0.033453718,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3676,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38131,38143,IdentifierMutator-Variable,pArray.length,16,4,0.032144215,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3677,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38131,38136,IdentifierMutator-Variable,pArray,Array,0,0.6888457,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask>.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3678,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38131,38136,IdentifierMutator-Variable,pArray,array,1,0.27955845,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask>.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3679,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38131,38136,IdentifierMutator-Variable,pArray,buffer,2,0.0035116186,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask>.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3680,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38131,38136,IdentifierMutator-Variable,pArray,this,3,0.002345703,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask>.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3681,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38131,38136,IdentifierMutator-Variable,pArray,data,4,0.0019203473,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask>.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3682,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38138,38143,FieldReferenceMutator,length,size,1,2.642277E-4,pArray.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3683,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38138,38143,FieldReferenceMutator,length,len,3,1.5998367E-4,pArray.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3684,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38138,38143,FieldReferenceMutator,length,Length,4,4.6745114E-5,pArray.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3685,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38147,38147,IdentifierMutator-Literal,4,3,1,0.35696718,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length *<mask>) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3686,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38147,38147,IdentifierMutator-Literal,4,2,2,0.085122965,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length *<mask>) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3687,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38147,38147,IdentifierMutator-Literal,4,5,3,0.008801148,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length *<mask>) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3688,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38147,38147,IdentifierMutator-Literal,4,8,4,0.0048501487,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length *<mask>) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3689,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38152,38152,IdentifierMutator-Literal,3,4,0,0.9792214,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) /<mask>;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3690,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38152,38152,IdentifierMutator-Literal,3,8,1,0.004820542,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) /<mask>;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3691,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38152,38152,IdentifierMutator-Literal,3,2,2,0.004698203,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) /<mask>;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3692,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,973,38152,38152,IdentifierMutator-Literal,3,5,4,0.0013046103,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) /<mask>;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3693,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,974,38177,38179,BinaryOperatorMutator,%,/,2,0.044680826,len <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len<mask>4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3694,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,974,38177,38179,BinaryOperatorMutator,%,*,3,0.013669026,len <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len<mask>4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3695,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,974,38177,38179,BinaryOperatorMutator,%,/,4,0.003808918,len <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len<mask>4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3696,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,974,38174,38176,IdentifierMutator-Variable,len,length,2,1.7645262E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod =<mask> % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3697,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,974,38174,38176,IdentifierMutator-Variable,len,Len,3,1.1776573E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod =<mask> % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3698,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,974,38174,38176,IdentifierMutator-Variable,len,0,4,4.061957E-5,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod =<mask> % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3699,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,974,38180,38180,IdentifierMutator-Literal,4,3,1,0.093714364,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len %<mask>;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3700,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,974,38180,38180,IdentifierMutator-Literal,4,2,2,0.02227574,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len %<mask>;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3701,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,974,38180,38180,IdentifierMutator-Literal,4,32,3,0.014692254,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len %<mask>;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3702,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,974,38180,38180,IdentifierMutator-Literal,4,8,4,0.009212671,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len %<mask>;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3703,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,975,38198,38201,BinaryOperatorMutator,!=,==,0,0.40180746,mod <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod<mask>0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3704,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,975,38198,38201,BinaryOperatorMutator,!=,>,1,0.31130987,mod <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod<mask>0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3705,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,975,38198,38201,BinaryOperatorMutator,!=,>,2,0.16050862,mod <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod<mask>0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3706,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,975,38198,38201,BinaryOperatorMutator,!=,<,4,0.02190726,mod <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod<mask>0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3707,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,975,38195,38197,IdentifierMutator-Variable,mod,Mod,2,1.6270451E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (<mask> != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3708,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,975,38195,38197,IdentifierMutator-Variable,mod,MOD,3,1.3211368E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (<mask> != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3709,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,975,38195,38197,IdentifierMutator-Variable,mod,div,4,1.2680917E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (<mask> != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3710,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,975,38202,38202,IdentifierMutator-Literal,0,len,1,0.03223993,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod !=<mask>) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3711,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,975,38202,38202,IdentifierMutator-Literal,0,1,2,0.011239246,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod !=<mask>) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3712,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,975,38202,38202,IdentifierMutator-Literal,0,4,3,0.008156157,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod !=<mask>) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3713,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,975,38202,38202,IdentifierMutator-Literal,0,mod,4,0.004971297,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod !=<mask>) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3714,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38222,38222,AssignmentMutator,len+=4-mod,*,0,0.6208573,len <mask>= 4 - mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len<mask>+= 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3715,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38222,38222,AssignmentMutator,len+=4-mod,/,1,0.20294932,len <mask>= 4 - mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len<mask>+= 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3716,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38222,38222,AssignmentMutator,len+=4-mod,//,2,0.043565005,len <mask>= 4 - mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len<mask>+= 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3717,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38222,38222,AssignmentMutator,len+=4-mod,|,3,0.028616333,len <mask>= 4 - mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len<mask>+= 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3718,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38222,38222,AssignmentMutator,len+=4-mod,%,4,0.016350625,len <mask>= 4 - mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len<mask>+= 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3719,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38219,38221,IdentifierMutator-Variable,len,Len,2,0.003104103,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {<mask> += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3720,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38219,38221,IdentifierMutator-Variable,len,length,3,0.0010736735,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {<mask> += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3721,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38219,38221,IdentifierMutator-Variable,len,err,4,7.8696647E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {<mask> += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3722,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38227,38229,BinaryOperatorMutator,-,*,0,0.9141032,4 <mask> mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4<mask>mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3723,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38227,38229,BinaryOperatorMutator,-,*,1,0.028346602,4 <mask> mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4<mask>mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3724,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38227,38229,BinaryOperatorMutator,-,**,3,0.014989038,4 <mask> mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4<mask>mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3725,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38227,38229,BinaryOperatorMutator,-,+,4,0.004105301,4 <mask> mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4<mask>mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3726,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38226,38226,IdentifierMutator-Literal,4,32,1,0.08176036,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len +=<mask> - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3727,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38226,38226,IdentifierMutator-Literal,4,len,2,0.05865364,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len +=<mask> - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3728,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38226,38226,IdentifierMutator-Literal,4,64,3,0.03778266,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len +=<mask> - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3729,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38226,38226,IdentifierMutator-Literal,4,8,4,0.02173213,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len +=<mask> - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3730,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38230,38232,IdentifierMutator-Variable,mod,Mod,1,7.1611453E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 -<mask>;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3731,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38230,38232,IdentifierMutator-Variable,mod,1,2,5.1725365E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 -<mask>;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3732,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38230,38232,IdentifierMutator-Variable,mod,div,3,4.6540948E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 -<mask>;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3733,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,976,38230,38232,IdentifierMutator-Variable,mod,dec,4,4.5103315E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 -<mask>;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3734,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,978,38266,38268,BinaryOperatorMutator,>,==,0,0.42665642,chunkSize <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize<mask>0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3735,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,978,38266,38268,BinaryOperatorMutator,>,!=,3,0.02422497,chunkSize <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize<mask>0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3736,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,978,38266,38268,BinaryOperatorMutator,>,==,4,0.016458822,chunkSize <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize<mask>0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3737,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,978,38257,38265,IdentifierMutator-Variable,chunkSize,len,0,0.97435886,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (<mask> > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3738,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,978,38257,38265,IdentifierMutator-Variable,chunkSize,length,1,0.002224858,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (<mask> > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3739,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,978,38257,38265,IdentifierMutator-Variable,chunkSize,Len,2,0.0020340185,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (<mask> > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3740,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,978,38257,38265,IdentifierMutator-Variable,chunkSize,mod,3,0.0010735629,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (<mask> > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3741,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,978,38257,38265,IdentifierMutator-Variable,chunkSize,len,4,6.814558E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (<mask> > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3742,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,978,38269,38269,IdentifierMutator-Literal,0,1,1,0.106186375,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize ><mask>) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3743,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,978,38269,38269,IdentifierMutator-Literal,0,4,2,0.07249552,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize ><mask>) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3744,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,978,38269,38269,IdentifierMutator-Literal,0,2,3,0.028006159,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize ><mask>) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3745,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,978,38269,38269,IdentifierMutator-Literal,0,3,4,0.022125917,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize ><mask>) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3746,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,979,38330,38333,BinaryOperatorMutator,==,!=,1,0.117873356,(len % chunkSize) <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize<mask>0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3747,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,979,38330,38333,BinaryOperatorMutator,==,=,3,0.021738809,(len % chunkSize) <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize<mask>0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3748,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,979,38330,38333,BinaryOperatorMutator,==,>,4,0.017359745,(len % chunkSize) <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize<mask>0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3749,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,979,38318,38320,BinaryOperatorMutator,%,/,2,0.1369017,len <mask> chunkSize,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len<mask>chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3750,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,979,38318,38320,BinaryOperatorMutator,%,-$,3,0.004605716,len <mask> chunkSize,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len<mask>chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3751,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,979,38318,38320,BinaryOperatorMutator,%,*,4,0.0044896216,len <mask> chunkSize,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len<mask>chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3752,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,979,38315,38317,IdentifierMutator-Variable,len,length,2,8.675184E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly =<mask> % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3753,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,979,38315,38317,IdentifierMutator-Variable,len,0,3,1.0422285E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly =<mask> % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3754,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,979,38315,38317,IdentifierMutator-Variable,len,Len,4,8.851278E-5,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly =<mask> % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3755,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,979,38321,38329,IdentifierMutator-Variable,chunkSize,4,0,0.88476956,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len %<mask> == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3756,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,979,38321,38329,IdentifierMutator-Variable,chunkSize,3,1,0.032893747,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len %<mask> == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3757,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,979,38321,38329,IdentifierMutator-Variable,chunkSize,2,2,0.031356677,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len %<mask> == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3758,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,979,38321,38329,IdentifierMutator-Variable,chunkSize,8,3,0.0075453436,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len %<mask> == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3759,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,979,38321,38329,IdentifierMutator-Variable,chunkSize,5,4,0.005714381,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len %<mask> == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3760,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,979,38334,38334,IdentifierMutator-Literal,0,1,1,0.021548418,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize ==<mask>;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3761,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,979,38334,38334,IdentifierMutator-Literal,0,2,2,0.0014325888,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize ==<mask>;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3762,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,979,38334,38334,IdentifierMutator-Literal,0,4,3,6.348271E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize ==<mask>;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3763,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,979,38334,38334,IdentifierMutator-Literal,0,3,4,5.438567E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize ==<mask>;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3764,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38352,38352,AssignmentMutator,len+=(len/chunkSize)*chunkSeparator.length,*,0,0.38173753,len <mask>= (len / chunkSize) * chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len<mask>+= (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3765,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38352,38352,AssignmentMutator,len+=(len/chunkSize)*chunkSeparator.length,//,1,0.07163011,len <mask>= (len / chunkSize) * chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len<mask>+= (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3766,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38352,38352,AssignmentMutator,len+=(len/chunkSize)*chunkSeparator.length,,2,0.05592861,len <mask>= (len / chunkSize) * chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len<mask>+= (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3767,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38352,38352,AssignmentMutator,len+=(len/chunkSize)*chunkSeparator.length,*,3,0.040907517,len <mask>= (len / chunkSize) * chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len<mask>+= (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3768,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38352,38352,AssignmentMutator,len+=(len/chunkSize)*chunkSeparator.length,+,4,0.039499134,len <mask>= (len / chunkSize) * chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len<mask>+= (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3769,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38349,38351,IdentifierMutator-Variable,len,//,1,0.17717728,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;<mask> += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3770,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38349,38351,IdentifierMutator-Variable,len,,3,0.0069302907,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;<mask> += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3771,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38349,38351,IdentifierMutator-Variable,len,pos,4,0.0057359356,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;<mask> += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3772,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38373,38375,BinaryOperatorMutator,*,+,2,0.019141003,(len / chunkSize) <mask> chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize)<mask>chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3773,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38373,38375,BinaryOperatorMutator,*,/,3,0.017518666,(len / chunkSize) <mask> chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize)<mask>chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3774,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38373,38375,BinaryOperatorMutator,*,^,4,0.010515787,(len / chunkSize) <mask> chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize)<mask>chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3775,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38360,38362,BinaryOperatorMutator,/,)/,1,0.07492397,len <mask> chunkSize,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len<mask>chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3776,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38360,38362,BinaryOperatorMutator,/,%,2,0.055136304,len <mask> chunkSize,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len<mask>chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3777,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38360,38362,BinaryOperatorMutator,/,*,4,0.04294577,len <mask> chunkSize,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len<mask>chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3778,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38357,38359,IdentifierMutator-Variable,len,Len,2,6.170651E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (<mask> / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3779,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38357,38359,IdentifierMutator-Variable,len,fin,3,8.2147235E-5,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (<mask> / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3780,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38357,38359,IdentifierMutator-Variable,len,0,4,7.993763E-5,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (<mask> / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3781,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38363,38371,IdentifierMutator-Variable,chunkSize,4,0,0.80962336,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len /<mask>) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3782,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38363,38371,IdentifierMutator-Variable,chunkSize,3,1,0.08805891,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len /<mask>) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3783,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38363,38371,IdentifierMutator-Variable,chunkSize,2,2,0.055543303,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len /<mask>) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3784,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38363,38371,IdentifierMutator-Variable,chunkSize,8,3,0.006437249,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len /<mask>) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3785,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38363,38371,IdentifierMutator-Variable,chunkSize,chunk,4,0.003611176,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len /<mask>) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3786,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38376,38396,IdentifierMutator-Variable,chunkSeparator.length,4,0,0.76078147,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3787,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38376,38396,IdentifierMutator-Variable,chunkSeparator.length,3,1,0.06535143,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3788,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38376,38396,IdentifierMutator-Variable,chunkSeparator.length,2,2,0.057437994,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3789,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38376,38396,IdentifierMutator-Variable,chunkSeparator.length,mod,3,0.017319407,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3790,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38376,38396,IdentifierMutator-Variable,chunkSeparator.length,8,4,0.012866691,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3791,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38376,38389,IdentifierMutator-Variable,chunkSeparator,array,0,0.38937578,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3792,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38376,38389,IdentifierMutator-Variable,chunkSeparator,arr,1,0.10213026,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3793,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38376,38389,IdentifierMutator-Variable,chunkSeparator,Array,2,0.08558387,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3794,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38376,38389,IdentifierMutator-Variable,chunkSeparator,buffer,3,0.04623182,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3795,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38376,38389,IdentifierMutator-Variable,chunkSeparator,Array,4,0.029352197,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3796,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38391,38396,FieldReferenceMutator,length,len,1,0.0011182418,chunkSeparator.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3797,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38391,38396,FieldReferenceMutator,length,width,2,1.1393922E-4,chunkSeparator.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3798,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38391,38396,FieldReferenceMutator,length,size,3,9.849639E-5,chunkSeparator.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3799,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,980,38391,38396,FieldReferenceMutator,length,count,4,5.8391033E-5,chunkSeparator.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3800,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,981,38415,38415,UnaryOperatorMutator,!,--,2,0.009289978,<mask>lenChunksPerfectly,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (<mask>lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3801,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,981,38415,38415,UnaryOperatorMutator,!,...,3,0.006332605,<mask>lenChunksPerfectly,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (<mask>lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3802,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,981,38415,38415,UnaryOperatorMutator,!,!!,4,0.002312401,<mask>lenChunksPerfectly,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (<mask>lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3803,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,981,38416,38433,IdentifierMutator-Variable,lenChunksPerfectly,broken,0,0.05640271,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!<mask>) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3804,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,981,38416,38433,IdentifierMutator-Variable,lenChunksPerfectly,break,1,0.047219757,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!<mask>) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3805,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,981,38416,38433,IdentifierMutator-Variable,lenChunksPerfectly,reverse,2,0.03924868,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!<mask>) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3806,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,981,38416,38433,IdentifierMutator-Variable,lenChunksPerfectly,fast,3,0.03328369,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!<mask>) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3807,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,981,38416,38433,IdentifierMutator-Variable,lenChunksPerfectly,slow,4,0.029463543,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!<mask>) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3808,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38457,38457,AssignmentMutator,len+=chunkSeparator.length,*,0,0.82963556,len <mask>= chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len<mask>+= chunkSeparator.length;
            }
        }
        return len;
    }"
3809,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38457,38457,AssignmentMutator,len+=chunkSeparator.length,/,1,0.10925856,len <mask>= chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len<mask>+= chunkSeparator.length;
            }
        }
        return len;
    }"
3810,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38457,38457,AssignmentMutator,len+=chunkSeparator.length,//,2,0.018342782,len <mask>= chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len<mask>+= chunkSeparator.length;
            }
        }
        return len;
    }"
3811,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38457,38457,AssignmentMutator,len+=chunkSeparator.length,|,3,0.009996202,len <mask>= chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len<mask>+= chunkSeparator.length;
            }
        }
        return len;
    }"
3812,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38457,38457,AssignmentMutator,len+=chunkSeparator.length,*,4,0.0037754227,len <mask>= chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len<mask>+= chunkSeparator.length;
            }
        }
        return len;
    }"
3813,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38454,38456,IdentifierMutator-Variable,len,Len,2,0.0014724658,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {<mask> += chunkSeparator.length;
            }
        }
        return len;
    }"
3814,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38454,38456,IdentifierMutator-Variable,len,str,3,8.6564856E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {<mask> += chunkSeparator.length;
            }
        }
        return len;
    }"
3815,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38454,38456,IdentifierMutator-Variable,len,length,4,7.715416E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {<mask> += chunkSeparator.length;
            }
        }
        return len;
    }"
3816,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38461,38481,IdentifierMutator-Variable,chunkSeparator.length,mod,0,0.5163985,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>;
            }
        }
        return len;
    }"
3817,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38461,38481,IdentifierMutator-Variable,chunkSeparator.length,1,1,0.20487992,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>;
            }
        }
        return len;
    }"
3818,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38461,38481,IdentifierMutator-Variable,chunkSeparator.length,4,2,0.064282306,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>;
            }
        }
        return len;
    }"
3819,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38461,38481,IdentifierMutator-Variable,chunkSeparator.length,3,3,0.03824685,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>;
            }
        }
        return len;
    }"
3820,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38461,38481,IdentifierMutator-Variable,chunkSeparator.length,2,4,0.028362343,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>;
            }
        }
        return len;
    }"
3821,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38461,38474,IdentifierMutator-Variable,chunkSeparator,array,0,0.21368952,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>.length;
            }
        }
        return len;
    }"
3822,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38461,38474,IdentifierMutator-Variable,chunkSeparator,buffer,1,0.11163643,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>.length;
            }
        }
        return len;
    }"
3823,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38461,38474,IdentifierMutator-Variable,chunkSeparator,arr,2,0.06837422,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>.length;
            }
        }
        return len;
    }"
3824,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38461,38474,IdentifierMutator-Variable,chunkSeparator,buf,3,0.045161966,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>.length;
            }
        }
        return len;
    }"
3825,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38461,38474,IdentifierMutator-Variable,chunkSeparator,Array,4,0.038819157,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>.length;
            }
        }
        return len;
    }"
3826,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38476,38481,FieldReferenceMutator,length,len,1,4.7619356E-4,chunkSeparator.<mask>,"codeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.<mask>;
            }
        }
        return len;
    }"
3827,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38476,38481,FieldReferenceMutator,length,width,2,6.557313E-5,chunkSeparator.<mask>,"codeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.<mask>;
            }
        }
        return len;
    }"
3828,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,982,38476,38481,FieldReferenceMutator,length,size,4,3.7971742E-5,chunkSeparator.<mask>,"codeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.<mask>;
            }
        }
        return len;
    }"
3829,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,985,38523,38525,IdentifierMutator-Variable,len,0,1,0.031097928,<mask>,"odes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return<mask>;
    }"
3830,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,985,38523,38525,IdentifierMutator-Variable,len,true,2,0.016361566,<mask>,"odes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return<mask>;
    }"
3831,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,985,38523,38525,IdentifierMutator-Variable,len,ret,3,0.014006297,<mask>,"odes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return<mask>;
    }"
3832,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",969,985,38523,38525,IdentifierMutator-Variable,len,"''",4,0.009495319,<mask>,"odes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return<mask>;
    }"
3833,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),997,998,38936,38936,IdentifierMutator-Literal,1,base,0,0.0871249,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(<mask>, decodeBase64(pArray));
    }"
3834,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),997,998,38936,38936,IdentifierMutator-Literal,1,1024,1,0.08487986,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(<mask>, decodeBase64(pArray));
    }"
3835,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),997,998,38936,38936,IdentifierMutator-Literal,1,0,2,0.07982505,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(<mask>, decodeBase64(pArray));
    }"
3836,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),997,998,38936,38936,IdentifierMutator-Literal,1,10,4,0.0697782,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(<mask>, decodeBase64(pArray));
    }"
3837,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),997,998,38939,38950,MethodCallMutator,decodeBase64,decode,0,0.9825644,<mask>(pArray),"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1,<mask>(pArray));
    }"
3838,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),997,998,38939,38950,MethodCallMutator,decodeBase64,encode,1,0.00430283,<mask>(pArray),"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1,<mask>(pArray));
    }"
3839,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),997,998,38939,38950,MethodCallMutator,decodeBase64,dec,2,0.0021592102,<mask>(pArray),"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1,<mask>(pArray));
    }"
3840,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),997,998,38939,38950,MethodCallMutator,decodeBase64,reverse,3,0.0016701736,<mask>(pArray),"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1,<mask>(pArray));
    }"
3841,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),997,998,38939,38950,MethodCallMutator,decodeBase64,decrypt,4,9.45154E-4,<mask>(pArray),"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1,<mask>(pArray));
    }"
3842,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),997,998,38952,38957,IdentifierMutator-Variable,pArray,array,0,0.55204374,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1, decodeBase64(<mask>));
    }"
3843,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),997,998,38952,38957,IdentifierMutator-Variable,pArray,Array,1,0.36896852,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1, decodeBase64(<mask>));
    }"
3844,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),997,998,38952,38957,IdentifierMutator-Variable,pArray,p,2,0.019651005,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1, decodeBase64(<mask>));
    }"
3845,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),997,998,38952,38957,IdentifierMutator-Variable,pArray,arr,3,0.012463191,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1, decodeBase64(<mask>));
    }"
3846,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),997,998,38952,38957,IdentifierMutator-Variable,pArray,buffer,4,0.0044633653,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1, decodeBase64(<mask>));
    }"
3847,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1012,39379,39382,BinaryOperatorMutator,==,=,2,0.030335454,bigInt <mask> null,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt<mask>null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
3848,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1012,39379,39382,BinaryOperatorMutator,==,||,3,0.0037420779,bigInt <mask> null,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt<mask>null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
3849,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1012,39379,39382,BinaryOperatorMutator,==,_,4,9.858963E-4,bigInt <mask> null,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt<mask>null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
3850,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1012,39373,39378,IdentifierMutator-Variable,bigInt,Parameter,0,0.11120432,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (<mask> == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
3851,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1012,39373,39378,IdentifierMutator-Variable,bigInt,arg,1,0.093337074,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (<mask> == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
3852,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1012,39373,39378,IdentifierMutator-Variable,bigInt,int,2,0.09172699,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (<mask> == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
3853,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1012,39373,39378,IdentifierMutator-Variable,bigInt,params,3,0.0786028,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (<mask> == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
3854,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1012,39373,39378,IdentifierMutator-Variable,bigInt,param,4,0.066067465,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (<mask> == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
3855,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1012,39383,39386,IdentifierMutator-Literal,null,NULL,1,7.713278E-4,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt ==<mask>) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
3856,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1012,39383,39386,IdentifierMutator-Literal,null,0,2,2.384645E-4,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt ==<mask>) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
3857,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1012,39383,39386,IdentifierMutator-Literal,null,this,3,5.929655E-5,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt ==<mask>) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
3858,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1012,39383,39386,IdentifierMutator-Literal,null,nil,4,3.7733767E-5,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt ==<mask>) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
3859,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1013,39434,39475,IdentifierMutator-Literal,"""encodeIntegercalledwithnullparameter""",null,0,0.6568566,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(<mask>);
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
3860,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1013,39434,39475,IdentifierMutator-Literal,"""encodeIntegercalledwithnullparameter""",this,1,0.10882717,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(<mask>);
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
3861,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1013,39434,39475,IdentifierMutator-Literal,"""encodeIntegercalledwithnullparameter""",int,2,0.040326968,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(<mask>);
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
3862,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1013,39434,39475,IdentifierMutator-Literal,"""encodeIntegercalledwithnullparameter""",string,3,0.0266979,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(<mask>);
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
3863,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1013,39434,39475,IdentifierMutator-Literal,"""encodeIntegercalledwithnullparameter""",0,4,0.015059375,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(<mask>);
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
3864,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39504,39515,MethodCallMutator,encodeBase64,encode,0,0.9373801,"<mask>(toIntegerBytes(bigInt), false)","byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return<mask>(toIntegerBytes(bigInt), false);
    }"
3865,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39504,39515,MethodCallMutator,encodeBase64,decode,1,0.023692034,"<mask>(toIntegerBytes(bigInt), false)","byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return<mask>(toIntegerBytes(bigInt), false);
    }"
3866,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39504,39515,MethodCallMutator,encodeBase64,append,2,0.009296445,"<mask>(toIntegerBytes(bigInt), false)","byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return<mask>(toIntegerBytes(bigInt), false);
    }"
3867,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39504,39515,MethodCallMutator,encodeBase64,write,3,0.007480262,"<mask>(toIntegerBytes(bigInt), false)","byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return<mask>(toIntegerBytes(bigInt), false);
    }"
3868,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39504,39515,MethodCallMutator,encodeBase64,pack,4,0.003138791,"<mask>(toIntegerBytes(bigInt), false)","byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return<mask>(toIntegerBytes(bigInt), false);
    }"
3869,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39517,39530,MethodCallMutator,toIntegerBytes,bytes,0,0.44908607,<mask>(bigInt),"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(<mask>(bigInt), false);
    }"
3870,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39517,39530,MethodCallMutator,toIntegerBytes,bits,1,0.0917492,<mask>(bigInt),"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(<mask>(bigInt), false);
    }"
3871,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39517,39530,MethodCallMutator,toIntegerBytes,format,2,0.054781564,<mask>(bigInt),"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(<mask>(bigInt), false);
    }"
3872,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39517,39530,MethodCallMutator,toIntegerBytes,string,3,0.04108071,<mask>(bigInt),"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(<mask>(bigInt), false);
    }"
3873,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39517,39530,MethodCallMutator,toIntegerBytes,wrap,4,0.038791526,<mask>(bigInt),"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(<mask>(bigInt), false);
    }"
3874,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39532,39537,IdentifierMutator-Variable,bigInt,int,0,0.6725798,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(<mask>), false);
    }"
3875,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39532,39537,IdentifierMutator-Variable,bigInt,Integer,1,0.0748183,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(<mask>), false);
    }"
3876,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39532,39537,IdentifierMutator-Variable,bigInt,integer,2,0.06649796,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(<mask>), false);
    }"
3877,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39532,39537,IdentifierMutator-Variable,bigInt,i,3,0.012533095,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(<mask>), false);
    }"
3878,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39532,39537,IdentifierMutator-Variable,bigInt,in,4,0.011997879,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(<mask>), false);
    }"
3879,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39541,39545,IdentifierMutator-Literal,false,true,0,0.27569658,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt),<mask>);
    }"
3880,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39541,39545,IdentifierMutator-Literal,false,encoding,1,0.25120947,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt),<mask>);
    }"
3881,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39541,39545,IdentifierMutator-Literal,false,null,3,0.03534399,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt),<mask>);
    }"
3882,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1011,1015,39541,39545,IdentifierMutator-Literal,false,codec,4,0.021135336,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt),<mask>);
    }"
3883,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1026,39902,39910,MethodCallMutator,bitLength,length,0,0.48251987,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.<mask>();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3884,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1026,39902,39910,MethodCallMutator,bitLength,bits,1,0.38687202,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.<mask>();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3885,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1026,39902,39910,MethodCallMutator,bitLength,size,2,0.07385074,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.<mask>();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3886,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1026,39902,39910,MethodCallMutator,bitLength,value,3,0.0109686665,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.<mask>();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3887,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1026,39902,39910,MethodCallMutator,bitLength,len,4,0.0062536923,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.<mask>();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3888,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1026,39895,39900,IdentifierMutator-Variable,bigInt,int,0,0.18107656,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen =<mask>.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3889,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1026,39895,39900,IdentifierMutator-Variable,bigInt,big,1,0.12825333,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen =<mask>.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3890,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1026,39895,39900,IdentifierMutator-Variable,bigInt,this,2,0.12717226,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen =<mask>.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3891,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1026,39895,39900,IdentifierMutator-Variable,bigInt,Integer,3,0.09035175,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen =<mask>.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3892,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1026,39895,39900,IdentifierMutator-Variable,bigInt,Int,4,0.04822755,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen =<mask>.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3893,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39953,39953,AssignmentMutator,bitlen=((bitlen+7)>>3)<<3,|,0,0.43720365,bitlen <mask>= ((bitlen + 7) >> 3) << 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen<mask>= ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3894,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39953,39953,AssignmentMutator,bitlen=((bitlen+7)>>3)<<3,^,1,0.18715443,bitlen <mask>= ((bitlen + 7) >> 3) << 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen<mask>= ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3895,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39953,39953,AssignmentMutator,bitlen=((bitlen+7)>>3)<<3,*,2,0.10112992,bitlen <mask>= ((bitlen + 7) >> 3) << 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen<mask>= ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3896,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39953,39953,AssignmentMutator,bitlen=((bitlen+7)>>3)<<3,/,3,0.088297136,bitlen <mask>= ((bitlen + 7) >> 3) << 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen<mask>= ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3897,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39953,39953,AssignmentMutator,bitlen=((bitlen+7)>>3)<<3,//,4,0.049632814,bitlen <mask>= ((bitlen + 7) >> 3) << 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen<mask>= ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3898,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39947,39952,IdentifierMutator-Variable,bitlen,bits,0,0.08313724,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen<mask> = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3899,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39947,39952,IdentifierMutator-Variable,bitlen,len,1,0.059650324,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen<mask> = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3900,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39947,39952,IdentifierMutator-Variable,bitlen,int,2,0.04552535,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen<mask> = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3901,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39947,39952,IdentifierMutator-Variable,bitlen,to,3,0.041318376,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen<mask> = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3902,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39947,39952,IdentifierMutator-Variable,bitlen,*,4,0.02975418,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen<mask> = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3903,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39975,39978,BinaryOperatorMutator,<<,&,1,0.19580212,((bitlen + 7) >> 3) <mask> 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3)<mask>3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3904,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39975,39978,BinaryOperatorMutator,<<,^,2,0.1060897,((bitlen + 7) >> 3) <mask> 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3)<mask>3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3905,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39975,39978,BinaryOperatorMutator,<<,*,3,0.09870726,((bitlen + 7) >> 3) <mask> 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3)<mask>3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3906,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39969,39972,BinaryOperatorMutator,>>,>>>,1,0.14948852,(bitlen + 7) <mask> 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7)<mask>3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3907,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39969,39972,BinaryOperatorMutator,>>,<<,2,0.11032278,(bitlen + 7) <mask> 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7)<mask>3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3908,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39969,39972,BinaryOperatorMutator,>>,*,4,0.08248834,(bitlen + 7) <mask> 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7)<mask>3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3909,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39964,39966,BinaryOperatorMutator,+,/,0,0.18338405,bitlen <mask> 7,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen<mask>7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3910,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39964,39966,BinaryOperatorMutator,+,>>>,2,0.120289825,bitlen <mask> 7,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen<mask>7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3911,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39964,39966,BinaryOperatorMutator,+,%,3,0.09331382,bitlen <mask> 7,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen<mask>7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3912,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39964,39966,BinaryOperatorMutator,+,/,4,0.068242244,bitlen <mask> 7,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen<mask>7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3913,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39958,39963,IdentifierMutator-Variable,bitlen,8,0,0.27621976,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((<mask> + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3914,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39958,39963,IdentifierMutator-Variable,bitlen,len,1,0.12567848,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((<mask> + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3915,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39958,39963,IdentifierMutator-Variable,bitlen,7,2,0.07215883,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((<mask> + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3916,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39958,39963,IdentifierMutator-Variable,bitlen,1,3,0.057754982,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((<mask> + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3917,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39958,39963,IdentifierMutator-Variable,bitlen,16,4,0.03745065,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((<mask> + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3918,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39967,39967,IdentifierMutator-Literal,7,1,0,0.5781683,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen +<mask>) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3919,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39967,39967,IdentifierMutator-Literal,7,8,2,0.049941115,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen +<mask>) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3920,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39967,39967,IdentifierMutator-Literal,7,3,3,0.03981444,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen +<mask>) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3921,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39967,39967,IdentifierMutator-Literal,7,4,4,0.035863984,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen +<mask>) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3922,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39973,39973,IdentifierMutator-Literal,3,6,1,0.07721478,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >><mask>) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3923,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39973,39973,IdentifierMutator-Literal,3,1,2,0.07711057,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >><mask>) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3924,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39973,39973,IdentifierMutator-Literal,3,2,3,0.07223876,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >><mask>) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3925,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39973,39973,IdentifierMutator-Literal,3,4,4,0.0714804,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >><mask>) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3926,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39979,39979,IdentifierMutator-Literal,3,1,1,0.0855002,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) <<<mask>;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3927,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39979,39979,IdentifierMutator-Literal,3,7,2,0.06189106,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) <<<mask>;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3928,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39979,39979,IdentifierMutator-Literal,3,4,3,0.060085412,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) <<<mask>;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3929,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1028,39979,39979,IdentifierMutator-Literal,3,2,4,0.051770635,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) <<<mask>;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3930,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1029,40015,40025,MethodCallMutator,toByteArray,bytes,0,0.9154517,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.<mask>();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3931,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1029,40015,40025,MethodCallMutator,toByteArray,bits,1,0.019694937,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.<mask>();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3932,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1029,40015,40025,MethodCallMutator,toByteArray,Bytes,2,0.012274291,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.<mask>();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3933,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1029,40015,40025,MethodCallMutator,toByteArray,bin,3,0.008588914,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.<mask>();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3934,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1029,40015,40025,MethodCallMutator,toByteArray,value,4,0.007243815,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.<mask>();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3935,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1029,40008,40013,IdentifierMutator-Variable,bigInt,big,0,0.19933367,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes =<mask>.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3936,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1029,40008,40013,IdentifierMutator-Variable,bigInt,input,1,0.06758484,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes =<mask>.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3937,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1029,40008,40013,IdentifierMutator-Variable,bigInt,bytes,2,0.059770394,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes =<mask>.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3938,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1029,40008,40013,IdentifierMutator-Variable,bigInt,this,3,0.057770573,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes =<mask>.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3939,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1029,40008,40013,IdentifierMutator-Variable,bigInt,bits,4,0.051053487,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes =<mask>.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3940,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40074,40077,BinaryOperatorMutator,&&,&,2,0.031849235,((bigInt.bitLength() % 8) != 0) <mask> (((bigInt.bitLength() / 8) + 1) == (bitlen / 8)),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0)<mask>(((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3941,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40074,40077,BinaryOperatorMutator,&&,&,3,0.01671658,((bigInt.bitLength() % 8) != 0) <mask> (((bigInt.bitLength() / 8) + 1) == (bitlen / 8)),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0)<mask>(((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3942,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40074,40077,BinaryOperatorMutator,&&,//,4,0.0063783694,((bigInt.bitLength() % 8) != 0) <mask> (((bigInt.bitLength() / 8) + 1) == (bitlen / 8)),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0)<mask>(((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3943,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40068,40071,BinaryOperatorMutator,!=,==,0,0.77037054,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8)<mask>0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3944,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40068,40071,BinaryOperatorMutator,!=,==,1,0.12744549,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8)<mask>0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3945,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40068,40071,BinaryOperatorMutator,!=,>,2,0.05485525,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8)<mask>0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3946,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40068,40071,BinaryOperatorMutator,!=,>,4,0.015251417,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8)<mask>0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3947,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40063,40065,BinaryOperatorMutator,%,/,0,0.5188738,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength()<mask>8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3948,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40063,40065,BinaryOperatorMutator,%,/,2,0.16815417,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength()<mask>8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3949,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40063,40065,BinaryOperatorMutator,%,)/,4,0.012889168,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength()<mask>8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3950,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40052,40060,MethodCallMutator,bitLength,length,0,0.9163653,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.<mask>() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3951,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40052,40060,MethodCallMutator,bitLength,bits,1,0.051798075,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.<mask>() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3952,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40052,40060,MethodCallMutator,bitLength,Length,2,0.009550717,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.<mask>() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3953,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40052,40060,MethodCallMutator,bitLength,bit,3,0.004910234,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.<mask>() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3954,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40052,40060,MethodCallMutator,bitLength,value,4,0.0023052199,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.<mask>() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3955,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40045,40050,IdentifierMutator-Variable,bigInt,int,0,0.746823,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((<mask>.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3956,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40045,40050,IdentifierMutator-Variable,bigInt,Int,1,0.1649221,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((<mask>.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3957,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40045,40050,IdentifierMutator-Variable,bigInt,Integer,2,0.0139945075,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((<mask>.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3958,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40045,40050,IdentifierMutator-Variable,bigInt,big,3,0.013856921,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((<mask>.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3959,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40045,40050,IdentifierMutator-Variable,bigInt,long,4,0.006214563,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((<mask>.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3960,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40066,40066,IdentifierMutator-Literal,8,7,1,0.005530607,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() %<mask>) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3961,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40066,40066,IdentifierMutator-Literal,8,2,2,9.932129E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() %<mask>) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3962,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40066,40066,IdentifierMutator-Literal,8,4,3,9.187786E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() %<mask>) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3963,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40066,40066,IdentifierMutator-Literal,8,16,4,8.816952E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() %<mask>) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3964,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40072,40072,IdentifierMutator-Literal,0,1,1,0.01637059,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) !=<mask>) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3965,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40072,40072,IdentifierMutator-Literal,0,8,2,0.0014612796,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) !=<mask>) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3966,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40072,40072,IdentifierMutator-Literal,0,7,3,9.844551E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) !=<mask>) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3967,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40072,40072,IdentifierMutator-Literal,0,2,4,5.684401E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) !=<mask>) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3968,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40109,40112,BinaryOperatorMutator,==,<,0,0.33627945,((bigInt.bitLength() / 8) + 1) <mask> (bitlen / 8),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1)<mask>(bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3969,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40109,40112,BinaryOperatorMutator,==,<=,3,0.07669811,((bigInt.bitLength() / 8) + 1) <mask> (bitlen / 8),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1)<mask>(bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3970,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40109,40112,BinaryOperatorMutator,==,>,4,0.07506787,((bigInt.bitLength() / 8) + 1) <mask> (bitlen / 8),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1)<mask>(bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3971,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40104,40106,BinaryOperatorMutator,+,-,0,0.4067248,(bigInt.bitLength() / 8) <mask> 1,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8)<mask>1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3972,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40104,40106,BinaryOperatorMutator,+,-,2,0.09282907,(bigInt.bitLength() / 8) <mask> 1,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8)<mask>1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3973,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40104,40106,BinaryOperatorMutator,+,**,4,0.021640921,(bigInt.bitLength() / 8) <mask> 1,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8)<mask>1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3974,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40099,40101,BinaryOperatorMutator,/,%,0,0.5219178,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength()<mask>8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3975,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40099,40101,BinaryOperatorMutator,/,//,3,0.044786364,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength()<mask>8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3976,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40099,40101,BinaryOperatorMutator,/,%,4,0.0199752,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength()<mask>8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3977,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40088,40096,MethodCallMutator,bitLength,bits,0,0.51306206,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.<mask>() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3978,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40088,40096,MethodCallMutator,bitLength,length,1,0.34586373,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.<mask>() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3979,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40088,40096,MethodCallMutator,bitLength,size,2,0.038241714,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.<mask>() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3980,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40088,40096,MethodCallMutator,bitLength,value,3,0.02103165,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.<mask>() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3981,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40088,40096,MethodCallMutator,bitLength,bytes,4,0.012758481,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.<mask>() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3982,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40081,40086,IdentifierMutator-Variable,bigInt,int,0,0.6868534,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((<mask>.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3983,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40081,40086,IdentifierMutator-Variable,bigInt,Int,1,0.17645743,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((<mask>.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3984,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40081,40086,IdentifierMutator-Variable,bigInt,big,2,0.022624277,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((<mask>.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3985,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40081,40086,IdentifierMutator-Variable,bigInt,Integer,3,0.011915404,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((<mask>.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3986,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40081,40086,IdentifierMutator-Variable,bigInt,long,4,0.011535025,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((<mask>.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3987,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40102,40102,IdentifierMutator-Literal,8,7,1,0.0014157639,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() /<mask>) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3988,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40102,40102,IdentifierMutator-Literal,8,2,2,3.993033E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() /<mask>) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3989,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40102,40102,IdentifierMutator-Literal,8,4,4,2.617816E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() /<mask>) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3990,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40107,40107,IdentifierMutator-Literal,1,7,0,0.53698957,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) +<mask>) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3991,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40107,40107,IdentifierMutator-Literal,1,8,2,0.04494058,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) +<mask>) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3992,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40107,40107,IdentifierMutator-Literal,1,6,3,0.021930046,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) +<mask>) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3993,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40107,40107,IdentifierMutator-Literal,1,3,4,0.013008297,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) +<mask>) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3994,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40120,40122,BinaryOperatorMutator,/,%,1,0.08506532,bitlen <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen<mask>8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3995,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40120,40122,BinaryOperatorMutator,/,%,3,0.050874334,bitlen <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen<mask>8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3996,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40120,40122,BinaryOperatorMutator,/,)/,4,0.029188493,bitlen <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen<mask>8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3997,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40114,40119,IdentifierMutator-Variable,bitlen,len,0,0.7807609,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (<mask> / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3998,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40114,40119,IdentifierMutator-Variable,bitlen,8,1,0.037611578,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (<mask> / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
3999,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40114,40119,IdentifierMutator-Variable,bitlen,1,2,0.020053845,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (<mask> / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4000,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40114,40119,IdentifierMutator-Variable,bitlen,length,3,0.01008563,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (<mask> / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4001,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40114,40119,IdentifierMutator-Variable,bitlen,255,4,0.008992478,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (<mask> / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4002,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40123,40123,IdentifierMutator-Literal,8,7,1,0.0122226635,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen /<mask>))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4003,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40123,40123,IdentifierMutator-Literal,8,2,2,0.011287117,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen /<mask>))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4004,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40123,40123,IdentifierMutator-Literal,8,4,3,0.005160084,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen /<mask>))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4005,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1031,40123,40123,IdentifierMutator-Literal,8,6,4,0.002372981,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen /<mask>))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4006,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1032,40149,40156,IdentifierMutator-Variable,bigBytes,null,0,0.8249167,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return<mask>;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4007,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1032,40149,40156,IdentifierMutator-Variable,bigBytes,bytes,1,0.041228767,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return<mask>;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4008,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1032,40149,40156,IdentifierMutator-Variable,bigBytes,"""""",2,0.024125043,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return<mask>;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4009,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1032,40149,40156,IdentifierMutator-Variable,bigBytes,0,3,0.018363696,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return<mask>;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4010,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1032,40149,40156,IdentifierMutator-Variable,bigBytes,false,4,0.009283522,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return<mask>;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4011,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1035,40253,40253,IdentifierMutator-Literal,0,1,1,0.021016305,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc =<mask>;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4012,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1035,40253,40253,IdentifierMutator-Literal,0,2,2,0.0048450893,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc =<mask>;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4013,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1035,40253,40253,IdentifierMutator-Literal,0,8,3,0.0010382727,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc =<mask>;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4014,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1035,40253,40253,IdentifierMutator-Literal,0,3,4,8.4656867E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc =<mask>;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4015,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1036,40274,40288,IdentifierMutator-Variable,bigBytes.length,0,0,0.30062032,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4016,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1036,40274,40288,IdentifierMutator-Variable,bigBytes.length,8,1,0.19684462,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4017,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1036,40274,40288,IdentifierMutator-Variable,bigBytes.length,1,2,0.16209225,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4018,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1036,40274,40288,IdentifierMutator-Variable,bigBytes.length,7,3,0.038919616,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4019,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1036,40274,40288,IdentifierMutator-Variable,bigBytes.length,2,4,0.036710225,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4020,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1036,40274,40281,IdentifierMutator-Variable,bigBytes,bytes,0,0.37873113,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4021,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1036,40274,40281,IdentifierMutator-Variable,bigBytes,src,1,0.16859323,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4022,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1036,40274,40281,IdentifierMutator-Variable,bigBytes,bits,2,0.07624572,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4023,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1036,40274,40281,IdentifierMutator-Variable,bigBytes,data,3,0.037784383,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4024,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1036,40274,40281,IdentifierMutator-Variable,bigBytes,arr,4,0.034755036,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4025,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1036,40283,40288,FieldReferenceMutator,length,size,1,0.006459289,bigBytes.<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4026,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1036,40283,40288,FieldReferenceMutator,length,len,2,0.0028275007,bigBytes.<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4027,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1036,40283,40288,FieldReferenceMutator,length,Length,4,1.4477444E-4,bigBytes.<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4028,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40400,40403,BinaryOperatorMutator,==,!=,1,0.050353006,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8)<mask>0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4029,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40400,40403,BinaryOperatorMutator,==,>,2,0.022252146,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8)<mask>0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4030,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40400,40403,BinaryOperatorMutator,==,=,4,0.004793392,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8)<mask>0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4031,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40395,40397,BinaryOperatorMutator,%,/,2,0.013124464,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength()<mask>8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4032,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40395,40397,BinaryOperatorMutator,%,/,3,0.0021349713,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength()<mask>8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4033,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40395,40397,BinaryOperatorMutator,%,)/,4,0.0010469529,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength()<mask>8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4034,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40384,40392,MethodCallMutator,bitLength,length,0,0.9524557,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.<mask>() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4035,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40384,40392,MethodCallMutator,bitLength,bits,1,0.027737807,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.<mask>() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4036,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40384,40392,MethodCallMutator,bitLength,len,2,0.004314162,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.<mask>() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4037,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40384,40392,MethodCallMutator,bitLength,Length,3,0.0022060445,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.<mask>() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4038,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40384,40392,MethodCallMutator,bitLength,value,4,0.0018004113,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.<mask>() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4039,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40377,40382,IdentifierMutator-Variable,bigInt,len,0,0.48073485,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((<mask>.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4040,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40377,40382,IdentifierMutator-Variable,bigInt,int,1,0.09259159,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((<mask>.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4041,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40377,40382,IdentifierMutator-Variable,bigInt,this,2,0.043618537,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((<mask>.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4042,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40377,40382,IdentifierMutator-Variable,bigInt,src,3,0.025487807,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((<mask>.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4043,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40377,40382,IdentifierMutator-Variable,bigInt,self,4,0.019777497,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((<mask>.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4044,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40398,40398,IdentifierMutator-Literal,8,7,1,0.007750802,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() %<mask>) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4045,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40398,40398,IdentifierMutator-Literal,8,2,2,0.007257772,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() %<mask>) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4046,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40398,40398,IdentifierMutator-Literal,8,4,3,0.0055588605,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() %<mask>) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4047,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40398,40398,IdentifierMutator-Literal,8,16,4,0.0032617177,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() %<mask>) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4048,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40404,40404,IdentifierMutator-Literal,0,1,1,0.017934965,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) ==<mask>) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4049,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40404,40404,IdentifierMutator-Literal,0,8,2,0.0029667788,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) ==<mask>) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4050,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40404,40404,IdentifierMutator-Literal,0,2,3,7.5614953E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) ==<mask>) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4051,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1039,40404,40404,IdentifierMutator-Literal,0,7,4,4.5119293E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) ==<mask>) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4052,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1040,40429,40429,AssignmentMutator,startSrc=1,*,0,0.3484217,startSrc <mask>= 1,"
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc<mask>= 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4053,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1040,40429,40429,AssignmentMutator,startSrc=1,<<,1,0.3361942,startSrc <mask>= 1,"
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc<mask>= 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4054,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1040,40429,40429,AssignmentMutator,startSrc=1,|,2,0.19524975,startSrc <mask>= 1,"
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc<mask>= 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4055,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1040,40429,40429,AssignmentMutator,startSrc=1,>>,3,0.05596123,startSrc <mask>= 1,"
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc<mask>= 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4056,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1040,40429,40429,AssignmentMutator,startSrc=1,^,4,0.012988011,startSrc <mask>= 1,"
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc<mask>= 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4057,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1040,40421,40428,IdentifierMutator-Variable,startSrc,len,0,0.94888735,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {<mask> = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4058,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1040,40421,40428,IdentifierMutator-Variable,startSrc,len,1,0.017293142,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {<mask> = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4059,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1040,40421,40428,IdentifierMutator-Variable,startSrc,Len,2,0.0066153617,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {<mask> = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4060,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1040,40421,40428,IdentifierMutator-Variable,startSrc,src,3,0.0021479556,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {<mask> = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4061,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1040,40421,40428,IdentifierMutator-Variable,startSrc,pos,4,0.0011132794,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {<mask> = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4062,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1040,40432,40432,IdentifierMutator-Literal,1,0,0,0.81215477,<mask>,"        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc =<mask>;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4063,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1040,40432,40432,IdentifierMutator-Literal,1,len,1,0.06501877,<mask>,"        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc =<mask>;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4064,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1040,40432,40432,IdentifierMutator-Literal,1,i,3,0.014734172,<mask>,"        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc =<mask>;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4065,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1040,40432,40432,IdentifierMutator-Literal,1,pos,4,0.008305038,<mask>,"        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc =<mask>;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4066,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1041,40450,40452,UnaryOperatorMutator,--,++;,0,0.8438007,len<mask>,"Length();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len<mask>
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4067,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1041,40450,40452,UnaryOperatorMutator,--,=,1,0.081237845,len<mask>,"Length();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len<mask>
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4068,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1041,40450,40452,UnaryOperatorMutator,--,;,3,0.0130390255,len<mask>,"Length();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len<mask>
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4069,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1041,40450,40452,UnaryOperatorMutator,--,++,4,0.010570115,len<mask>,"Length();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len<mask>
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4070,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1041,40447,40449,IdentifierMutator-Variable,len,Len,2,0.0030426686,<mask>,"      int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;<mask>--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4071,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1041,40447,40449,IdentifierMutator-Variable,len,pos,3,6.6311454E-4,<mask>,"      int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;<mask>--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4072,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1041,40447,40449,IdentifierMutator-Variable,len,length,4,4.54495E-4,<mask>,"      int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;<mask>--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4073,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40497,40499,BinaryOperatorMutator,-,*,0,0.47997975,(bitlen / 8) <mask> len," + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8<mask>len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4074,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40497,40499,BinaryOperatorMutator,-,.,1,0.16752994,(bitlen / 8) <mask> len," + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8<mask>len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4075,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40497,40499,BinaryOperatorMutator,-,+,2,0.12269536,(bitlen / 8) <mask> len," + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8<mask>len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4076,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40497,40499,BinaryOperatorMutator,-,^,4,0.02007228,(bitlen / 8) <mask> len," + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8<mask>len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4077,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40493,40495,BinaryOperatorMutator,/,)/,2,0.005524496,bitlen <mask> 8,"bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen<mask>8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4078,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40493,40495,BinaryOperatorMutator,/,%,3,0.0047038374,bitlen <mask> 8,"bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen<mask>8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4079,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40493,40495,BinaryOperatorMutator,/,*,4,0.004628589,bitlen <mask> 8,"bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen<mask>8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4080,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40487,40492,IdentifierMutator-Variable,bitlen,len,0,0.24148533,<mask>," = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst =<mask> / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4081,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40487,40492,IdentifierMutator-Variable,bitlen,src,1,0.12174079,<mask>," = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst =<mask> / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4082,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40487,40492,IdentifierMutator-Variable,bitlen,64,2,0.052029595,<mask>," = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst =<mask> / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4083,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40487,40492,IdentifierMutator-Variable,bitlen,8,3,0.03793712,<mask>," = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst =<mask> / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4084,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40487,40492,IdentifierMutator-Variable,bitlen,size,4,0.033401415,<mask>," = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst =<mask> / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4085,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40496,40496,IdentifierMutator-Literal,8,2,1,0.01293465,<mask>,"len + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen /<mask> - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4086,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40496,40496,IdentifierMutator-Literal,8,4,2,0.005816742,<mask>,"len + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen /<mask> - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4087,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40496,40496,IdentifierMutator-Literal,8,7,3,0.0017996825,<mask>,"len + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen /<mask> - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4088,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40496,40496,IdentifierMutator-Literal,8,3,4,0.0014576969,<mask>,"len + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen /<mask> - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4089,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40500,40502,IdentifierMutator-Variable,len,1,0,0.704221,<mask>," 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 -<mask>; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4090,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40500,40502,IdentifierMutator-Variable,len,2,2,0.031460054,<mask>," 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 -<mask>; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4091,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40500,40502,IdentifierMutator-Variable,len,4,3,0.0065544904,<mask>," 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 -<mask>; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4092,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1043,40500,40502,IdentifierMutator-Variable,len,0,4,0.0050731213,<mask>," 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 -<mask>; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4093,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1044,40581,40583,BinaryOperatorMutator,/,*,1,0.081972696,bitlen <mask> 8,"      if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen<mask>8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4094,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1044,40581,40583,BinaryOperatorMutator,/,)/,2,0.011129106,bitlen <mask> 8,"      if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen<mask>8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4095,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1044,40581,40583,BinaryOperatorMutator,/,+,3,0.009592882,bitlen <mask> 8,"      if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen<mask>8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4096,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1044,40575,40580,IdentifierMutator-Variable,bitlen,len,0,0.97348195,<mask>,"        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[<mask> / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4097,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1044,40575,40580,IdentifierMutator-Variable,bitlen,Len,1,0.004694517,<mask>,"        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[<mask> / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4098,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1044,40575,40580,IdentifierMutator-Variable,bitlen,8,2,0.003338404,<mask>,"        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[<mask> / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4099,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1044,40575,40580,IdentifierMutator-Variable,bitlen,len,3,0.002493743,<mask>,"        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[<mask> / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4100,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1044,40575,40580,IdentifierMutator-Variable,bitlen,64,4,0.0013884339,<mask>,"        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[<mask> / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4101,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1044,40584,40584,IdentifierMutator-Literal,8,2,1,0.012058348,<mask>,"     if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen /<mask>];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4102,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1044,40584,40584,IdentifierMutator-Literal,8,4,2,0.0110394545,<mask>,"     if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen /<mask>];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4103,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1044,40584,40584,IdentifierMutator-Literal,8,6,3,0.0028689392,<mask>,"     if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen /<mask>];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4104,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1044,40584,40584,IdentifierMutator-Literal,8,16,4,0.002247962,<mask>,"     if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen /<mask>];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4105,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40603,40611,MethodCallMutator,arraycopy,copy,0,0.99759585,"System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len)","() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4106,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40603,40611,MethodCallMutator,arraycopy,array,1,3.2043117E-4,"System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len)","() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4107,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40603,40611,MethodCallMutator,arraycopy,fill,2,3.0976618E-4,"System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len)","() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4108,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40603,40611,MethodCallMutator,arraycopy,abs,3,2.5887712E-4,"System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len)","() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4109,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40603,40611,MethodCallMutator,arraycopy,printf,4,2.1275487E-4,"System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len)","() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4110,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40613,40620,IdentifierMutator-Variable,bigBytes,bytes,0,0.6258725,<mask>,") != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(<mask>, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4111,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40613,40620,IdentifierMutator-Variable,bigBytes,buf,1,0.07608221,<mask>,") != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(<mask>, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4112,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40613,40620,IdentifierMutator-Variable,bigBytes,data,2,0.06558221,<mask>,") != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(<mask>, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4113,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40613,40620,IdentifierMutator-Variable,bigBytes,buffer,3,0.037495412,<mask>,") != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(<mask>, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4114,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40613,40620,IdentifierMutator-Variable,bigBytes,array,4,0.03456289,<mask>,") != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(<mask>, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4115,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40623,40630,IdentifierMutator-Variable,startSrc,0,0,0.9043985,<mask>,") && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes,<mask>, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4116,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40623,40630,IdentifierMutator-Variable,startSrc,src,1,0.037909202,<mask>,") && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes,<mask>, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4117,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40623,40630,IdentifierMutator-Variable,startSrc,start,2,0.01425248,<mask>,") && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes,<mask>, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4118,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40623,40630,IdentifierMutator-Variable,startSrc,offset,3,0.008289592,<mask>,") && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes,<mask>, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4119,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40623,40630,IdentifierMutator-Variable,startSrc,0,4,0.0057999636,<mask>,") && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes,<mask>, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4120,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40633,40644,IdentifierMutator-Variable,resizedBytes,bytes,0,0.7497938,<mask>,"bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc,<mask>, startDst, len);
        return resizedBytes;
    }"
4121,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40633,40644,IdentifierMutator-Variable,resizedBytes,data,1,0.023462327,<mask>,"bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc,<mask>, startDst, len);
        return resizedBytes;
    }"
4122,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40633,40644,IdentifierMutator-Variable,resizedBytes,arr,2,0.0233899,<mask>,"bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc,<mask>, startDst, len);
        return resizedBytes;
    }"
4123,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40633,40644,IdentifierMutator-Variable,resizedBytes,buf,3,0.022987185,<mask>,"bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc,<mask>, startDst, len);
        return resizedBytes;
    }"
4124,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40633,40644,IdentifierMutator-Variable,resizedBytes,array,4,0.018114606,<mask>,"bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc,<mask>, startDst, len);
        return resizedBytes;
    }"
4125,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40647,40654,IdentifierMutator-Variable,startDst,0,0,0.9683424,<mask>,"Length() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes,<mask>, len);
        return resizedBytes;
    }"
4126,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40647,40654,IdentifierMutator-Variable,startDst,off,1,0.0064939056,<mask>,"Length() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes,<mask>, len);
        return resizedBytes;
    }"
4127,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40647,40654,IdentifierMutator-Variable,startDst,1,2,0.0051957383,<mask>,"Length() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes,<mask>, len);
        return resizedBytes;
    }"
4128,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40647,40654,IdentifierMutator-Variable,startDst,offset,3,0.004979938,<mask>,"Length() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes,<mask>, len);
        return resizedBytes;
    }"
4129,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40647,40654,IdentifierMutator-Variable,startDst,start,4,0.004014385,<mask>,"Length() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes,<mask>, len);
        return resizedBytes;
    }"
4130,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40657,40659,IdentifierMutator-Variable,len,Len,2,0.0011227366,<mask>,") + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst,<mask>);
        return resizedBytes;
    }"
4131,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40657,40659,IdentifierMutator-Variable,len,length,3,4.8368544E-4,<mask>,") + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst,<mask>);
        return resizedBytes;
    }"
4132,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1045,40657,40659,IdentifierMutator-Variable,len,n,4,3.130909E-4,<mask>,") + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst,<mask>);
        return resizedBytes;
    }"
4133,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1046,40678,40689,IdentifierMutator-Variable,resizedBytes,true,0,0.16599308,<mask>," {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return<mask>;
    }"
4134,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1046,40678,40689,IdentifierMutator-Variable,resizedBytes,ret,1,0.1373218,<mask>," {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return<mask>;
    }"
4135,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1046,40678,40689,IdentifierMutator-Variable,resizedBytes,0,2,0.11892544,<mask>," {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return<mask>;
    }"
4136,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1046,40678,40689,IdentifierMutator-Variable,resizedBytes,len,3,0.10996403,<mask>," {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return<mask>;
    }"
4137,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1025,1046,40678,40689,IdentifierMutator-Variable,resizedBytes,res,4,0.077649586,<mask>," {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return<mask>;
    }"
4138,Base64.java,reset,void reset(),1052,1053,40829,40829,AssignmentMutator,buffer=null,Data,0,0.07159031,buffer <mask>= null,"void reset() {
        buffer<mask>= null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4139,Base64.java,reset,void reset(),1052,1053,40829,40829,AssignmentMutator,buffer=null,List,1,0.068108216,buffer <mask>= null,"void reset() {
        buffer<mask>= null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4140,Base64.java,reset,void reset(),1052,1053,40829,40829,AssignmentMutator,buffer=null,_,2,0.06616849,buffer <mask>= null,"void reset() {
        buffer<mask>= null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4141,Base64.java,reset,void reset(),1052,1053,40829,40829,AssignmentMutator,buffer=null,Pool,3,0.06374878,buffer <mask>= null,"void reset() {
        buffer<mask>= null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4142,Base64.java,reset,void reset(),1052,1053,40829,40829,AssignmentMutator,buffer=null,Info,4,0.031458925,buffer <mask>= null,"void reset() {
        buffer<mask>= null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4143,Base64.java,reset,void reset(),1052,1053,40823,40828,IdentifierMutator-Variable,buffer,reader,1,0.07818558,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4144,Base64.java,reset,void reset(),1052,1053,40823,40828,IdentifierMutator-Variable,buffer,line,2,0.049444243,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4145,Base64.java,reset,void reset(),1052,1053,40823,40828,IdentifierMutator-Variable,buffer,file,3,0.034612086,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4146,Base64.java,reset,void reset(),1052,1053,40823,40828,IdentifierMutator-Variable,buffer,stream,4,0.033980455,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4147,Base64.java,reset,void reset(),1052,1053,40823,40828,FieldReferenceMutator,buffer,reader,1,0.07818558,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4148,Base64.java,reset,void reset(),1052,1053,40823,40828,FieldReferenceMutator,buffer,line,2,0.049444243,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4149,Base64.java,reset,void reset(),1052,1053,40823,40828,FieldReferenceMutator,buffer,file,3,0.034612086,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4150,Base64.java,reset,void reset(),1052,1053,40823,40828,FieldReferenceMutator,buffer,stream,4,0.033980455,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4151,Base64.java,reset,void reset(),1052,1053,40832,40835,IdentifierMutator-Literal,null,"""""",1,0.07173865,<mask>,"void reset() {
        buffer =<mask>;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4152,Base64.java,reset,void reset(),1052,1053,40832,40835,IdentifierMutator-Literal,null,0,2,0.029990716,<mask>,"void reset() {
        buffer =<mask>;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4153,Base64.java,reset,void reset(),1052,1053,40832,40835,IdentifierMutator-Literal,null,"''",3,0.020619337,<mask>,"void reset() {
        buffer =<mask>;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4154,Base64.java,reset,void reset(),1052,1053,40832,40835,IdentifierMutator-Literal,null,false,4,0.004369159,<mask>,"void reset() {
        buffer =<mask>;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4155,Base64.java,reset,void reset(),1052,1054,40849,40849,AssignmentMutator,pos=0,|,0,0.4901789,pos <mask>= 0,"void reset() {
        buffer = null;
        pos<mask>= 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4156,Base64.java,reset,void reset(),1052,1054,40849,40849,AssignmentMutator,pos=0,*,1,0.14493254,pos <mask>= 0,"void reset() {
        buffer = null;
        pos<mask>= 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4157,Base64.java,reset,void reset(),1052,1054,40849,40849,AssignmentMutator,pos=0,>>,2,0.07640264,pos <mask>= 0,"void reset() {
        buffer = null;
        pos<mask>= 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4158,Base64.java,reset,void reset(),1052,1054,40849,40849,AssignmentMutator,pos=0,<<,3,0.05094505,pos <mask>= 0,"void reset() {
        buffer = null;
        pos<mask>= 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4159,Base64.java,reset,void reset(),1052,1054,40849,40849,AssignmentMutator,pos=0,&,4,0.042873614,pos <mask>= 0,"void reset() {
        buffer = null;
        pos<mask>= 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4160,Base64.java,reset,void reset(),1052,1054,40846,40848,IdentifierMutator-Variable,pos,offset,0,0.27125272,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4161,Base64.java,reset,void reset(),1052,1054,40846,40848,IdentifierMutator-Variable,pos,position,2,0.12208049,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4162,Base64.java,reset,void reset(),1052,1054,40846,40848,IdentifierMutator-Variable,pos,length,3,0.09401891,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4163,Base64.java,reset,void reset(),1052,1054,40846,40848,IdentifierMutator-Variable,pos,count,4,0.032574717,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4164,Base64.java,reset,void reset(),1052,1054,40846,40848,FieldReferenceMutator,pos,offset,0,0.27125272,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4165,Base64.java,reset,void reset(),1052,1054,40846,40848,FieldReferenceMutator,pos,position,2,0.12208049,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4166,Base64.java,reset,void reset(),1052,1054,40846,40848,FieldReferenceMutator,pos,length,3,0.09401891,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4167,Base64.java,reset,void reset(),1052,1054,40846,40848,FieldReferenceMutator,pos,count,4,0.032574717,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4168,Base64.java,reset,void reset(),1052,1054,40852,40852,IdentifierMutator-Literal,0,null,1,0.012261926,<mask>,"void reset() {
        buffer = null;
        pos =<mask>;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4169,Base64.java,reset,void reset(),1052,1054,40852,40852,IdentifierMutator-Literal,0,1,2,0.004182846,<mask>,"void reset() {
        buffer = null;
        pos =<mask>;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4170,Base64.java,reset,void reset(),1052,1054,40852,40852,IdentifierMutator-Literal,0,pos,3,0.002392879,<mask>,"void reset() {
        buffer = null;
        pos =<mask>;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4171,Base64.java,reset,void reset(),1052,1054,40852,40852,IdentifierMutator-Literal,0,false,4,0.0019585544,<mask>,"void reset() {
        buffer = null;
        pos =<mask>;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4172,Base64.java,reset,void reset(),1052,1055,40870,40870,AssignmentMutator,readPos=0,|,0,0.42254975,readPos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos<mask>= 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4173,Base64.java,reset,void reset(),1052,1055,40870,40870,AssignmentMutator,readPos=0,*,1,0.1987296,readPos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos<mask>= 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4174,Base64.java,reset,void reset(),1052,1055,40870,40870,AssignmentMutator,readPos=0,&,2,0.071804106,readPos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos<mask>= 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4175,Base64.java,reset,void reset(),1052,1055,40870,40870,AssignmentMutator,readPos=0,<<,3,0.070528805,readPos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos<mask>= 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4176,Base64.java,reset,void reset(),1052,1055,40870,40870,AssignmentMutator,readPos=0,/,4,0.039192457,readPos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos<mask>= 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4177,Base64.java,reset,void reset(),1052,1055,40863,40869,IdentifierMutator-Variable,readPos,length,0,0.15366279,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4178,Base64.java,reset,void reset(),1052,1055,40863,40869,IdentifierMutator-Variable,readPos,line,1,0.10980444,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4179,Base64.java,reset,void reset(),1052,1055,40863,40869,IdentifierMutator-Variable,readPos,offset,2,0.08136528,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4180,Base64.java,reset,void reset(),1052,1055,40863,40869,IdentifierMutator-Variable,readPos,len,3,0.03876669,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4181,Base64.java,reset,void reset(),1052,1055,40863,40869,IdentifierMutator-Variable,readPos,index,4,0.028189087,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4182,Base64.java,reset,void reset(),1052,1055,40863,40869,FieldReferenceMutator,readPos,length,0,0.15366279,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4183,Base64.java,reset,void reset(),1052,1055,40863,40869,FieldReferenceMutator,readPos,line,1,0.10980444,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4184,Base64.java,reset,void reset(),1052,1055,40863,40869,FieldReferenceMutator,readPos,offset,2,0.08136528,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4185,Base64.java,reset,void reset(),1052,1055,40863,40869,FieldReferenceMutator,readPos,len,3,0.03876669,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4186,Base64.java,reset,void reset(),1052,1055,40863,40869,FieldReferenceMutator,readPos,index,4,0.028189087,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4187,Base64.java,reset,void reset(),1052,1055,40873,40873,IdentifierMutator-Literal,0,null,1,0.0055957786,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos =<mask>;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4188,Base64.java,reset,void reset(),1052,1055,40873,40873,IdentifierMutator-Literal,0,1,2,0.0045285965,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos =<mask>;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4189,Base64.java,reset,void reset(),1052,1055,40873,40873,IdentifierMutator-Literal,0,false,3,0.0026240894,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos =<mask>;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4190,Base64.java,reset,void reset(),1052,1055,40873,40873,IdentifierMutator-Literal,0,zero,4,5.8432756E-4,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos =<mask>;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4191,Base64.java,reset,void reset(),1052,1056,40898,40898,AssignmentMutator,currentLinePos=0,|,0,0.3252196,currentLinePos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos<mask>= 0;
        modulus = 0;
        eof = false;
    }"
4192,Base64.java,reset,void reset(),1052,1056,40898,40898,AssignmentMutator,currentLinePos=0,*,1,0.21810818,currentLinePos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos<mask>= 0;
        modulus = 0;
        eof = false;
    }"
4193,Base64.java,reset,void reset(),1052,1056,40898,40898,AssignmentMutator,currentLinePos=0,<<,2,0.116552,currentLinePos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos<mask>= 0;
        modulus = 0;
        eof = false;
    }"
4194,Base64.java,reset,void reset(),1052,1056,40898,40898,AssignmentMutator,currentLinePos=0,||,3,0.07053653,currentLinePos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos<mask>= 0;
        modulus = 0;
        eof = false;
    }"
4195,Base64.java,reset,void reset(),1052,1056,40898,40898,AssignmentMutator,currentLinePos=0,&,4,0.049070105,currentLinePos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos<mask>= 0;
        modulus = 0;
        eof = false;
    }"
4196,Base64.java,reset,void reset(),1052,1056,40884,40897,IdentifierMutator-Variable,currentLinePos,length,0,0.12613648,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4197,Base64.java,reset,void reset(),1052,1056,40884,40897,IdentifierMutator-Variable,currentLinePos,offset,1,0.06150515,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4198,Base64.java,reset,void reset(),1052,1056,40884,40897,IdentifierMutator-Variable,currentLinePos,len,2,0.05087585,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4199,Base64.java,reset,void reset(),1052,1056,40884,40897,IdentifierMutator-Variable,currentLinePos,size,3,0.04989753,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4200,Base64.java,reset,void reset(),1052,1056,40884,40897,IdentifierMutator-Variable,currentLinePos,count,4,0.04040517,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4201,Base64.java,reset,void reset(),1052,1056,40884,40897,FieldReferenceMutator,currentLinePos,length,0,0.12613648,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4202,Base64.java,reset,void reset(),1052,1056,40884,40897,FieldReferenceMutator,currentLinePos,offset,1,0.06150515,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4203,Base64.java,reset,void reset(),1052,1056,40884,40897,FieldReferenceMutator,currentLinePos,len,2,0.05087585,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4204,Base64.java,reset,void reset(),1052,1056,40884,40897,FieldReferenceMutator,currentLinePos,size,3,0.04989753,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4205,Base64.java,reset,void reset(),1052,1056,40884,40897,FieldReferenceMutator,currentLinePos,count,4,0.04040517,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4206,Base64.java,reset,void reset(),1052,1056,40901,40901,IdentifierMutator-Literal,0,null,1,0.012948825,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos =<mask>;
        modulus = 0;
        eof = false;
    }"
4207,Base64.java,reset,void reset(),1052,1056,40901,40901,IdentifierMutator-Literal,0,1,2,0.00658629,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos =<mask>;
        modulus = 0;
        eof = false;
    }"
4208,Base64.java,reset,void reset(),1052,1056,40901,40901,IdentifierMutator-Literal,0,false,3,0.0038040658,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos =<mask>;
        modulus = 0;
        eof = false;
    }"
4209,Base64.java,reset,void reset(),1052,1056,40901,40901,IdentifierMutator-Literal,0,undefined,4,0.0011471427,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos =<mask>;
        modulus = 0;
        eof = false;
    }"
4210,Base64.java,reset,void reset(),1052,1057,40919,40919,AssignmentMutator,modulus=0,|,0,0.37451282,modulus <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus<mask>= 0;
        eof = false;
    }"
4211,Base64.java,reset,void reset(),1052,1057,40919,40919,AssignmentMutator,modulus=0,*,1,0.3215155,modulus <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus<mask>= 0;
        eof = false;
    }"
4212,Base64.java,reset,void reset(),1052,1057,40919,40919,AssignmentMutator,modulus=0,^,2,0.12662207,modulus <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus<mask>= 0;
        eof = false;
    }"
4213,Base64.java,reset,void reset(),1052,1057,40919,40919,AssignmentMutator,modulus=0,&,3,0.059786137,modulus <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus<mask>= 0;
        eof = false;
    }"
4214,Base64.java,reset,void reset(),1052,1057,40919,40919,AssignmentMutator,modulus=0,<<,4,0.023140948,modulus <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus<mask>= 0;
        eof = false;
    }"
4215,Base64.java,reset,void reset(),1052,1057,40912,40918,IdentifierMutator-Variable,modulus,pos,0,0.21849275,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4216,Base64.java,reset,void reset(),1052,1057,40912,40918,IdentifierMutator-Variable,modulus,line,1,0.14301813,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4217,Base64.java,reset,void reset(),1052,1057,40912,40918,IdentifierMutator-Variable,modulus,offset,2,0.11567888,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4218,Base64.java,reset,void reset(),1052,1057,40912,40918,IdentifierMutator-Variable,modulus,length,3,0.08439825,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4219,Base64.java,reset,void reset(),1052,1057,40912,40918,IdentifierMutator-Variable,modulus,index,4,0.028484449,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4220,Base64.java,reset,void reset(),1052,1057,40912,40918,FieldReferenceMutator,modulus,pos,0,0.21849275,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4221,Base64.java,reset,void reset(),1052,1057,40912,40918,FieldReferenceMutator,modulus,line,1,0.14301813,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4222,Base64.java,reset,void reset(),1052,1057,40912,40918,FieldReferenceMutator,modulus,offset,2,0.11567888,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4223,Base64.java,reset,void reset(),1052,1057,40912,40918,FieldReferenceMutator,modulus,length,3,0.08439825,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4224,Base64.java,reset,void reset(),1052,1057,40912,40918,FieldReferenceMutator,modulus,index,4,0.028484449,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4225,Base64.java,reset,void reset(),1052,1057,40922,40922,IdentifierMutator-Literal,0,1,1,0.099731855,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus =<mask>;
        eof = false;
    }"
4226,Base64.java,reset,void reset(),1052,1057,40922,40922,IdentifierMutator-Literal,0,null,2,0.010692796,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus =<mask>;
        eof = false;
    }"
4227,Base64.java,reset,void reset(),1052,1057,40922,40922,IdentifierMutator-Literal,0,false,3,0.0062312614,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus =<mask>;
        eof = false;
    }"
4228,Base64.java,reset,void reset(),1052,1057,40922,40922,IdentifierMutator-Literal,0,2,4,0.005245677,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus =<mask>;
        eof = false;
    }"
4229,Base64.java,reset,void reset(),1052,1058,40936,40936,AssignmentMutator,eof=false,Flag,0,0.15248011,eof <mask>= false,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof<mask>= false;
    }"
4230,Base64.java,reset,void reset(),1052,1058,40936,40936,AssignmentMutator,eof=false,Found,1,0.08163081,eof <mask>= false,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof<mask>= false;
    }"
4231,Base64.java,reset,void reset(),1052,1058,40936,40936,AssignmentMutator,eof=false,flag,2,0.041007932,eof <mask>= false,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof<mask>= false;
    }"
4232,Base64.java,reset,void reset(),1052,1058,40936,40936,AssignmentMutator,eof=false,Ok,3,0.038225308,eof <mask>= false,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof<mask>= false;
    }"
4233,Base64.java,reset,void reset(),1052,1058,40936,40936,AssignmentMutator,eof=false,Match,4,0.03317603,eof <mask>= false,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof<mask>= false;
    }"
4234,Base64.java,reset,void reset(),1052,1058,40933,40935,IdentifierMutator-Variable,eof,valid,0,0.05957121,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4235,Base64.java,reset,void reset(),1052,1058,40933,40935,IdentifierMutator-Variable,eof,modified,1,0.034466684,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4236,Base64.java,reset,void reset(),1052,1058,40933,40935,IdentifierMutator-Variable,eof,done,2,0.031822406,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4237,Base64.java,reset,void reset(),1052,1058,40933,40935,IdentifierMutator-Variable,eof,changed,3,0.024370342,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4238,Base64.java,reset,void reset(),1052,1058,40933,40935,IdentifierMutator-Variable,eof,initialized,4,0.023468198,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4239,Base64.java,reset,void reset(),1052,1058,40933,40935,FieldReferenceMutator,eof,valid,0,0.05957121,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4240,Base64.java,reset,void reset(),1052,1058,40933,40935,FieldReferenceMutator,eof,modified,1,0.034466684,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4241,Base64.java,reset,void reset(),1052,1058,40933,40935,FieldReferenceMutator,eof,done,2,0.031822406,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4242,Base64.java,reset,void reset(),1052,1058,40933,40935,FieldReferenceMutator,eof,changed,3,0.024370342,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4243,Base64.java,reset,void reset(),1052,1058,40933,40935,FieldReferenceMutator,eof,initialized,4,0.023468198,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4244,Base64.java,reset,void reset(),1052,1058,40939,40943,IdentifierMutator-Literal,false,true,0,0.4440178,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof =<mask>;
    }"
4245,Base64.java,reset,void reset(),1052,1058,40939,40943,IdentifierMutator-Literal,false,0,2,0.18760204,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof =<mask>;
    }"
4246,Base64.java,reset,void reset(),1052,1058,40939,40943,IdentifierMutator-Literal,false,null,3,0.02340096,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof =<mask>;
    }"
4247,Base64.java,reset,void reset(),1052,1058,40939,40943,IdentifierMutator-Literal,false,1,4,0.0042812945,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof =<mask>;
    }"
