id,classname,method_name,method_sig,method_def_line,mut_location,mut_start,mut_end,mut_operator,orig_token,pred_token,pred_pos,pred_score,masked_expr,masked_seq
0,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14135,14138,BinaryOperatorMutator,==,=,0,0.2843572,this.encodeTable <mask> org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,"boolean isUrlSafe() {
        return this.encodeTable<mask>URL_SAFE_ENCODE_TABLE;
    }"
1,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14135,14138,BinaryOperatorMutator,==,IS,1,0.2492414,this.encodeTable <mask> org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,"boolean isUrlSafe() {
        return this.encodeTable<mask>URL_SAFE_ENCODE_TABLE;
    }"
2,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14135,14138,BinaryOperatorMutator,==,.,2,0.2025588,this.encodeTable <mask> org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,"boolean isUrlSafe() {
        return this.encodeTable<mask>URL_SAFE_ENCODE_TABLE;
    }"
3,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14135,14138,BinaryOperatorMutator,==,Is,3,0.079036824,this.encodeTable <mask> org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,"boolean isUrlSafe() {
        return this.encodeTable<mask>URL_SAFE_ENCODE_TABLE;
    }"
4,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14135,14138,BinaryOperatorMutator,==,_,4,0.03650931,this.encodeTable <mask> org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,"boolean isUrlSafe() {
        return this.encodeTable<mask>URL_SAFE_ENCODE_TABLE;
    }"
5,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14119,14134,IdentifierMutator-Variable,this.encodeTable,table,0,0.70714295,<mask>,"boolean isUrlSafe() {
        return<mask> == URL_SAFE_ENCODE_TABLE;
    }"
6,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14119,14134,IdentifierMutator-Variable,this.encodeTable,encoding,1,0.062470734,<mask>,"boolean isUrlSafe() {
        return<mask> == URL_SAFE_ENCODE_TABLE;
    }"
7,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14119,14134,IdentifierMutator-Variable,this.encodeTable,enc,2,0.022495214,<mask>,"boolean isUrlSafe() {
        return<mask> == URL_SAFE_ENCODE_TABLE;
    }"
8,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14119,14134,IdentifierMutator-Variable,this.encodeTable,type,3,0.013758537,<mask>,"boolean isUrlSafe() {
        return<mask> == URL_SAFE_ENCODE_TABLE;
    }"
9,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14119,14134,IdentifierMutator-Variable,this.encodeTable,tables,4,0.01133225,<mask>,"boolean isUrlSafe() {
        return<mask> == URL_SAFE_ENCODE_TABLE;
    }"
10,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14119,14122,IdentifierMutator-ThisAccess,this,config,1,0.03620054,<mask>,"boolean isUrlSafe() {
        return<mask>.encodeTable == URL_SAFE_ENCODE_TABLE;
    }"
11,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14119,14122,IdentifierMutator-ThisAccess,this,options,2,0.015777318,<mask>,"boolean isUrlSafe() {
        return<mask>.encodeTable == URL_SAFE_ENCODE_TABLE;
    }"
12,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14119,14122,IdentifierMutator-ThisAccess,this,settings,3,0.014880351,<mask>,"boolean isUrlSafe() {
        return<mask>.encodeTable == URL_SAFE_ENCODE_TABLE;
    }"
13,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14119,14122,IdentifierMutator-ThisAccess,this,env,4,0.009000222,<mask>,"boolean isUrlSafe() {
        return<mask>.encodeTable == URL_SAFE_ENCODE_TABLE;
    }"
14,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14124,14134,FieldReferenceMutator,encodeTable,table,0,0.61776394,this.<mask>,"boolean isUrlSafe() {
        return this.<mask> == URL_SAFE_ENCODE_TABLE;
    }"
15,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14124,14134,FieldReferenceMutator,encodeTable,enc,1,0.036451984,this.<mask>,"boolean isUrlSafe() {
        return this.<mask> == URL_SAFE_ENCODE_TABLE;
    }"
16,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14124,14134,FieldReferenceMutator,encodeTable,code,2,0.03590355,this.<mask>,"boolean isUrlSafe() {
        return this.<mask> == URL_SAFE_ENCODE_TABLE;
    }"
17,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14124,14134,FieldReferenceMutator,encodeTable,type,3,0.03188064,this.<mask>,"boolean isUrlSafe() {
        return this.<mask> == URL_SAFE_ENCODE_TABLE;
    }"
18,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14124,14134,FieldReferenceMutator,encodeTable,name,4,0.025844902,this.<mask>,"boolean isUrlSafe() {
        return this.<mask> == URL_SAFE_ENCODE_TABLE;
    }"
19,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14139,14159,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,table,0,0.7777944,<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
20,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14139,14159,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,null,1,0.05689768,<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
21,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14139,14159,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,0,2,0.047562327,<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
22,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14139,14159,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,TABLE,3,0.0229317,<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
23,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14139,14159,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,1,4,0.010206895,<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
24,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14139,14159,FieldReferenceMutator,URL_SAFE_ENCODE_TABLE,table,0,0.7777944,org.apache.commons.codec.binary.Base64.<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
25,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14139,14159,FieldReferenceMutator,URL_SAFE_ENCODE_TABLE,null,1,0.05689768,org.apache.commons.codec.binary.Base64.<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
26,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14139,14159,FieldReferenceMutator,URL_SAFE_ENCODE_TABLE,0,2,0.047562327,org.apache.commons.codec.binary.Base64.<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
27,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14139,14159,FieldReferenceMutator,URL_SAFE_ENCODE_TABLE,TABLE,3,0.0229317,org.apache.commons.codec.binary.Base64.<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
28,Base64.java,isUrlSafe,boolean isUrlSafe(),347,348,14139,14159,FieldReferenceMutator,URL_SAFE_ENCODE_TABLE,1,4,0.010206895,org.apache.commons.codec.binary.Base64.<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
29,Base64.java,hasData,boolean hasData(),356,357,14391,14394,BinaryOperatorMutator,!=,==,0,0.7420034,this.buffer <mask> null,"boolean hasData() {
        return this.buffer<mask>null;
    }"
30,Base64.java,hasData,boolean hasData(),356,357,14391,14394,BinaryOperatorMutator,!=,=,2,0.046860874,this.buffer <mask> null,"boolean hasData() {
        return this.buffer<mask>null;
    }"
31,Base64.java,hasData,boolean hasData(),356,357,14391,14394,BinaryOperatorMutator,!=,==,3,0.015022981,this.buffer <mask> null,"boolean hasData() {
        return this.buffer<mask>null;
    }"
32,Base64.java,hasData,boolean hasData(),356,357,14391,14394,BinaryOperatorMutator,!=,===,4,0.014372619,this.buffer <mask> null,"boolean hasData() {
        return this.buffer<mask>null;
    }"
33,Base64.java,hasData,boolean hasData(),356,357,14380,14390,IdentifierMutator-Variable,this.buffer,data,0,0.8235272,<mask>,"boolean hasData() {
        return<mask> != null;
    }"
34,Base64.java,hasData,boolean hasData(),356,357,14380,14390,IdentifierMutator-Variable,this.buffer,result,1,0.025498437,<mask>,"boolean hasData() {
        return<mask> != null;
    }"
35,Base64.java,hasData,boolean hasData(),356,357,14380,14390,IdentifierMutator-Variable,this.buffer,response,2,0.006110003,<mask>,"boolean hasData() {
        return<mask> != null;
    }"
36,Base64.java,hasData,boolean hasData(),356,357,14380,14390,IdentifierMutator-Variable,this.buffer,value,3,0.0050241635,<mask>,"boolean hasData() {
        return<mask> != null;
    }"
37,Base64.java,hasData,boolean hasData(),356,357,14380,14390,IdentifierMutator-Variable,this.buffer,d,4,0.00488934,<mask>,"boolean hasData() {
        return<mask> != null;
    }"
38,Base64.java,hasData,boolean hasData(),356,357,14380,14383,IdentifierMutator-ThisAccess,this,buffer,1,0.019601444,<mask>,"boolean hasData() {
        return<mask>.buffer != null;
    }"
39,Base64.java,hasData,boolean hasData(),356,357,14380,14383,IdentifierMutator-ThisAccess,this,m,2,0.011960568,<mask>,"boolean hasData() {
        return<mask>.buffer != null;
    }"
40,Base64.java,hasData,boolean hasData(),356,357,14380,14383,IdentifierMutator-ThisAccess,this,b,3,0.0068625947,<mask>,"boolean hasData() {
        return<mask>.buffer != null;
    }"
41,Base64.java,hasData,boolean hasData(),356,357,14380,14383,IdentifierMutator-ThisAccess,this,data,4,0.006812522,<mask>,"boolean hasData() {
        return<mask>.buffer != null;
    }"
42,Base64.java,hasData,boolean hasData(),356,357,14385,14390,FieldReferenceMutator,buffer,data,0,0.8169109,this.<mask>,"boolean hasData() {
        return this.<mask> != null;
    }"
43,Base64.java,hasData,boolean hasData(),356,357,14385,14390,FieldReferenceMutator,buffer,next,1,0.015416469,this.<mask>,"boolean hasData() {
        return this.<mask> != null;
    }"
44,Base64.java,hasData,boolean hasData(),356,357,14385,14390,FieldReferenceMutator,buffer,value,2,0.010786855,this.<mask>,"boolean hasData() {
        return this.<mask> != null;
    }"
45,Base64.java,hasData,boolean hasData(),356,357,14385,14390,FieldReferenceMutator,buffer,table,3,0.008582931,this.<mask>,"boolean hasData() {
        return this.<mask> != null;
    }"
46,Base64.java,hasData,boolean hasData(),356,357,14395,14398,IdentifierMutator-Literal,null,buffer,1,0.0090063745,<mask>,"boolean hasData() {
        return this.buffer !=<mask>;
    }"
47,Base64.java,hasData,boolean hasData(),356,357,14395,14398,IdentifierMutator-Literal,null,0,2,0.008980388,<mask>,"boolean hasData() {
        return this.buffer !=<mask>;
    }"
48,Base64.java,hasData,boolean hasData(),356,357,14395,14398,IdentifierMutator-Literal,null,"""""",3,0.0042835455,<mask>,"boolean hasData() {
        return this.buffer !=<mask>;
    }"
49,Base64.java,hasData,boolean hasData(),356,357,14395,14398,IdentifierMutator-Literal,null,nil,4,0.0038371386,<mask>,"boolean hasData() {
        return this.buffer !=<mask>;
    }"
50,Base64.java,avail,int avail(),365,366,14597,14630,IdentifierMutator-Conditional,buffer!=null?pos-readPos:0,avail,0,0.6324072,<mask>,"int avail() {
        return<mask>;
    }"
51,Base64.java,avail,int avail(),365,366,14597,14630,IdentifierMutator-Conditional,buffer!=null?pos-readPos:0,0,1,0.11783128,<mask>,"int avail() {
        return<mask>;
    }"
52,Base64.java,avail,int avail(),365,366,14597,14630,IdentifierMutator-Conditional,buffer!=null?pos-readPos:0,1,2,0.05654944,<mask>,"int avail() {
        return<mask>;
    }"
53,Base64.java,avail,int avail(),365,366,14597,14630,IdentifierMutator-Conditional,buffer!=null?pos-readPos:0,available,3,0.04339945,<mask>,"int avail() {
        return<mask>;
    }"
54,Base64.java,avail,int avail(),365,366,14597,14630,IdentifierMutator-Conditional,buffer!=null?pos-readPos:0,capacity,4,0.014927301,<mask>,"int avail() {
        return<mask>;
    }"
55,Base64.java,avail,int avail(),365,366,14603,14606,BinaryOperatorMutator,!=,==,0,0.84894454,buffer <mask> null,"int avail() {
        return buffer<mask>null ? pos - readPos : 0;
    }"
56,Base64.java,avail,int avail(),365,366,14603,14606,BinaryOperatorMutator,!=,==,2,0.03189363,buffer <mask> null,"int avail() {
        return buffer<mask>null ? pos - readPos : 0;
    }"
57,Base64.java,avail,int avail(),365,366,14603,14606,BinaryOperatorMutator,!=,=,3,0.02440542,buffer <mask> null,"int avail() {
        return buffer<mask>null ? pos - readPos : 0;
    }"
58,Base64.java,avail,int avail(),365,366,14603,14606,BinaryOperatorMutator,!=,.,4,0.0037829767,buffer <mask> null,"int avail() {
        return buffer<mask>null ? pos - readPos : 0;
    }"
59,Base64.java,avail,int avail(),365,366,14597,14602,IdentifierMutator-Variable,buffer,pos,0,0.6842773,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
60,Base64.java,avail,int avail(),365,366,14597,14602,IdentifierMutator-Variable,buffer,position,1,0.03559566,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
61,Base64.java,avail,int avail(),365,366,14597,14602,IdentifierMutator-Variable,buffer,buf,2,0.02107256,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
62,Base64.java,avail,int avail(),365,366,14597,14602,IdentifierMutator-Variable,buffer,reader,4,0.011582953,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
63,Base64.java,avail,int avail(),365,366,14597,14602,FieldReferenceMutator,buffer,pos,0,0.6842773,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
64,Base64.java,avail,int avail(),365,366,14597,14602,FieldReferenceMutator,buffer,position,1,0.03559566,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
65,Base64.java,avail,int avail(),365,366,14597,14602,FieldReferenceMutator,buffer,buf,2,0.02107256,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
66,Base64.java,avail,int avail(),365,366,14597,14602,FieldReferenceMutator,buffer,reader,4,0.011582953,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
67,Base64.java,avail,int avail(),365,366,14607,14610,IdentifierMutator-Literal,null,0,2,3.0271194E-4,<mask>,"int avail() {
        return buffer !=<mask> ? pos - readPos : 0;
    }"
68,Base64.java,avail,int avail(),365,366,14607,14610,IdentifierMutator-Literal,null,nil,3,1.8120975E-4,<mask>,"int avail() {
        return buffer !=<mask> ? pos - readPos : 0;
    }"
69,Base64.java,avail,int avail(),365,366,14607,14610,IdentifierMutator-Literal,null,NULL,4,1.6804806E-4,<mask>,"int avail() {
        return buffer !=<mask> ? pos - readPos : 0;
    }"
70,Base64.java,avail,int avail(),365,366,14617,14619,BinaryOperatorMutator,-,+,1,0.3186232,pos <mask> readPos,"int avail() {
        return buffer != null ? pos<mask>readPos : 0;
    }"
71,Base64.java,avail,int avail(),365,366,14617,14619,BinaryOperatorMutator,-,.,2,0.03662823,pos <mask> readPos,"int avail() {
        return buffer != null ? pos<mask>readPos : 0;
    }"
72,Base64.java,avail,int avail(),365,366,14617,14619,BinaryOperatorMutator,-,/,4,0.013476046,pos <mask> readPos,"int avail() {
        return buffer != null ? pos<mask>readPos : 0;
    }"
73,Base64.java,avail,int avail(),365,366,14614,14616,IdentifierMutator-Variable,pos,buffer,0,0.38500774,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
74,Base64.java,avail,int avail(),365,366,14614,14616,IdentifierMutator-Variable,pos,position,1,0.25913656,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
75,Base64.java,avail,int avail(),365,366,14614,14616,IdentifierMutator-Variable,pos,limit,2,0.04765534,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
76,Base64.java,avail,int avail(),365,366,14614,14616,IdentifierMutator-Variable,pos,available,3,0.03913235,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
77,Base64.java,avail,int avail(),365,366,14614,14616,FieldReferenceMutator,pos,buffer,0,0.38500774,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
78,Base64.java,avail,int avail(),365,366,14614,14616,FieldReferenceMutator,pos,position,1,0.25913656,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
79,Base64.java,avail,int avail(),365,366,14614,14616,FieldReferenceMutator,pos,limit,2,0.04765534,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
80,Base64.java,avail,int avail(),365,366,14614,14616,FieldReferenceMutator,pos,available,3,0.03913235,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
81,Base64.java,avail,int avail(),365,366,14620,14626,IdentifierMutator-Variable,readPos,buffer,0,0.8479305,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
82,Base64.java,avail,int avail(),365,366,14620,14626,IdentifierMutator-Variable,readPos,avail,1,0.043809254,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
83,Base64.java,avail,int avail(),365,366,14620,14626,IdentifierMutator-Variable,readPos,available,2,0.013781001,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
84,Base64.java,avail,int avail(),365,366,14620,14626,IdentifierMutator-Variable,readPos,1,3,0.009437389,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
85,Base64.java,avail,int avail(),365,366,14620,14626,IdentifierMutator-Variable,readPos,start,4,0.009393641,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
86,Base64.java,avail,int avail(),365,366,14620,14626,FieldReferenceMutator,readPos,buffer,0,0.8479305,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
87,Base64.java,avail,int avail(),365,366,14620,14626,FieldReferenceMutator,readPos,avail,1,0.043809254,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
88,Base64.java,avail,int avail(),365,366,14620,14626,FieldReferenceMutator,readPos,available,2,0.013781001,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
89,Base64.java,avail,int avail(),365,366,14620,14626,FieldReferenceMutator,readPos,1,3,0.009437389,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
90,Base64.java,avail,int avail(),365,366,14620,14626,FieldReferenceMutator,readPos,start,4,0.009393641,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
91,Base64.java,avail,int avail(),365,366,14630,14630,IdentifierMutator-Literal,0,pos,1,0.053147975,<mask>,"int avail() {
        return buffer != null ? pos - readPos :<mask>;
    }"
92,Base64.java,avail,int avail(),365,366,14630,14630,IdentifierMutator-Literal,0,avail,2,0.04842747,<mask>,"int avail() {
        return buffer != null ? pos - readPos :<mask>;
    }"
93,Base64.java,avail,int avail(),365,366,14630,14630,IdentifierMutator-Literal,0,position,3,0.011988309,<mask>,"int avail() {
        return buffer != null ? pos - readPos :<mask>;
    }"
94,Base64.java,avail,int avail(),365,366,14630,14630,IdentifierMutator-Literal,0,1,4,0.009000819,<mask>,"int avail() {
        return buffer != null ? pos - readPos :<mask>;
    }"
95,Base64.java,resizeBuffer,void resizeBuffer(),370,371,14723,14726,BinaryOperatorMutator,==,=,2,0.038895022,buffer <mask> null,"void resizeBuffer() {
        if (buffer<mask>null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
96,Base64.java,resizeBuffer,void resizeBuffer(),370,371,14723,14726,BinaryOperatorMutator,==,!=,3,0.0037705088,buffer <mask> null,"void resizeBuffer() {
        if (buffer<mask>null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
97,Base64.java,resizeBuffer,void resizeBuffer(),370,371,14723,14726,BinaryOperatorMutator,==,_,4,8.9660665E-4,buffer <mask> null,"void resizeBuffer() {
        if (buffer<mask>null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
98,Base64.java,resizeBuffer,void resizeBuffer(),370,371,14717,14722,IdentifierMutator-Variable,buffer,Buffer,2,3.5758392E-4,<mask>,"void resizeBuffer() {
        if (<mask> == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
99,Base64.java,resizeBuffer,void resizeBuffer(),370,371,14717,14722,IdentifierMutator-Variable,buffer,buf,3,2.1959419E-4,<mask>,"void resizeBuffer() {
        if (<mask> == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
100,Base64.java,resizeBuffer,void resizeBuffer(),370,371,14717,14722,IdentifierMutator-Variable,buffer,source,4,2.0003051E-4,<mask>,"void resizeBuffer() {
        if (<mask> == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
101,Base64.java,resizeBuffer,void resizeBuffer(),370,371,14717,14722,FieldReferenceMutator,buffer,Buffer,2,3.5758392E-4,<mask>,"void resizeBuffer() {
        if (<mask> == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
102,Base64.java,resizeBuffer,void resizeBuffer(),370,371,14717,14722,FieldReferenceMutator,buffer,buf,3,2.1959419E-4,<mask>,"void resizeBuffer() {
        if (<mask> == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
103,Base64.java,resizeBuffer,void resizeBuffer(),370,371,14717,14722,FieldReferenceMutator,buffer,source,4,2.0003051E-4,<mask>,"void resizeBuffer() {
        if (<mask> == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
104,Base64.java,resizeBuffer,void resizeBuffer(),370,371,14727,14730,IdentifierMutator-Literal,null,0,1,4.752759E-4,<mask>,"void resizeBuffer() {
        if (buffer ==<mask>) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
105,Base64.java,resizeBuffer,void resizeBuffer(),370,371,14727,14730,IdentifierMutator-Literal,null,nil,2,3.5452028E-4,<mask>,"void resizeBuffer() {
        if (buffer ==<mask>) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
106,Base64.java,resizeBuffer,void resizeBuffer(),370,371,14727,14730,IdentifierMutator-Literal,null,NULL,3,3.0958635E-4,<mask>,"void resizeBuffer() {
        if (buffer ==<mask>) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
107,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14753,14753,AssignmentMutator,buffer=newbyte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],*,0,0.5153762,buffer <mask>= new byte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],"void resizeBuffer() {
        if (buffer == null) {
            buffer<mask>= new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
108,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14753,14753,AssignmentMutator,buffer=newbyte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],|,1,0.17859434,buffer <mask>= new byte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],"void resizeBuffer() {
        if (buffer == null) {
            buffer<mask>= new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
109,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14753,14753,AssignmentMutator,buffer=newbyte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],[],2,0.08555169,buffer <mask>= new byte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],"void resizeBuffer() {
        if (buffer == null) {
            buffer<mask>= new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
110,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14753,14753,AssignmentMutator,buffer=newbyte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],||,3,0.036428154,buffer <mask>= new byte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],"void resizeBuffer() {
        if (buffer == null) {
            buffer<mask>= new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
111,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14753,14753,AssignmentMutator,buffer=newbyte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],=,4,0.022377187,buffer <mask>= new byte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],"void resizeBuffer() {
        if (buffer == null) {
            buffer<mask>= new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
112,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14747,14752,IdentifierMutator-Variable,buffer,b,2,3.3286124E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {<mask> = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
113,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14747,14752,IdentifierMutator-Variable,buffer,buf,3,2.9198776E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {<mask> = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
114,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14747,14752,IdentifierMutator-Variable,buffer,buff,4,1.0084516E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {<mask> = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
115,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14747,14752,FieldReferenceMutator,buffer,b,2,3.3286124E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {<mask> = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
116,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14747,14752,FieldReferenceMutator,buffer,buf,3,2.9198776E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {<mask> = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
117,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14747,14752,FieldReferenceMutator,buffer,buff,4,1.0084516E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {<mask> = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
118,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14765,14783,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE,size,0,0.34460708,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
119,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14765,14783,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE,0,1,0.13565125,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
120,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14765,14783,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE,capacity,2,0.12566428,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
121,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14765,14783,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE,1024,3,0.029645784,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
122,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14765,14783,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE,length,4,0.025477322,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
123,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14765,14783,FieldReferenceMutator,DEFAULT_BUFFER_SIZE,size,0,0.34460708,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
124,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14765,14783,FieldReferenceMutator,DEFAULT_BUFFER_SIZE,0,1,0.13565125,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
125,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14765,14783,FieldReferenceMutator,DEFAULT_BUFFER_SIZE,capacity,2,0.12566428,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
126,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14765,14783,FieldReferenceMutator,DEFAULT_BUFFER_SIZE,1024,3,0.029645784,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
127,Base64.java,resizeBuffer,void resizeBuffer(),370,372,14765,14783,FieldReferenceMutator,DEFAULT_BUFFER_SIZE,length,4,0.025477322,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
128,Base64.java,resizeBuffer,void resizeBuffer(),370,373,14802,14802,AssignmentMutator,pos=0,|,0,0.39245072,pos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos<mask>= 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
129,Base64.java,resizeBuffer,void resizeBuffer(),370,373,14802,14802,AssignmentMutator,pos=0,*,1,0.27559638,pos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos<mask>= 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
130,Base64.java,resizeBuffer,void resizeBuffer(),370,373,14802,14802,AssignmentMutator,pos=0,&,2,0.05735226,pos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos<mask>= 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
131,Base64.java,resizeBuffer,void resizeBuffer(),370,373,14802,14802,AssignmentMutator,pos=0,^,3,0.056953393,pos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos<mask>= 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
132,Base64.java,resizeBuffer,void resizeBuffer(),370,373,14802,14802,AssignmentMutator,pos=0,<<,4,0.027322184,pos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos<mask>= 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
133,Base64.java,resizeBuffer,void resizeBuffer(),370,373,14799,14801,IdentifierMutator-Variable,pos,position,1,0.247314,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
134,Base64.java,resizeBuffer,void resizeBuffer(),370,373,14799,14801,IdentifierMutator-Variable,pos,offset,2,0.1119119,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
135,Base64.java,resizeBuffer,void resizeBuffer(),370,373,14799,14801,IdentifierMutator-Variable,pos,size,3,0.048590504,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
136,Base64.java,resizeBuffer,void resizeBuffer(),370,373,14799,14801,IdentifierMutator-Variable,pos,length,4,0.034745116,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
137,Base64.java,resizeBuffer,void resizeBuffer(),370,373,14799,14801,FieldReferenceMutator,pos,position,1,0.247314,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
138,Base64.java,resizeBuffer,void resizeBuffer(),370,373,14799,14801,FieldReferenceMutator,pos,offset,2,0.1119119,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
139,Base64.java,resizeBuffer,void resizeBuffer(),370,373,14799,14801,FieldReferenceMutator,pos,size,3,0.048590504,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
140,Base64.java,resizeBuffer,void resizeBuffer(),370,373,14799,14801,FieldReferenceMutator,pos,length,4,0.034745116,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
141,Base64.java,resizeBuffer,void resizeBuffer(),370,373,14805,14805,IdentifierMutator-Literal,0,pos,1,0.013057393,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos =<mask>;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
142,Base64.java,resizeBuffer,void resizeBuffer(),370,373,14805,14805,IdentifierMutator-Literal,0,1,2,0.005226168,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos =<mask>;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
143,Base64.java,resizeBuffer,void resizeBuffer(),370,373,14805,14805,IdentifierMutator-Literal,0,position,3,0.005217901,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos =<mask>;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
144,Base64.java,resizeBuffer,void resizeBuffer(),370,373,14805,14805,IdentifierMutator-Literal,0,size,4,0.0017768156,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos =<mask>;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
145,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14827,14827,AssignmentMutator,readPos=0,|,0,0.37869298,readPos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos<mask>= 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
146,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14827,14827,AssignmentMutator,readPos=0,*,1,0.21572544,readPos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos<mask>= 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
147,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14827,14827,AssignmentMutator,readPos=0,&,2,0.16219305,readPos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos<mask>= 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
148,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14827,14827,AssignmentMutator,readPos=0,/,3,0.05325817,readPos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos<mask>= 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
149,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14827,14827,AssignmentMutator,readPos=0,^,4,0.048508678,readPos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos<mask>= 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
150,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14820,14826,IdentifierMutator-Variable,readPos,offset,0,0.19163232,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
151,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14820,14826,IdentifierMutator-Variable,readPos,limit,1,0.09158048,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
152,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14820,14826,IdentifierMutator-Variable,readPos,size,2,0.0835456,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
153,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14820,14826,IdentifierMutator-Variable,readPos,count,3,0.062918335,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
154,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14820,14826,IdentifierMutator-Variable,readPos,length,4,0.061428133,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
155,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14820,14826,FieldReferenceMutator,readPos,offset,0,0.19163232,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
156,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14820,14826,FieldReferenceMutator,readPos,limit,1,0.09158048,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
157,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14820,14826,FieldReferenceMutator,readPos,size,2,0.0835456,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
158,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14820,14826,FieldReferenceMutator,readPos,count,3,0.062918335,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
159,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14820,14826,FieldReferenceMutator,readPos,length,4,0.061428133,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
160,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14830,14830,IdentifierMutator-Literal,0,pos,1,0.32420737,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos =<mask>;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
161,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14830,14830,IdentifierMutator-Literal,0,position,2,0.015387487,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos =<mask>;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
162,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14830,14830,IdentifierMutator-Literal,0,1,3,0.007912336,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos =<mask>;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
163,Base64.java,resizeBuffer,void resizeBuffer(),370,374,14830,14830,IdentifierMutator-Literal,0,offset,4,0.0037060792,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos =<mask>;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
164,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14895,14897,BinaryOperatorMutator,*,/,2,0.05686551,buffer.length <mask> org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length<mask>DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
165,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14895,14897,BinaryOperatorMutator,*,/,3,0.010096999,buffer.length <mask> org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length<mask>DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
166,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14895,14897,BinaryOperatorMutator,*,//,4,0.0057115383,buffer.length <mask> org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length<mask>DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
167,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14882,14894,IdentifierMutator-Variable,buffer.length,size,0,0.15002394,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
168,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14882,14894,IdentifierMutator-Variable,buffer.length,1024,1,0.09849174,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
169,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14882,14894,IdentifierMutator-Variable,buffer.length,2,2,0.05713501,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
170,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14882,14894,IdentifierMutator-Variable,buffer.length,SIZE,3,0.042523887,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
171,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14882,14894,IdentifierMutator-Variable,buffer.length,8,4,0.036943916,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
172,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14882,14887,IdentifierMutator-Variable,buffer,Buffer,1,0.0046080067,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask>.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
173,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14882,14887,IdentifierMutator-Variable,buffer,buf,3,3.1533375E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask>.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
174,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14882,14887,IdentifierMutator-Variable,buffer,queue,4,1.9087548E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask>.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
175,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14882,14887,FieldReferenceMutator,buffer,Buffer,1,0.0046080067,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask>.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
176,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14882,14887,FieldReferenceMutator,buffer,buf,3,3.1533375E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask>.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
177,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14882,14887,FieldReferenceMutator,buffer,queue,4,1.9087548E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask>.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
178,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14889,14894,FieldReferenceMutator,length,size,1,5.9637625E-4,buffer.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
179,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14889,14894,FieldReferenceMutator,length,capacity,2,5.5692275E-4,buffer.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
180,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14889,14894,FieldReferenceMutator,length,position,3,8.739172E-5,buffer.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
181,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14898,14925,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,2,0,0.6583112,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
182,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14898,14925,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,4,1,0.15488945,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
183,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14898,14925,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,3,2,0.051842883,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
184,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14898,14925,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,8,3,0.037875786,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
185,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14898,14925,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,1024,4,0.0108403815,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
186,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14898,14925,FieldReferenceMutator,DEFAULT_BUFFER_RESIZE_FACTOR,2,0,0.6583112,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
187,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14898,14925,FieldReferenceMutator,DEFAULT_BUFFER_RESIZE_FACTOR,4,1,0.15488945,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
188,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14898,14925,FieldReferenceMutator,DEFAULT_BUFFER_RESIZE_FACTOR,3,2,0.051842883,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
189,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14898,14925,FieldReferenceMutator,DEFAULT_BUFFER_RESIZE_FACTOR,8,3,0.037875786,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
190,Base64.java,resizeBuffer,void resizeBuffer(),370,376,14898,14925,FieldReferenceMutator,DEFAULT_BUFFER_RESIZE_FACTOR,1024,4,0.0108403815,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
191,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14948,14956,MethodCallMutator,arraycopy,copy,0,0.98117334,"System.<mask>(buffer, 0, b, 0, buffer.length)","void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.<mask>(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
192,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14948,14956,MethodCallMutator,arraycopy,array,1,0.0031739804,"System.<mask>(buffer, 0, b, 0, buffer.length)","void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.<mask>(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
193,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14948,14956,MethodCallMutator,arraycopy,write,2,0.0031280164,"System.<mask>(buffer, 0, b, 0, buffer.length)","void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.<mask>(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
194,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14948,14956,MethodCallMutator,arraycopy,bytes,3,0.0029730068,"System.<mask>(buffer, 0, b, 0, buffer.length)","void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.<mask>(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
195,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14948,14956,MethodCallMutator,arraycopy,read,4,0.0015968026,"System.<mask>(buffer, 0, b, 0, buffer.length)","void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.<mask>(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
196,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14958,14963,IdentifierMutator-Variable,buffer,Buffer,2,1.1309912E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(<mask>, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
197,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14958,14963,IdentifierMutator-Variable,buffer,buf,3,2.4314462E-5,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(<mask>, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
198,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14958,14963,IdentifierMutator-Variable,buffer,source,4,2.391295E-5,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(<mask>, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
199,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14958,14963,FieldReferenceMutator,buffer,Buffer,2,1.1309912E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(<mask>, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
200,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14958,14963,FieldReferenceMutator,buffer,buf,3,2.4314462E-5,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(<mask>, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
201,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14958,14963,FieldReferenceMutator,buffer,source,4,2.391295E-5,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(<mask>, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
202,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14966,14966,IdentifierMutator-Literal,0,pos,1,0.010127073,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer,<mask>, b, 0, buffer.length);
            buffer = b;
        }
    }"
203,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14966,14966,IdentifierMutator-Literal,0,1,2,0.007938074,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer,<mask>, b, 0, buffer.length);
            buffer = b;
        }
    }"
204,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14966,14966,IdentifierMutator-Literal,0,length,3,0.003676184,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer,<mask>, b, 0, buffer.length);
            buffer = b;
        }
    }"
205,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14966,14966,IdentifierMutator-Literal,0,len,4,0.0019418129,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer,<mask>, b, 0, buffer.length);
            buffer = b;
        }
    }"
206,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14969,14969,IdentifierMutator-Variable,b,buffer,1,7.7730726E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0,<mask>, 0, buffer.length);
            buffer = b;
        }
    }"
207,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14969,14969,IdentifierMutator-Variable,b,a,2,3.4320206E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0,<mask>, 0, buffer.length);
            buffer = b;
        }
    }"
208,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14969,14969,IdentifierMutator-Variable,b,buf,3,2.3874287E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0,<mask>, 0, buffer.length);
            buffer = b;
        }
    }"
209,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14972,14972,IdentifierMutator-Literal,0,pos,1,0.044146985,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b,<mask>, buffer.length);
            buffer = b;
        }
    }"
210,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14972,14972,IdentifierMutator-Literal,0,1,2,0.02007706,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b,<mask>, buffer.length);
            buffer = b;
        }
    }"
211,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14972,14972,IdentifierMutator-Literal,0,size,3,0.0020945072,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b,<mask>, buffer.length);
            buffer = b;
        }
    }"
212,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14972,14972,IdentifierMutator-Literal,0,4,4,0.0019141458,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b,<mask>, buffer.length);
            buffer = b;
        }
    }"
213,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14975,14987,IdentifierMutator-Variable,buffer.length,pos,0,0.93046486,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>);
            buffer = b;
        }
    }"
214,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14975,14987,IdentifierMutator-Variable,buffer.length,len,1,0.022601316,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>);
            buffer = b;
        }
    }"
215,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14975,14987,IdentifierMutator-Variable,buffer.length,size,2,0.007844301,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>);
            buffer = b;
        }
    }"
216,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14975,14987,IdentifierMutator-Variable,buffer.length,n,3,0.005124929,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>);
            buffer = b;
        }
    }"
217,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14975,14987,IdentifierMutator-Variable,buffer.length,offset,4,0.0050978553,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>);
            buffer = b;
        }
    }"
218,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14975,14980,IdentifierMutator-Variable,buffer,b,1,0.0108165145,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>.length);
            buffer = b;
        }
    }"
219,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14975,14980,IdentifierMutator-Variable,buffer,buf,3,7.636923E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>.length);
            buffer = b;
        }
    }"
220,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14975,14980,IdentifierMutator-Variable,buffer,buffers,4,4.4694712E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>.length);
            buffer = b;
        }
    }"
221,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14975,14980,FieldReferenceMutator,buffer,b,1,0.0108165145,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>.length);
            buffer = b;
        }
    }"
222,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14975,14980,FieldReferenceMutator,buffer,buf,3,7.636923E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>.length);
            buffer = b;
        }
    }"
223,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14975,14980,FieldReferenceMutator,buffer,buffers,4,4.4694712E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>.length);
            buffer = b;
        }
    }"
224,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14982,14987,FieldReferenceMutator,length,position,1,1.21198726E-4,buffer.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.<mask>);
            buffer = b;
        }
    }"
225,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14982,14987,FieldReferenceMutator,length,size,3,2.1060217E-5,buffer.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.<mask>);
            buffer = b;
        }
    }"
226,Base64.java,resizeBuffer,void resizeBuffer(),370,377,14982,14987,FieldReferenceMutator,length,count,4,1.6033995E-5,buffer.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.<mask>);
            buffer = b;
        }
    }"
227,Base64.java,resizeBuffer,void resizeBuffer(),370,378,15009,15009,AssignmentMutator,buffer=b,[],0,0.540444,buffer <mask>= b,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer<mask>= b;
        }
    }"
228,Base64.java,resizeBuffer,void resizeBuffer(),370,378,15009,15009,AssignmentMutator,buffer=b,|,1,0.22721569,buffer <mask>= b,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer<mask>= b;
        }
    }"
229,Base64.java,resizeBuffer,void resizeBuffer(),370,378,15009,15009,AssignmentMutator,buffer=b,.,2,0.06996397,buffer <mask>= b,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer<mask>= b;
        }
    }"
230,Base64.java,resizeBuffer,void resizeBuffer(),370,378,15009,15009,AssignmentMutator,buffer=b,.,3,0.04075797,buffer <mask>= b,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer<mask>= b;
        }
    }"
231,Base64.java,resizeBuffer,void resizeBuffer(),370,378,15009,15009,AssignmentMutator,buffer=b,^,4,0.026115466,buffer <mask>= b,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer<mask>= b;
        }
    }"
232,Base64.java,resizeBuffer,void resizeBuffer(),370,378,15003,15008,IdentifierMutator-Variable,buffer,buf,2,8.3654636E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);<mask> = b;
        }
    }"
233,Base64.java,resizeBuffer,void resizeBuffer(),370,378,15003,15008,IdentifierMutator-Variable,buffer,buffers,3,7.569468E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);<mask> = b;
        }
    }"
234,Base64.java,resizeBuffer,void resizeBuffer(),370,378,15003,15008,IdentifierMutator-Variable,buffer,Buffer,4,7.2781055E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);<mask> = b;
        }
    }"
235,Base64.java,resizeBuffer,void resizeBuffer(),370,378,15003,15008,FieldReferenceMutator,buffer,buf,2,8.3654636E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);<mask> = b;
        }
    }"
236,Base64.java,resizeBuffer,void resizeBuffer(),370,378,15003,15008,FieldReferenceMutator,buffer,buffers,3,7.569468E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);<mask> = b;
        }
    }"
237,Base64.java,resizeBuffer,void resizeBuffer(),370,378,15003,15008,FieldReferenceMutator,buffer,Buffer,4,7.2781055E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);<mask> = b;
        }
    }"
238,Base64.java,resizeBuffer,void resizeBuffer(),370,378,15012,15012,IdentifierMutator-Variable,b,null,1,0.04959017,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer =<mask>;
        }
    }"
239,Base64.java,resizeBuffer,void resizeBuffer(),370,378,15012,15012,IdentifierMutator-Variable,b,0,2,7.0119475E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer =<mask>;
        }
    }"
240,Base64.java,resizeBuffer,void resizeBuffer(),370,378,15012,15012,IdentifierMutator-Variable,b,a,4,4.905091E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer =<mask>;
        }
    }"
241,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,395,15691,15694,BinaryOperatorMutator,!=,==,0,0.5928318,buffer <mask> null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer<mask>null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
242,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,395,15691,15694,BinaryOperatorMutator,!=,==,2,0.11785365,buffer <mask> null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer<mask>null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
243,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,395,15691,15694,BinaryOperatorMutator,!=,=,3,0.057654608,buffer <mask> null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer<mask>null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
244,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,395,15691,15694,BinaryOperatorMutator,!=,!,4,9.783455E-4,buffer <mask> null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer<mask>null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
245,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,395,15685,15690,IdentifierMutator-Variable,buffer,b,1,0.043929122,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
246,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,395,15685,15690,IdentifierMutator-Variable,buffer,buf,2,0.007960141,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
247,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,395,15685,15690,IdentifierMutator-Variable,buffer,bb,3,0.006993577,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
248,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,395,15685,15690,IdentifierMutator-Variable,buffer,Buffer,4,0.0043558734,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
249,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,395,15685,15690,FieldReferenceMutator,buffer,b,1,0.043929122,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
250,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,395,15685,15690,FieldReferenceMutator,buffer,buf,2,0.007960141,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
251,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,395,15685,15690,FieldReferenceMutator,buffer,bb,3,0.006993577,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
252,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,395,15685,15690,FieldReferenceMutator,buffer,Buffer,4,0.0043558734,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
253,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,395,15695,15698,IdentifierMutator-Literal,null,b,1,0.08690027,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer !=<mask>) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
254,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,395,15695,15698,IdentifierMutator-Literal,null,nil,2,0.0023644997,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer !=<mask>) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
255,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,395,15695,15698,IdentifierMutator-Literal,null,a,3,0.0023485883,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer !=<mask>) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
256,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,395,15695,15698,IdentifierMutator-Literal,null,0,4,0.0017861786,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer !=<mask>) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
257,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,396,15730,15732,MethodCallMutator,min,max,0,0.5111452,"Math.<mask>(avail(), bAvail)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.<mask>(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
258,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,396,15730,15732,MethodCallMutator,min,div,2,0.0057413774,"Math.<mask>(avail(), bAvail)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.<mask>(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
259,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,396,15730,15732,MethodCallMutator,min,diff,3,0.0048660305,"Math.<mask>(avail(), bAvail)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.<mask>(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
260,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,396,15734,15738,MethodCallMutator,avail,len,0,0.51891404,<mask>(),"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(<mask>(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
261,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,396,15734,15738,MethodCallMutator,avail,length,1,0.1402075,<mask>(),"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(<mask>(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
262,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,396,15734,15738,MethodCallMutator,avail,size,2,0.07255191,<mask>(),"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(<mask>(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
263,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,396,15734,15738,MethodCallMutator,avail,limit,3,0.034165174,<mask>(),"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(<mask>(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
264,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,396,15734,15738,MethodCallMutator,avail,pos,4,0.016755255,<mask>(),"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(<mask>(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
265,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,396,15743,15748,IdentifierMutator-Variable,bAvail,len,0,0.3276092,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(),<mask>);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
266,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,396,15743,15748,IdentifierMutator-Variable,bAvail,pos,1,0.25411612,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(),<mask>);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
267,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,396,15743,15748,IdentifierMutator-Variable,bAvail,avail,2,0.2113732,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(),<mask>);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
268,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,396,15743,15748,IdentifierMutator-Variable,bAvail,buf,3,0.015767002,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(),<mask>);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
269,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,396,15743,15748,IdentifierMutator-Variable,bAvail,length,4,0.01393332,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(),<mask>);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
270,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,397,15774,15777,BinaryOperatorMutator,!=,==,1,0.08186549,buffer <mask> b,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer<mask>b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
271,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,397,15774,15777,BinaryOperatorMutator,!=,=,2,0.054267198,buffer <mask> b,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer<mask>b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
272,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,397,15774,15777,BinaryOperatorMutator,!=,==,3,0.010027055,buffer <mask> b,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer<mask>b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
273,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,397,15774,15777,BinaryOperatorMutator,!=,<,4,0.0047950204,buffer <mask> b,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer<mask>b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
274,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,397,15768,15773,IdentifierMutator-Variable,buffer,null,1,0.07905773,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (<mask> != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
275,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,397,15768,15773,IdentifierMutator-Variable,buffer,Buffer,2,0.013602355,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (<mask> != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
276,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,397,15768,15773,IdentifierMutator-Variable,buffer,buf,3,0.013125694,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (<mask> != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
277,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,397,15768,15773,IdentifierMutator-Variable,buffer,this,4,0.005331501,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (<mask> != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
278,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,397,15768,15773,FieldReferenceMutator,buffer,null,1,0.07905773,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (<mask> != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
279,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,397,15768,15773,FieldReferenceMutator,buffer,Buffer,2,0.013602355,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (<mask> != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
280,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,397,15768,15773,FieldReferenceMutator,buffer,buf,3,0.013125694,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (<mask> != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
281,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,397,15768,15773,FieldReferenceMutator,buffer,this,4,0.005331501,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (<mask> != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
282,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,397,15778,15778,IdentifierMutator-Variable,b,null,0,0.99904305,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer !=<mask>) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
283,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,397,15778,15778,IdentifierMutator-Variable,b,null,1,2.1213107E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer !=<mask>) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
284,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,397,15778,15778,IdentifierMutator-Variable,b,0,2,1.1686201E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer !=<mask>) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
285,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,397,15778,15778,IdentifierMutator-Variable,b,nil,3,9.286482E-5,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer !=<mask>) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
286,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,397,15778,15778,IdentifierMutator-Variable,b,buffer,4,7.330082E-5,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer !=<mask>) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
287,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15806,15814,MethodCallMutator,arraycopy,copy,0,0.99813396,"System.<mask>(buffer, readPos, b, bPos, len)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.<mask>(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
288,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15806,15814,MethodCallMutator,arraycopy,fill,1,3.4737174E-4,"System.<mask>(buffer, readPos, b, bPos, len)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.<mask>(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
289,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15806,15814,MethodCallMutator,arraycopy,write,2,2.6493066E-4,"System.<mask>(buffer, readPos, b, bPos, len)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.<mask>(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
290,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15806,15814,MethodCallMutator,arraycopy,read,3,2.4135142E-4,"System.<mask>(buffer, readPos, b, bPos, len)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.<mask>(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
291,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15806,15814,MethodCallMutator,arraycopy,array,4,2.3703066E-4,"System.<mask>(buffer, readPos, b, bPos, len)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.<mask>(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
292,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15816,15821,IdentifierMutator-Variable,buffer,b,1,0.08261473,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(<mask>, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
293,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15816,15821,IdentifierMutator-Variable,buffer,a,2,0.01892693,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(<mask>, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
294,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15816,15821,IdentifierMutator-Variable,buffer,buf,3,0.016065864,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(<mask>, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
295,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15816,15821,IdentifierMutator-Variable,buffer,buff,4,0.008418677,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(<mask>, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
296,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15816,15821,FieldReferenceMutator,buffer,b,1,0.08261473,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(<mask>, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
297,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15816,15821,FieldReferenceMutator,buffer,a,2,0.01892693,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(<mask>, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
298,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15816,15821,FieldReferenceMutator,buffer,buf,3,0.016065864,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(<mask>, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
299,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15816,15821,FieldReferenceMutator,buffer,buff,4,0.008418677,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(<mask>, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
300,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15824,15830,IdentifierMutator-Variable,readPos,0,0,0.97651064,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
301,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15824,15830,IdentifierMutator-Variable,readPos,pos,1,0.011396354,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
302,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15824,15830,IdentifierMutator-Variable,readPos,off,2,0.0029571946,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
303,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15824,15830,IdentifierMutator-Variable,readPos,0,3,0.0022172837,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
304,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15824,15830,IdentifierMutator-Variable,readPos,len,4,0.0013470198,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
305,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15824,15830,FieldReferenceMutator,readPos,0,0,0.97651064,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
306,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15824,15830,FieldReferenceMutator,readPos,pos,1,0.011396354,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
307,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15824,15830,FieldReferenceMutator,readPos,off,2,0.0029571946,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
308,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15824,15830,FieldReferenceMutator,readPos,0,3,0.0022172837,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
309,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15824,15830,FieldReferenceMutator,readPos,len,4,0.0013470198,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
310,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15833,15833,IdentifierMutator-Variable,b,buffer,1,0.0075172163,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos,<mask>, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
311,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15833,15833,IdentifierMutator-Variable,b,a,2,0.004429151,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos,<mask>, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
312,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15833,15833,IdentifierMutator-Variable,b,buf,3,0.0026695626,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos,<mask>, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
313,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15833,15833,IdentifierMutator-Variable,b,output,4,0.0011687083,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos,<mask>, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
314,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15836,15839,IdentifierMutator-Variable,bPos,pos,0,0.64307934,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b,<mask>, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
315,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15836,15839,IdentifierMutator-Variable,bPos,0,1,0.28497908,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b,<mask>, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
316,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15836,15839,IdentifierMutator-Variable,bPos,off,2,0.046385903,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b,<mask>, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
317,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15836,15839,IdentifierMutator-Variable,bPos,offset,3,0.012231663,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b,<mask>, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
318,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15836,15839,IdentifierMutator-Variable,bPos,Pos,4,0.001881053,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b,<mask>, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
319,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15842,15844,IdentifierMutator-Variable,len,pos,1,0.0013072627,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos,<mask>);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
320,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15842,15844,IdentifierMutator-Variable,len,length,3,7.535234E-5,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos,<mask>);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
321,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,398,15842,15844,IdentifierMutator-Variable,len,n,4,5.472175E-5,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos,<mask>);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
322,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15871,15871,AssignmentMutator,readPos+=len,++,0,0.27567104,readPos <mask>= len,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos<mask>+= len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
323,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15871,15871,AssignmentMutator,readPos+=len,*,1,0.1753126,readPos <mask>= len,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos<mask>+= len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
324,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15871,15871,AssignmentMutator,readPos+=len,*,2,0.110553496,readPos <mask>= len,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos<mask>+= len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
325,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15871,15871,AssignmentMutator,readPos+=len,//,3,0.059827756,readPos <mask>= len,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos<mask>+= len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
326,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15871,15871,AssignmentMutator,readPos+=len,|,4,0.027135741,readPos <mask>= len,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos<mask>+= len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
327,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15864,15870,IdentifierMutator-Variable,readPos,pos,0,0.9652716,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
328,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15864,15870,IdentifierMutator-Variable,readPos,pos,1,0.011851549,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
329,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15864,15870,IdentifierMutator-Variable,readPos,offset,2,0.0040938174,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
330,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15864,15870,IdentifierMutator-Variable,readPos,position,3,0.0031750116,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
331,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15864,15870,IdentifierMutator-Variable,readPos,len,4,0.0014009856,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
332,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15864,15870,FieldReferenceMutator,readPos,pos,0,0.9652716,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
333,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15864,15870,FieldReferenceMutator,readPos,pos,1,0.011851549,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
334,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15864,15870,FieldReferenceMutator,readPos,offset,2,0.0040938174,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
335,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15864,15870,FieldReferenceMutator,readPos,position,3,0.0031750116,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
336,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15864,15870,FieldReferenceMutator,readPos,len,4,0.0014009856,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
337,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15875,15877,IdentifierMutator-Variable,len,1,1,4.9659784E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos +=<mask>;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
338,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15875,15877,IdentifierMutator-Variable,len,pos,2,4.1558515E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos +=<mask>;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
339,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15875,15877,IdentifierMutator-Variable,len,2,3,2.9972725E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos +=<mask>;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
340,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,399,15875,15877,IdentifierMutator-Variable,len,length,4,1.7989149E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos +=<mask>;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
341,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15907,15910,BinaryOperatorMutator,>=,==,0,0.4963244,readPos <mask> pos,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos<mask>pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
342,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15907,15910,BinaryOperatorMutator,>=,<,1,0.18656628,readPos <mask> pos,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos<mask>pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
343,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15907,15910,BinaryOperatorMutator,>=,!=,2,0.062623605,readPos <mask> pos,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos<mask>pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
344,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15907,15910,BinaryOperatorMutator,>=,>,3,0.05326289,readPos <mask> pos,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos<mask>pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
345,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15907,15910,BinaryOperatorMutator,>=,>,4,0.04871892,readPos <mask> pos,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos<mask>pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
346,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15900,15906,IdentifierMutator-Variable,readPos,len,0,0.5431593,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
347,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15900,15906,IdentifierMutator-Variable,readPos,end,1,0.120956436,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
348,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15900,15906,IdentifierMutator-Variable,readPos,offset,2,0.03451969,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
349,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15900,15906,IdentifierMutator-Variable,readPos,pos,3,0.034197595,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
350,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15900,15906,IdentifierMutator-Variable,readPos,length,4,0.0200239,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
351,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15900,15906,FieldReferenceMutator,readPos,len,0,0.5431593,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
352,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15900,15906,FieldReferenceMutator,readPos,end,1,0.120956436,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
353,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15900,15906,FieldReferenceMutator,readPos,offset,2,0.03451969,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
354,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15900,15906,FieldReferenceMutator,readPos,pos,3,0.034197595,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
355,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15900,15906,FieldReferenceMutator,readPos,length,4,0.0200239,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
356,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15911,15913,IdentifierMutator-Variable,pos,len,0,0.5736299,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
357,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15911,15913,IdentifierMutator-Variable,pos,limit,1,0.08756221,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
358,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15911,15913,IdentifierMutator-Variable,pos,0,2,0.038317945,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
359,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15911,15913,IdentifierMutator-Variable,pos,n,3,0.031352434,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
360,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15911,15913,IdentifierMutator-Variable,pos,length,4,0.028452622,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
361,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15911,15913,FieldReferenceMutator,pos,len,0,0.5736299,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
362,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15911,15913,FieldReferenceMutator,pos,limit,1,0.08756221,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
363,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15911,15913,FieldReferenceMutator,pos,0,2,0.038317945,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
364,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15911,15913,FieldReferenceMutator,pos,n,3,0.031352434,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
365,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,400,15911,15913,FieldReferenceMutator,pos,length,4,0.028452622,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
366,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,401,15944,15944,AssignmentMutator,buffer=null,&,0,0.23664978,buffer <mask>= null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer<mask>= null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
367,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,401,15944,15944,AssignmentMutator,buffer=null,*,1,0.22174147,buffer <mask>= null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer<mask>= null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
368,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,401,15944,15944,AssignmentMutator,buffer=null,!,2,0.21433789,buffer <mask>= null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer<mask>= null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
369,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,401,15944,15944,AssignmentMutator,buffer=null,|,3,0.12891358,buffer <mask>= null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer<mask>= null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
370,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,401,15944,15944,AssignmentMutator,buffer=null,||,4,0.058560688,buffer <mask>= null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer<mask>= null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
371,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,401,15938,15943,IdentifierMutator-Variable,buffer,reader,1,0.0017130193,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {<mask> = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
372,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,401,15938,15943,IdentifierMutator-Variable,buffer,b,2,0.0017106896,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {<mask> = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
373,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,401,15938,15943,IdentifierMutator-Variable,buffer,buf,4,0.0012960918,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {<mask> = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
374,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,401,15938,15943,FieldReferenceMutator,buffer,reader,1,0.0017130193,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {<mask> = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
375,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,401,15938,15943,FieldReferenceMutator,buffer,b,2,0.0017106896,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {<mask> = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
376,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,401,15938,15943,FieldReferenceMutator,buffer,buf,4,0.0012960918,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {<mask> = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
377,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,401,15947,15950,IdentifierMutator-Literal,null,b,1,0.026511936,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer =<mask>;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
378,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,401,15947,15950,IdentifierMutator-Literal,null,nil,2,0.0024392828,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer =<mask>;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
379,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,401,15947,15950,IdentifierMutator-Literal,null,"""""",3,6.70203E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer =<mask>;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
380,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,401,15947,15950,IdentifierMutator-Literal,null,buffer,4,5.261728E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer =<mask>;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
381,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,406,16129,16129,AssignmentMutator,buffer=null,!,0,0.34105435,buffer <mask>= null,"   if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer<mask>= null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
382,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,406,16129,16129,AssignmentMutator,buffer=null,*,1,0.25918993,buffer <mask>= null,"   if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer<mask>= null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
383,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,406,16129,16129,AssignmentMutator,buffer=null,&,2,0.120966114,buffer <mask>= null,"   if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer<mask>= null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
384,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,406,16129,16129,AssignmentMutator,buffer=null,||,3,0.05230672,buffer <mask>= null,"   if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer<mask>= null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
385,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,406,16129,16129,AssignmentMutator,buffer=null,|,4,0.042981137,buffer <mask>= null,"   if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer<mask>= null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
386,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,406,16123,16128,IdentifierMutator-Variable,buffer,b,1,0.28750157,<mask>,", int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
387,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,406,16123,16128,IdentifierMutator-Variable,buffer,input,2,0.0076402347,<mask>,", int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
388,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,406,16123,16128,IdentifierMutator-Variable,buffer,buf,3,0.0066065006,<mask>,", int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
389,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,406,16123,16128,IdentifierMutator-Variable,buffer,output,4,0.0035677585,<mask>,", int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
390,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,406,16123,16128,FieldReferenceMutator,buffer,b,1,0.28750157,<mask>,", int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
391,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,406,16123,16128,FieldReferenceMutator,buffer,input,2,0.0076402347,<mask>,", int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
392,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,406,16123,16128,FieldReferenceMutator,buffer,buf,3,0.0066065006,<mask>,", int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
393,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,406,16123,16128,FieldReferenceMutator,buffer,output,4,0.0035677585,<mask>,", int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
394,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,406,16132,16135,IdentifierMutator-Literal,null,b,1,0.2084152,<mask>,"  if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer =<mask>;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
395,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,406,16132,16135,IdentifierMutator-Literal,null,nil,2,0.0045961123,<mask>,"  if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer =<mask>;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
396,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,406,16132,16135,IdentifierMutator-Literal,null,undefined,3,0.0023095808,<mask>,"  if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer =<mask>;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
397,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,406,16132,16135,IdentifierMutator-Literal,null,a,4,9.838173E-4,<mask>,"  if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer =<mask>;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
398,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,408,16171,16173,IdentifierMutator-Variable,len,buffer,0,0.54770184,<mask>,"ail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return<mask>;
        }
        return eof ? -1 : 0;
    }"
399,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,408,16171,16173,IdentifierMutator-Variable,len,b,1,0.18174793,<mask>,"ail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return<mask>;
        }
        return eof ? -1 : 0;
    }"
400,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,408,16171,16173,IdentifierMutator-Variable,len,buf,2,0.04597363,<mask>,"ail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return<mask>;
        }
        return eof ? -1 : 0;
    }"
401,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,408,16171,16173,IdentifierMutator-Variable,len,0,3,0.04320586,<mask>,"ail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return<mask>;
        }
        return eof ? -1 : 0;
    }"
402,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,408,16171,16173,IdentifierMutator-Variable,len,null,4,0.016592212,<mask>,"ail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return<mask>;
        }
        return eof ? -1 : 0;
    }"
403,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16201,16212,IdentifierMutator-Conditional,eof?-1:0,0,0,0.2375896,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask>;
    }"
404,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16201,16212,IdentifierMutator-Conditional,eof?-1:0,b,1,0.20608939,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask>;
    }"
405,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16201,16212,IdentifierMutator-Conditional,eof?-1:0,buffer,2,0.14947222,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask>;
    }"
406,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16201,16212,IdentifierMutator-Conditional,eof?-1:0,null,3,0.07340877,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask>;
    }"
407,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16201,16212,IdentifierMutator-Conditional,eof?-1:0,buf,4,0.040902775,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask>;
    }"
408,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16201,16203,IdentifierMutator-Variable,eof,negative,0,0.62197536,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
409,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16201,16203,IdentifierMutator-Variable,eof,reversed,1,0.03409621,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
410,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16201,16203,IdentifierMutator-Variable,eof,reverse,2,0.030431136,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
411,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16201,16203,IdentifierMutator-Variable,eof,0,3,0.017484184,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
412,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16201,16203,IdentifierMutator-Variable,eof,neg,4,0.016923545,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
413,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16201,16203,FieldReferenceMutator,eof,negative,0,0.62197536,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
414,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16201,16203,FieldReferenceMutator,eof,reversed,1,0.03409621,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
415,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16201,16203,FieldReferenceMutator,eof,reverse,2,0.030431136,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
416,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16201,16203,FieldReferenceMutator,eof,0,3,0.017484184,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
417,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16201,16203,FieldReferenceMutator,eof,neg,4,0.016923545,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
418,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16207,16207,UnaryOperatorMutator,-,$,1,0.002904153,<mask>1,") {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ?<mask>1 : 0;
    }"
419,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16207,16207,UnaryOperatorMutator,-,+,2,0.001843675,<mask>1,") {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ?<mask>1 : 0;
    }"
420,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16207,16207,UnaryOperatorMutator,-,!,4,5.1324064E-4,<mask>1,") {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ?<mask>1 : 0;
    }"
421,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16208,16208,IdentifierMutator-Literal,1,2,1,0.0015188624,<mask>," {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -<mask> : 0;
    }"
422,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16208,16208,IdentifierMutator-Literal,1,3,3,9.6279364E-5,<mask>," {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -<mask> : 0;
    }"
423,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16208,16208,IdentifierMutator-Literal,1,Infinity,4,8.285509E-5,<mask>," {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -<mask> : 0;
    }"
424,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16212,16212,IdentifierMutator-Literal,0,1,1,0.08179466,<mask>,"                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 :<mask>;
    }"
425,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16212,16212,IdentifierMutator-Literal,0,len,2,0.042342626,<mask>,"                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 :<mask>;
    }"
426,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16212,16212,IdentifierMutator-Literal,0,null,3,0.017626926,<mask>,"                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 :<mask>;
    }"
427,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",394,410,16212,16212,IdentifierMutator-Literal,0,pos,4,0.011236394,<mask>,"                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 :<mask>;
    }"
428,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16927,16930,BinaryOperatorMutator,&&,&,2,0.024439977,(out != null) <mask> (out.length == outAvail),"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null<mask>out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
429,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16927,16930,BinaryOperatorMutator,&&,||,3,0.008184119,(out != null) <mask> (out.length == outAvail),"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null<mask>out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
430,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16927,16930,BinaryOperatorMutator,&&,.,4,0.005439521,(out != null) <mask> (out.length == outAvail),"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null<mask>out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
431,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16919,16922,BinaryOperatorMutator,!=,==,1,0.020267881,out <mask> null,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out<mask>null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
432,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16919,16922,BinaryOperatorMutator,!=,=,2,0.007667449,out <mask> null,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out<mask>null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
433,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16919,16922,BinaryOperatorMutator,!=,!,3,0.0011559238,out <mask> null,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out<mask>null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
434,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16919,16922,BinaryOperatorMutator,!=,.,4,5.9748755E-4,out <mask> null,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out<mask>null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
435,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16916,16918,IdentifierMutator-Variable,out,buffer,1,0.09019017,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (<mask> != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
436,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16916,16918,IdentifierMutator-Variable,out,in,2,0.013020912,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (<mask> != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
437,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16916,16918,IdentifierMutator-Variable,out,raw,3,0.0044664345,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (<mask> != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
438,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16923,16926,IdentifierMutator-Literal,null,buffer,2,4.6255975E-4,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out !=<mask> && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
439,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16923,16926,IdentifierMutator-Literal,null,nil,3,4.514922E-4,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out !=<mask> && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
440,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16923,16926,IdentifierMutator-Literal,null,NULL,4,1.6594128E-4,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out !=<mask> && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
441,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16941,16944,BinaryOperatorMutator,==,<,1,0.1641892,out.length <mask> outAvail,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length<mask>outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
442,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16941,16944,BinaryOperatorMutator,==,>,2,0.14383334,out.length <mask> outAvail,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length<mask>outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
443,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16941,16944,BinaryOperatorMutator,==,<,3,0.09177125,out.length <mask> outAvail,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length<mask>outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
444,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16941,16944,BinaryOperatorMutator,==,>=,4,0.08300209,out.length <mask> outAvail,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length<mask>outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
445,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16931,16940,IdentifierMutator-Variable,out.length,avail,0,0.18955195,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null &&<mask> == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
446,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16931,16940,IdentifierMutator-Variable,out.length,pos,1,0.17935348,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null &&<mask> == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
447,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16931,16940,IdentifierMutator-Variable,out.length,0,2,0.14641057,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null &&<mask> == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
448,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16931,16940,IdentifierMutator-Variable,out.length,offset,3,0.03900305,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null &&<mask> == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
449,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16931,16940,IdentifierMutator-Variable,out.length,size,4,0.038735345,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null &&<mask> == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
450,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16931,16933,IdentifierMutator-Variable,out,buffer,1,0.067934506,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null &&<mask>.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
451,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16931,16933,IdentifierMutator-Variable,out,in,2,0.0053871595,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null &&<mask>.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
452,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16931,16933,IdentifierMutator-Variable,out,output,3,0.0024574546,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null &&<mask>.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
453,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16935,16940,FieldReferenceMutator,length,size,2,5.559805E-4,out.<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.<mask> == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
454,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16935,16940,FieldReferenceMutator,length,len,3,3.4576768E-4,out.<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.<mask> == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
455,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16935,16940,FieldReferenceMutator,length,read,4,2.1612718E-4,out.<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.<mask> == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
456,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16945,16952,IdentifierMutator-Variable,outAvail,0,0,0.57634324,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length ==<mask>) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
457,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16945,16952,IdentifierMutator-Variable,outAvail,capacity,1,0.13315304,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length ==<mask>) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
458,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16945,16952,IdentifierMutator-Variable,outAvail,limit,2,0.032771766,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length ==<mask>) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
459,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16945,16952,IdentifierMutator-Variable,outAvail,size,3,0.032395586,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length ==<mask>) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
460,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,427,16945,16952,IdentifierMutator-Variable,outAvail,1,4,0.016693259,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length ==<mask>) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
461,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,428,16975,16975,AssignmentMutator,buffer=out,[],0,0.90489644,buffer <mask>= out,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer<mask>= out;
            pos = outPos;
            readPos = outPos;
        }
    }"
462,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,428,16975,16975,AssignmentMutator,buffer=out,Array,1,0.025338857,buffer <mask>= out,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer<mask>= out;
            pos = outPos;
            readPos = outPos;
        }
    }"
463,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,428,16975,16975,AssignmentMutator,buffer=out,|,2,0.010240666,buffer <mask>= out,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer<mask>= out;
            pos = outPos;
            readPos = outPos;
        }
    }"
464,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,428,16975,16975,AssignmentMutator,buffer=out,Bytes,3,0.007355219,buffer <mask>= out,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer<mask>= out;
            pos = outPos;
            readPos = outPos;
        }
    }"
465,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,428,16975,16975,AssignmentMutator,buffer=out,*,4,0.0028085366,buffer <mask>= out,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer<mask>= out;
            pos = outPos;
            readPos = outPos;
        }
    }"
466,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,428,16969,16974,IdentifierMutator-Variable,buffer,buf,1,0.16216211,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {<mask> = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
467,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,428,16969,16974,IdentifierMutator-Variable,buffer,out,2,0.15520911,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {<mask> = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
468,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,428,16969,16974,IdentifierMutator-Variable,buffer,in,3,0.018152885,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {<mask> = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
469,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,428,16969,16974,IdentifierMutator-Variable,buffer,bytes,4,0.008103398,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {<mask> = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
470,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,428,16969,16974,FieldReferenceMutator,buffer,buf,1,0.16216211,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {<mask> = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
471,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,428,16969,16974,FieldReferenceMutator,buffer,out,2,0.15520911,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {<mask> = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
472,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,428,16969,16974,FieldReferenceMutator,buffer,in,3,0.018152885,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {<mask> = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
473,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,428,16969,16974,FieldReferenceMutator,buffer,bytes,4,0.008103398,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {<mask> = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
474,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,428,16978,16980,IdentifierMutator-Variable,out,null,1,0.02526874,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer =<mask>;
            pos = outPos;
            readPos = outPos;
        }
    }"
475,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,428,16978,16980,IdentifierMutator-Variable,out,0,2,0.0070171696,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer =<mask>;
            pos = outPos;
            readPos = outPos;
        }
    }"
476,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,428,16978,16980,IdentifierMutator-Variable,out,"""""",3,0.0062760864,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer =<mask>;
            pos = outPos;
            readPos = outPos;
        }
    }"
477,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,428,16978,16980,IdentifierMutator-Variable,out,in,4,0.0034074527,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer =<mask>;
            pos = outPos;
            readPos = outPos;
        }
    }"
478,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,429,16998,16998,AssignmentMutator,pos=outPos,|,0,0.6727651,pos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos<mask>= outPos;
            readPos = outPos;
        }
    }"
479,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,429,16998,16998,AssignmentMutator,pos=outPos,*,1,0.1740724,pos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos<mask>= outPos;
            readPos = outPos;
        }
    }"
480,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,429,16998,16998,AssignmentMutator,pos=outPos,^,2,0.031229826,pos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos<mask>= outPos;
            readPos = outPos;
        }
    }"
481,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,429,16998,16998,AssignmentMutator,pos=outPos,&,3,0.024800051,pos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos<mask>= outPos;
            readPos = outPos;
        }
    }"
482,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,429,16998,16998,AssignmentMutator,pos=outPos,/,4,0.011816745,pos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos<mask>= outPos;
            readPos = outPos;
        }
    }"
483,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,429,16995,16997,IdentifierMutator-Variable,pos,offset,0,0.38235542,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;<mask> = outPos;
            readPos = outPos;
        }
    }"
484,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,429,16995,16997,IdentifierMutator-Variable,pos,position,1,0.229,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;<mask> = outPos;
            readPos = outPos;
        }
    }"
485,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,429,16995,16997,IdentifierMutator-Variable,pos,index,3,0.029905181,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;<mask> = outPos;
            readPos = outPos;
        }
    }"
486,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,429,16995,16997,IdentifierMutator-Variable,pos,off,4,0.024775626,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;<mask> = outPos;
            readPos = outPos;
        }
    }"
487,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,429,16995,16997,FieldReferenceMutator,pos,offset,0,0.38235542,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;<mask> = outPos;
            readPos = outPos;
        }
    }"
488,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,429,16995,16997,FieldReferenceMutator,pos,position,1,0.229,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;<mask> = outPos;
            readPos = outPos;
        }
    }"
489,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,429,16995,16997,FieldReferenceMutator,pos,index,3,0.029905181,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;<mask> = outPos;
            readPos = outPos;
        }
    }"
490,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,429,16995,16997,FieldReferenceMutator,pos,off,4,0.024775626,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;<mask> = outPos;
            readPos = outPos;
        }
    }"
491,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,429,17001,17006,IdentifierMutator-Variable,outPos,pos,0,0.49127096,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos =<mask>;
            readPos = outPos;
        }
    }"
492,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,429,17001,17006,IdentifierMutator-Variable,outPos,0,1,0.43252343,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos =<mask>;
            readPos = outPos;
        }
    }"
493,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,429,17001,17006,IdentifierMutator-Variable,outPos,position,2,0.026665945,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos =<mask>;
            readPos = outPos;
        }
    }"
494,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,429,17001,17006,IdentifierMutator-Variable,outPos,offset,3,0.011094583,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos =<mask>;
            readPos = outPos;
        }
    }"
495,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,429,17001,17006,IdentifierMutator-Variable,outPos,start,4,0.005085646,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos =<mask>;
            readPos = outPos;
        }
    }"
496,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17028,17028,AssignmentMutator,readPos=outPos,|,0,0.7022642,readPos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos<mask>= outPos;
        }
    }"
497,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17028,17028,AssignmentMutator,readPos=outPos,*,1,0.204247,readPos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos<mask>= outPos;
        }
    }"
498,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17028,17028,AssignmentMutator,readPos=outPos,^,2,0.021865107,readPos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos<mask>= outPos;
        }
    }"
499,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17028,17028,AssignmentMutator,readPos=outPos,&,3,0.017436674,readPos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos<mask>= outPos;
        }
    }"
500,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17028,17028,AssignmentMutator,readPos=outPos,/,4,0.015005814,readPos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos<mask>= outPos;
        }
    }"
501,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17021,17027,IdentifierMutator-Variable,readPos,offset,0,0.32260492,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
502,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17021,17027,IdentifierMutator-Variable,readPos,avail,1,0.10832181,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
503,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17021,17027,IdentifierMutator-Variable,readPos,off,2,0.07419637,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
504,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17021,17027,IdentifierMutator-Variable,readPos,available,3,0.033441678,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
505,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17021,17027,IdentifierMutator-Variable,readPos,remaining,4,0.031114496,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
506,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17021,17027,FieldReferenceMutator,readPos,offset,0,0.32260492,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
507,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17021,17027,FieldReferenceMutator,readPos,avail,1,0.10832181,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
508,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17021,17027,FieldReferenceMutator,readPos,off,2,0.07419637,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
509,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17021,17027,FieldReferenceMutator,readPos,available,3,0.033441678,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
510,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17021,17027,FieldReferenceMutator,readPos,remaining,4,0.031114496,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
511,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17031,17036,IdentifierMutator-Variable,outPos,pos,0,0.52477264,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos =<mask>;
        }
    }"
512,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17031,17036,IdentifierMutator-Variable,outPos,0,1,0.3918165,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos =<mask>;
        }
    }"
513,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17031,17036,IdentifierMutator-Variable,outPos,position,2,0.023034813,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos =<mask>;
        }
    }"
514,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17031,17036,IdentifierMutator-Variable,outPos,offset,3,0.00632868,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos =<mask>;
        }
    }"
515,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",424,430,17031,17036,IdentifierMutator-Variable,outPos,off,4,0.0047229603,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos =<mask>;
        }
    }"
516,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,453,17905,17907,IdentifierMutator-Variable,eof,done,0,0.19429876,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
517,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,453,17905,17907,IdentifierMutator-Variable,eof,finished,1,0.16145582,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
518,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,453,17905,17907,IdentifierMutator-Variable,eof,end,2,0.074207194,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
519,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,453,17905,17907,IdentifierMutator-Variable,eof,stop,3,0.066900685,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
520,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,453,17905,17907,IdentifierMutator-Variable,eof,error,4,0.0407589,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
521,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,453,17905,17907,FieldReferenceMutator,eof,done,0,0.19429876,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
522,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,453,17905,17907,FieldReferenceMutator,eof,finished,1,0.16145582,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
523,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,453,17905,17907,FieldReferenceMutator,eof,end,2,0.074207194,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
524,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,453,17905,17907,FieldReferenceMutator,eof,stop,3,0.066900685,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
525,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,453,17905,17907,FieldReferenceMutator,eof,error,4,0.0407589,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
526,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,458,18063,18065,BinaryOperatorMutator,<,>,1,0.25205335,inAvail <mask> 0,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail<mask>0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
527,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,458,18063,18065,BinaryOperatorMutator,<,>,3,0.053521637,inAvail <mask> 0,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail<mask>0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
528,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,458,18063,18065,BinaryOperatorMutator,<,==,4,0.052368738,inAvail <mask> 0,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail<mask>0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
529,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,458,18056,18062,IdentifierMutator-Variable,inAvail,pos,0,0.7517562,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (<mask> < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
530,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,458,18056,18062,IdentifierMutator-Variable,inAvail,offset,1,0.08945218,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (<mask> < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
531,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,458,18056,18062,IdentifierMutator-Variable,inAvail,abs,2,0.0102591915,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (<mask> < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
532,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,458,18056,18062,IdentifierMutator-Variable,inAvail,off,3,0.007988152,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (<mask> < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
533,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,458,18056,18062,IdentifierMutator-Variable,inAvail,i,4,0.0068571665,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (<mask> < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
534,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,458,18066,18066,IdentifierMutator-Literal,0,1,1,0.0028293866,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail <<mask>) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
535,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,458,18066,18066,IdentifierMutator-Literal,0,pos,3,1.4442338E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail <<mask>) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
536,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,458,18066,18066,IdentifierMutator-Literal,0,size,4,1.2638369E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail <<mask>) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
537,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,459,18086,18086,AssignmentMutator,eof=true,|,0,0.97770643,eof <mask>= true,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof<mask>= true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
538,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,459,18086,18086,AssignmentMutator,eof=true,&,1,0.008145292,eof <mask>= true,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof<mask>= true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
539,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,459,18086,18086,AssignmentMutator,eof=true,!,2,0.0038271723,eof <mask>= true,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof<mask>= true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
540,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,459,18086,18086,AssignmentMutator,eof=true,|,3,0.0017310834,eof <mask>= true,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof<mask>= true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
541,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,459,18086,18086,AssignmentMutator,eof=true,||,4,0.0016703724,eof <mask>= true,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof<mask>= true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
542,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,459,18083,18085,IdentifierMutator-Variable,eof,done,0,0.5250192,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
543,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,459,18083,18085,IdentifierMutator-Variable,eof,finished,1,0.12915988,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
544,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,459,18083,18085,IdentifierMutator-Variable,eof,ended,2,0.03053205,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
545,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,459,18083,18085,IdentifierMutator-Variable,eof,closed,3,0.029502647,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
546,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,459,18083,18085,IdentifierMutator-Variable,eof,end,4,0.027778732,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
547,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,459,18083,18085,FieldReferenceMutator,eof,done,0,0.5250192,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
548,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,459,18083,18085,FieldReferenceMutator,eof,finished,1,0.12915988,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
549,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,459,18083,18085,FieldReferenceMutator,eof,ended,2,0.03053205,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
550,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,459,18083,18085,FieldReferenceMutator,eof,closed,3,0.029502647,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
551,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,459,18083,18085,FieldReferenceMutator,eof,end,4,0.027778732,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
552,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,459,18089,18092,IdentifierMutator-Literal,true,false,1,0.018989656,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof =<mask>;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
553,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,459,18089,18092,IdentifierMutator-Literal,true,TRUE,2,3.1368452E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof =<mask>;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
554,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,459,18089,18092,IdentifierMutator-Literal,true,1,4,1.6627122E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof =<mask>;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
555,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18125,18128,BinaryOperatorMutator,||,|,2,0.0071264445,(buffer == null) <mask> ((buffer.length - pos) < encodeSize),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null<mask>buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
556,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18125,18128,BinaryOperatorMutator,||,.,3,0.0054187533,(buffer == null) <mask> ((buffer.length - pos) < encodeSize),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null<mask>buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
557,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18125,18128,BinaryOperatorMutator,||,?,4,0.0022501089,(buffer == null) <mask> ((buffer.length - pos) < encodeSize),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null<mask>buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
558,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18117,18120,BinaryOperatorMutator,==,=,2,0.0045053973,buffer <mask> null,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer<mask>null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
559,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18117,18120,BinaryOperatorMutator,==,===,3,0.003271591,buffer <mask> null,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer<mask>null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
560,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18117,18120,BinaryOperatorMutator,==,_,4,7.145099E-4,buffer <mask> null,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer<mask>null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
561,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18111,18116,IdentifierMutator-Variable,buffer,buf,1,0.0022869138,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (<mask> == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
562,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18111,18116,IdentifierMutator-Variable,buffer,queue,2,0.0013071565,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (<mask> == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
563,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18111,18116,IdentifierMutator-Variable,buffer,Buffer,4,0.001093673,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (<mask> == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
564,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18111,18116,FieldReferenceMutator,buffer,buf,1,0.0022869138,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (<mask> == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
565,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18111,18116,FieldReferenceMutator,buffer,queue,2,0.0013071565,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (<mask> == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
566,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18111,18116,FieldReferenceMutator,buffer,Buffer,4,0.001093673,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (<mask> == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
567,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18121,18124,IdentifierMutator-Literal,null,NULL,1,7.0559524E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer ==<mask> || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
568,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18121,18124,IdentifierMutator-Literal,null,nil,2,6.426485E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer ==<mask> || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
569,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18121,18124,IdentifierMutator-Literal,null,undefined,4,1.4356709E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer ==<mask> || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
570,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18148,18150,BinaryOperatorMutator,<,>,1,0.18230161,(buffer.length - pos) <mask> encodeSize,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos<mask>encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
571,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18148,18150,BinaryOperatorMutator,<,>,3,0.090189576,(buffer.length - pos) <mask> encodeSize,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos<mask>encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
572,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18148,18150,BinaryOperatorMutator,<,==,4,0.067225225,(buffer.length - pos) <mask> encodeSize,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos<mask>encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
573,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18142,18144,BinaryOperatorMutator,-,*,1,0.15344656,buffer.length <mask> pos,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length<mask>pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
574,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18142,18144,BinaryOperatorMutator,-,+,2,0.1075529,buffer.length <mask> pos,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length<mask>pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
575,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18142,18144,BinaryOperatorMutator,-,/,3,0.05484094,buffer.length <mask> pos,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length<mask>pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
576,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18142,18144,BinaryOperatorMutator,-,_,4,0.02774839,buffer.length <mask> pos,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length<mask>pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
577,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18129,18141,IdentifierMutator-Variable,buffer.length,size,0,0.36834443,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
578,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18129,18141,IdentifierMutator-Variable,buffer.length,limit,1,0.14885868,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
579,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18129,18141,IdentifierMutator-Variable,buffer.length,length,2,0.06917371,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
580,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18129,18141,IdentifierMutator-Variable,buffer.length,capacity,3,0.062514275,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
581,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18129,18141,IdentifierMutator-Variable,buffer.length,end,4,0.041550223,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
582,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18129,18134,IdentifierMutator-Variable,buffer,buf,1,0.0018659565,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask>.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
583,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18129,18134,IdentifierMutator-Variable,buffer,buffers,2,0.0014083367,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask>.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
584,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18129,18134,IdentifierMutator-Variable,buffer,input,4,4.2346347E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask>.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
585,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18129,18134,FieldReferenceMutator,buffer,buf,1,0.0018659565,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask>.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
586,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18129,18134,FieldReferenceMutator,buffer,buffers,2,0.0014083367,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask>.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
587,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18129,18134,FieldReferenceMutator,buffer,input,4,4.2346347E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask>.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
588,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18136,18141,FieldReferenceMutator,length,size,1,0.003997627,buffer.<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
589,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18136,18141,FieldReferenceMutator,length,position,2,0.0032238394,buffer.<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
590,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18136,18141,FieldReferenceMutator,length,len,3,0.0021605846,buffer.<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
591,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18136,18141,FieldReferenceMutator,length,capacity,4,0.0014499035,buffer.<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
592,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18145,18147,IdentifierMutator-Variable,pos,offset,1,0.06881157,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
593,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18145,18147,IdentifierMutator-Variable,pos,size,2,0.025420422,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
594,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18145,18147,IdentifierMutator-Variable,pos,1,3,0.022509627,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
595,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18145,18147,IdentifierMutator-Variable,pos,len,4,0.020821935,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
596,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18145,18147,FieldReferenceMutator,pos,offset,1,0.06881157,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
597,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18145,18147,FieldReferenceMutator,pos,size,2,0.025420422,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
598,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18145,18147,FieldReferenceMutator,pos,1,3,0.022509627,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
599,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18145,18147,FieldReferenceMutator,pos,len,4,0.020821935,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
600,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18151,18160,IdentifierMutator-Variable,encodeSize,0,0,0.20743708,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
601,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18151,18160,IdentifierMutator-Variable,encodeSize,limit,1,0.19221807,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
602,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18151,18160,IdentifierMutator-Variable,encodeSize,length,2,0.050543293,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
603,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18151,18160,IdentifierMutator-Variable,encodeSize,size,3,0.047710393,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
604,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18151,18160,IdentifierMutator-Variable,encodeSize,len,4,0.04746102,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
605,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18151,18160,FieldReferenceMutator,encodeSize,0,0,0.20743708,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
606,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18151,18160,FieldReferenceMutator,encodeSize,limit,1,0.19221807,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
607,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18151,18160,FieldReferenceMutator,encodeSize,length,2,0.050543293,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
608,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18151,18160,FieldReferenceMutator,encodeSize,size,3,0.047710393,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
609,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,460,18151,18160,FieldReferenceMutator,encodeSize,len,4,0.04746102,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
610,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,461,18181,18192,MethodCallMutator,resizeBuffer,flush,0,0.3780323,<mask>(),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer"
611,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,461,18181,18192,MethodCallMutator,resizeBuffer,close,1,0.29456574,<mask>(),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer"
612,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,461,18181,18192,MethodCallMutator,resizeBuffer,reset,2,0.03776145,<mask>(),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer"
613,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,461,18181,18192,MethodCallMutator,resizeBuffer,end,3,0.03066888,<mask>(),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer"
614,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,461,18181,18192,MethodCallMutator,resizeBuffer,complete,4,0.03007615,<mask>(),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer"
615,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,463,18231,18237,IdentifierMutator-Variable,modulus,mode,0,0.17134255,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
616,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,463,18231,18237,IdentifierMutator-Variable,modulus,type,1,0.13142978,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
617,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,463,18231,18237,IdentifierMutator-Variable,modulus,bit,2,0.039191253,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
618,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,463,18231,18237,IdentifierMutator-Variable,modulus,pos,3,0.03375763,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
619,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,463,18231,18237,IdentifierMutator-Variable,modulus,version,4,0.027490968,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
620,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,463,18231,18237,FieldReferenceMutator,modulus,mode,0,0.17134255,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
621,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,463,18231,18237,FieldReferenceMutator,modulus,type,1,0.13142978,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
622,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,463,18231,18237,FieldReferenceMutator,modulus,bit,2,0.039191253,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
623,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,463,18231,18237,FieldReferenceMutator,modulus,pos,3,0.03375763,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
624,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,463,18231,18237,FieldReferenceMutator,modulus,version,4,0.027490968,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
625,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,464,18263,18263,IdentifierMutator-Literal,1,0,1,0.054954752,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
626,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,464,18263,18263,IdentifierMutator-Literal,1,3,2,0.04661077,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
627,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,464,18263,18263,IdentifierMutator-Literal,1,2,3,0.017740346,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
628,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,464,18263,18263,IdentifierMutator-Literal,1,4,4,0.008284727,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
629,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18300,18300,AssignmentMutator,buffer[pos++]=encodeTable[(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.7590315,buffer[pos++] <mask>= encodeTable[(x >> 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++]<mask>= encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
630,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18300,18300,AssignmentMutator,buffer[pos++]=encodeTable[(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.18873869,buffer[pos++] <mask>= encodeTable[(x >> 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++]<mask>= encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
631,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18300,18300,AssignmentMutator,buffer[pos++]=encodeTable[(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.020246686,buffer[pos++] <mask>= encodeTable[(x >> 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++]<mask>= encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
632,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18300,18300,AssignmentMutator,buffer[pos++]=encodeTable[(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.009587456,buffer[pos++] <mask>= encodeTable[(x >> 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++]<mask>= encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
633,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18300,18300,AssignmentMutator,buffer[pos++]=encodeTable[(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,4,0.0032216315,buffer[pos++] <mask>= encodeTable[(x >> 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++]<mask>= encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
634,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18294,18298,ArrayAccessMutator,pos++,pos,0,0.99829334,buffer[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
635,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18294,18298,ArrayAccessMutator,pos++,++,1,1.8626895E-4,buffer[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
636,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18294,18298,ArrayAccessMutator,pos++,neg,2,1.3344926E-4,buffer[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
637,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18294,18298,ArrayAccessMutator,pos++,push,3,1.0868133E-4,buffer[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
638,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18294,18298,ArrayAccessMutator,pos++,position,4,9.961791E-5,buffer[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
639,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18287,18292,IdentifierMutator-Variable,buffer,buf,2,6.9732615E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :<mask>[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++"
640,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18287,18292,IdentifierMutator-Variable,buffer,byte,3,6.6206E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :<mask>[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++"
641,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18287,18292,IdentifierMutator-Variable,buffer,Buffer,4,4.5481455E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :<mask>[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++"
642,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18287,18292,FieldReferenceMutator,buffer,buf,2,6.9732615E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :<mask>[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++"
643,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18287,18292,FieldReferenceMutator,buffer,byte,3,6.6206E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :<mask>[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++"
644,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18287,18292,FieldReferenceMutator,buffer,Buffer,4,4.5481455E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :<mask>[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++"
645,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18297,18298,UnaryOperatorMutator,++,+,2,2.5552875E-4,pos<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
646,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18297,18298,UnaryOperatorMutator,++,++;,3,7.411792E-5,pos<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
647,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18297,18298,UnaryOperatorMutator,++,--,4,5.8394104E-5,pos<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
648,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18294,18296,IdentifierMutator-Variable,pos,neg,1,4.9532995E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
649,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18294,18296,IdentifierMutator-Variable,pos,len,2,3.780034E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
650,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18294,18296,IdentifierMutator-Variable,pos,size,3,3.673594E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
651,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18294,18296,FieldReferenceMutator,pos,neg,1,4.9532995E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
652,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18294,18296,FieldReferenceMutator,pos,len,2,3.780034E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
653,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18294,18296,FieldReferenceMutator,pos,size,3,3.673594E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
654,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18315,18335,ArrayAccessMutator,(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.900394,encodeTable[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
              "
655,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18315,18335,ArrayAccessMutator,(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.021540886,encodeTable[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
              "
656,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18315,18335,ArrayAccessMutator,(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,2,0.011227727,encodeTable[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
              "
657,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18315,18335,ArrayAccessMutator,(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,xx,3,0.0072812657,encodeTable[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
              "
658,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18315,18335,ArrayAccessMutator,(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,X,4,0.004639651,encodeTable[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
              "
659,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18303,18313,IdentifierMutator-Variable,encodeTable,encode,0,0.3502056,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
660,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18303,18313,IdentifierMutator-Variable,encodeTable,decode,1,0.078881785,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
661,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18303,18313,IdentifierMutator-Variable,encodeTable,table,2,0.055399686,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
662,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18303,18313,IdentifierMutator-Variable,encodeTable,encoded,3,0.033183258,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
663,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18303,18313,IdentifierMutator-Variable,encodeTable,encoding,4,0.025917934,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
664,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18303,18313,FieldReferenceMutator,encodeTable,encode,0,0.3502056,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
665,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18303,18313,FieldReferenceMutator,encodeTable,decode,1,0.078881785,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
666,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18303,18313,FieldReferenceMutator,encodeTable,table,2,0.055399686,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
667,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18303,18313,FieldReferenceMutator,encodeTable,encoded,3,0.033183258,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
668,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18303,18313,FieldReferenceMutator,encodeTable,encoding,4,0.025917934,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
669,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18323,18325,BinaryOperatorMutator,&,|,2,0.0015625239,(x >> 2) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
      "
670,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18323,18325,BinaryOperatorMutator,&,^,3,1.20068624E-4,(x >> 2) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
      "
671,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18323,18325,BinaryOperatorMutator,&,~,4,3.0527593E-5,(x >> 2) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
      "
672,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18317,18320,BinaryOperatorMutator,>>,<<,0,0.7636425,x <mask> 2,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x<mask>2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
673,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18317,18320,BinaryOperatorMutator,>>,<<,1,0.20518024,x <mask> 2,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x<mask>2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
674,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18317,18320,BinaryOperatorMutator,>>,>>>,3,0.009546914,x <mask> 2,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x<mask>2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
675,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18316,18316,IdentifierMutator-Variable,x,y,1,0.0012006484,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(<mask> >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
676,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18316,18316,IdentifierMutator-Variable,x,xx,2,1.7857723E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(<mask> >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
677,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18316,18316,IdentifierMutator-Variable,x,b,3,9.344628E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(<mask> >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
678,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18316,18316,FieldReferenceMutator,x,y,1,0.0012006484,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(<mask> >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
679,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18316,18316,FieldReferenceMutator,x,xx,2,1.7857723E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(<mask> >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
680,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18316,18316,FieldReferenceMutator,x,b,3,9.344628E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(<mask> >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
681,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18321,18321,IdentifierMutator-Literal,2,6,1,0.20613815,<mask>," encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
682,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18321,18321,IdentifierMutator-Literal,2,4,2,0.19874048,<mask>," encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
683,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18321,18321,IdentifierMutator-Literal,2,3,3,0.07592256,<mask>," encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
684,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18321,18321,IdentifierMutator-Literal,2,5,4,0.07236434,<mask>," encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
685,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18326,18335,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,0,0.40965712,<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
686,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18326,18335,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,1,0.08821417,<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
687,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18326,18335,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,2,0.065015025,<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
688,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18326,18335,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,63,3,0.058936555,<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
689,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18326,18335,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,4,0.057763945,<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
690,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18326,18335,FieldReferenceMutator,MASK_6BITS,mask,0,0.40965712,org.apache.commons.codec.binary.Base64.<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
691,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18326,18335,FieldReferenceMutator,MASK_6BITS,7,1,0.08821417,org.apache.commons.codec.binary.Base64.<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
692,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18326,18335,FieldReferenceMutator,MASK_6BITS,3,2,0.065015025,org.apache.commons.codec.binary.Base64.<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
693,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18326,18335,FieldReferenceMutator,MASK_6BITS,63,3,0.058936555,org.apache.commons.codec.binary.Base64.<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
694,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,465,18326,18335,FieldReferenceMutator,MASK_6BITS,1,4,0.057763945,org.apache.commons.codec.binary.Base64.<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
695,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18372,18372,AssignmentMutator,buffer[pos++]=encodeTable[(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.7252279,buffer[pos++] <mask>= encodeTable[(x << 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"        return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6"
696,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18372,18372,AssignmentMutator,buffer[pos++]=encodeTable[(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.17072235,buffer[pos++] <mask>= encodeTable[(x << 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"        return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6"
697,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18372,18372,AssignmentMutator,buffer[pos++]=encodeTable[(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.045159075,buffer[pos++] <mask>= encodeTable[(x << 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"        return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6"
698,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18372,18372,AssignmentMutator,buffer[pos++]=encodeTable[(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.011590125,buffer[pos++] <mask>= encodeTable[(x << 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"        return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6"
699,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18372,18372,AssignmentMutator,buffer[pos++]=encodeTable[(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],||,4,0.007766007,buffer[pos++] <mask>= encodeTable[(x << 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"        return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6"
700,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18366,18370,ArrayAccessMutator,pos++,pos,0,0.9917168,buffer[<mask>],"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
701,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18366,18370,ArrayAccessMutator,pos++,++,1,0.0013328174,buffer[<mask>],"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
702,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18366,18370,ArrayAccessMutator,pos++,offset,2,4.2848106E-4,buffer[<mask>],"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
703,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18366,18370,ArrayAccessMutator,pos++,len,3,4.192596E-4,buffer[<mask>],"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
704,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18366,18370,ArrayAccessMutator,pos++,size,4,3.425378E-4,buffer[<mask>],"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
705,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18359,18364,IdentifierMutator-Variable,buffer,byte,2,0.0011420909,<mask>," int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &"
706,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18359,18364,IdentifierMutator-Variable,buffer,buf,3,0.001104526,<mask>," int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &"
707,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18359,18364,IdentifierMutator-Variable,buffer,pad,4,5.813769E-4,<mask>," int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &"
708,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18359,18364,FieldReferenceMutator,buffer,byte,2,0.0011420909,<mask>," int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &"
709,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18359,18364,FieldReferenceMutator,buffer,buf,3,0.001104526,<mask>," int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &"
710,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18359,18364,FieldReferenceMutator,buffer,pad,4,5.813769E-4,<mask>," int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &"
711,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18369,18370,UnaryOperatorMutator,++,+,2,1.6009732E-4,pos<mask>,"          return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
712,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18369,18370,UnaryOperatorMutator,++,++;,3,1.3102376E-4,pos<mask>,"          return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
713,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18369,18370,UnaryOperatorMutator,++,--,4,7.566134E-5,pos<mask>,"          return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
714,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18366,18368,IdentifierMutator-Variable,pos,len,1,1.2618772E-4,<mask>,"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK"
715,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18366,18368,IdentifierMutator-Variable,pos,size,2,1.21800396E-4,<mask>,"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK"
716,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18366,18368,IdentifierMutator-Variable,pos,neg,3,7.470588E-5,<mask>,"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK"
717,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18366,18368,FieldReferenceMutator,pos,len,1,1.2618772E-4,<mask>,"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK"
718,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18366,18368,FieldReferenceMutator,pos,size,2,1.21800396E-4,<mask>,"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK"
719,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18366,18368,FieldReferenceMutator,pos,neg,3,7.470588E-5,<mask>,"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK"
720,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18387,18407,ArrayAccessMutator,(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.46944067,encodeTable[<mask>],"    return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
721,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18387,18407,ArrayAccessMutator,(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.07089725,encodeTable[<mask>],"    return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
722,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18387,18407,ArrayAccessMutator,(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,2,0.05649393,encodeTable[<mask>],"    return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
723,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18387,18407,ArrayAccessMutator,(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,pos,3,0.042519633,encodeTable[<mask>],"    return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
724,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18387,18407,ArrayAccessMutator,(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,2,4,0.027682172,encodeTable[<mask>],"    return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
725,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18375,18385,IdentifierMutator-Variable,encodeTable,buffer,0,0.1352958,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
726,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18375,18385,IdentifierMutator-Variable,encodeTable,padding,1,0.13085298,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
727,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18375,18385,IdentifierMutator-Variable,encodeTable,encode,2,0.097900845,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
728,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18375,18385,IdentifierMutator-Variable,encodeTable,pad,3,0.07295836,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
729,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18375,18385,IdentifierMutator-Variable,encodeTable,decode,4,0.0514366,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
730,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18375,18385,FieldReferenceMutator,encodeTable,buffer,0,0.1352958,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
731,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18375,18385,FieldReferenceMutator,encodeTable,padding,1,0.13085298,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
732,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18375,18385,FieldReferenceMutator,encodeTable,encode,2,0.097900845,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
733,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18375,18385,FieldReferenceMutator,encodeTable,pad,3,0.07295836,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
734,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18375,18385,FieldReferenceMutator,encodeTable,decode,4,0.0514366,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
735,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18395,18397,BinaryOperatorMutator,&,|,2,0.01860183,(x << 4) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4)<mask>MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
      "
736,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18395,18397,BinaryOperatorMutator,&,^,3,7.7618205E-4,(x << 4) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4)<mask>MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
      "
737,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18395,18397,BinaryOperatorMutator,&,|,4,3.331899E-4,(x << 4) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4)<mask>MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
      "
738,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18389,18392,BinaryOperatorMutator,<<,>>,0,0.70748925,x <mask> 4,"  return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
   "
739,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18389,18392,BinaryOperatorMutator,<<,>>,1,0.20853873,x <mask> 4,"  return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
   "
740,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18389,18392,BinaryOperatorMutator,<<,-,3,0.010474247,x <mask> 4,"  return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
   "
741,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18389,18392,BinaryOperatorMutator,<<,->,4,0.0030510647,x <mask> 4,"  return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
   "
742,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18388,18388,IdentifierMutator-Variable,x,y,1,1.20980214E-4,<mask>,"   return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
  "
743,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18388,18388,IdentifierMutator-Variable,x,xx,2,6.727812E-5,<mask>,"   return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
  "
744,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18388,18388,IdentifierMutator-Variable,x,X,4,1.879067E-5,<mask>,"   return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
  "
745,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18388,18388,FieldReferenceMutator,x,y,1,1.20980214E-4,<mask>,"   return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
  "
746,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18388,18388,FieldReferenceMutator,x,xx,2,6.727812E-5,<mask>,"   return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
  "
747,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18388,18388,FieldReferenceMutator,x,X,4,1.879067E-5,<mask>,"   return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
  "
748,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18393,18393,IdentifierMutator-Literal,4,1,0,0.19887765,<mask>," return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
    "
749,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18393,18393,IdentifierMutator-Literal,4,3,1,0.14177974,<mask>," return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
    "
750,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18393,18393,IdentifierMutator-Literal,4,6,2,0.12830861,<mask>," return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
    "
751,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18393,18393,IdentifierMutator-Literal,4,5,3,0.11965267,<mask>," return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
    "
752,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18398,18407,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,0,0.41023532,<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
753,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18398,18407,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,1,0.122704715,<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
754,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18398,18407,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,2,0.05653944,<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
755,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18398,18407,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,255,3,0.0391737,<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
756,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18398,18407,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,4,0.037439104,<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
757,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18398,18407,FieldReferenceMutator,MASK_6BITS,mask,0,0.41023532,org.apache.commons.codec.binary.Base64.<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
758,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18398,18407,FieldReferenceMutator,MASK_6BITS,1,1,0.122704715,org.apache.commons.codec.binary.Base64.<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
759,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18398,18407,FieldReferenceMutator,MASK_6BITS,7,2,0.05653944,org.apache.commons.codec.binary.Base64.<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
760,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18398,18407,FieldReferenceMutator,MASK_6BITS,255,3,0.0391737,org.apache.commons.codec.binary.Base64.<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
761,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,466,18398,18407,FieldReferenceMutator,MASK_6BITS,3,4,0.037439104,org.apache.commons.codec.binary.Base64.<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
762,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18520,18523,BinaryOperatorMutator,==,!=,2,0.086140886,encodeTable <mask> org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,"           eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable<mask>STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
763,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18520,18523,BinaryOperatorMutator,==,_,3,0.017122086,encodeTable <mask> org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,"           eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable<mask>STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
764,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18520,18523,BinaryOperatorMutator,==,=,4,0.012852635,encodeTable <mask> org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,"           eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable<mask>STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
765,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18509,18519,IdentifierMutator-Variable,encodeTable,mode,0,0.17699435,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
766,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18509,18519,IdentifierMutator-Variable,encodeTable,type,1,0.13789225,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
767,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18509,18519,IdentifierMutator-Variable,encodeTable,x,2,0.086638995,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
768,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18509,18519,IdentifierMutator-Variable,encodeTable,padding,3,0.03498366,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
769,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18509,18519,IdentifierMutator-Variable,encodeTable,format,4,0.026209446,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
770,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18509,18519,FieldReferenceMutator,encodeTable,mode,0,0.17699435,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
771,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18509,18519,FieldReferenceMutator,encodeTable,type,1,0.13789225,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
772,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18509,18519,FieldReferenceMutator,encodeTable,x,2,0.086638995,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
773,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18509,18519,FieldReferenceMutator,encodeTable,padding,3,0.03498366,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
774,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18509,18519,FieldReferenceMutator,encodeTable,format,4,0.026209446,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
775,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18524,18544,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,null,0,0.8546874,<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
776,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18524,18544,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,0,1,0.039812077,<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
777,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18524,18544,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,1,2,0.016675754,<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
778,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18524,18544,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,nil,3,0.0074899825,<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
779,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18524,18544,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,NULL,4,0.006329378,<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
780,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18524,18544,FieldReferenceMutator,STANDARD_ENCODE_TABLE,null,0,0.8546874,org.apache.commons.codec.binary.Base64.<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
781,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18524,18544,FieldReferenceMutator,STANDARD_ENCODE_TABLE,0,1,0.039812077,org.apache.commons.codec.binary.Base64.<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
782,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18524,18544,FieldReferenceMutator,STANDARD_ENCODE_TABLE,1,2,0.016675754,org.apache.commons.codec.binary.Base64.<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
783,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18524,18544,FieldReferenceMutator,STANDARD_ENCODE_TABLE,nil,3,0.0074899825,org.apache.commons.codec.binary.Base64.<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
784,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,468,18524,18544,FieldReferenceMutator,STANDARD_ENCODE_TABLE,NULL,4,0.006329378,org.apache.commons.codec.binary.Base64.<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
785,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18586,18586,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,|,0,0.6528652,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD," encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the"
786,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18586,18586,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,^,1,0.16533926,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD," encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the"
787,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18586,18586,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,*,2,0.10714945,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD," encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the"
788,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18586,18586,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,&,3,0.019563375,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD," encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the"
789,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18586,18586,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,|,4,0.007915882,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD," encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the"
790,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18580,18584,ArrayAccessMutator,pos++,pos,0,0.9968829,buffer[<mask>]," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
791,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18580,18584,ArrayAccessMutator,pos++,++,1,4.8905157E-4,buffer[<mask>]," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
792,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18580,18584,ArrayAccessMutator,pos++,push,2,2.3605679E-4,buffer[<mask>]," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
793,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18580,18584,ArrayAccessMutator,pos++,size,3,1.4590618E-4,buffer[<mask>]," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
794,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18580,18584,ArrayAccessMutator,pos++,len,4,1.2484242E-4,buffer[<mask>]," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
795,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18573,18578,IdentifierMutator-Variable,buffer,pad,2,0.002047175,<mask>," eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SA"
796,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18573,18578,IdentifierMutator-Variable,buffer,byte,3,0.0013995272,<mask>," eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SA"
797,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18573,18578,IdentifierMutator-Variable,buffer,header,4,0.0012758017,<mask>," eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SA"
798,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18573,18578,FieldReferenceMutator,buffer,pad,2,0.002047175,<mask>," eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SA"
799,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18573,18578,FieldReferenceMutator,buffer,byte,3,0.0013995272,<mask>," eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SA"
800,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18573,18578,FieldReferenceMutator,buffer,header,4,0.0012758017,<mask>," eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SA"
801,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18583,18584,UnaryOperatorMutator,++,++;,2,1.7955797E-4,pos<mask>," pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
802,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18583,18584,UnaryOperatorMutator,++,+,3,1.1226093E-4,pos<mask>," pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
803,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18583,18584,UnaryOperatorMutator,++,--,4,7.178132E-5,pos<mask>," pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
804,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18580,18582,IdentifierMutator-Variable,pos,size,1,1.2489846E-4,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
805,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18580,18582,IdentifierMutator-Variable,pos,len,2,1.1581752E-4,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
806,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18580,18582,IdentifierMutator-Variable,pos,neg,3,7.4294054E-5,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
807,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18580,18582,IdentifierMutator-Variable,pos,count,4,3.158705E-5,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
808,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18580,18582,FieldReferenceMutator,pos,size,1,1.2489846E-4,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
809,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18580,18582,FieldReferenceMutator,pos,len,2,1.1581752E-4,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
810,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18580,18582,FieldReferenceMutator,pos,neg,3,7.4294054E-5,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
811,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18580,18582,FieldReferenceMutator,pos,count,4,3.158705E-5,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
812,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18589,18591,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,SPACE,0,0.08046446,<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
813,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18589,18591,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,ESC,1,0.061571576,<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
814,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18589,18591,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,END,2,0.059094843,<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
815,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18589,18591,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,CONTROL,3,0.04906223,<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
816,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18589,18591,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,OP,4,0.03906672,<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
817,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18589,18591,FieldReferenceMutator,PAD,SPACE,0,0.08046446,org.apache.commons.codec.binary.Base64.<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
818,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18589,18591,FieldReferenceMutator,PAD,ESC,1,0.061571576,org.apache.commons.codec.binary.Base64.<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
819,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18589,18591,FieldReferenceMutator,PAD,END,2,0.059094843,org.apache.commons.codec.binary.Base64.<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
820,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18589,18591,FieldReferenceMutator,PAD,CONTROL,3,0.04906223,org.apache.commons.codec.binary.Base64.<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
821,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,469,18589,18591,FieldReferenceMutator,PAD,OP,4,0.03906672,org.apache.commons.codec.binary.Base64.<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
822,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18631,18631,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,|,0,0.5270846,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"   }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++]<mask>= PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STAND"
823,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18631,18631,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,^,1,0.28804612,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"   }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++]<mask>= PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STAND"
824,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18631,18631,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,*,2,0.11740384,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"   }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++]<mask>= PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STAND"
825,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18631,18631,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,&,3,0.021688653,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"   }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++]<mask>= PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STAND"
826,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18631,18631,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,|,4,0.0054546776,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"   }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++]<mask>= PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STAND"
827,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18625,18629,ArrayAccessMutator,pos++,pos,0,0.99240816,buffer[<mask>],"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
828,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18625,18629,ArrayAccessMutator,pos++,++,1,7.495023E-4,buffer[<mask>],"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
829,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18625,18629,ArrayAccessMutator,pos++,len,2,5.879905E-4,buffer[<mask>],"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
830,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18625,18629,ArrayAccessMutator,pos++,size,3,5.464432E-4,buffer[<mask>],"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
831,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18625,18629,ArrayAccessMutator,pos++,neg,4,3.9207624E-4,buffer[<mask>],"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
832,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18618,18623,IdentifierMutator-Variable,buffer,pad,1,0.105922684,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
833,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18618,18623,IdentifierMutator-Variable,buffer,padding,2,0.103313886,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
834,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18618,18623,IdentifierMutator-Variable,buffer,output,3,0.047545757,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
835,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18618,18623,IdentifierMutator-Variable,buffer,out,4,0.018802049,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
836,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18618,18623,FieldReferenceMutator,buffer,pad,1,0.105922684,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
837,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18618,18623,FieldReferenceMutator,buffer,padding,2,0.103313886,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
838,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18618,18623,FieldReferenceMutator,buffer,output,3,0.047545757,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
839,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18618,18623,FieldReferenceMutator,buffer,out,4,0.018802049,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
840,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18628,18629,UnaryOperatorMutator,++,--,2,2.2116514E-4,pos<mask>,"     }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
841,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18628,18629,UnaryOperatorMutator,++,++;,3,1.4731004E-4,pos<mask>,"     }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
842,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18628,18629,UnaryOperatorMutator,++,+,4,1.0931901E-4,pos<mask>,"     }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
843,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18625,18627,IdentifierMutator-Variable,pos,len,1,5.8309315E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
844,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18625,18627,IdentifierMutator-Variable,pos,neg,2,4.683775E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
845,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18625,18627,IdentifierMutator-Variable,pos,size,3,4.2802066E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
846,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18625,18627,IdentifierMutator-Variable,pos,count,4,1.2716428E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
847,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18625,18627,FieldReferenceMutator,pos,len,1,5.8309315E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
848,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18625,18627,FieldReferenceMutator,pos,neg,2,4.683775E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
849,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18625,18627,FieldReferenceMutator,pos,size,3,4.2802066E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
850,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18625,18627,FieldReferenceMutator,pos,count,4,1.2716428E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
851,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18634,18636,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,SPACE,0,0.12200858,<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
852,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18634,18636,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,END,1,0.09355739,<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
853,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18634,18636,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,0,2,0.054976795,<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
854,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18634,18636,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,NULL,3,0.05491863,<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
855,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18634,18636,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,WHITE,4,0.04002215,<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
856,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18634,18636,FieldReferenceMutator,PAD,SPACE,0,0.12200858,org.apache.commons.codec.binary.Base64.<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
857,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18634,18636,FieldReferenceMutator,PAD,END,1,0.09355739,org.apache.commons.codec.binary.Base64.<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
858,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18634,18636,FieldReferenceMutator,PAD,0,2,0.054976795,org.apache.commons.codec.binary.Base64.<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
859,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18634,18636,FieldReferenceMutator,PAD,NULL,3,0.05491863,org.apache.commons.codec.binary.Base64.<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
860,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,470,18634,18636,FieldReferenceMutator,PAD,WHITE,4,0.04002215,org.apache.commons.codec.binary.Base64.<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
861,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,474,18710,18710,IdentifierMutator-Literal,2,10,0,0.08821452,<mask>,"] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
  "
862,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,474,18710,18710,IdentifierMutator-Literal,2,32,2,0.051304154,<mask>,"] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
  "
863,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,474,18710,18710,IdentifierMutator-Literal,2,8,3,0.04720085,<mask>,"] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
  "
864,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,474,18710,18710,IdentifierMutator-Literal,2,13,4,0.046745274,<mask>,"] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
  "
865,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18747,18747,AssignmentMutator,buffer[pos++]=encodeTable[(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.55993384,buffer[pos++] <mask>= encodeTable[(x >> 10) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++]<mask>= encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
      "
866,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18747,18747,AssignmentMutator,buffer[pos++]=encodeTable[(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.20096484,buffer[pos++] <mask>= encodeTable[(x >> 10) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++]<mask>= encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
      "
867,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18747,18747,AssignmentMutator,buffer[pos++]=encodeTable[(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.1375762,buffer[pos++] <mask>= encodeTable[(x >> 10) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++]<mask>= encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
      "
868,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18747,18747,AssignmentMutator,buffer[pos++]=encodeTable[(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.017520567,buffer[pos++] <mask>= encodeTable[(x >> 10) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++]<mask>= encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
      "
869,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18747,18747,AssignmentMutator,buffer[pos++]=encodeTable[(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS],||,4,0.013834343,buffer[pos++] <mask>= encodeTable[(x >> 10) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++]<mask>= encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
      "
870,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18741,18745,ArrayAccessMutator,pos++,pos,0,0.9974579,buffer[<mask>],"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
871,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18741,18745,ArrayAccessMutator,pos++,++,1,2.2722773E-4,buffer[<mask>],"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
872,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18741,18745,ArrayAccessMutator,pos++,position,2,1.3266483E-4,buffer[<mask>],"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
873,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18741,18745,ArrayAccessMutator,pos++,push,3,1.1517692E-4,buffer[<mask>],"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
874,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18741,18745,ArrayAccessMutator,pos++,len,4,1.0592083E-4,buffer[<mask>],"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
875,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18734,18739,IdentifierMutator-Variable,buffer,byte,2,0.0033770215,<mask>," encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :<mask>[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
  "
876,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18734,18739,IdentifierMutator-Variable,buffer,Buffer,3,0.0012441438,<mask>," encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :<mask>[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
  "
877,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18734,18739,IdentifierMutator-Variable,buffer,Buffer,4,8.9903094E-4,<mask>," encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :<mask>[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
  "
878,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18734,18739,FieldReferenceMutator,buffer,byte,2,0.0033770215,<mask>," encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :<mask>[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
  "
879,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18734,18739,FieldReferenceMutator,buffer,Buffer,3,0.0012441438,<mask>," encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :<mask>[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
  "
880,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18734,18739,FieldReferenceMutator,buffer,Buffer,4,8.9903094E-4,<mask>," encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :<mask>[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
  "
881,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18744,18745,UnaryOperatorMutator,++,+,2,8.97298E-5,pos<mask>,"              buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
882,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18744,18745,UnaryOperatorMutator,++,++;,3,4.1023275E-5,pos<mask>,"              buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
883,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18744,18745,UnaryOperatorMutator,++,+=,4,1.2975764E-5,pos<mask>,"              buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
884,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18741,18743,IdentifierMutator-Variable,pos,len,1,5.3168344E-5,<mask>,"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
    "
885,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18741,18743,IdentifierMutator-Variable,pos,size,2,4.046301E-5,<mask>,"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
    "
886,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18741,18743,IdentifierMutator-Variable,pos,neg,3,3.688734E-5,<mask>,"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
    "
887,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18741,18743,FieldReferenceMutator,pos,len,1,5.3168344E-5,<mask>,"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
    "
888,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18741,18743,FieldReferenceMutator,pos,size,2,4.046301E-5,<mask>,"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
    "
889,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18741,18743,FieldReferenceMutator,pos,neg,3,3.688734E-5,<mask>,"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
    "
890,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18762,18783,ArrayAccessMutator,(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.76318437,encodeTable[<mask>],"        buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
891,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18762,18783,ArrayAccessMutator,(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,1,0.050167717,encodeTable[<mask>],"        buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
892,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18762,18783,ArrayAccessMutator,(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS,2,2,0.037808243,encodeTable[<mask>],"        buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
893,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18762,18783,ArrayAccessMutator,(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,3,0.01987375,encodeTable[<mask>],"        buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
894,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18762,18783,ArrayAccessMutator,(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS,i,4,0.014358742,encodeTable[<mask>],"        buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
895,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18750,18760,IdentifierMutator-Variable,encodeTable,encode,0,0.23676376,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
896,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18750,18760,IdentifierMutator-Variable,encodeTable,table,1,0.16934125,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
897,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18750,18760,IdentifierMutator-Variable,encodeTable,buffer,2,0.052260287,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
898,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18750,18760,IdentifierMutator-Variable,encodeTable,decode,3,0.052082166,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
899,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18750,18760,IdentifierMutator-Variable,encodeTable,encoded,4,0.049330443,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
900,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18750,18760,FieldReferenceMutator,encodeTable,encode,0,0.23676376,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
901,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18750,18760,FieldReferenceMutator,encodeTable,table,1,0.16934125,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
902,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18750,18760,FieldReferenceMutator,encodeTable,buffer,2,0.052260287,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
903,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18750,18760,FieldReferenceMutator,encodeTable,decode,3,0.052082166,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
904,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18750,18760,FieldReferenceMutator,encodeTable,encoded,4,0.049330443,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
905,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18771,18773,BinaryOperatorMutator,&,|,2,2.3115605E-4,(x >> 10) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"   buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
   "
906,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18771,18773,BinaryOperatorMutator,&,^,3,3.7780846E-5,(x >> 10) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"   buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
   "
907,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18771,18773,BinaryOperatorMutator,&,+,4,2.1154929E-5,(x >> 10) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"   buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
   "
908,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18764,18767,BinaryOperatorMutator,>>,>>>,2,0.20307624,x <mask> 10,"      buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x<mask>10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
"
909,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18764,18767,BinaryOperatorMutator,>>,<<,3,0.16924475,x <mask> 10,"      buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x<mask>10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
"
910,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18764,18767,BinaryOperatorMutator,>>,>>>,4,0.022735298,x <mask> 10,"      buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x<mask>10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
"
911,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18763,18763,IdentifierMutator-Variable,x,y,1,2.1688893E-5,<mask>,"       buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(<mask> >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }"
912,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18763,18763,IdentifierMutator-Variable,x,xx,2,7.924042E-6,<mask>,"       buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(<mask> >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }"
913,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18763,18763,IdentifierMutator-Variable,x,X,3,6.468315E-6,<mask>,"       buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(<mask> >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }"
914,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18763,18763,FieldReferenceMutator,x,y,1,2.1688893E-5,<mask>,"       buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(<mask> >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }"
915,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18763,18763,FieldReferenceMutator,x,xx,2,7.924042E-6,<mask>,"       buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(<mask> >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }"
916,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18763,18763,FieldReferenceMutator,x,X,3,6.468315E-6,<mask>,"       buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(<mask> >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }"
917,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18768,18769,IdentifierMutator-Literal,10,6,0,0.4788991,<mask>,"     buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
 "
918,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18768,18769,IdentifierMutator-Literal,10,8,1,0.1464764,<mask>,"     buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
 "
919,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18768,18769,IdentifierMutator-Literal,10,5,2,0.09553842,<mask>,"     buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
 "
920,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18768,18769,IdentifierMutator-Literal,10,2,3,0.085164286,<mask>,"     buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
 "
921,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18768,18769,IdentifierMutator-Literal,10,7,4,0.068057455,<mask>,"     buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
 "
922,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18774,18783,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,0,0.12702222,<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
923,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18774,18783,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,1,0.09988066,<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
924,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18774,18783,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,255,2,0.0651491,<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
925,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18774,18783,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,3,0.06439076,<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
926,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18774,18783,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,4,0.04845752,<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
927,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18774,18783,FieldReferenceMutator,MASK_6BITS,7,0,0.12702222,org.apache.commons.codec.binary.Base64.<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
928,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18774,18783,FieldReferenceMutator,MASK_6BITS,mask,1,0.09988066,org.apache.commons.codec.binary.Base64.<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
929,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18774,18783,FieldReferenceMutator,MASK_6BITS,255,2,0.0651491,org.apache.commons.codec.binary.Base64.<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
930,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18774,18783,FieldReferenceMutator,MASK_6BITS,3,3,0.06439076,org.apache.commons.codec.binary.Base64.<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
931,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,475,18774,18783,FieldReferenceMutator,MASK_6BITS,1,4,0.04845752,org.apache.commons.codec.binary.Base64.<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
932,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18820,18820,AssignmentMutator,buffer[pos++]=encodeTable[(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.5297001,buffer[pos++] <mask>= encodeTable[(x >> 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
           "
933,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18820,18820,AssignmentMutator,buffer[pos++]=encodeTable[(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.21699329,buffer[pos++] <mask>= encodeTable[(x >> 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
           "
934,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18820,18820,AssignmentMutator,buffer[pos++]=encodeTable[(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.13735306,buffer[pos++] <mask>= encodeTable[(x >> 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
           "
935,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18820,18820,AssignmentMutator,buffer[pos++]=encodeTable[(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.022625152,buffer[pos++] <mask>= encodeTable[(x >> 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
           "
936,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18820,18820,AssignmentMutator,buffer[pos++]=encodeTable[(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],||,4,0.013497411,buffer[pos++] <mask>= encodeTable[(x >> 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
           "
937,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18814,18818,ArrayAccessMutator,pos++,pos,0,0.9963117,buffer[<mask>],"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
          "
938,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18814,18818,ArrayAccessMutator,pos++,++,1,0.0010268332,buffer[<mask>],"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
          "
939,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18814,18818,ArrayAccessMutator,pos++,push,2,2.1710286E-4,buffer[<mask>],"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
          "
940,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18814,18818,ArrayAccessMutator,pos++,neg,3,1.8292603E-4,buffer[<mask>],"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
          "
941,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18814,18818,ArrayAccessMutator,pos++,+,4,1.4297428E-4,buffer[<mask>],"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
          "
942,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18807,18812,IdentifierMutator-Variable,buffer,byte,2,0.0029300281,<mask>," encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
       "
943,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18807,18812,IdentifierMutator-Variable,buffer,Buffer,3,0.0017636112,<mask>," encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
       "
944,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18807,18812,IdentifierMutator-Variable,buffer,byte,4,0.0016083259,<mask>," encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
       "
945,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18807,18812,FieldReferenceMutator,buffer,byte,2,0.0029300281,<mask>," encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
       "
946,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18807,18812,FieldReferenceMutator,buffer,Buffer,3,0.0017636112,<mask>," encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
       "
947,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18807,18812,FieldReferenceMutator,buffer,byte,4,0.0016083259,<mask>," encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
       "
948,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18817,18818,UnaryOperatorMutator,++,+,2,1.1587008E-4,pos<mask>,"              // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
          "
949,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18817,18818,UnaryOperatorMutator,++,++;,3,5.3191947E-5,pos<mask>,"              // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
          "
950,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18817,18818,UnaryOperatorMutator,++,--,4,1.5739111E-5,pos<mask>,"              // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
          "
951,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18814,18816,IdentifierMutator-Variable,pos,len,2,2.567302E-5,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
         "
952,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18814,18816,IdentifierMutator-Variable,pos,neg,3,2.4802452E-5,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
         "
953,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18814,18816,IdentifierMutator-Variable,pos,size,4,2.0665399E-5,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
         "
954,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18814,18816,FieldReferenceMutator,pos,len,2,2.567302E-5,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
         "
955,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18814,18816,FieldReferenceMutator,pos,neg,3,2.4802452E-5,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
         "
956,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18814,18816,FieldReferenceMutator,pos,size,4,2.0665399E-5,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
         "
957,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18835,18855,ArrayAccessMutator,(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.76009697,encodeTable[<mask>],"        // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
958,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18835,18855,ArrayAccessMutator,(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,1,0.026352694,encodeTable[<mask>],"        // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
959,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18835,18855,ArrayAccessMutator,(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,2,0.024082247,encodeTable[<mask>],"        // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
960,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18835,18855,ArrayAccessMutator,(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,2,3,0.01902234,encodeTable[<mask>],"        // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
961,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18835,18855,ArrayAccessMutator,(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,xx,4,0.011275223,encodeTable[<mask>],"        // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
962,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18823,18833,IdentifierMutator-Variable,encodeTable,encode,0,0.24245185,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
963,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18823,18833,IdentifierMutator-Variable,encodeTable,table,1,0.2208678,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
964,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18823,18833,IdentifierMutator-Variable,encodeTable,decode,2,0.08833705,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
965,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18823,18833,IdentifierMutator-Variable,encodeTable,buffer,3,0.07402167,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
966,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18823,18833,IdentifierMutator-Variable,encodeTable,encoded,4,0.027084071,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
967,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18823,18833,FieldReferenceMutator,encodeTable,encode,0,0.24245185,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
968,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18823,18833,FieldReferenceMutator,encodeTable,table,1,0.2208678,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
969,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18823,18833,FieldReferenceMutator,encodeTable,decode,2,0.08833705,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
970,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18823,18833,FieldReferenceMutator,encodeTable,buffer,3,0.07402167,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
971,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18823,18833,FieldReferenceMutator,encodeTable,encoded,4,0.027084071,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
972,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18843,18845,BinaryOperatorMutator,&,|,2,8.0903503E-4,(x >> 4) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"   // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(line"
973,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18843,18845,BinaryOperatorMutator,&,^,3,7.6121454E-5,(x >> 4) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"   // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(line"
974,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18843,18845,BinaryOperatorMutator,&,~,4,2.5047766E-5,(x >> 4) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"   // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(line"
975,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18837,18840,BinaryOperatorMutator,>>,<<,0,0.3391889,x <mask> 4,"      // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.array"
976,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18837,18840,BinaryOperatorMutator,>>,<<,1,0.33032012,x <mask> 4,"      // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.array"
977,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18837,18840,BinaryOperatorMutator,>>,>>>,4,0.042499438,x <mask> 4,"      // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.array"
978,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18836,18836,IdentifierMutator-Variable,x,y,1,3.4249806E-5,<mask>,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System."
979,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18836,18836,IdentifierMutator-Variable,x,xx,2,2.1085285E-5,<mask>,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System."
980,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18836,18836,IdentifierMutator-Variable,x,wx,4,8.698228E-6,<mask>,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System."
981,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18836,18836,FieldReferenceMutator,x,y,1,3.4249806E-5,<mask>,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System."
982,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18836,18836,FieldReferenceMutator,x,xx,2,2.1085285E-5,<mask>,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System."
983,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18836,18836,FieldReferenceMutator,x,wx,4,8.698228E-6,<mask>,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System."
984,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18841,18841,IdentifierMutator-Literal,4,6,0,0.2945813,<mask>,"     // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy"
985,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18841,18841,IdentifierMutator-Literal,4,5,2,0.109946884,<mask>,"     // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy"
986,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18841,18841,IdentifierMutator-Literal,4,7,3,0.09871699,<mask>,"     // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy"
987,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18841,18841,IdentifierMutator-Literal,4,3,4,0.08316801,<mask>,"     // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy"
988,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18846,18855,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,0,0.16688965,<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
989,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18846,18855,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,1,0.15878484,<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
990,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18846,18855,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,2,0.0921082,<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
991,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18846,18855,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,4,3,0.063080065,<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
992,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18846,18855,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,2,4,0.04418742,<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
993,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18846,18855,FieldReferenceMutator,MASK_6BITS,3,0,0.16688965,org.apache.commons.codec.binary.Base64.<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
994,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18846,18855,FieldReferenceMutator,MASK_6BITS,7,1,0.15878484,org.apache.commons.codec.binary.Base64.<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
995,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18846,18855,FieldReferenceMutator,MASK_6BITS,1,2,0.0921082,org.apache.commons.codec.binary.Base64.<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
996,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18846,18855,FieldReferenceMutator,MASK_6BITS,4,3,0.063080065,org.apache.commons.codec.binary.Base64.<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
997,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,476,18846,18855,FieldReferenceMutator,MASK_6BITS,2,4,0.04418742,org.apache.commons.codec.binary.Base64.<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
998,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18892,18892,AssignmentMutator,buffer[pos++]=encodeTable[(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.7402295,buffer[pos++] <mask>= encodeTable[(x << 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
              "
999,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18892,18892,AssignmentMutator,buffer[pos++]=encodeTable[(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.15739428,buffer[pos++] <mask>= encodeTable[(x << 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
              "
1000,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18892,18892,AssignmentMutator,buffer[pos++]=encodeTable[(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.045090687,buffer[pos++] <mask>= encodeTable[(x << 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
              "
1001,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18892,18892,AssignmentMutator,buffer[pos++]=encodeTable[(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.010330504,buffer[pos++] <mask>= encodeTable[(x << 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
              "
1002,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18892,18892,AssignmentMutator,buffer[pos++]=encodeTable[(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],||,4,0.008814114,buffer[pos++] <mask>= encodeTable[(x << 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
              "
1003,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18886,18890,ArrayAccessMutator,pos++,pos,0,0.9864862,buffer[<mask>],"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1004,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18886,18890,ArrayAccessMutator,pos++,++,1,0.0037266272,buffer[<mask>],"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1005,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18886,18890,ArrayAccessMutator,pos++,push,2,8.595456E-4,buffer[<mask>],"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1006,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18886,18890,ArrayAccessMutator,pos++,size,3,4.756963E-4,buffer[<mask>],"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1007,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18886,18890,ArrayAccessMutator,pos++,+,4,4.3693662E-4,buffer[<mask>],"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1008,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18879,18884,IdentifierMutator-Variable,buffer,Buffer,2,0.0012239766,<mask>,"ips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
          "
1009,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18879,18884,IdentifierMutator-Variable,buffer,byte,3,0.0011830932,<mask>,"ips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
          "
1010,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18879,18884,IdentifierMutator-Variable,buffer,byte,4,0.0011270125,<mask>,"ips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
          "
1011,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18879,18884,FieldReferenceMutator,buffer,Buffer,2,0.0012239766,<mask>,"ips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
          "
1012,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18879,18884,FieldReferenceMutator,buffer,byte,3,0.0011830932,<mask>,"ips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
          "
1013,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18879,18884,FieldReferenceMutator,buffer,byte,4,0.0011270125,<mask>,"ips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
          "
1014,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18889,18890,UnaryOperatorMutator,++,+,2,1.195389E-4,pos<mask>,"      if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1015,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18889,18890,UnaryOperatorMutator,++,++;,3,7.291847E-5,pos<mask>,"      if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1016,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18889,18890,UnaryOperatorMutator,++,--,4,2.4648376E-5,pos<mask>,"      if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1017,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18886,18888,IdentifierMutator-Variable,pos,len,1,6.592597E-5,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1018,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18886,18888,IdentifierMutator-Variable,pos,size,3,5.018656E-5,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1019,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18886,18888,IdentifierMutator-Variable,pos,neg,4,4.5159315E-5,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1020,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18886,18888,FieldReferenceMutator,pos,len,1,6.592597E-5,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1021,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18886,18888,FieldReferenceMutator,pos,size,3,5.018656E-5,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1022,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18886,18888,FieldReferenceMutator,pos,neg,4,4.5159315E-5,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1023,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18907,18927,ArrayAccessMutator,(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.32501307,encodeTable[<mask>]," (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1024,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18907,18927,ArrayAccessMutator,(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.08488165,encodeTable[<mask>]," (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1025,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18907,18927,ArrayAccessMutator,(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,2,0.07098488,encodeTable[<mask>]," (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1026,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18907,18927,ArrayAccessMutator,(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,pos,3,0.049747486,encodeTable[<mask>]," (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1027,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18907,18927,ArrayAccessMutator,(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,2,4,0.038435612,encodeTable[<mask>]," (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1028,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18895,18905,IdentifierMutator-Variable,encodeTable,buffer,0,0.2287151,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1029,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18895,18905,IdentifierMutator-Variable,encodeTable,padding,1,0.09239903,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1030,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18895,18905,IdentifierMutator-Variable,encodeTable,encode,2,0.06309052,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1031,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18895,18905,IdentifierMutator-Variable,encodeTable,table,3,0.036829483,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1032,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18895,18905,IdentifierMutator-Variable,encodeTable,encoded,4,0.03361492,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1033,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18895,18905,FieldReferenceMutator,encodeTable,buffer,0,0.2287151,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1034,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18895,18905,FieldReferenceMutator,encodeTable,padding,1,0.09239903,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1035,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18895,18905,FieldReferenceMutator,encodeTable,encode,2,0.06309052,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1036,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18895,18905,FieldReferenceMutator,encodeTable,table,3,0.036829483,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1037,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18895,18905,FieldReferenceMutator,encodeTable,encoded,4,0.03361492,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1038,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18915,18917,BinaryOperatorMutator,&,|,2,0.006319396,(x << 2) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS," STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2)<mask>MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;"
1039,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18915,18917,BinaryOperatorMutator,&,|,3,3.0868832E-4,(x << 2) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS," STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2)<mask>MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;"
1040,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18915,18917,BinaryOperatorMutator,&,^,4,2.2057975E-4,(x << 2) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS," STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2)<mask>MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;"
1041,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18909,18912,BinaryOperatorMutator,<<,>>,0,0.42384383,x <mask> 2,"codeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator"
1042,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18909,18912,BinaryOperatorMutator,<<,>>,1,0.2099288,x <mask> 2,"codeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator"
1043,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18909,18912,BinaryOperatorMutator,<<,-,3,0.03422512,x <mask> 2,"codeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator"
1044,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18908,18908,IdentifierMutator-Variable,x,y,1,1.0864724E-4,<mask>,"encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSepar"
1045,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18908,18908,IdentifierMutator-Variable,x,xx,2,7.922586E-5,<mask>,"encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSepar"
1046,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18908,18908,IdentifierMutator-Variable,x,1,4,2.2680024E-5,<mask>,"encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSepar"
1047,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18908,18908,FieldReferenceMutator,x,y,1,1.0864724E-4,<mask>,"encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSepar"
1048,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18908,18908,FieldReferenceMutator,x,xx,2,7.922586E-5,<mask>,"encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSepar"
1049,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18908,18908,FieldReferenceMutator,x,1,4,2.2680024E-5,<mask>,"encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSepar"
1050,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18913,18913,IdentifierMutator-Literal,2,3,1,0.18994637,<mask>,"Table == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator."
1051,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18913,18913,IdentifierMutator-Literal,2,1,2,0.0896128,<mask>,"Table == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator."
1052,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18913,18913,IdentifierMutator-Literal,2,6,3,0.037396092,<mask>,"Table == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator."
1053,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18913,18913,IdentifierMutator-Literal,2,0,4,0.036962956,<mask>,"Table == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator."
1054,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18918,18927,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,0,0.23547813,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1055,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18918,18927,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,1,0.19351144,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1056,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18918,18927,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,2,0.09690851,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1057,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18918,18927,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,3,0.059470437,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1058,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18918,18927,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,255,4,0.050094225,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1059,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18918,18927,FieldReferenceMutator,MASK_6BITS,mask,0,0.23547813,org.apache.commons.codec.binary.Base64.<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1060,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18918,18927,FieldReferenceMutator,MASK_6BITS,1,1,0.19351144,org.apache.commons.codec.binary.Base64.<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1061,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18918,18927,FieldReferenceMutator,MASK_6BITS,7,2,0.09690851,org.apache.commons.codec.binary.Base64.<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1062,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18918,18927,FieldReferenceMutator,MASK_6BITS,3,3,0.059470437,org.apache.commons.codec.binary.Base64.<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1063,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,477,18918,18927,FieldReferenceMutator,MASK_6BITS,255,4,0.050094225,org.apache.commons.codec.binary.Base64.<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1064,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19040,19043,BinaryOperatorMutator,==,!=,2,0.095014386,encodeTable <mask> org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,"[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable<mask>STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1065,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19040,19043,BinaryOperatorMutator,==,===,3,0.016412526,encodeTable <mask> org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,"[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable<mask>STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1066,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19040,19043,BinaryOperatorMutator,==,_,4,0.014559802,encodeTable <mask> org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,"[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable<mask>STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1067,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19029,19039,IdentifierMutator-Variable,encodeTable,x,0,0.15962929,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1068,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19029,19039,IdentifierMutator-Variable,encodeTable,type,1,0.15209433,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1069,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19029,19039,IdentifierMutator-Variable,encodeTable,mode,2,0.07210477,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1070,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19029,19039,IdentifierMutator-Variable,encodeTable,format,3,0.028690048,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1071,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19029,19039,IdentifierMutator-Variable,encodeTable,b,4,0.020672118,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1072,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19029,19039,FieldReferenceMutator,encodeTable,x,0,0.15962929,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1073,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19029,19039,FieldReferenceMutator,encodeTable,type,1,0.15209433,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1074,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19029,19039,FieldReferenceMutator,encodeTable,mode,2,0.07210477,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1075,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19029,19039,FieldReferenceMutator,encodeTable,format,3,0.028690048,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1076,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19029,19039,FieldReferenceMutator,encodeTable,b,4,0.020672118,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1077,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19044,19064,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,null,0,0.4124047,<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1078,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19044,19064,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,1,1,0.11573551,<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1079,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19044,19064,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,0,2,0.09438745,<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1080,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19044,19064,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,2,3,0.081205286,<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1081,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19044,19064,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,3,4,0.0308826,<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1082,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19044,19064,FieldReferenceMutator,STANDARD_ENCODE_TABLE,null,0,0.4124047,org.apache.commons.codec.binary.Base64.<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1083,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19044,19064,FieldReferenceMutator,STANDARD_ENCODE_TABLE,1,1,0.11573551,org.apache.commons.codec.binary.Base64.<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1084,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19044,19064,FieldReferenceMutator,STANDARD_ENCODE_TABLE,0,2,0.09438745,org.apache.commons.codec.binary.Base64.<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1085,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19044,19064,FieldReferenceMutator,STANDARD_ENCODE_TABLE,2,3,0.081205286,org.apache.commons.codec.binary.Base64.<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1086,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,479,19044,19064,FieldReferenceMutator,STANDARD_ENCODE_TABLE,3,4,0.0308826,org.apache.commons.codec.binary.Base64.<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1087,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19106,19106,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,|,0,0.74714583,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"           break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resize"
1088,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19106,19106,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,^,1,0.14103618,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"           break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resize"
1089,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19106,19106,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,*,2,0.08161489,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"           break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resize"
1090,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19106,19106,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,&,3,0.01056231,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"           break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resize"
1091,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19106,19106,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,<<,4,0.0064846696,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"           break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resize"
1092,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19100,19104,ArrayAccessMutator,pos++,pos,0,0.99443924,buffer[<mask>],"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                   "
1093,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19100,19104,ArrayAccessMutator,pos++,++,1,5.0441327E-4,buffer[<mask>],"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                   "
1094,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19100,19104,ArrayAccessMutator,pos++,len,2,3.9711234E-4,buffer[<mask>],"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                   "
1095,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19100,19104,ArrayAccessMutator,pos++,offset,3,3.7979882E-4,buffer[<mask>],"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                   "
1096,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19100,19104,ArrayAccessMutator,pos++,size,4,3.337856E-4,buffer[<mask>],"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                   "
1097,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19093,19098,IdentifierMutator-Variable,buffer,buf,2,5.310403E-4,<mask>,"                   }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                "
1098,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19093,19098,IdentifierMutator-Variable,buffer,pad,3,4.2705913E-4,<mask>,"                   }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                "
1099,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19093,19098,IdentifierMutator-Variable,buffer,padding,4,2.9652216E-4,<mask>,"                   }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                "
1100,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19093,19098,FieldReferenceMutator,buffer,buf,2,5.310403E-4,<mask>,"                   }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                "
1101,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19093,19098,FieldReferenceMutator,buffer,pad,3,4.2705913E-4,<mask>,"                   }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                "
1102,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19093,19098,FieldReferenceMutator,buffer,padding,4,2.9652216E-4,<mask>,"                   }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                "
1103,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19103,19104,UnaryOperatorMutator,++,++;,2,6.1777784E-5,pos<mask>,"             break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos<mask>] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                   "
1104,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19103,19104,UnaryOperatorMutator,++,+,3,5.112599E-5,pos<mask>,"             break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos<mask>] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                   "
1105,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19103,19104,UnaryOperatorMutator,++,--,4,1.7274688E-5,pos<mask>,"             break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos<mask>] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                   "
1106,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19100,19102,IdentifierMutator-Variable,pos,len,1,1.6041941E-4,<mask>,"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                  "
1107,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19100,19102,IdentifierMutator-Variable,pos,size,2,1.3862847E-4,<mask>,"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                  "
1108,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19100,19102,IdentifierMutator-Variable,pos,offset,4,5.0819417E-5,<mask>,"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                  "
1109,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19100,19102,FieldReferenceMutator,pos,len,1,1.6041941E-4,<mask>,"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                  "
1110,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19100,19102,FieldReferenceMutator,pos,size,2,1.3862847E-4,<mask>,"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                  "
1111,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19100,19102,FieldReferenceMutator,pos,offset,4,5.0819417E-5,<mask>,"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                  "
1112,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19109,19111,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,x,0,0.55746853,<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1113,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19109,19111,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,0,1,0.168952,<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1114,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19109,19111,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,"''",2,0.042754926,<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1115,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19109,19111,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,"""""",3,0.03778507,<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1116,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19109,19111,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,null,4,0.033318948,<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1117,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19109,19111,FieldReferenceMutator,PAD,x,0,0.55746853,org.apache.commons.codec.binary.Base64.<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1118,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19109,19111,FieldReferenceMutator,PAD,0,1,0.168952,org.apache.commons.codec.binary.Base64.<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1119,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19109,19111,FieldReferenceMutator,PAD,"''",2,0.042754926,org.apache.commons.codec.binary.Base64.<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1120,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19109,19111,FieldReferenceMutator,PAD,"""""",3,0.03778507,org.apache.commons.codec.binary.Base64.<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1121,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,480,19109,19111,FieldReferenceMutator,PAD,null,4,0.033318948,org.apache.commons.codec.binary.Base64.<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1122,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19207,19210,BinaryOperatorMutator,&&,||,2,0.047093447,(lineLength > 0) <mask> (pos > 0),"                buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0<mask>pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
       "
1123,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19207,19210,BinaryOperatorMutator,&&,|,3,0.023211166,(lineLength > 0) <mask> (pos > 0),"                buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0<mask>pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
       "
1124,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19207,19210,BinaryOperatorMutator,&&,+,4,0.02307327,(lineLength > 0) <mask> (pos > 0),"                buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0<mask>pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
       "
1125,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19203,19205,BinaryOperatorMutator,>,==,2,0.23655224,lineLength <mask> 0,"                  buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength<mask>0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
     "
1126,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19203,19205,BinaryOperatorMutator,>,==,3,0.03507341,lineLength <mask> 0,"                  buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength<mask>0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
     "
1127,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19203,19205,BinaryOperatorMutator,>,!=,4,0.011662802,lineLength <mask> 0,"                  buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength<mask>0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
     "
1128,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19193,19202,IdentifierMutator-Variable,lineLength,buffer,0,0.80018413,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1129,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19193,19202,IdentifierMutator-Variable,lineLength,length,1,0.038591832,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1130,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19193,19202,IdentifierMutator-Variable,lineLength,pos,2,0.012767276,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1131,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19193,19202,IdentifierMutator-Variable,lineLength,size,3,0.010971412,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1132,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19193,19202,IdentifierMutator-Variable,lineLength,offset,4,0.010061023,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1133,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19193,19202,FieldReferenceMutator,lineLength,buffer,0,0.80018413,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1134,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19193,19202,FieldReferenceMutator,lineLength,length,1,0.038591832,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1135,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19193,19202,FieldReferenceMutator,lineLength,pos,2,0.012767276,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1136,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19193,19202,FieldReferenceMutator,lineLength,size,3,0.010971412,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1137,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19193,19202,FieldReferenceMutator,lineLength,offset,4,0.010061023,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1138,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19206,19206,IdentifierMutator-Literal,0,1,1,0.059038393,<mask>,"                 buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength ><mask> && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
      "
1139,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19206,19206,IdentifierMutator-Literal,0,2,2,0.0053756633,<mask>,"                 buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength ><mask> && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
      "
1140,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19206,19206,IdentifierMutator-Literal,0,3,3,0.001344272,<mask>,"                 buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength ><mask> && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
      "
1141,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19206,19206,IdentifierMutator-Literal,0,4,4,0.0011896865,<mask>,"                 buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength ><mask> && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
      "
1142,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19214,19216,BinaryOperatorMutator,>,==,1,0.17634995,pos <mask> 0,"              buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos<mask>0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
         "
1143,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19214,19216,BinaryOperatorMutator,>,==,3,0.050473865,pos <mask> 0,"              buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos<mask>0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
         "
1144,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19214,19216,BinaryOperatorMutator,>,>=,4,0.043412216,pos <mask> 0,"              buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos<mask>0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
         "
1145,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19211,19213,IdentifierMutator-Variable,pos,offset,1,0.015939124,<mask>,"               buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 &&<mask> > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
        "
1146,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19211,19213,IdentifierMutator-Variable,pos,position,2,0.014173968,<mask>,"               buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 &&<mask> > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
        "
1147,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19211,19213,IdentifierMutator-Variable,pos,index,3,0.0041875197,<mask>,"               buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 &&<mask> > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
        "
1148,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19211,19213,IdentifierMutator-Variable,pos,length,4,0.0037898691,<mask>,"               buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 &&<mask> > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
        "
1149,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19211,19213,FieldReferenceMutator,pos,offset,1,0.015939124,<mask>,"               buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 &&<mask> > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
        "
1150,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19211,19213,FieldReferenceMutator,pos,position,2,0.014173968,<mask>,"               buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 &&<mask> > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
        "
1151,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19211,19213,FieldReferenceMutator,pos,index,3,0.0041875197,<mask>,"               buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 &&<mask> > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
        "
1152,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19211,19213,FieldReferenceMutator,pos,length,4,0.0037898691,<mask>,"               buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 &&<mask> > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
        "
1153,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19217,19217,IdentifierMutator-Literal,0,start,1,0.009996922,<mask>,"             buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos ><mask>) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
          "
1154,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19217,19217,IdentifierMutator-Literal,0,limit,2,0.0070491247,<mask>,"             buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos ><mask>) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
          "
1155,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19217,19217,IdentifierMutator-Literal,0,pos,3,0.0058853226,<mask>,"             buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos ><mask>) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
          "
1156,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,484,19217,19217,IdentifierMutator-Literal,0,1,4,0.0048765177,<mask>,"             buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos ><mask>) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
          "
1157,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19245,19253,MethodCallMutator,arraycopy,printf,0,0.4575249,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)","(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
         "
1158,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19245,19253,MethodCallMutator,arraycopy,copy,1,0.31570378,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)","(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
         "
1159,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19245,19253,MethodCallMutator,arraycopy,format,2,0.052819908,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)","(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
         "
1160,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19245,19253,MethodCallMutator,arraycopy,write,3,0.05220404,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)","(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
         "
1161,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19245,19253,MethodCallMutator,arraycopy,replace,4,0.011798085,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)","(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
         "
1162,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19255,19267,IdentifierMutator-Variable,lineSeparator,in,0,0.41719532,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1163,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19255,19267,IdentifierMutator-Variable,lineSeparator,buffer,1,0.3444904,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1164,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19255,19267,IdentifierMutator-Variable,lineSeparator,line,2,0.079513244,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1165,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19255,19267,IdentifierMutator-Variable,lineSeparator,lines,3,0.06415421,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1166,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19255,19267,IdentifierMutator-Variable,lineSeparator,out,4,0.00818442,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1167,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19255,19267,FieldReferenceMutator,lineSeparator,in,0,0.41719532,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1168,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19255,19267,FieldReferenceMutator,lineSeparator,buffer,1,0.3444904,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1169,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19255,19267,FieldReferenceMutator,lineSeparator,line,2,0.079513244,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1170,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19255,19267,FieldReferenceMutator,lineSeparator,lines,3,0.06415421,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1171,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19255,19267,FieldReferenceMutator,lineSeparator,out,4,0.00818442,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1172,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19270,19270,IdentifierMutator-Literal,0,1,2,0.0018115321,<mask>,"_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator,<mask>, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                "
1173,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19270,19270,IdentifierMutator-Literal,0,pos,3,5.1056716E-4,<mask>,"_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator,<mask>, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                "
1174,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19270,19270,IdentifierMutator-Literal,0,offset,4,3.5733078E-4,<mask>,"_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator,<mask>, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                "
1175,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19273,19278,IdentifierMutator-Variable,buffer,in,1,0.0059449216,<mask>,"BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1176,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19273,19278,IdentifierMutator-Variable,buffer,buf,2,0.0011486965,<mask>,"BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1177,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19273,19278,IdentifierMutator-Variable,buffer,line,3,0.0011190659,<mask>,"BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1178,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19273,19278,IdentifierMutator-Variable,buffer,out,4,0.0010440564,<mask>,"BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1179,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19273,19278,FieldReferenceMutator,buffer,in,1,0.0059449216,<mask>,"BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1180,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19273,19278,FieldReferenceMutator,buffer,buf,2,0.0011486965,<mask>,"BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1181,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19273,19278,FieldReferenceMutator,buffer,line,3,0.0011190659,<mask>,"BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1182,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19273,19278,FieldReferenceMutator,buffer,out,4,0.0010440564,<mask>,"BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1183,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19281,19283,IdentifierMutator-Variable,pos,0,1,0.011068404,<mask>,"];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b"
1184,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19281,19283,IdentifierMutator-Variable,pos,1,3,6.6461036E-4,<mask>,"];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b"
1185,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19281,19283,IdentifierMutator-Variable,pos,offset,4,5.925577E-4,<mask>,"];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b"
1186,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19281,19283,FieldReferenceMutator,pos,0,1,0.011068404,<mask>,"];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b"
1187,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19281,19283,FieldReferenceMutator,pos,1,3,6.6461036E-4,<mask>,"];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b"
1188,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19281,19283,FieldReferenceMutator,pos,offset,4,5.925577E-4,<mask>,"];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b"
1189,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19286,19305,IdentifierMutator-Variable,lineSeparator.length,len,0,0.5981063,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1190,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19286,19305,IdentifierMutator-Variable,lineSeparator.length,length,1,0.10379741,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1191,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19286,19305,IdentifierMutator-Variable,lineSeparator.length,n,2,0.07983037,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1192,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19286,19305,IdentifierMutator-Variable,lineSeparator.length,pos,3,0.036363974,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1193,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19286,19305,IdentifierMutator-Variable,lineSeparator.length,len,4,0.013404466,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1194,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19286,19298,IdentifierMutator-Variable,lineSeparator,buffer,0,0.9907803,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1195,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19286,19298,IdentifierMutator-Variable,lineSeparator,buffer,1,0.004720448,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1196,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19286,19298,IdentifierMutator-Variable,lineSeparator,line,2,0.0014906409,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1197,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19286,19298,IdentifierMutator-Variable,lineSeparator,buf,3,3.0753633E-4,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1198,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19286,19298,IdentifierMutator-Variable,lineSeparator,Buffer,4,2.605978E-4,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1199,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19286,19298,FieldReferenceMutator,lineSeparator,buffer,0,0.9907803,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1200,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19286,19298,FieldReferenceMutator,lineSeparator,buffer,1,0.004720448,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1201,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19286,19298,FieldReferenceMutator,lineSeparator,line,2,0.0014906409,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1202,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19286,19298,FieldReferenceMutator,lineSeparator,buf,3,3.0753633E-4,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1203,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19286,19298,FieldReferenceMutator,lineSeparator,Buffer,4,2.605978E-4,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1204,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19300,19305,FieldReferenceMutator,length,len,1,7.863087E-5,lineSeparator.<mask>,"               buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1205,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19300,19305,FieldReferenceMutator,length,position,2,3.2318705E-5,lineSeparator.<mask>,"               buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1206,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,485,19300,19305,FieldReferenceMutator,length,count,4,1.1865282E-5,lineSeparator.<mask>,"               buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1207,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19328,19328,AssignmentMutator,pos+=lineSeparator.length,++,0,0.8251513,pos <mask>= lineSeparator.length," = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos<mask>+= lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1208,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19328,19328,AssignmentMutator,pos+=lineSeparator.length,*,1,0.04038883,pos <mask>= lineSeparator.length," = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos<mask>+= lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1209,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19328,19328,AssignmentMutator,pos+=lineSeparator.length,*,2,0.018502941,pos <mask>= lineSeparator.length," = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos<mask>+= lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1210,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19328,19328,AssignmentMutator,pos+=lineSeparator.length,//,3,0.017402723,pos <mask>= lineSeparator.length," = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos<mask>+= lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1211,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19328,19328,AssignmentMutator,pos+=lineSeparator.length,|,4,0.012794839,pos <mask>= lineSeparator.length," = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos<mask>+= lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1212,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19325,19327,IdentifierMutator-Variable,pos,position,2,4.3460948E-4,<mask>,"             buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1213,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19325,19327,IdentifierMutator-Variable,pos,Pos,3,1.5368845E-4,<mask>,"             buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1214,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19325,19327,IdentifierMutator-Variable,pos,offset,4,1.2691536E-4,<mask>,"             buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1215,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19325,19327,FieldReferenceMutator,pos,position,2,4.3460948E-4,<mask>,"             buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1216,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19325,19327,FieldReferenceMutator,pos,Pos,3,1.5368845E-4,<mask>,"             buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1217,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19325,19327,FieldReferenceMutator,pos,offset,4,1.2691536E-4,<mask>,"             buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1218,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19332,19351,IdentifierMutator-Variable,lineSeparator.length,length,0,0.13518956,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1219,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19332,19351,IdentifierMutator-Variable,lineSeparator.length,2,1,0.1337497,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1220,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19332,19351,IdentifierMutator-Variable,lineSeparator.length,1,2,0.11780608,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1221,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19332,19351,IdentifierMutator-Variable,lineSeparator.length,4,3,0.07759516,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1222,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19332,19351,IdentifierMutator-Variable,lineSeparator.length,len,4,0.052620254,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1223,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19332,19344,IdentifierMutator-Variable,lineSeparator,buffer,0,0.9921069,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1224,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19332,19344,IdentifierMutator-Variable,lineSeparator,line,1,0.0033804025,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1225,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19332,19344,IdentifierMutator-Variable,lineSeparator,buf,2,5.8461976E-4,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1226,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19332,19344,IdentifierMutator-Variable,lineSeparator,buffer,3,2.2123357E-4,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1227,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19332,19344,IdentifierMutator-Variable,lineSeparator,text,4,1.9107935E-4,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1228,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19332,19344,FieldReferenceMutator,lineSeparator,buffer,0,0.9921069,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1229,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19332,19344,FieldReferenceMutator,lineSeparator,line,1,0.0033804025,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1230,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19332,19344,FieldReferenceMutator,lineSeparator,buf,2,5.8461976E-4,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1231,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19332,19344,FieldReferenceMutator,lineSeparator,buffer,3,2.2123357E-4,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1232,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19332,19344,FieldReferenceMutator,lineSeparator,text,4,1.9107935E-4,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1233,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19346,19351,FieldReferenceMutator,length,position,1,3.4089544E-4,lineSeparator.<mask>," << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1234,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19346,19351,FieldReferenceMutator,length,len,2,1.9360203E-4,lineSeparator.<mask>," << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1235,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,486,19346,19351,FieldReferenceMutator,length,width,3,7.743036E-5,lineSeparator.<mask>," << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1236,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19410,19410,IdentifierMutator-Literal,0,pos,1,0.0058404254,<mask>," size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i =<mask>; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
    "
1237,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19410,19410,IdentifierMutator-Literal,0,1,2,0.0052376254,<mask>," size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i =<mask>; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
    "
1238,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19410,19410,IdentifierMutator-Literal,0,offset,3,0.0019229413,<mask>," size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i =<mask>; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
    "
1239,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19410,19410,IdentifierMutator-Literal,0,start,4,0.001858975,<mask>," size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i =<mask>; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
    "
1240,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19414,19416,BinaryOperatorMutator,<,++,2,0.0017309716,i <mask> inAvail,"                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i<mask>inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
       "
1241,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19414,19416,BinaryOperatorMutator,<,<=,3,9.2930626E-4,i <mask> inAvail,"                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i<mask>inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
       "
1242,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19414,19416,BinaryOperatorMutator,<,==,4,8.852311E-4,i <mask> inAvail,"                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i<mask>inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
       "
1243,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19413,19413,IdentifierMutator-Variable,i,I,2,1.2223773E-4,<mask>,"
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0;<mask> < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
      "
1244,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19413,19413,IdentifierMutator-Variable,i,I,3,3.1330077E-5,<mask>,"
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0;<mask> < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
      "
1245,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19413,19413,IdentifierMutator-Variable,i,ii,4,2.9303501E-5,<mask>,"
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0;<mask> < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
      "
1246,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19417,19423,IdentifierMutator-Variable,inAvail,size,0,0.14366975,<mask>,"                   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i <<mask>; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
          "
1247,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19417,19423,IdentifierMutator-Variable,inAvail,length,1,0.0788649,<mask>,"                   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i <<mask>; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
          "
1248,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19417,19423,IdentifierMutator-Variable,inAvail,256,2,0.07440925,<mask>,"                   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i <<mask>; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
          "
1249,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19417,19423,IdentifierMutator-Variable,inAvail,len,3,0.07136424,<mask>,"                   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i <<mask>; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
          "
1250,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19417,19423,IdentifierMutator-Variable,inAvail,n,4,0.059067473,<mask>,"                   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i <<mask>; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
          "
1251,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19427,19428,UnaryOperatorMutator,++,++),2,0.0013965091,i<mask>,"              if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i<mask>) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
            "
1252,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19427,19428,UnaryOperatorMutator,++,++;,3,3.3227907E-4,i<mask>,"              if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i<mask>) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
            "
1253,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19427,19428,UnaryOperatorMutator,++,--,4,2.5739544E-4,i<mask>,"              if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i<mask>) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
            "
1254,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19426,19426,IdentifierMutator-Variable,i,I,2,6.9920214E-5,<mask>,"               if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail;<mask>++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
            "
1255,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19426,19426,IdentifierMutator-Variable,i,,3,3.514921E-5,<mask>,"               if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail;<mask>++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
            "
1256,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,489,19426,19426,IdentifierMutator-Variable,i,j,4,2.9864277E-5,<mask>,"               if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail;<mask>++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
            "
1257,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19467,19470,BinaryOperatorMutator,||,|,2,0.009690151,(buffer == null) <mask> ((buffer.length - pos) < encodeSize),"ODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null<mask>buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK"
1258,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19467,19470,BinaryOperatorMutator,||,.,3,0.0044482853,(buffer == null) <mask> ((buffer.length - pos) < encodeSize),"ODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null<mask>buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK"
1259,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19467,19470,BinaryOperatorMutator,||,?,4,0.0017501197,(buffer == null) <mask> ((buffer.length - pos) < encodeSize),"ODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null<mask>buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK"
1260,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19459,19462,BinaryOperatorMutator,==,=,2,0.012145824,buffer <mask> null,"_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer<mask>null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &"
1261,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19459,19462,BinaryOperatorMutator,==,===,3,0.005809828,buffer <mask> null,"_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer<mask>null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &"
1262,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19459,19462,BinaryOperatorMutator,==,===,4,0.001195325,buffer <mask> null,"_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer<mask>null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &"
1263,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19453,19458,IdentifierMutator-Variable,buffer,Buffer,2,0.0029023364,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (<mask> == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)"
1264,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19453,19458,IdentifierMutator-Variable,buffer,buf,3,0.0014749382,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (<mask> == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)"
1265,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19453,19458,IdentifierMutator-Variable,buffer,in,4,0.0011709792,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (<mask> == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)"
1266,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19453,19458,FieldReferenceMutator,buffer,Buffer,2,0.0029023364,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (<mask> == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)"
1267,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19453,19458,FieldReferenceMutator,buffer,buf,3,0.0014749382,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (<mask> == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)"
1268,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19453,19458,FieldReferenceMutator,buffer,in,4,0.0011709792,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (<mask> == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)"
1269,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19463,19466,IdentifierMutator-Literal,null,nil,1,0.0016498294,<mask>,"ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer ==<mask> || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MAS"
1270,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19463,19466,IdentifierMutator-Literal,null,NULL,2,7.17349E-4,<mask>,"ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer ==<mask> || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MAS"
1271,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19463,19466,IdentifierMutator-Literal,null,undefined,4,4.8640807E-4,<mask>,"ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer ==<mask> || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MAS"
1272,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19490,19492,BinaryOperatorMutator,<,>,1,0.20770806,(buffer.length - pos) <mask> encodeSize,"                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos<mask>encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1273,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19490,19492,BinaryOperatorMutator,<,>,3,0.11078587,(buffer.length - pos) <mask> encodeSize,"                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos<mask>encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1274,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19490,19492,BinaryOperatorMutator,<,==,4,0.09896263,(buffer.length - pos) <mask> encodeSize,"                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos<mask>encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1275,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19484,19486,BinaryOperatorMutator,-,+,1,0.18878353,buffer.length <mask> pos," {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length<mask>pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS"
1276,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19484,19486,BinaryOperatorMutator,-,*,2,0.082328506,buffer.length <mask> pos," {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length<mask>pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS"
1277,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19484,19486,BinaryOperatorMutator,-,_,4,0.006510122,buffer.length <mask> pos," {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length<mask>pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS"
1278,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19471,19483,IdentifierMutator-Variable,buffer.length,i,0,0.18425716,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1279,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19471,19483,IdentifierMutator-Variable,buffer.length,size,1,0.14102772,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1280,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19471,19483,IdentifierMutator-Variable,buffer.length,length,2,0.0968811,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1281,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19471,19483,IdentifierMutator-Variable,buffer.length,limit,3,0.058803067,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1282,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19471,19483,IdentifierMutator-Variable,buffer.length,256,4,0.03123311,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1283,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19471,19476,IdentifierMutator-Variable,buffer,in,1,0.0010918559,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask>.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_"
1284,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19471,19476,IdentifierMutator-Variable,buffer,buf,2,6.573179E-4,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask>.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_"
1285,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19471,19476,IdentifierMutator-Variable,buffer,input,3,3.919257E-4,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask>.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_"
1286,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19471,19476,FieldReferenceMutator,buffer,in,1,0.0010918559,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask>.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_"
1287,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19471,19476,FieldReferenceMutator,buffer,buf,2,6.573179E-4,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask>.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_"
1288,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19471,19476,FieldReferenceMutator,buffer,input,3,3.919257E-4,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask>.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_"
1289,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19478,19483,FieldReferenceMutator,length,position,1,0.0041366075,buffer.<mask>,") {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1290,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19478,19483,FieldReferenceMutator,length,size,2,0.0011246969,buffer.<mask>,") {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1291,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19478,19483,FieldReferenceMutator,length,len,3,0.001039405,buffer.<mask>,") {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1292,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19478,19483,FieldReferenceMutator,length,capacity,4,4.4905336E-4,buffer.<mask>,") {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1293,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19487,19489,IdentifierMutator-Variable,pos,i,1,0.4091551,<mask>,"
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1294,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19487,19489,IdentifierMutator-Variable,pos,1,2,0.008814072,<mask>,"
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1295,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19487,19489,IdentifierMutator-Variable,pos,index,3,0.008114432,<mask>,"
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1296,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19487,19489,IdentifierMutator-Variable,pos,offset,4,0.003906174,<mask>,"
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1297,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19487,19489,FieldReferenceMutator,pos,i,1,0.4091551,<mask>,"
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1298,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19487,19489,FieldReferenceMutator,pos,1,2,0.008814072,<mask>,"
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1299,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19487,19489,FieldReferenceMutator,pos,index,3,0.008114432,<mask>,"
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1300,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19487,19489,FieldReferenceMutator,pos,offset,4,0.003906174,<mask>,"
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1301,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19493,19502,IdentifierMutator-Variable,encodeSize,0,0,0.31298754,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1302,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19493,19502,IdentifierMutator-Variable,encodeSize,1,1,0.069835626,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1303,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19493,19502,IdentifierMutator-Variable,encodeSize,3,2,0.062432777,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1304,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19493,19502,IdentifierMutator-Variable,encodeSize,2,3,0.049996737,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1305,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19493,19502,IdentifierMutator-Variable,encodeSize,4,4,0.03850666,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1306,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19493,19502,FieldReferenceMutator,encodeSize,0,0,0.31298754,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1307,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19493,19502,FieldReferenceMutator,encodeSize,1,1,0.069835626,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1308,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19493,19502,FieldReferenceMutator,encodeSize,3,2,0.062432777,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1309,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19493,19502,FieldReferenceMutator,encodeSize,2,3,0.049996737,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1310,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,490,19493,19502,FieldReferenceMutator,encodeSize,4,4,0.03850666,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1311,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,491,19527,19538,MethodCallMutator,resizeBuffer,flush,0,0.2299465,<mask>(),"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encode"
1312,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,491,19527,19538,MethodCallMutator,resizeBuffer,break,1,0.14850865,<mask>(),"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encode"
1313,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,491,19527,19538,MethodCallMutator,resizeBuffer,close,2,0.14498119,<mask>(),"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encode"
1314,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,491,19527,19538,MethodCallMutator,resizeBuffer,reset,3,0.022870919,<mask>(),"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encode"
1315,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,491,19527,19538,MethodCallMutator,resizeBuffer,return,4,0.019781845,<mask>(),"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encode"
1316,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19584,19584,AssignmentMutator,modulus=(++modulus)%3,|,0,0.47851506,modulus <mask>= (++modulus) % 3,"           break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus<mask>= (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1317,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19584,19584,AssignmentMutator,modulus=(++modulus)%3,^,1,0.29056475,modulus <mask>= (++modulus) % 3,"           break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus<mask>= (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1318,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19584,19584,AssignmentMutator,modulus=(++modulus)%3,*,2,0.13664393,modulus <mask>= (++modulus) % 3,"           break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus<mask>= (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1319,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19584,19584,AssignmentMutator,modulus=(++modulus)%3,~,3,0.025976336,modulus <mask>= (++modulus) % 3,"           break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus<mask>= (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1320,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19584,19584,AssignmentMutator,modulus=(++modulus)%3,&,4,0.022402443,modulus <mask>= (++modulus) % 3,"           break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus<mask>= (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1321,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19577,19583,IdentifierMutator-Variable,modulus,mod,0,0.366039,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1322,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19577,19583,IdentifierMutator-Variable,modulus,i,1,0.22918198,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1323,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19577,19583,IdentifierMutator-Variable,modulus,shift,2,0.037381936,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1324,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19577,19583,IdentifierMutator-Variable,modulus,x,3,0.034641884,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1325,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19577,19583,IdentifierMutator-Variable,modulus,b,4,0.02758909,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1326,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19577,19583,FieldReferenceMutator,modulus,mod,0,0.366039,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1327,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19577,19583,FieldReferenceMutator,modulus,i,1,0.22918198,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1328,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19577,19583,FieldReferenceMutator,modulus,shift,2,0.037381936,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1329,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19577,19583,FieldReferenceMutator,modulus,x,3,0.034641884,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1330,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19577,19583,FieldReferenceMutator,modulus,b,4,0.02758909,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1331,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19598,19600,BinaryOperatorMutator,%,<<,0,0.2591907,(++modulus) <mask> 3,"     break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus)<mask>3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable"
1332,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19598,19600,BinaryOperatorMutator,%,^,1,0.110905826,(++modulus) <mask> 3,"     break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus)<mask>3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable"
1333,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19598,19600,BinaryOperatorMutator,%,*,2,0.0977899,(++modulus) <mask> 3,"     break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus)<mask>3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable"
1334,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19598,19600,BinaryOperatorMutator,%,/,3,0.097750545,(++modulus) <mask> 3,"     break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus)<mask>3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable"
1335,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19598,19600,BinaryOperatorMutator,%,>>>,4,0.090635665,(++modulus) <mask> 3,"     break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus)<mask>3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable"
1336,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19587,19589,UnaryOperatorMutator,++,(,0,0.89161223,<mask>modulus,"          break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus =<mask>modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++"
1337,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19587,19589,UnaryOperatorMutator,++,((,1,0.040229503,<mask>modulus,"          break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus =<mask>modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++"
1338,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19587,19589,UnaryOperatorMutator,++,(-,2,0.019966546,<mask>modulus,"          break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus =<mask>modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++"
1339,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19587,19589,UnaryOperatorMutator,++,$(,3,0.019793415,<mask>modulus,"          break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus =<mask>modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++"
1340,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19587,19589,UnaryOperatorMutator,++,(,4,0.014999445,<mask>modulus,"          break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus =<mask>modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++"
1341,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19590,19596,IdentifierMutator-Variable,modulus,pos,0,0.3082645,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1342,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19590,19596,IdentifierMutator-Variable,modulus,i,1,0.13752128,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1343,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19590,19596,IdentifierMutator-Variable,modulus,x,2,0.028434496,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1344,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19590,19596,IdentifierMutator-Variable,modulus,shift,3,0.023058115,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1345,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19590,19596,IdentifierMutator-Variable,modulus,32,4,0.012451312,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1346,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19590,19596,FieldReferenceMutator,modulus,pos,0,0.3082645,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1347,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19590,19596,FieldReferenceMutator,modulus,i,1,0.13752128,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1348,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19590,19596,FieldReferenceMutator,modulus,x,2,0.028434496,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1349,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19590,19596,FieldReferenceMutator,modulus,shift,3,0.023058115,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1350,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19590,19596,FieldReferenceMutator,modulus,32,4,0.012451312,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1351,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19601,19601,IdentifierMutator-Literal,3,256,0,0.6057818,<mask>,"    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) %<mask>;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable["
1352,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19601,19601,IdentifierMutator-Literal,3,8,1,0.12547572,<mask>,"    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) %<mask>;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable["
1353,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19601,19601,IdentifierMutator-Literal,3,7,2,0.034191027,<mask>,"    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) %<mask>;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable["
1354,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19601,19601,IdentifierMutator-Literal,3,32,3,0.03331981,<mask>,"    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) %<mask>;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable["
1355,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,493,19601,19601,IdentifierMutator-Literal,3,4,4,0.02795065,<mask>,"    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) %<mask>;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable["
1356,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,494,19631,19637,ArrayAccessMutator,inPos++,i,0,0.66938376,in[<mask>],"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1357,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,494,19631,19637,ArrayAccessMutator,inPos++,pos,1,0.294579,in[<mask>],"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1358,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,494,19631,19637,ArrayAccessMutator,inPos++,0,2,0.0031445394,in[<mask>],"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1359,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,494,19631,19637,ArrayAccessMutator,inPos++,j,3,0.0020748985,in[<mask>],"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1360,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,494,19631,19637,ArrayAccessMutator,inPos++,i,4,0.0020171243,in[<mask>],"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1361,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,494,19628,19629,IdentifierMutator-Variable,in,buffer,0,0.6025827,<mask>,"          if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b =<mask>[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
       "
1362,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,494,19628,19629,IdentifierMutator-Variable,in,bytes,2,0.027596995,<mask>,"          if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b =<mask>[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
       "
1363,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,494,19628,19629,IdentifierMutator-Variable,in,buf,3,0.024895383,<mask>,"          if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b =<mask>[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
       "
1364,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,494,19628,19629,IdentifierMutator-Variable,in,data,4,0.02476139,<mask>,"          if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b =<mask>[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
       "
1365,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,494,19636,19637,UnaryOperatorMutator,++,--,2,9.5790206E-4,inPos<mask>,"      if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1366,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,494,19636,19637,UnaryOperatorMutator,++,x,3,8.321881E-4,inPos<mask>,"      if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1367,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,494,19636,19637,UnaryOperatorMutator,++,i,4,3.1109917E-4,inPos<mask>,"      if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1368,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,494,19631,19635,IdentifierMutator-Variable,inPos,pos,0,0.9789731,<mask>,"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
          "
1369,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,494,19631,19635,IdentifierMutator-Variable,inPos,i,1,0.008143472,<mask>,"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
          "
1370,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,494,19631,19635,IdentifierMutator-Variable,inPos,pos,2,0.0050295508,<mask>,"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
          "
1371,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,494,19631,19635,IdentifierMutator-Variable,inPos,index,3,6.505765E-4,<mask>,"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
          "
1372,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,494,19631,19635,IdentifierMutator-Variable,inPos,offset,4,5.82215E-4,<mask>,"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
          "
1373,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,495,19662,19664,BinaryOperatorMutator,<,>,1,0.19194485,b <mask> 0,"             System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b<mask>0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK"
1374,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,495,19662,19664,BinaryOperatorMutator,<,==,2,0.18435054,b <mask> 0,"             System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b<mask>0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK"
1375,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,495,19662,19664,BinaryOperatorMutator,<,==,4,0.060205013,b <mask> 0,"             System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b<mask>0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK"
1376,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,495,19661,19661,IdentifierMutator-Variable,b,bb,1,0.0012546774,<mask>,"              System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (<mask> < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MAS"
1377,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,495,19661,19661,IdentifierMutator-Variable,b,bc,2,0.001182256,<mask>,"              System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (<mask> < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MAS"
1378,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,495,19661,19661,IdentifierMutator-Variable,b,a,3,6.7194423E-4,<mask>,"              System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (<mask> < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MAS"
1379,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,495,19665,19665,IdentifierMutator-Literal,0,256,1,0.21156868,<mask>,"            System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b <<mask>) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_"
1380,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,495,19665,19665,IdentifierMutator-Literal,0,128,2,0.04199126,<mask>,"            System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b <<mask>) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_"
1381,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,495,19665,19665,IdentifierMutator-Literal,0,1,3,0.011147414,<mask>,"            System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b <<mask>) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_"
1382,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,495,19665,19665,IdentifierMutator-Literal,0,255,4,0.009976119,<mask>,"            System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b <<mask>) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_"
1383,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,496,19691,19691,AssignmentMutator,b+=256,*,0,0.47544602,b <mask>= 256,", pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b<mask>+= 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1384,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,496,19691,19691,AssignmentMutator,b+=256,&,1,0.17089388,b <mask>= 256,", pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b<mask>+= 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1385,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,496,19691,19691,AssignmentMutator,b+=256,|,2,0.09240969,b <mask>= 256,", pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b<mask>+= 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1386,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,496,19691,19691,AssignmentMutator,b+=256,>>>,3,0.055562455,b <mask>= 256,", pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b<mask>+= 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1387,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,496,19691,19691,AssignmentMutator,b+=256,/,4,0.039260786,b <mask>= 256,", pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b<mask>+= 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1388,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,496,19690,19690,IdentifierMutator-Variable,b,x,2,0.0023339507,<mask>,"         System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {<mask> += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1389,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,496,19690,19690,IdentifierMutator-Variable,b,a,3,6.8368885E-4,<mask>,"         System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {<mask> += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1390,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,496,19690,19690,IdentifierMutator-Variable,b,x,4,3.4877277E-4,<mask>,"         System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {<mask> += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1391,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,496,19695,19697,IdentifierMutator-Literal,256,b,0,0.5066582,<mask>," pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b +=<mask>;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    current"
1392,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,496,19695,19697,IdentifierMutator-Literal,256,1,1,0.18218191,<mask>," pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b +=<mask>;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    current"
1393,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,496,19695,19697,IdentifierMutator-Literal,256,3,2,0.057953328,<mask>," pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b +=<mask>;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    current"
1394,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,496,19695,19697,IdentifierMutator-Literal,256,a,3,0.03459489,<mask>," pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b +=<mask>;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    current"
1395,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,496,19695,19697,IdentifierMutator-Literal,256,4,4,0.018121801,<mask>," pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b +=<mask>;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    current"
1396,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19735,19735,AssignmentMutator,x=(x<<8)+b,^,0,0.64949256,x <mask>= (x << 8) + b,"           }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x<mask>= (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1397,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19735,19735,AssignmentMutator,x=(x<<8)+b,|,1,0.1648105,x <mask>= (x << 8) + b,"           }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x<mask>= (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1398,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19735,19735,AssignmentMutator,x=(x<<8)+b,*,2,0.063775286,x <mask>= (x << 8) + b,"           }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x<mask>= (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1399,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19735,19735,AssignmentMutator,x=(x<<8)+b,>>,3,0.023959793,x <mask>= (x << 8) + b,"           }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x<mask>= (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1400,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19735,19735,AssignmentMutator,x=(x<<8)+b,&,4,0.013052157,x <mask>= (x << 8) + b,"           }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x<mask>= (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1401,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19734,19734,IdentifierMutator-Variable,x,xx,2,0.0056569874,<mask>,"       pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }<mask> = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1402,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19734,19734,IdentifierMutator-Variable,x,b,3,0.005582003,<mask>,"       pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }<mask> = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1403,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19734,19734,IdentifierMutator-Variable,x,pos,4,0.003914058,<mask>,"       pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }<mask> = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1404,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19734,19734,FieldReferenceMutator,x,xx,2,0.0056569874,<mask>,"       pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }<mask> = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1405,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19734,19734,FieldReferenceMutator,x,b,3,0.005582003,<mask>,"       pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }<mask> = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1406,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19734,19734,FieldReferenceMutator,x,pos,4,0.003914058,<mask>,"       pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }<mask> = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1407,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19746,19748,BinaryOperatorMutator,+,|,0,0.4727424,(x << 8) <mask> b,"     }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8)<mask>b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
 "
1408,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19746,19748,BinaryOperatorMutator,+,^,1,0.24300185,(x << 8) <mask> b,"     }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8)<mask>b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
 "
1409,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19746,19748,BinaryOperatorMutator,+,^,2,0.06435483,(x << 8) <mask> b,"     }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8)<mask>b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
 "
1410,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19746,19748,BinaryOperatorMutator,+,*,4,0.03675517,(x << 8) <mask> b,"     }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8)<mask>b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
 "
1411,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19740,19743,BinaryOperatorMutator,<<,*,2,0.052197065,x <mask> 8,"        }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x<mask>8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos)"
1412,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19740,19743,BinaryOperatorMutator,<<,*,3,0.04134577,x <mask> 8,"        }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x<mask>8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos)"
1413,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19740,19743,BinaryOperatorMutator,<<,>>,4,0.039283052,x <mask> 8,"        }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x<mask>8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos)"
1414,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19739,19739,IdentifierMutator-Variable,x,1,1,0.02460696,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1415,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19739,19739,IdentifierMutator-Variable,x,a,2,0.018948747,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1416,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19739,19739,IdentifierMutator-Variable,x,0,3,0.0052235285,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1417,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19739,19739,IdentifierMutator-Variable,x,i,4,0.004632921,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1418,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19739,19739,FieldReferenceMutator,x,1,1,0.02460696,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1419,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19739,19739,FieldReferenceMutator,x,a,2,0.018948747,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1420,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19739,19739,FieldReferenceMutator,x,0,3,0.0052235285,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1421,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19739,19739,FieldReferenceMutator,x,i,4,0.004632921,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1422,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19744,19744,IdentifierMutator-Literal,8,3,0,0.487876,<mask>,"       }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x <<<mask>) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {"
1423,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19744,19744,IdentifierMutator-Literal,8,6,1,0.09101585,<mask>,"       }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x <<<mask>) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {"
1424,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19744,19744,IdentifierMutator-Literal,8,7,2,0.068030104,<mask>,"       }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x <<<mask>) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {"
1425,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19744,19744,IdentifierMutator-Literal,8,4,3,0.06388681,<mask>,"       }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x <<<mask>) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {"
1426,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19744,19744,IdentifierMutator-Literal,8,1,4,0.058835242,<mask>,"       }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x <<<mask>) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {"
1427,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19749,19749,IdentifierMutator-Variable,b,1,1,0.06379104,<mask>,"    }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) +<mask>;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
  "
1428,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19749,19749,IdentifierMutator-Variable,b,0,2,0.003952813,<mask>,"    }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) +<mask>;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
  "
1429,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19749,19749,IdentifierMutator-Variable,b,2,3,0.0034723906,<mask>,"    }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) +<mask>;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
  "
1430,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,498,19749,19749,IdentifierMutator-Variable,b,a,4,0.0033479622,<mask>,"    }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) +<mask>;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
  "
1431,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,499,19773,19776,BinaryOperatorMutator,==,<,0,0.26369897,0 <mask> modulus,"       for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0<mask>modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                       "
1432,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,499,19773,19776,BinaryOperatorMutator,==,<,3,0.16148953,0 <mask> modulus,"       for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0<mask>modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                       "
1433,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,499,19773,19776,BinaryOperatorMutator,==,!=,4,0.076652415,0 <mask> modulus,"       for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0<mask>modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                       "
1434,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,499,19772,19772,IdentifierMutator-Literal,0,b,0,0.7616199,<mask>,"        for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (<mask> == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                      "
1435,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,499,19772,19772,IdentifierMutator-Literal,0,x,1,0.09502475,<mask>,"        for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (<mask> == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                      "
1436,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,499,19772,19772,IdentifierMutator-Literal,0,a,2,0.027436377,<mask>,"        for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (<mask> == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                      "
1437,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,499,19772,19772,IdentifierMutator-Literal,0,3,4,0.012158273,<mask>,"        for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (<mask> == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                      "
1438,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,499,19777,19783,IdentifierMutator-Variable,modulus,x,0,0.47359556,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1439,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,499,19777,19783,IdentifierMutator-Variable,modulus,b,1,0.41289622,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1440,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,499,19777,19783,IdentifierMutator-Variable,modulus,c,2,0.0117913615,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1441,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,499,19777,19783,IdentifierMutator-Variable,modulus,f,3,0.0065254415,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1442,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,499,19777,19783,IdentifierMutator-Variable,modulus,i,4,0.006065281,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1443,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,499,19777,19783,FieldReferenceMutator,modulus,x,0,0.47359556,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1444,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,499,19777,19783,FieldReferenceMutator,modulus,b,1,0.41289622,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1445,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,499,19777,19783,FieldReferenceMutator,modulus,c,2,0.0117913615,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1446,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,499,19777,19783,FieldReferenceMutator,modulus,f,3,0.0065254415,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1447,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,499,19777,19783,FieldReferenceMutator,modulus,i,4,0.006065281,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1448,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19821,19821,AssignmentMutator,buffer[pos++]=encodeTable[(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.58595383,buffer[pos++] <mask>= encodeTable[(x >> 18) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"         if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++]<mask>= encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
     "
1449,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19821,19821,AssignmentMutator,buffer[pos++]=encodeTable[(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.2882388,buffer[pos++] <mask>= encodeTable[(x >> 18) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"         if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++]<mask>= encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
     "
1450,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19821,19821,AssignmentMutator,buffer[pos++]=encodeTable[(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.043555997,buffer[pos++] <mask>= encodeTable[(x >> 18) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"         if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++]<mask>= encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
     "
1451,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19821,19821,AssignmentMutator,buffer[pos++]=encodeTable[(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.015775343,buffer[pos++] <mask>= encodeTable[(x >> 18) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"         if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++]<mask>= encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
     "
1452,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19821,19821,AssignmentMutator,buffer[pos++]=encodeTable[(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS],+,4,0.007666908,buffer[pos++] <mask>= encodeTable[(x >> 18) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"         if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++]<mask>= encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
     "
1453,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19815,19819,ArrayAccessMutator,pos++,pos,0,0.9988036,buffer[<mask>],"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1454,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19815,19819,ArrayAccessMutator,pos++,++,1,1.4204906E-4,buffer[<mask>],"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1455,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19815,19819,ArrayAccessMutator,pos++,0,2,1.1054925E-4,buffer[<mask>],"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1456,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19815,19819,ArrayAccessMutator,pos++,neg,3,7.330352E-5,buffer[<mask>],"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1457,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19815,19819,ArrayAccessMutator,pos++,position,4,6.649292E-5,buffer[<mask>],"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1458,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19808,19813,IdentifierMutator-Variable,buffer,Buffer,2,5.7525554E-4,<mask>,"  for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {<mask>[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
 "
1459,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19808,19813,IdentifierMutator-Variable,buffer,byte,3,3.3002844E-4,<mask>,"  for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {<mask>[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
 "
1460,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19808,19813,IdentifierMutator-Variable,buffer,byte,4,2.2382181E-4,<mask>,"  for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {<mask>[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
 "
1461,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19808,19813,FieldReferenceMutator,buffer,Buffer,2,5.7525554E-4,<mask>,"  for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {<mask>[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
 "
1462,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19808,19813,FieldReferenceMutator,buffer,byte,3,3.3002844E-4,<mask>,"  for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {<mask>[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
 "
1463,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19808,19813,FieldReferenceMutator,buffer,byte,4,2.2382181E-4,<mask>,"  for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {<mask>[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
 "
1464,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19818,19819,UnaryOperatorMutator,++,+,1,1.0852303E-4,pos<mask>,"           if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1465,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19818,19819,UnaryOperatorMutator,++,++;,3,4.3012962E-5,pos<mask>,"           if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1466,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19818,19819,UnaryOperatorMutator,++,--,4,3.441421E-5,pos<mask>,"           if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1467,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19815,19817,IdentifierMutator-Variable,pos,len,1,2.4805724E-5,<mask>,"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
   "
1468,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19815,19817,IdentifierMutator-Variable,pos,neg,2,2.326667E-5,<mask>,"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
   "
1469,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19815,19817,IdentifierMutator-Variable,pos,size,3,1.9429799E-5,<mask>,"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
   "
1470,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19815,19817,FieldReferenceMutator,pos,len,1,2.4805724E-5,<mask>,"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
   "
1471,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19815,19817,FieldReferenceMutator,pos,neg,2,2.326667E-5,<mask>,"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
   "
1472,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19815,19817,FieldReferenceMutator,pos,size,3,1.9429799E-5,<mask>,"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
   "
1473,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19836,19857,ArrayAccessMutator,(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.88661486,encodeTable[<mask>],"     if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1474,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19836,19857,ArrayAccessMutator,(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.020588694,encodeTable[<mask>],"     if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1475,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19836,19857,ArrayAccessMutator,(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,2,0.0059377034,encodeTable[<mask>],"     if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1476,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19836,19857,ArrayAccessMutator,(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS,xx,3,0.004727886,encodeTable[<mask>],"     if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1477,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19836,19857,ArrayAccessMutator,(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS,i,4,0.004462088,encodeTable[<mask>],"     if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1478,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19824,19834,IdentifierMutator-Variable,encodeTable,table,0,0.28265503,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1479,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19824,19834,IdentifierMutator-Variable,encodeTable,encode,1,0.143001,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1480,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19824,19834,IdentifierMutator-Variable,encodeTable,decode,2,0.039326105,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1481,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19824,19834,IdentifierMutator-Variable,encodeTable,byte,3,0.031816043,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1482,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19824,19834,IdentifierMutator-Variable,encodeTable,buffer,4,0.027764978,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1483,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19824,19834,FieldReferenceMutator,encodeTable,table,0,0.28265503,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1484,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19824,19834,FieldReferenceMutator,encodeTable,encode,1,0.143001,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1485,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19824,19834,FieldReferenceMutator,encodeTable,decode,2,0.039326105,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1486,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19824,19834,FieldReferenceMutator,encodeTable,byte,3,0.031816043,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1487,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19824,19834,FieldReferenceMutator,encodeTable,buffer,4,0.027764978,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1488,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19845,19847,BinaryOperatorMutator,&,|,2,7.0039235E-4,(x >> 18) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS," (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
               "
1489,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19845,19847,BinaryOperatorMutator,&,^,3,8.209885E-5,(x >> 18) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS," (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
               "
1490,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19845,19847,BinaryOperatorMutator,&,~,4,2.6727665E-5,(x >> 18) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS," (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
               "
1491,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19838,19841,BinaryOperatorMutator,>>,>>>,2,0.014077157,x <mask> 18,"   if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x<mask>18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1492,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19838,19841,BinaryOperatorMutator,>>,<<,3,0.011360025,x <mask> 18,"   if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x<mask>18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1493,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19838,19841,BinaryOperatorMutator,>>,>>>,4,0.0023995826,x <mask> 18,"   if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x<mask>18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1494,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19837,19837,IdentifierMutator-Variable,x,y,1,2.184737E-5,<mask>,"    if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(<mask> >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
           "
1495,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19837,19837,IdentifierMutator-Variable,x,b,3,6.949012E-6,<mask>,"    if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(<mask> >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
           "
1496,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19837,19837,IdentifierMutator-Variable,x,xx,4,6.0042985E-6,<mask>,"    if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(<mask> >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
           "
1497,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19837,19837,FieldReferenceMutator,x,y,1,2.184737E-5,<mask>,"    if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(<mask> >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
           "
1498,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19837,19837,FieldReferenceMutator,x,b,3,6.949012E-6,<mask>,"    if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(<mask> >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
           "
1499,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19837,19837,FieldReferenceMutator,x,xx,4,6.0042985E-6,<mask>,"    if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(<mask> >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
           "
1500,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19842,19843,IdentifierMutator-Literal,18,6,0,0.30219615,<mask>,"  if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1501,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19842,19843,IdentifierMutator-Literal,18,14,2,0.15861839,<mask>,"  if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1502,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19842,19843,IdentifierMutator-Literal,18,16,3,0.12405489,<mask>,"  if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1503,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19842,19843,IdentifierMutator-Literal,18,13,4,0.044997454,<mask>,"  if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1504,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19848,19857,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,0,0.10203409,<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1505,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19848,19857,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,63,1,0.07741652,<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1506,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19848,19857,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,2,0.07146262,<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1507,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19848,19857,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,bits,3,0.06290492,<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1508,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19848,19857,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,6,4,0.056504957,<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1509,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19848,19857,FieldReferenceMutator,MASK_6BITS,7,0,0.10203409,org.apache.commons.codec.binary.Base64.<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1510,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19848,19857,FieldReferenceMutator,MASK_6BITS,63,1,0.07741652,org.apache.commons.codec.binary.Base64.<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1511,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19848,19857,FieldReferenceMutator,MASK_6BITS,mask,2,0.07146262,org.apache.commons.codec.binary.Base64.<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1512,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19848,19857,FieldReferenceMutator,MASK_6BITS,bits,3,0.06290492,org.apache.commons.codec.binary.Base64.<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1513,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,500,19848,19857,FieldReferenceMutator,MASK_6BITS,6,4,0.056504957,org.apache.commons.codec.binary.Base64.<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1514,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19894,19894,AssignmentMutator,buffer[pos++]=encodeTable[(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.6265021,buffer[pos++] <mask>= encodeTable[(x >> 12) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"   resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
              "
1515,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19894,19894,AssignmentMutator,buffer[pos++]=encodeTable[(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.20987435,buffer[pos++] <mask>= encodeTable[(x >> 12) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"   resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
              "
1516,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19894,19894,AssignmentMutator,buffer[pos++]=encodeTable[(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.05411837,buffer[pos++] <mask>= encodeTable[(x >> 12) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"   resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
              "
1517,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19894,19894,AssignmentMutator,buffer[pos++]=encodeTable[(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.024408977,buffer[pos++] <mask>= encodeTable[(x >> 12) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"   resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
              "
1518,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19894,19894,AssignmentMutator,buffer[pos++]=encodeTable[(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS],+,4,0.00917603,buffer[pos++] <mask>= encodeTable[(x >> 12) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"   resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
              "
1519,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19888,19892,ArrayAccessMutator,pos++,pos,0,0.99518543,buffer[<mask>],"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1520,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19888,19892,ArrayAccessMutator,pos++,++,1,0.0020608834,buffer[<mask>],"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1521,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19888,19892,ArrayAccessMutator,pos++,push,2,2.4151117E-4,buffer[<mask>],"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1522,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19888,19892,ArrayAccessMutator,pos++,+,3,1.6428687E-4,buffer[<mask>],"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1523,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19888,19892,ArrayAccessMutator,pos++,position,4,1.6262548E-4,buffer[<mask>],"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1524,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19881,19886,IdentifierMutator-Variable,buffer,Buffer,2,0.0017264769,<mask>," - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
          "
1525,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19881,19886,IdentifierMutator-Variable,buffer,byte,3,0.0013109291,<mask>," - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
          "
1526,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19881,19886,IdentifierMutator-Variable,buffer,byte,4,5.684142E-4,<mask>," - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
          "
1527,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19881,19886,FieldReferenceMutator,buffer,Buffer,2,0.0017264769,<mask>," - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
          "
1528,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19881,19886,FieldReferenceMutator,buffer,byte,3,0.0013109291,<mask>," - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
          "
1529,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19881,19886,FieldReferenceMutator,buffer,byte,4,5.684142E-4,<mask>," - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
          "
1530,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19891,19892,UnaryOperatorMutator,++,+,1,1.08531625E-4,pos<mask>,"     resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1531,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19891,19892,UnaryOperatorMutator,++,++;,3,5.0732004E-5,pos<mask>,"     resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1532,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19891,19892,UnaryOperatorMutator,++,--,4,3.8721104E-5,pos<mask>,"     resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1533,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19888,19890,IdentifierMutator-Variable,pos,len,1,3.1099207E-5,<mask>,"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
            "
1534,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19888,19890,IdentifierMutator-Variable,pos,size,3,2.2258011E-5,<mask>,"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
            "
1535,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19888,19890,IdentifierMutator-Variable,pos,neg,4,1.7419106E-5,<mask>,"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
            "
1536,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19888,19890,FieldReferenceMutator,pos,len,1,3.1099207E-5,<mask>,"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
            "
1537,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19888,19890,FieldReferenceMutator,pos,size,3,2.2258011E-5,<mask>,"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
            "
1538,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19888,19890,FieldReferenceMutator,pos,neg,4,1.7419106E-5,<mask>,"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
            "
1539,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19909,19930,ArrayAccessMutator,(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.95328385,encodeTable[<mask>],"();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1540,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19909,19930,ArrayAccessMutator,(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.008241688,encodeTable[<mask>],"();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1541,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19909,19930,ArrayAccessMutator,(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS,16,2,0.0026908512,encodeTable[<mask>],"();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1542,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19909,19930,ArrayAccessMutator,(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,3,0.0022774427,encodeTable[<mask>],"();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1543,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19909,19930,ArrayAccessMutator,(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS,xx,4,0.0016143019,encodeTable[<mask>],"();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1544,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19897,19907,IdentifierMutator-Variable,encodeTable,table,0,0.48148024,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1545,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19897,19907,IdentifierMutator-Variable,encodeTable,encode,1,0.14044945,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1546,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19897,19907,IdentifierMutator-Variable,encodeTable,decode,2,0.03432762,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1547,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19897,19907,IdentifierMutator-Variable,encodeTable,buffer,3,0.027771132,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1548,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19897,19907,IdentifierMutator-Variable,encodeTable,encoded,4,0.01158907,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1549,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19897,19907,FieldReferenceMutator,encodeTable,table,0,0.48148024,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1550,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19897,19907,FieldReferenceMutator,encodeTable,encode,1,0.14044945,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1551,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19897,19907,FieldReferenceMutator,encodeTable,decode,2,0.03432762,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1552,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19897,19907,FieldReferenceMutator,encodeTable,buffer,3,0.027771132,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1553,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19897,19907,FieldReferenceMutator,encodeTable,encoded,4,0.01158907,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1554,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19918,19920,BinaryOperatorMutator,&,|,2,0.0011354018,(x >> 12) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"             }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        current"
1555,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19918,19920,BinaryOperatorMutator,&,^,3,1.1328529E-4,(x >> 12) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"             }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        current"
1556,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19918,19920,BinaryOperatorMutator,&,~,4,3.3629418E-5,(x >> 12) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"             }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        current"
1557,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19911,19914,BinaryOperatorMutator,>>,<<,2,0.052085314,x <mask> 12,"                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                     "
1558,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19911,19914,BinaryOperatorMutator,>>,>>>,3,0.011910077,x <mask> 12,"                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                     "
1559,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19911,19914,BinaryOperatorMutator,>>,<<,4,0.00887428,x <mask> 12,"                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                     "
1560,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19910,19910,IdentifierMutator-Variable,x,y,1,1.0916224E-5,<mask>,"
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                    "
1561,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19910,19910,IdentifierMutator-Variable,x,xx,3,3.9245033E-6,<mask>,"
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                    "
1562,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19910,19910,IdentifierMutator-Variable,x,X,4,2.8354457E-6,<mask>,"
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                    "
1563,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19910,19910,FieldReferenceMutator,x,y,1,1.0916224E-5,<mask>,"
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                    "
1564,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19910,19910,FieldReferenceMutator,x,xx,3,3.9245033E-6,<mask>,"
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                    "
1565,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19910,19910,FieldReferenceMutator,x,X,4,2.8354457E-6,<mask>,"
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                    "
1566,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19915,19916,IdentifierMutator-Literal,12,6,1,0.17941055,<mask>,"               }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                      "
1567,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19915,19916,IdentifierMutator-Literal,12,14,2,0.06264525,<mask>,"               }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                      "
1568,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19915,19916,IdentifierMutator-Literal,12,7,3,0.060345404,<mask>,"               }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                      "
1569,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19915,19916,IdentifierMutator-Literal,12,16,4,0.046771787,<mask>,"               }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                      "
1570,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19921,19930,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,0,0.13090064,<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1571,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19921,19930,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,1,0.07710009,<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1572,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19921,19930,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,2,0.07468237,<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1573,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19921,19930,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,63,3,0.07388949,<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1574,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19921,19930,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,4,0.056199297,<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1575,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19921,19930,FieldReferenceMutator,MASK_6BITS,7,0,0.13090064,org.apache.commons.codec.binary.Base64.<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1576,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19921,19930,FieldReferenceMutator,MASK_6BITS,3,1,0.07710009,org.apache.commons.codec.binary.Base64.<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1577,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19921,19930,FieldReferenceMutator,MASK_6BITS,mask,2,0.07468237,org.apache.commons.codec.binary.Base64.<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1578,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19921,19930,FieldReferenceMutator,MASK_6BITS,63,3,0.07388949,org.apache.commons.codec.binary.Base64.<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1579,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,501,19921,19930,FieldReferenceMutator,MASK_6BITS,1,4,0.056199297,org.apache.commons.codec.binary.Base64.<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1580,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19967,19967,AssignmentMutator,buffer[pos++]=encodeTable[(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.65121436,buffer[pos++] <mask>= encodeTable[(x >> 6) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
     "
1581,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19967,19967,AssignmentMutator,buffer[pos++]=encodeTable[(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.21317977,buffer[pos++] <mask>= encodeTable[(x >> 6) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
     "
1582,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19967,19967,AssignmentMutator,buffer[pos++]=encodeTable[(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.04482653,buffer[pos++] <mask>= encodeTable[(x >> 6) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
     "
1583,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19967,19967,AssignmentMutator,buffer[pos++]=encodeTable[(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.019286197,buffer[pos++] <mask>= encodeTable[(x >> 6) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
     "
1584,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19967,19967,AssignmentMutator,buffer[pos++]=encodeTable[(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS],||,4,0.007369323,buffer[pos++] <mask>= encodeTable[(x >> 6) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
     "
1585,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19961,19965,ArrayAccessMutator,pos++,pos,0,0.98372895,buffer[<mask>],"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1586,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19961,19965,ArrayAccessMutator,pos++,++,1,0.010866406,buffer[<mask>],"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1587,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19961,19965,ArrayAccessMutator,pos++,push,2,5.2627426E-4,buffer[<mask>],"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1588,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19961,19965,ArrayAccessMutator,pos++,+,3,4.1251088E-4,buffer[<mask>],"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1589,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19961,19965,ArrayAccessMutator,pos++,position,4,2.7012572E-4,buffer[<mask>],"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1590,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19954,19959,IdentifierMutator-Variable,buffer,Buffer,2,0.0017312749,<mask>,"     }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
 "
1591,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19954,19959,IdentifierMutator-Variable,buffer,byte,3,0.0016420389,<mask>,"     }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
 "
1592,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19954,19959,IdentifierMutator-Variable,buffer,byte,4,9.167108E-4,<mask>,"     }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
 "
1593,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19954,19959,FieldReferenceMutator,buffer,Buffer,2,0.0017312749,<mask>,"     }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
 "
1594,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19954,19959,FieldReferenceMutator,buffer,byte,3,0.0016420389,<mask>,"     }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
 "
1595,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19954,19959,FieldReferenceMutator,buffer,byte,4,9.167108E-4,<mask>,"     }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
 "
1596,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19964,19965,UnaryOperatorMutator,++,+,1,1.7133576E-4,pos<mask>," = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1597,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19964,19965,UnaryOperatorMutator,++,--,3,7.310897E-5,pos<mask>," = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1598,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19964,19965,UnaryOperatorMutator,++,++;,4,7.2908304E-5,pos<mask>," = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1599,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19961,19963,IdentifierMutator-Variable,pos,len,1,5.3808442E-5,<mask>,"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
   "
1600,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19961,19963,IdentifierMutator-Variable,pos,neg,3,2.9870067E-5,<mask>,"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
   "
1601,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19961,19963,IdentifierMutator-Variable,pos,size,4,2.5797883E-5,<mask>,"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
   "
1602,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19961,19963,FieldReferenceMutator,pos,len,1,5.3808442E-5,<mask>,"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
   "
1603,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19961,19963,FieldReferenceMutator,pos,neg,3,2.9870067E-5,<mask>,"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
   "
1604,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19961,19963,FieldReferenceMutator,pos,size,4,2.5797883E-5,<mask>,"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
   "
1605,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19982,20002,ArrayAccessMutator,(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.95006937,encodeTable[<mask>]," % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1606,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19982,20002,ArrayAccessMutator,(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.007493759,encodeTable[<mask>]," % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1607,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19982,20002,ArrayAccessMutator,(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS,xx,2,0.0029070026,encodeTable[<mask>]," % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1608,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19982,20002,ArrayAccessMutator,(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,3,0.0026921376,encodeTable[<mask>]," % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1609,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19982,20002,ArrayAccessMutator,(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS,i,4,0.0020907486,encodeTable[<mask>]," % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1610,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19970,19980,IdentifierMutator-Variable,encodeTable,table,0,0.4588444,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1611,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19970,19980,IdentifierMutator-Variable,encodeTable,encode,1,0.08936572,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1612,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19970,19980,IdentifierMutator-Variable,encodeTable,buffer,2,0.06389635,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1613,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19970,19980,IdentifierMutator-Variable,encodeTable,decode,3,0.030876225,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1614,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19970,19980,IdentifierMutator-Variable,encodeTable,code,4,0.010733704,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1615,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19970,19980,FieldReferenceMutator,encodeTable,table,0,0.4588444,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1616,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19970,19980,FieldReferenceMutator,encodeTable,encode,1,0.08936572,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1617,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19970,19980,FieldReferenceMutator,encodeTable,buffer,2,0.06389635,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1618,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19970,19980,FieldReferenceMutator,encodeTable,decode,3,0.030876225,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1619,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19970,19980,FieldReferenceMutator,encodeTable,code,4,0.010733704,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1620,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19990,19992,BinaryOperatorMutator,&,|,2,0.0015251794,(x >> 6) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"               int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
               "
1621,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19990,19992,BinaryOperatorMutator,&,^,3,1.3367423E-4,(x >> 6) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"               int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
               "
1622,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19990,19992,BinaryOperatorMutator,&,~,4,4.563869E-5,(x >> 6) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"               int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
               "
1623,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19984,19987,BinaryOperatorMutator,>>,>>>,2,0.014577287,x <mask> 6,";
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
            "
1624,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19984,19987,BinaryOperatorMutator,>>,<<,3,0.005326201,x <mask> 6,";
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
            "
1625,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19984,19987,BinaryOperatorMutator,>>,<<,4,0.0021441604,x <mask> 6,";
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
            "
1626,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19983,19983,IdentifierMutator-Variable,x,y,1,1.4756923E-5,<mask>," 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
           "
1627,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19983,19983,IdentifierMutator-Variable,x,xx,2,8.941584E-6,<mask>," 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
           "
1628,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19983,19983,IdentifierMutator-Variable,x,X,4,4.0363348E-6,<mask>," 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
           "
1629,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19983,19983,FieldReferenceMutator,x,y,1,1.4756923E-5,<mask>," 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
           "
1630,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19983,19983,FieldReferenceMutator,x,xx,2,8.941584E-6,<mask>," 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
           "
1631,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19983,19983,FieldReferenceMutator,x,X,4,4.0363348E-6,<mask>," 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
           "
1632,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19988,19988,IdentifierMutator-Literal,6,8,1,0.16930921,<mask>,"
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
             "
1633,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19988,19988,IdentifierMutator-Literal,6,7,2,0.07269451,<mask>,"
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
             "
1634,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19988,19988,IdentifierMutator-Literal,6,4,3,0.05644892,<mask>,"
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
             "
1635,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19988,19988,IdentifierMutator-Literal,6,5,4,0.04977193,<mask>,"
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
             "
1636,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19993,20002,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,0,0.20099264,<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1637,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19993,20002,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,1,0.091443405,<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1638,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19993,20002,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,2,0.08155483,<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1639,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19993,20002,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,63,3,0.08051241,<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1640,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19993,20002,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,6,4,0.06678464,<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1641,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19993,20002,FieldReferenceMutator,MASK_6BITS,7,0,0.20099264,org.apache.commons.codec.binary.Base64.<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1642,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19993,20002,FieldReferenceMutator,MASK_6BITS,1,1,0.091443405,org.apache.commons.codec.binary.Base64.<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1643,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19993,20002,FieldReferenceMutator,MASK_6BITS,3,2,0.08155483,org.apache.commons.codec.binary.Base64.<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1644,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19993,20002,FieldReferenceMutator,MASK_6BITS,63,3,0.08051241,org.apache.commons.codec.binary.Base64.<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1645,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,502,19993,20002,FieldReferenceMutator,MASK_6BITS,6,4,0.06678464,org.apache.commons.codec.binary.Base64.<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1646,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20039,20039,AssignmentMutator,buffer[pos++]=encodeTable[x&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.64512175,buffer[pos++] <mask>= encodeTable[x & org.apache.commons.codec.binary.Base64.MASK_6BITS],"       if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1647,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20039,20039,AssignmentMutator,buffer[pos++]=encodeTable[x&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.21509565,buffer[pos++] <mask>= encodeTable[x & org.apache.commons.codec.binary.Base64.MASK_6BITS],"       if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1648,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20039,20039,AssignmentMutator,buffer[pos++]=encodeTable[x&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.05649529,buffer[pos++] <mask>= encodeTable[x & org.apache.commons.codec.binary.Base64.MASK_6BITS],"       if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1649,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20039,20039,AssignmentMutator,buffer[pos++]=encodeTable[x&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.012102621,buffer[pos++] <mask>= encodeTable[x & org.apache.commons.codec.binary.Base64.MASK_6BITS],"       if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1650,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20039,20039,AssignmentMutator,buffer[pos++]=encodeTable[x&org.apache.commons.codec.binary.Base64.MASK_6BITS],||,4,0.008375433,buffer[pos++] <mask>= encodeTable[x & org.apache.commons.codec.binary.Base64.MASK_6BITS],"       if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1651,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20033,20037,ArrayAccessMutator,pos++,pos,0,0.9776703,buffer[<mask>],"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1652,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20033,20037,ArrayAccessMutator,pos++,++,1,0.008991658,buffer[<mask>],"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1653,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20033,20037,ArrayAccessMutator,pos++,len,2,9.916008E-4,buffer[<mask>],"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1654,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20033,20037,ArrayAccessMutator,pos++,push,3,6.236473E-4,buffer[<mask>],"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1655,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20033,20037,ArrayAccessMutator,pos++,size,4,5.041644E-4,buffer[<mask>],"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1656,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20026,20031,IdentifierMutator-Variable,buffer,in,2,0.0036895804,<mask>,"       int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];<mask>[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1657,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20026,20031,IdentifierMutator-Variable,buffer,out,3,0.0026296019,<mask>,"       int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];<mask>[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1658,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20026,20031,IdentifierMutator-Variable,buffer,Buffer,4,0.0021281603,<mask>,"       int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];<mask>[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1659,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20026,20031,FieldReferenceMutator,buffer,in,2,0.0036895804,<mask>,"       int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];<mask>[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1660,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20026,20031,FieldReferenceMutator,buffer,out,3,0.0026296019,<mask>,"       int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];<mask>[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1661,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20026,20031,FieldReferenceMutator,buffer,Buffer,4,0.0021281603,<mask>,"       int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];<mask>[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1662,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20036,20037,UnaryOperatorMutator,++,+,2,1.21851E-4,pos<mask>,"         if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1663,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20036,20037,UnaryOperatorMutator,++,++;,3,8.960821E-5,pos<mask>,"         if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1664,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20036,20037,UnaryOperatorMutator,++,--,4,6.255811E-5,pos<mask>,"         if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1665,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20033,20035,IdentifierMutator-Variable,pos,len,1,1.621372E-4,<mask>,"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1666,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20033,20035,IdentifierMutator-Variable,pos,neg,2,5.3722943E-5,<mask>,"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1667,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20033,20035,IdentifierMutator-Variable,pos,size,3,5.3070828E-5,<mask>,"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1668,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20033,20035,FieldReferenceMutator,pos,len,1,1.621372E-4,<mask>,"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1669,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20033,20035,FieldReferenceMutator,pos,neg,2,5.3722943E-5,<mask>,"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1670,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20033,20035,FieldReferenceMutator,pos,size,3,5.3070828E-5,<mask>,"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1671,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20054,20067,ArrayAccessMutator,x&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.24399617,encodeTable[<mask>],"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1672,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20054,20067,ArrayAccessMutator,x&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.11902633,encodeTable[<mask>],"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1673,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20054,20067,ArrayAccessMutator,x&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,2,0.046845116,encodeTable[<mask>],"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1674,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20054,20067,ArrayAccessMutator,x&org.apache.commons.codec.binary.Base64.MASK_6BITS,6,3,0.044247672,encodeTable[<mask>],"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1675,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20054,20067,ArrayAccessMutator,x&org.apache.commons.codec.binary.Base64.MASK_6BITS,4,4,0.0390516,encodeTable[<mask>],"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1676,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20042,20052,IdentifierMutator-Variable,encodeTable,table,0,0.34797645,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1677,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20042,20052,IdentifierMutator-Variable,encodeTable,buffer,1,0.14833394,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1678,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20042,20052,IdentifierMutator-Variable,encodeTable,code,2,0.021642365,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1679,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20042,20052,IdentifierMutator-Variable,encodeTable,encode,3,0.018327847,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1680,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20042,20052,IdentifierMutator-Variable,encodeTable,alphabet,4,0.016969493,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1681,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20042,20052,FieldReferenceMutator,encodeTable,table,0,0.34797645,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1682,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20042,20052,FieldReferenceMutator,encodeTable,buffer,1,0.14833394,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1683,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20042,20052,FieldReferenceMutator,encodeTable,code,2,0.021642365,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1684,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20042,20052,FieldReferenceMutator,encodeTable,encode,3,0.018327847,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1685,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20042,20052,FieldReferenceMutator,encodeTable,alphabet,4,0.016969493,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1686,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20055,20057,BinaryOperatorMutator,&,-,2,0.012634097,x <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"  if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x<mask>MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1687,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20055,20057,BinaryOperatorMutator,&,+,3,0.0102019785,x <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"  if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x<mask>MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1688,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20055,20057,BinaryOperatorMutator,&,<<,4,0.009637333,x <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"  if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x<mask>MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1689,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20054,20054,IdentifierMutator-Variable,x,xx,1,7.230686E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1690,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20054,20054,IdentifierMutator-Variable,x,1,2,6.211949E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1691,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20054,20054,IdentifierMutator-Variable,x,y,3,4.0198036E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1692,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20054,20054,IdentifierMutator-Variable,x,0,4,3.4021927E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1693,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20054,20054,FieldReferenceMutator,x,xx,1,7.230686E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1694,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20054,20054,FieldReferenceMutator,x,1,2,6.211949E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1695,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20054,20054,FieldReferenceMutator,x,y,3,4.0198036E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1696,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20054,20054,FieldReferenceMutator,x,0,4,3.4021927E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1697,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20058,20067,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,0,0.23924552,<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1698,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20058,20067,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,63,1,0.16866417,<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1699,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20058,20067,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,2,0.13106935,<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1700,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20058,20067,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,3,0.057394836,<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1701,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20058,20067,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,6,4,0.05220101,<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1702,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20058,20067,FieldReferenceMutator,MASK_6BITS,7,0,0.23924552,org.apache.commons.codec.binary.Base64.<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1703,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20058,20067,FieldReferenceMutator,MASK_6BITS,63,1,0.16866417,org.apache.commons.codec.binary.Base64.<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1704,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20058,20067,FieldReferenceMutator,MASK_6BITS,3,2,0.13106935,org.apache.commons.codec.binary.Base64.<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1705,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20058,20067,FieldReferenceMutator,MASK_6BITS,1,3,0.057394836,org.apache.commons.codec.binary.Base64.<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1706,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,503,20058,20067,FieldReferenceMutator,MASK_6BITS,6,4,0.05220101,org.apache.commons.codec.binary.Base64.<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1707,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20105,20105,AssignmentMutator,currentLinePos+=4,*,0,0.34029716,currentLinePos <mask>= 4,";
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos<mask>+= 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1708,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20105,20105,AssignmentMutator,currentLinePos+=4,++,1,0.18653326,currentLinePos <mask>= 4,";
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos<mask>+= 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1709,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20105,20105,AssignmentMutator,currentLinePos+=4,*,2,0.12206475,currentLinePos <mask>= 4,";
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos<mask>+= 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1710,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20105,20105,AssignmentMutator,currentLinePos+=4,//,3,0.04192252,currentLinePos <mask>= 4,";
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos<mask>+= 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1711,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20105,20105,AssignmentMutator,currentLinePos+=4,|,4,0.03014381,currentLinePos <mask>= 4,";
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos<mask>+= 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1712,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20091,20104,IdentifierMutator-Variable,currentLinePos,pos,0,0.5798388,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1713,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20091,20104,IdentifierMutator-Variable,currentLinePos,pos,1,0.40308696,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1714,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20091,20104,IdentifierMutator-Variable,currentLinePos,x,2,0.0028060998,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1715,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20091,20104,IdentifierMutator-Variable,currentLinePos,Pos,3,0.0018321931,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1716,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20091,20104,IdentifierMutator-Variable,currentLinePos,position,4,0.0013593595,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1717,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20091,20104,FieldReferenceMutator,currentLinePos,pos,0,0.5798388,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1718,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20091,20104,FieldReferenceMutator,currentLinePos,pos,1,0.40308696,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1719,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20091,20104,FieldReferenceMutator,currentLinePos,x,2,0.0028060998,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1720,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20091,20104,FieldReferenceMutator,currentLinePos,Pos,3,0.0018321931,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1721,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20091,20104,FieldReferenceMutator,currentLinePos,position,4,0.0013593595,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1722,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20109,20109,IdentifierMutator-Literal,4,pos,0,0.45371884,<mask>,"
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos +=<mask>;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1723,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20109,20109,IdentifierMutator-Literal,4,1,1,0.22995412,<mask>,"
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos +=<mask>;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1724,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20109,20109,IdentifierMutator-Literal,4,2,2,0.07983624,<mask>,"
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos +=<mask>;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1725,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,504,20109,20109,IdentifierMutator-Literal,4,length,4,0.017705763,<mask>,"
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos +=<mask>;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1726,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20150,20153,BinaryOperatorMutator,&&,&,2,0.02042675,(lineLength > 0) <mask> (lineLength <= currentLinePos),"      x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0<mask>lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1727,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20150,20153,BinaryOperatorMutator,&&,AND,3,0.0021275724,(lineLength > 0) <mask> (lineLength <= currentLinePos),"      x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0<mask>lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1728,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20150,20153,BinaryOperatorMutator,&&,and,4,8.8561187E-4,(lineLength > 0) <mask> (lineLength <= currentLinePos),"      x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0<mask>lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1729,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20146,20148,BinaryOperatorMutator,>,!=,2,0.03354259,lineLength <mask> 0,"        x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength<mask>0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1730,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20146,20148,BinaryOperatorMutator,>,==,3,0.023923254,lineLength <mask> 0,"        x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength<mask>0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1731,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20146,20148,BinaryOperatorMutator,>,>=,4,0.009211616,lineLength <mask> 0,"        x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength<mask>0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1732,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20136,20145,IdentifierMutator-Variable,lineLength,pos,0,0.8061634,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1733,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20136,20145,IdentifierMutator-Variable,lineLength,length,1,0.081273995,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1734,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20136,20145,IdentifierMutator-Variable,lineLength,position,2,0.03991801,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1735,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20136,20145,IdentifierMutator-Variable,lineLength,offset,3,0.008178057,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1736,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20136,20145,IdentifierMutator-Variable,lineLength,len,4,0.0050431336,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1737,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20136,20145,FieldReferenceMutator,lineLength,pos,0,0.8061634,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1738,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20136,20145,FieldReferenceMutator,lineLength,length,1,0.081273995,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1739,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20136,20145,FieldReferenceMutator,lineLength,position,2,0.03991801,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1740,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20136,20145,FieldReferenceMutator,lineLength,offset,3,0.008178057,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1741,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20136,20145,FieldReferenceMutator,lineLength,len,4,0.0050431336,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1742,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20149,20149,IdentifierMutator-Literal,0,1,1,0.036307774,<mask>,"       x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength ><mask> && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1743,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20149,20149,IdentifierMutator-Literal,0,2,2,0.005767462,<mask>,"       x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength ><mask> && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1744,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20149,20149,IdentifierMutator-Literal,0,4,3,0.0027120064,<mask>,"       x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength ><mask> && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1745,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20149,20149,IdentifierMutator-Literal,0,pos,4,0.0024671396,<mask>,"       x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength ><mask> && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1746,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20164,20167,BinaryOperatorMutator,<=,<,0,0.39389122,lineLength <mask> currentLinePos,"   x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength<mask>currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1747,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20164,20167,BinaryOperatorMutator,<=,==,1,0.27772817,lineLength <mask> currentLinePos,"   x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength<mask>currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1748,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20164,20167,BinaryOperatorMutator,<=,>,2,0.09517997,lineLength <mask> currentLinePos,"   x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength<mask>currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1749,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20164,20167,BinaryOperatorMutator,<=,<,3,0.07151448,lineLength <mask> currentLinePos,"   x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength<mask>currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1750,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20154,20163,IdentifierMutator-Variable,lineLength,pos,0,0.95054585,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1751,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20154,20163,IdentifierMutator-Variable,lineLength,0,1,0.029080542,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1752,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20154,20163,IdentifierMutator-Variable,lineLength,position,2,0.0041239043,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1753,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20154,20163,IdentifierMutator-Variable,lineLength,start,3,0.0018849447,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1754,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20154,20163,IdentifierMutator-Variable,lineLength,1,4,0.0018175166,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1755,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20154,20163,FieldReferenceMutator,lineLength,pos,0,0.95054585,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1756,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20154,20163,FieldReferenceMutator,lineLength,0,1,0.029080542,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1757,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20154,20163,FieldReferenceMutator,lineLength,position,2,0.0041239043,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1758,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20154,20163,FieldReferenceMutator,lineLength,start,3,0.0018849447,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1759,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20154,20163,FieldReferenceMutator,lineLength,1,4,0.0018175166,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1760,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20168,20181,IdentifierMutator-Variable,currentLinePos,256,0,0.08368058,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1761,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20168,20181,IdentifierMutator-Variable,currentLinePos,255,1,0.05682104,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1762,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20168,20181,IdentifierMutator-Variable,currentLinePos,1,2,0.044809103,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1763,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20168,20181,IdentifierMutator-Variable,currentLinePos,127,3,0.03487211,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1764,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20168,20181,IdentifierMutator-Variable,currentLinePos,4,4,0.030467179,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1765,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20168,20181,FieldReferenceMutator,currentLinePos,256,0,0.08368058,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1766,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20168,20181,FieldReferenceMutator,currentLinePos,255,1,0.05682104,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1767,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20168,20181,FieldReferenceMutator,currentLinePos,1,2,0.044809103,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1768,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20168,20181,FieldReferenceMutator,currentLinePos,127,3,0.03487211,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1769,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,505,20168,20181,FieldReferenceMutator,currentLinePos,4,4,0.030467179,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1770,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20217,20225,MethodCallMutator,arraycopy,copy,0,0.44838908,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)"," modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1771,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20217,20225,MethodCallMutator,arraycopy,printf,1,0.27453634,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)"," modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1772,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20217,20225,MethodCallMutator,arraycopy,format,2,0.103110895,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)"," modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1773,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20217,20225,MethodCallMutator,arraycopy,write,3,0.034942545,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)"," modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1774,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20217,20225,MethodCallMutator,arraycopy,replace,4,0.014357003,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)"," modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1775,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20227,20239,IdentifierMutator-Variable,lineSeparator,buffer,0,0.8169459,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1776,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20227,20239,IdentifierMutator-Variable,lineSeparator,line,1,0.04690348,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1777,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20227,20239,IdentifierMutator-Variable,lineSeparator,lines,2,0.021744726,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1778,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20227,20239,IdentifierMutator-Variable,lineSeparator,buf,3,0.009267252,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1779,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20227,20239,IdentifierMutator-Variable,lineSeparator,string,4,0.008680807,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1780,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20227,20239,FieldReferenceMutator,lineSeparator,buffer,0,0.8169459,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1781,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20227,20239,FieldReferenceMutator,lineSeparator,line,1,0.04690348,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1782,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20227,20239,FieldReferenceMutator,lineSeparator,lines,2,0.021744726,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1783,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20227,20239,FieldReferenceMutator,lineSeparator,buf,3,0.009267252,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1784,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20227,20239,FieldReferenceMutator,lineSeparator,string,4,0.008680807,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1785,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20242,20242,IdentifierMutator-Literal,0,1,2,0.0038664232,<mask>,"                 buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator,<mask>, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1786,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20242,20242,IdentifierMutator-Literal,0,pos,3,0.0010919744,<mask>,"                 buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator,<mask>, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1787,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20242,20242,IdentifierMutator-Literal,0,4,4,0.0010349891,<mask>,"                 buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator,<mask>, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1788,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20245,20250,IdentifierMutator-Variable,buffer,line,2,3.8841917E-4,<mask>,"               buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1789,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20245,20250,IdentifierMutator-Variable,buffer,buf,3,1.9171674E-4,<mask>,"               buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1790,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20245,20250,IdentifierMutator-Variable,buffer,source,4,1.4794039E-4,<mask>,"               buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1791,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20245,20250,FieldReferenceMutator,buffer,line,2,3.8841917E-4,<mask>,"               buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1792,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20245,20250,FieldReferenceMutator,buffer,buf,3,1.9171674E-4,<mask>,"               buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1793,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20245,20250,FieldReferenceMutator,buffer,source,4,1.4794039E-4,<mask>,"               buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1794,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20253,20255,IdentifierMutator-Variable,pos,0,1,0.01524594,<mask>,"             buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1795,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20253,20255,IdentifierMutator-Variable,pos,1,3,0.001386155,<mask>,"             buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1796,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20253,20255,IdentifierMutator-Variable,pos,position,4,7.9083163E-4,<mask>,"             buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1797,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20253,20255,FieldReferenceMutator,pos,0,1,0.01524594,<mask>,"             buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1798,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20253,20255,FieldReferenceMutator,pos,1,3,0.001386155,<mask>,"             buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1799,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20253,20255,FieldReferenceMutator,pos,position,4,7.9083163E-4,<mask>,"             buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1800,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20258,20277,IdentifierMutator-Variable,lineSeparator.length,len,0,0.40724584,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1801,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20258,20277,IdentifierMutator-Variable,lineSeparator.length,length,1,0.1738978,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1802,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20258,20277,IdentifierMutator-Variable,lineSeparator.length,4,2,0.07947996,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1803,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20258,20277,IdentifierMutator-Variable,lineSeparator.length,n,3,0.040844593,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1804,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20258,20277,IdentifierMutator-Variable,lineSeparator.length,line,4,0.025696028,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1805,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20258,20270,IdentifierMutator-Variable,lineSeparator,buffer,0,0.9938554,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1806,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20258,20270,IdentifierMutator-Variable,lineSeparator,buffer,1,0.002136814,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1807,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20258,20270,IdentifierMutator-Variable,lineSeparator,line,2,0.0013068112,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1808,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20258,20270,IdentifierMutator-Variable,lineSeparator,buf,3,3.138145E-4,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1809,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20258,20270,IdentifierMutator-Variable,lineSeparator,text,4,1.8696343E-4,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1810,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20258,20270,FieldReferenceMutator,lineSeparator,buffer,0,0.9938554,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1811,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20258,20270,FieldReferenceMutator,lineSeparator,buffer,1,0.002136814,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1812,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20258,20270,FieldReferenceMutator,lineSeparator,line,2,0.0013068112,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1813,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20258,20270,FieldReferenceMutator,lineSeparator,buf,3,3.138145E-4,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1814,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20258,20270,FieldReferenceMutator,lineSeparator,text,4,1.8696343E-4,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1815,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20272,20277,FieldReferenceMutator,length,len,1,2.4772357E-4,lineSeparator.<mask>,"      buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1816,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20272,20277,FieldReferenceMutator,length,position,2,4.939695E-5,lineSeparator.<mask>,"      buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1817,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,506,20272,20277,FieldReferenceMutator,length,count,3,2.6590738E-5,lineSeparator.<mask>,"      buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1818,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20308,20308,AssignmentMutator,pos+=lineSeparator.length,++,0,0.9640786,pos <mask>= lineSeparator.length,"
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos<mask>+= lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1819,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20308,20308,AssignmentMutator,pos+=lineSeparator.length,+,1,0.008239496,pos <mask>= lineSeparator.length,"
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos<mask>+= lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1820,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20308,20308,AssignmentMutator,pos+=lineSeparator.length,++,2,0.0036510515,pos <mask>= lineSeparator.length,"
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos<mask>+= lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1821,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20308,20308,AssignmentMutator,pos+=lineSeparator.length,*,3,0.003487082,pos <mask>= lineSeparator.length,"
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos<mask>+= lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1822,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20308,20308,AssignmentMutator,pos+=lineSeparator.length,+,4,0.0025446527,pos <mask>= lineSeparator.length,"
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos<mask>+= lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1823,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20305,20307,IdentifierMutator-Variable,pos,position,2,0.0014238023,<mask>,"    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1824,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20305,20307,IdentifierMutator-Variable,pos,Pos,3,4.3400706E-4,<mask>,"    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1825,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20305,20307,IdentifierMutator-Variable,pos,offset,4,8.658397E-5,<mask>,"    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1826,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20305,20307,FieldReferenceMutator,pos,position,2,0.0014238023,<mask>,"    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1827,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20305,20307,FieldReferenceMutator,pos,Pos,3,4.3400706E-4,<mask>,"    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1828,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20305,20307,FieldReferenceMutator,pos,offset,4,8.658397E-5,<mask>,"    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1829,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20312,20331,IdentifierMutator-Variable,lineSeparator.length,4,0,0.79304135,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1830,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20312,20331,IdentifierMutator-Variable,lineSeparator.length,2,1,0.054201618,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1831,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20312,20331,IdentifierMutator-Variable,lineSeparator.length,5,2,0.023471013,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1832,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20312,20331,IdentifierMutator-Variable,lineSeparator.length,1,3,0.022097014,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1833,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20312,20331,IdentifierMutator-Variable,lineSeparator.length,3,4,0.020625181,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1834,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20312,20324,IdentifierMutator-Variable,lineSeparator,buffer,0,0.97794867,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1835,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20312,20324,IdentifierMutator-Variable,lineSeparator,line,1,0.007852801,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1836,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20312,20324,IdentifierMutator-Variable,lineSeparator,buf,2,0.0023001505,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1837,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20312,20324,IdentifierMutator-Variable,lineSeparator,text,3,0.0010461648,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1838,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20312,20324,IdentifierMutator-Variable,lineSeparator,code,4,3.7937233E-4,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1839,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20312,20324,FieldReferenceMutator,lineSeparator,buffer,0,0.97794867,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1840,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20312,20324,FieldReferenceMutator,lineSeparator,line,1,0.007852801,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1841,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20312,20324,FieldReferenceMutator,lineSeparator,buf,2,0.0023001505,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1842,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20312,20324,FieldReferenceMutator,lineSeparator,text,3,0.0010461648,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1843,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20312,20324,FieldReferenceMutator,lineSeparator,code,4,3.7937233E-4,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1844,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20326,20331,FieldReferenceMutator,length,position,1,1.9497819E-4,lineSeparator.<mask>,"               buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1845,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20326,20331,FieldReferenceMutator,length,len,2,1.6991064E-4,lineSeparator.<mask>,"               buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1846,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,507,20326,20331,FieldReferenceMutator,length,width,4,2.8037513E-5,lineSeparator.<mask>,"               buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1847,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20372,20372,AssignmentMutator,currentLinePos=0,*,0,0.4809754,currentLinePos <mask>= 0," MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos<mask>= 0;
                    }
                }
            }
        }
   "
1848,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20372,20372,AssignmentMutator,currentLinePos=0,||,1,0.19663772,currentLinePos <mask>= 0," MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos<mask>= 0;
                    }
                }
            }
        }
   "
1849,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20372,20372,AssignmentMutator,currentLinePos=0,^,2,0.08168908,currentLinePos <mask>= 0," MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos<mask>= 0;
                    }
                }
            }
        }
   "
1850,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20372,20372,AssignmentMutator,currentLinePos=0,|,3,0.079475954,currentLinePos <mask>= 0," MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos<mask>= 0;
                    }
                }
            }
        }
   "
1851,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20372,20372,AssignmentMutator,currentLinePos=0,>>,4,0.02047174,currentLinePos <mask>= 0," MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos<mask>= 0;
                    }
                }
            }
        }
   "
1852,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20358,20371,IdentifierMutator-Variable,currentLinePos,buffer,0,0.2174502,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1853,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20358,20371,IdentifierMutator-Variable,currentLinePos,line,1,0.09240584,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1854,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20358,20371,IdentifierMutator-Variable,currentLinePos,pos,2,0.078489065,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1855,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20358,20371,IdentifierMutator-Variable,currentLinePos,buf,3,0.03820603,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1856,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20358,20371,IdentifierMutator-Variable,currentLinePos,length,4,0.03634959,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1857,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20358,20371,FieldReferenceMutator,currentLinePos,buffer,0,0.2174502,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1858,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20358,20371,FieldReferenceMutator,currentLinePos,line,1,0.09240584,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1859,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20358,20371,FieldReferenceMutator,currentLinePos,pos,2,0.078489065,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1860,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20358,20371,FieldReferenceMutator,currentLinePos,buf,3,0.03820603,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1861,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20358,20371,FieldReferenceMutator,currentLinePos,length,4,0.03634959,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1862,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20375,20375,IdentifierMutator-Literal,0,pos,0,0.9606277,<mask>,"K_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos =<mask>;
                    }
                }
            }
        }
   "
1863,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20375,20375,IdentifierMutator-Literal,0,position,2,0.0030007649,<mask>,"K_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos =<mask>;
                    }
                }
            }
        }
   "
1864,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20375,20375,IdentifierMutator-Literal,0,index,3,9.940353E-4,<mask>,"K_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos =<mask>;
                    }
                }
            }
        }
   "
1865,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",452,508,20375,20375,IdentifierMutator-Literal,0,i,4,7.2437775E-4,<mask>,"K_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos =<mask>;
                    }
                }
            }
        }
   "
1866,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,539,21653,21655,IdentifierMutator-Variable,eof,done,0,0.30600673,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1867,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,539,21653,21655,IdentifierMutator-Variable,eof,finished,1,0.1257539,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1868,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,539,21653,21655,IdentifierMutator-Variable,eof,stop,2,0.07442391,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1869,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,539,21653,21655,IdentifierMutator-Variable,eof,exit,3,0.050556906,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1870,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,539,21653,21655,IdentifierMutator-Variable,eof,end,4,0.04960955,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1871,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,539,21653,21655,FieldReferenceMutator,eof,done,0,0.30600673,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1872,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,539,21653,21655,FieldReferenceMutator,eof,finished,1,0.1257539,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1873,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,539,21653,21655,FieldReferenceMutator,eof,stop,2,0.07442391,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1874,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,539,21653,21655,FieldReferenceMutator,eof,exit,3,0.050556906,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1875,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,539,21653,21655,FieldReferenceMutator,eof,end,4,0.04960955,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1876,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,542,21709,21711,BinaryOperatorMutator,<,==,0,0.223451,inAvail <mask> 0,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail<mask>0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1877,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,542,21709,21711,BinaryOperatorMutator,<,==,1,0.21845761,inAvail <mask> 0,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail<mask>0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1878,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,542,21709,21711,BinaryOperatorMutator,<,>,2,0.21460688,inAvail <mask> 0,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail<mask>0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1879,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,542,21709,21711,BinaryOperatorMutator,<,<=,4,0.08764514,inAvail <mask> 0,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail<mask>0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1880,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,542,21702,21708,IdentifierMutator-Variable,inAvail,pos,0,0.6025664,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (<mask> < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1881,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,542,21702,21708,IdentifierMutator-Variable,inAvail,i,1,0.060962595,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (<mask> < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1882,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,542,21702,21708,IdentifierMutator-Variable,inAvail,offset,2,0.01839406,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (<mask> < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1883,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,542,21702,21708,IdentifierMutator-Variable,inAvail,position,3,0.013375317,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (<mask> < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1884,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,542,21702,21708,IdentifierMutator-Variable,inAvail,b,4,0.012427245,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (<mask> < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1885,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,542,21712,21712,IdentifierMutator-Literal,0,1,1,0.04096003,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail <<mask>) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1886,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,542,21712,21712,IdentifierMutator-Literal,0,pos,2,0.017515754,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail <<mask>) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1887,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,542,21712,21712,IdentifierMutator-Literal,0,2,3,0.0140517065,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail <<mask>) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1888,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,542,21712,21712,IdentifierMutator-Literal,0,i,4,0.012964744,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail <<mask>) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1889,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,543,21732,21732,AssignmentMutator,eof=true,|,0,0.9368005,eof <mask>= true,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof<mask>= true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1890,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,543,21732,21732,AssignmentMutator,eof=true,&,1,0.03523596,eof <mask>= true,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof<mask>= true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1891,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,543,21732,21732,AssignmentMutator,eof=true,||,2,0.0063775703,eof <mask>= true,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof<mask>= true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1892,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,543,21732,21732,AssignmentMutator,eof=true,^,3,0.0046112183,eof <mask>= true,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof<mask>= true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1893,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,543,21732,21732,AssignmentMutator,eof=true,!,4,0.0037213026,eof <mask>= true,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof<mask>= true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1894,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,543,21729,21731,IdentifierMutator-Variable,eof,done,0,0.5852882,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1895,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,543,21729,21731,IdentifierMutator-Variable,eof,finished,1,0.081278555,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1896,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,543,21729,21731,IdentifierMutator-Variable,eof,end,2,0.034523726,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1897,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,543,21729,21731,IdentifierMutator-Variable,eof,ended,3,0.029406138,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1898,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,543,21729,21731,IdentifierMutator-Variable,eof,closed,4,0.027027369,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1899,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,543,21729,21731,FieldReferenceMutator,eof,done,0,0.5852882,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1900,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,543,21729,21731,FieldReferenceMutator,eof,finished,1,0.081278555,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1901,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,543,21729,21731,FieldReferenceMutator,eof,end,2,0.034523726,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1902,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,543,21729,21731,FieldReferenceMutator,eof,ended,3,0.029406138,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1903,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,543,21729,21731,FieldReferenceMutator,eof,closed,4,0.027027369,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1904,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,543,21735,21738,IdentifierMutator-Literal,true,false,1,0.028067522,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof =<mask>;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1905,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,543,21735,21738,IdentifierMutator-Literal,true,TRUE,3,1.3249651E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof =<mask>;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1906,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,543,21735,21738,IdentifierMutator-Literal,true,1,4,9.629265E-5,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof =<mask>;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1907,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21772,21772,IdentifierMutator-Literal,0,pos,1,0.08268388,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i =<mask>; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1908,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21772,21772,IdentifierMutator-Literal,0,1,2,0.006390756,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i =<mask>; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1909,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21772,21772,IdentifierMutator-Literal,0,offset,4,0.001435486,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i =<mask>; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1910,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21776,21778,BinaryOperatorMutator,<,<=,2,0.0032129693,i <mask> inAvail,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i<mask>inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1911,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21776,21778,BinaryOperatorMutator,<,++,3,0.0017119371,i <mask> inAvail,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i<mask>inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1912,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21776,21778,BinaryOperatorMutator,<,+,4,4.137092E-4,i <mask> inAvail,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i<mask>inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1913,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21775,21775,IdentifierMutator-Variable,i,pos,2,0.0014674164,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0;<mask> < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1914,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21775,21775,IdentifierMutator-Variable,i,j,3,1.1250476E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0;<mask> < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1915,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21775,21775,IdentifierMutator-Variable,i,0,4,1.07833E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0;<mask> < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1916,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21779,21785,IdentifierMutator-Variable,inAvail,n,0,0.14292932,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i <<mask>; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1917,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21779,21785,IdentifierMutator-Variable,inAvail,size,1,0.115542,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i <<mask>; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1918,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21779,21785,IdentifierMutator-Variable,inAvail,len,2,0.1027158,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i <<mask>; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1919,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21779,21785,IdentifierMutator-Variable,inAvail,pos,3,0.07468494,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i <<mask>; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1920,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21779,21785,IdentifierMutator-Variable,inAvail,limit,4,0.072005756,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i <<mask>; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1921,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21789,21790,UnaryOperatorMutator,++,++),2,0.0037155217,i<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i<mask>) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1922,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21789,21790,UnaryOperatorMutator,++,++;,3,3.471651E-4,i<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i<mask>) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1923,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21789,21790,UnaryOperatorMutator,++,--,4,2.0901115E-4,i<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i<mask>) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1924,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21788,21788,IdentifierMutator-Variable,i,++,2,1.087855E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail;<mask>++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1925,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21788,21788,IdentifierMutator-Variable,i,I,3,5.2334315E-5,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail;<mask>++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1926,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,545,21788,21788,IdentifierMutator-Variable,i,j,4,5.0137125E-5,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail;<mask>++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1927,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21825,21828,BinaryOperatorMutator,||,|,2,0.009832157,(buffer == null) <mask> ((buffer.length - pos) < decodeSize),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null<mask>buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1928,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21825,21828,BinaryOperatorMutator,||,.,3,0.008927607,(buffer == null) <mask> ((buffer.length - pos) < decodeSize),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null<mask>buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1929,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21825,21828,BinaryOperatorMutator,||,?,4,0.0031648385,(buffer == null) <mask> ((buffer.length - pos) < decodeSize),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null<mask>buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1930,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21817,21820,BinaryOperatorMutator,==,=,2,0.009059136,buffer <mask> null,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer<mask>null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1931,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21817,21820,BinaryOperatorMutator,==,===,3,0.0014111465,buffer <mask> null,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer<mask>null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1932,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21817,21820,BinaryOperatorMutator,==,!=,4,6.824041E-4,buffer <mask> null,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer<mask>null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1933,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21811,21816,IdentifierMutator-Variable,buffer,Buffer,2,0.0018047302,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1934,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21811,21816,IdentifierMutator-Variable,buffer,buf,3,9.906832E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1935,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21811,21816,IdentifierMutator-Variable,buffer,queue,4,5.849453E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1936,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21811,21816,FieldReferenceMutator,buffer,Buffer,2,0.0018047302,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1937,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21811,21816,FieldReferenceMutator,buffer,buf,3,9.906832E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1938,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21811,21816,FieldReferenceMutator,buffer,queue,4,5.849453E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1939,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21821,21824,IdentifierMutator-Literal,null,nil,1,0.0012571932,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer ==<mask> || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1940,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21821,21824,IdentifierMutator-Literal,null,NULL,2,0.0010901536,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer ==<mask> || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1941,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21821,21824,IdentifierMutator-Literal,null,undefined,4,2.1016036E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer ==<mask> || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1942,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21848,21850,BinaryOperatorMutator,<,>,1,0.2302898,(buffer.length - pos) <mask> decodeSize,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos<mask>decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1943,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21848,21850,BinaryOperatorMutator,<,>,3,0.09603589,(buffer.length - pos) <mask> decodeSize,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos<mask>decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1944,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21848,21850,BinaryOperatorMutator,<,>=,4,0.0836145,(buffer.length - pos) <mask> decodeSize,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos<mask>decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1945,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21842,21844,BinaryOperatorMutator,-,*,1,0.19134657,buffer.length <mask> pos,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1946,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21842,21844,BinaryOperatorMutator,-,+,2,0.15388948,buffer.length <mask> pos,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1947,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21842,21844,BinaryOperatorMutator,-,_,3,0.052787326,buffer.length <mask> pos,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1948,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21842,21844,BinaryOperatorMutator,-,/,4,0.035744138,buffer.length <mask> pos,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1949,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21829,21841,IdentifierMutator-Variable,buffer.length,i,0,0.5350913,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1950,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21829,21841,IdentifierMutator-Variable,buffer.length,size,1,0.09398828,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1951,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21829,21841,IdentifierMutator-Variable,buffer.length,limit,2,0.040866785,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1952,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21829,21841,IdentifierMutator-Variable,buffer.length,length,3,0.03957807,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1953,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21829,21841,IdentifierMutator-Variable,buffer.length,buffer,4,0.020405691,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1954,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21829,21834,IdentifierMutator-Variable,buffer,in,1,0.06961245,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1955,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21829,21834,IdentifierMutator-Variable,buffer,buf,2,0.0075013856,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1956,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21829,21834,IdentifierMutator-Variable,buffer,input,3,0.002350563,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1957,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21829,21834,IdentifierMutator-Variable,buffer,out,4,0.0018378728,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1958,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21829,21834,FieldReferenceMutator,buffer,in,1,0.06961245,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1959,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21829,21834,FieldReferenceMutator,buffer,buf,2,0.0075013856,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1960,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21829,21834,FieldReferenceMutator,buffer,input,3,0.002350563,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1961,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21829,21834,FieldReferenceMutator,buffer,out,4,0.0018378728,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1962,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21836,21841,FieldReferenceMutator,length,position,1,0.002160781,buffer.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1963,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21836,21841,FieldReferenceMutator,length,size,2,0.0020418996,buffer.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1964,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21836,21841,FieldReferenceMutator,length,len,3,0.0015271057,buffer.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1965,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21836,21841,FieldReferenceMutator,length,read,4,8.278441E-4,buffer.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1966,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21845,21847,IdentifierMutator-Variable,pos,i,0,0.9898303,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1967,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21845,21847,IdentifierMutator-Variable,pos,1,1,0.0022602202,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1968,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21845,21847,IdentifierMutator-Variable,pos,i,2,9.841333E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1969,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21845,21847,IdentifierMutator-Variable,pos,8,3,9.110976E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1970,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21845,21847,IdentifierMutator-Variable,pos,index,4,5.5149256E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1971,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21845,21847,FieldReferenceMutator,pos,i,0,0.9898303,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1972,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21845,21847,FieldReferenceMutator,pos,1,1,0.0022602202,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1973,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21845,21847,FieldReferenceMutator,pos,i,2,9.841333E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1974,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21845,21847,FieldReferenceMutator,pos,8,3,9.110976E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1975,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21845,21847,FieldReferenceMutator,pos,index,4,5.5149256E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1976,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21851,21860,IdentifierMutator-Variable,decodeSize,0,0,0.38190857,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1977,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21851,21860,IdentifierMutator-Variable,decodeSize,limit,1,0.1105233,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1978,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21851,21860,IdentifierMutator-Variable,decodeSize,i,2,0.11033225,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1979,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21851,21860,IdentifierMutator-Variable,decodeSize,len,3,0.047684494,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1980,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21851,21860,IdentifierMutator-Variable,decodeSize,size,4,0.026908359,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1981,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21851,21860,FieldReferenceMutator,decodeSize,0,0,0.38190857,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1982,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21851,21860,FieldReferenceMutator,decodeSize,limit,1,0.1105233,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1983,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21851,21860,FieldReferenceMutator,decodeSize,i,2,0.11033225,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1984,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21851,21860,FieldReferenceMutator,decodeSize,len,3,0.047684494,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1985,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,546,21851,21860,FieldReferenceMutator,decodeSize,size,4,0.026908359,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1986,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,547,21881,21892,MethodCallMutator,resizeBuffer,close,0,0.3517236,<mask>(),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1987,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,547,21881,21892,MethodCallMutator,resizeBuffer,flush,1,0.14769296,<mask>(),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1988,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,547,21881,21892,MethodCallMutator,resizeBuffer,decode,2,0.052173354,<mask>(),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1989,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,547,21881,21892,MethodCallMutator,resizeBuffer,break,3,0.038577206,<mask>(),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1990,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,547,21881,21892,MethodCallMutator,resizeBuffer,complete,4,0.028946027,<mask>(),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1991,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,549,21935,21941,ArrayAccessMutator,inPos++,i,0,0.6254486,in[<mask>],"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1992,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,549,21935,21941,ArrayAccessMutator,inPos++,pos,1,0.35539037,in[<mask>],"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1993,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,549,21935,21941,ArrayAccessMutator,inPos++,0,2,0.0029729423,in[<mask>],"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1994,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,549,21935,21941,ArrayAccessMutator,inPos++,p,3,9.37085E-4,in[<mask>],"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1995,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,549,21935,21941,ArrayAccessMutator,inPos++,Pos,4,8.155088E-4,in[<mask>],"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1996,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,549,21932,21933,IdentifierMutator-Variable,in,buffer,1,0.037988707,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b =<mask>[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1997,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,549,21932,21933,IdentifierMutator-Variable,in,bytes,2,0.023616761,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b =<mask>[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1998,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,549,21932,21933,IdentifierMutator-Variable,in,input,3,0.016035194,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b =<mask>[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1999,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,549,21932,21933,IdentifierMutator-Variable,in,data,4,0.012918302,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b =<mask>[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2000,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,549,21940,21941,UnaryOperatorMutator,++,--,2,9.3166454E-4,inPos<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2001,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,549,21940,21941,UnaryOperatorMutator,++,*/,3,3.0580416E-4,inPos<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2002,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,549,21940,21941,UnaryOperatorMutator,++,+,4,2.5941827E-4,inPos<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2003,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,549,21935,21939,IdentifierMutator-Variable,inPos,pos,0,0.783149,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2004,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,549,21935,21939,IdentifierMutator-Variable,inPos,i,1,0.1898064,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2005,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,549,21935,21939,IdentifierMutator-Variable,inPos,pos,2,0.00396269,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2006,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,549,21935,21939,IdentifierMutator-Variable,inPos,Pos,3,0.0024369045,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2007,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,549,21935,21939,IdentifierMutator-Variable,inPos,offset,4,0.0014244992,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2008,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,550,21962,21965,BinaryOperatorMutator,==,<,0,0.33759326,b <mask> org.apache.commons.codec.binary.Base64.PAD,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b<mask>PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2009,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,550,21962,21965,BinaryOperatorMutator,==,<,2,0.059361983,b <mask> org.apache.commons.codec.binary.Base64.PAD,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b<mask>PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2010,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,550,21962,21965,BinaryOperatorMutator,==,>=,4,0.032735188,b <mask> org.apache.commons.codec.binary.Base64.PAD,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b<mask>PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2011,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,550,21961,21961,IdentifierMutator-Variable,b,bc,1,0.0010331722,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (<mask> == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2012,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,550,21961,21961,IdentifierMutator-Variable,b,a,3,4.8363625E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (<mask> == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2013,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,550,21961,21961,IdentifierMutator-Variable,b,sb,4,3.881319E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (<mask> == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2014,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,550,21966,21968,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,0,0,0.8472015,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2015,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,550,21966,21968,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,127,1,0.049700234,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2016,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,550,21966,21968,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,b,2,0.020087166,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2017,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,550,21966,21968,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,255,3,0.010305227,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2018,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,550,21966,21968,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,null,4,0.009432046,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2019,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,550,21966,21968,FieldReferenceMutator,PAD,0,0,0.8472015,org.apache.commons.codec.binary.Base64.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2020,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,550,21966,21968,FieldReferenceMutator,PAD,127,1,0.049700234,org.apache.commons.codec.binary.Base64.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2021,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,550,21966,21968,FieldReferenceMutator,PAD,b,2,0.020087166,org.apache.commons.codec.binary.Base64.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2022,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,550,21966,21968,FieldReferenceMutator,PAD,255,3,0.010305227,org.apache.commons.codec.binary.Base64.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2023,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,550,21966,21968,FieldReferenceMutator,PAD,null,4,0.009432046,org.apache.commons.codec.binary.Base64.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2024,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,552,22023,22023,AssignmentMutator,eof=true,|,0,0.90622437,eof <mask>= true,", int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof<mask>= true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                          "
2025,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,552,22023,22023,AssignmentMutator,eof=true,&,1,0.0685714,eof <mask>= true,", int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof<mask>= true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                          "
2026,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,552,22023,22023,AssignmentMutator,eof=true,*,2,0.010431921,eof <mask>= true,", int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof<mask>= true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                          "
2027,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,552,22023,22023,AssignmentMutator,eof=true,||,3,0.0045410474,eof <mask>= true,", int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof<mask>= true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                          "
2028,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,552,22023,22023,AssignmentMutator,eof=true,^,4,0.0031841302,eof <mask>= true,", int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof<mask>= true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                          "
2029,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,552,22020,22022,IdentifierMutator-Variable,eof,done,0,0.5822251,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2030,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,552,22020,22022,IdentifierMutator-Variable,eof,finished,1,0.0749867,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2031,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,552,22020,22022,IdentifierMutator-Variable,eof,completed,2,0.0207111,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2032,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,552,22020,22022,IdentifierMutator-Variable,eof,complete,3,0.019147605,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2033,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,552,22020,22022,IdentifierMutator-Variable,eof,ok,4,0.016916098,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2034,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,552,22020,22022,FieldReferenceMutator,eof,done,0,0.5822251,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2035,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,552,22020,22022,FieldReferenceMutator,eof,finished,1,0.0749867,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2036,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,552,22020,22022,FieldReferenceMutator,eof,completed,2,0.0207111,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2037,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,552,22020,22022,FieldReferenceMutator,eof,complete,3,0.019147605,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2038,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,552,22020,22022,FieldReferenceMutator,eof,ok,4,0.016916098,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2039,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,552,22026,22029,IdentifierMutator-Literal,true,false,1,0.022653628,<mask>," int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof =<mask>;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer"
2040,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,552,22026,22029,IdentifierMutator-Literal,true,True,2,1.2616171E-4,<mask>," int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof =<mask>;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer"
2041,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,552,22026,22029,IdentifierMutator-Literal,true,1,4,4.7072164E-5,<mask>," int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof =<mask>;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer"
2042,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22102,22105,BinaryOperatorMutator,&&,&,2,0.019086072,(b >= 0) <mask> (b < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)," (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0<mask>b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = ("
2043,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22102,22105,BinaryOperatorMutator,&&,&,3,0.0019726616,(b >= 0) <mask> (b < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)," (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0<mask>b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = ("
2044,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22102,22105,BinaryOperatorMutator,&&,AND,4,0.0017750916,(b >= 0) <mask> (b < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)," (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0<mask>b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = ("
2045,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22097,22100,BinaryOperatorMutator,>=,>,1,0.21913998,b <mask> 0,"  if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b<mask>0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]"
2046,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22097,22100,BinaryOperatorMutator,>=,>,2,0.1036691,b <mask> 0,"  if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b<mask>0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]"
2047,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22097,22100,BinaryOperatorMutator,>=,!=,3,0.044702142,b <mask> 0,"  if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b<mask>0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]"
2048,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22097,22100,BinaryOperatorMutator,>=,==,4,0.010695067,b <mask> 0,"  if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b<mask>0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]"
2049,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22096,22096,IdentifierMutator-Variable,b,result,1,0.021446548,<mask>,"   if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (<mask> >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++"
2050,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22096,22096,IdentifierMutator-Variable,b,bc,2,0.002022709,<mask>,"   if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (<mask> >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++"
2051,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22096,22096,IdentifierMutator-Variable,b,a,4,7.179882E-4,<mask>,"   if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (<mask> >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++"
2052,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22101,22101,IdentifierMutator-Literal,0,1,1,0.004490776,<mask>," if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >=<mask> && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] ="
2053,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22101,22101,IdentifierMutator-Literal,0,offset,2,0.0039863857,<mask>," if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >=<mask> && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] ="
2054,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22101,22101,IdentifierMutator-Literal,0,pos,3,0.0029801773,<mask>," if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >=<mask> && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] ="
2055,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22101,22101,IdentifierMutator-Literal,0,32,4,0.0020950756,<mask>," if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >=<mask> && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] ="
2056,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22107,22109,BinaryOperatorMutator,<,<=,2,0.01899425,b <mask> org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,"Avail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b<mask>DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte)"
2057,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22107,22109,BinaryOperatorMutator,<,!=,3,0.00610453,b <mask> org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,"Avail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b<mask>DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte)"
2058,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22107,22109,BinaryOperatorMutator,<,>=,4,0.0019163891,b <mask> org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,"Avail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b<mask>DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte)"
2059,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22106,22106,IdentifierMutator-Variable,b,bi,2,7.3170377E-4,<mask>,"inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 &&<mask> < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte"
2060,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22106,22106,IdentifierMutator-Variable,b,result,3,2.5595404E-4,<mask>,"inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 &&<mask> < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte"
2061,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22106,22106,IdentifierMutator-Variable,b,a,4,2.4868533E-4,<mask>,"inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 &&<mask> < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte"
2062,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22110,22128,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,256,0,0.21313636,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2063,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22110,22128,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,127,1,0.17466232,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2064,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22110,22128,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,255,2,0.05645742,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2065,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22110,22128,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,32,3,0.03200671,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2066,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22110,22128,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,128,4,0.028498704,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2067,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22110,22121,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,in,0,0.4893274,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2068,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22110,22121,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,buffer,1,0.37093952,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2069,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22110,22121,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,table,2,0.022430008,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2070,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22110,22121,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,buf,3,0.01231022,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2071,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22110,22121,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,out,4,0.010743957,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2072,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22110,22121,FieldReferenceMutator,DECODE_TABLE,in,0,0.4893274,org.apache.commons.codec.binary.Base64.<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2073,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22110,22121,FieldReferenceMutator,DECODE_TABLE,buffer,1,0.37093952,org.apache.commons.codec.binary.Base64.<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2074,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22110,22121,FieldReferenceMutator,DECODE_TABLE,table,2,0.022430008,org.apache.commons.codec.binary.Base64.<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2075,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22110,22121,FieldReferenceMutator,DECODE_TABLE,buf,3,0.01231022,org.apache.commons.codec.binary.Base64.<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2076,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22110,22121,FieldReferenceMutator,DECODE_TABLE,out,4,0.010743957,org.apache.commons.codec.binary.Base64.<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2077,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22123,22128,FieldReferenceMutator,length,size,1,0.012956805,org.apache.commons.codec.binary.Base64.DECODE_TABLE.<mask>,"
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2078,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22123,22128,FieldReferenceMutator,length,SIZE,3,6.2544533E-4,org.apache.commons.codec.binary.Base64.DECODE_TABLE.<mask>,"
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2079,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,555,22123,22128,FieldReferenceMutator,length,len,4,3.5875774E-4,org.apache.commons.codec.binary.Base64.DECODE_TABLE.<mask>,"
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2080,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,556,22179,22179,ArrayAccessMutator,b,sb,1,4.0137925E-4,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"    for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[<mask>];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                       "
2081,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,556,22179,22179,ArrayAccessMutator,b,bc,3,1.6075248E-4,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"    for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[<mask>];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                       "
2082,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,556,22179,22179,ArrayAccessMutator,b,bb,4,1.241853E-4,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"    for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[<mask>];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                       "
2083,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,556,22166,22177,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,out,0,0.161933,<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2084,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,556,22166,22177,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,result,1,0.16134569,<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2085,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,556,22166,22177,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,table,2,0.122663885,<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2086,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,556,22166,22177,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,decode,3,0.10492258,<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2087,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,556,22166,22177,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,in,4,0.06700945,<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2088,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,556,22166,22177,FieldReferenceMutator,DECODE_TABLE,out,0,0.161933,org.apache.commons.codec.binary.Base64.<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2089,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,556,22166,22177,FieldReferenceMutator,DECODE_TABLE,result,1,0.16134569,org.apache.commons.codec.binary.Base64.<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2090,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,556,22166,22177,FieldReferenceMutator,DECODE_TABLE,table,2,0.122663885,org.apache.commons.codec.binary.Base64.<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2091,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,556,22166,22177,FieldReferenceMutator,DECODE_TABLE,decode,3,0.10492258,org.apache.commons.codec.binary.Base64.<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2092,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,556,22166,22177,FieldReferenceMutator,DECODE_TABLE,in,4,0.06700945,org.apache.commons.codec.binary.Base64.<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2093,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,556,22179,22179,IdentifierMutator-Variable,b,sb,1,4.0137925E-4,<mask>,"    for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[<mask>];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                       "
2094,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,556,22179,22179,IdentifierMutator-Variable,b,bc,3,1.6075248E-4,<mask>,"    for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[<mask>];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                       "
2095,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,556,22179,22179,IdentifierMutator-Variable,b,bb,4,1.241853E-4,<mask>,"    for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[<mask>];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                       "
2096,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,557,22213,22216,BinaryOperatorMutator,>=,==,0,0.19789413,result <mask> 0,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result<mask>0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
 "
2097,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,557,22213,22216,BinaryOperatorMutator,>=,<,1,0.18820265,result <mask> 0,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result<mask>0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
 "
2098,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,557,22213,22216,BinaryOperatorMutator,>=,==,2,0.17100784,result <mask> 0,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result<mask>0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
 "
2099,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,557,22213,22216,BinaryOperatorMutator,>=,>,3,0.12228257,result <mask> 0,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result<mask>0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
 "
2100,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,557,22213,22216,BinaryOperatorMutator,>=,!=,4,0.083168045,result <mask> 0,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result<mask>0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
 "
2101,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,557,22207,22212,IdentifierMutator-Variable,result,b,1,0.0020867772,<mask>,"        if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (<mask> >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
"
2102,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,557,22207,22212,IdentifierMutator-Variable,result,x,3,5.300513E-4,<mask>,"        if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (<mask> >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
"
2103,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,557,22207,22212,IdentifierMutator-Variable,result,Result,4,3.0898253E-4,<mask>,"        if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (<mask> >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
"
2104,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,557,22217,22217,IdentifierMutator-Literal,0,result,1,0.047678776,<mask>,"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >=<mask>) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
  "
2105,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,557,22217,22217,IdentifierMutator-Literal,0,1,2,0.01506779,<mask>,"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >=<mask>) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
  "
2106,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,557,22217,22217,IdentifierMutator-Literal,0,4,3,0.014520599,<mask>,"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >=<mask>) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
  "
2107,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,557,22217,22217,IdentifierMutator-Literal,0,b,4,0.010874171,<mask>,"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >=<mask>) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
  "
2108,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22253,22253,AssignmentMutator,modulus=(++modulus)%4,|,0,0.65899664,modulus <mask>= (++modulus) % 4,"         resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus<mask>= (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2109,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22253,22253,AssignmentMutator,modulus=(++modulus)%4,^,1,0.14296398,modulus <mask>= (++modulus) % 4,"         resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus<mask>= (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2110,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22253,22253,AssignmentMutator,modulus=(++modulus)%4,*,2,0.12800941,modulus <mask>= (++modulus) % 4,"         resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus<mask>= (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2111,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22253,22253,AssignmentMutator,modulus=(++modulus)%4,~,3,0.016311442,modulus <mask>= (++modulus) % 4,"         resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus<mask>= (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2112,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22253,22253,AssignmentMutator,modulus=(++modulus)%4,&,4,0.015128292,modulus <mask>= (++modulus) % 4,"         resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus<mask>= (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2113,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22246,22252,IdentifierMutator-Variable,modulus,result,0,0.9300049,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2114,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22246,22252,IdentifierMutator-Variable,modulus,result,1,0.02841901,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2115,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22246,22252,IdentifierMutator-Variable,modulus,x,2,0.010010788,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2116,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22246,22252,IdentifierMutator-Variable,modulus,b,3,0.0047685863,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2117,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22246,22252,IdentifierMutator-Variable,modulus,r,4,0.002740545,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2118,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22246,22252,FieldReferenceMutator,modulus,result,0,0.9300049,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2119,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22246,22252,FieldReferenceMutator,modulus,result,1,0.02841901,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2120,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22246,22252,FieldReferenceMutator,modulus,x,2,0.010010788,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2121,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22246,22252,FieldReferenceMutator,modulus,b,3,0.0047685863,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2122,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22246,22252,FieldReferenceMutator,modulus,r,4,0.002740545,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2123,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22267,22269,BinaryOperatorMutator,%,<<,0,0.3310226,(++modulus) <mask> 4,"   resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus)<mask>4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
            "
2124,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22267,22269,BinaryOperatorMutator,%,<<,1,0.19898808,(++modulus) <mask> 4,"   resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus)<mask>4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
            "
2125,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22267,22269,BinaryOperatorMutator,%,>>>,2,0.1163094,(++modulus) <mask> 4,"   resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus)<mask>4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
            "
2126,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22267,22269,BinaryOperatorMutator,%,>>,3,0.10253956,(++modulus) <mask> 4,"   resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus)<mask>4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
            "
2127,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22267,22269,BinaryOperatorMutator,%,*,4,0.086625755,(++modulus) <mask> 4,"   resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus)<mask>4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
            "
2128,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22256,22258,UnaryOperatorMutator,++,(,0,0.89622533,<mask>modulus,"        resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus =<mask>modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
        "
2129,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22256,22258,UnaryOperatorMutator,++,((,1,0.062281184,<mask>modulus,"        resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus =<mask>modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
        "
2130,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22256,22258,UnaryOperatorMutator,++,(-,2,0.02788103,<mask>modulus,"        resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus =<mask>modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
        "
2131,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22256,22258,UnaryOperatorMutator,++,(+,3,0.0044850786,<mask>modulus,"        resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus =<mask>modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
        "
2132,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22256,22258,UnaryOperatorMutator,++,$(,4,0.003222266,<mask>modulus,"        resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus =<mask>modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
        "
2133,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22259,22265,IdentifierMutator-Variable,modulus,result,0,0.90665376,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2134,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22259,22265,IdentifierMutator-Variable,modulus,result,1,0.044579715,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2135,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22259,22265,IdentifierMutator-Variable,modulus,x,2,0.006188522,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2136,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22259,22265,IdentifierMutator-Variable,modulus,b,3,0.0058603315,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2137,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22259,22265,IdentifierMutator-Variable,modulus,Result,4,0.0017172208,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2138,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22259,22265,FieldReferenceMutator,modulus,result,0,0.90665376,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2139,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22259,22265,FieldReferenceMutator,modulus,result,1,0.044579715,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2140,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22259,22265,FieldReferenceMutator,modulus,x,2,0.006188522,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2141,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22259,22265,FieldReferenceMutator,modulus,b,3,0.0058603315,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2142,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22259,22265,FieldReferenceMutator,modulus,Result,4,0.0017172208,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2143,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22270,22270,IdentifierMutator-Literal,4,6,0,0.23011923,<mask>,"  resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) %<mask>;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
             "
2144,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22270,22270,IdentifierMutator-Literal,4,7,1,0.17289494,<mask>,"  resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) %<mask>;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
             "
2145,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22270,22270,IdentifierMutator-Literal,4,8,2,0.11898011,<mask>,"  resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) %<mask>;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
             "
2146,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22270,22270,IdentifierMutator-Literal,4,16,3,0.06912174,<mask>,"  resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) %<mask>;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
             "
2147,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,558,22270,22270,IdentifierMutator-Literal,4,2,4,0.060726397,<mask>,"  resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) %<mask>;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
             "
2148,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22298,22298,AssignmentMutator,x=(x<<6)+result,^,0,0.4999693,x <mask>= (x << 6) + result,"   byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x<mask>= (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2149,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22298,22298,AssignmentMutator,x=(x<<6)+result,|,1,0.322209,x <mask>= (x << 6) + result,"   byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x<mask>= (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2150,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22298,22298,AssignmentMutator,x=(x<<6)+result,*,2,0.08955514,x <mask>= (x << 6) + result,"   byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x<mask>= (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2151,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22298,22298,AssignmentMutator,x=(x<<6)+result,&,3,0.016634347,x <mask>= (x << 6) + result,"   byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x<mask>= (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2152,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22298,22298,AssignmentMutator,x=(x<<6)+result,>>,4,0.016120763,x <mask>= (x << 6) + result,"   byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x<mask>= (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2153,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22297,22297,IdentifierMutator-Variable,x,result,1,0.0640868,<mask>,"Buffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;<mask> = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2154,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22297,22297,IdentifierMutator-Variable,x,b,3,0.012007701,<mask>,"Buffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;<mask> = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2155,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22297,22297,IdentifierMutator-Variable,x,byte,4,0.0016528858,<mask>,"Buffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;<mask> = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2156,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22297,22297,FieldReferenceMutator,x,result,1,0.0640868,<mask>,"Buffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;<mask> = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2157,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22297,22297,FieldReferenceMutator,x,b,3,0.012007701,<mask>,"Buffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;<mask> = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2158,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22297,22297,FieldReferenceMutator,x,byte,4,0.0016528858,<mask>,"Buffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;<mask> = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2159,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22309,22311,BinaryOperatorMutator,+,|,0,0.6570313,(x << 6) <mask> result,"[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6)<mask>result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
        "
2160,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22309,22311,BinaryOperatorMutator,+,^,1,0.12923063,(x << 6) <mask> result,"[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6)<mask>result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
        "
2161,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22309,22311,BinaryOperatorMutator,+,^,3,0.025890976,(x << 6) <mask> result,"[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6)<mask>result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
        "
2162,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22309,22311,BinaryOperatorMutator,+,|,4,0.023562854,(x << 6) <mask> result,"[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6)<mask>result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
        "
2163,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22303,22306,BinaryOperatorMutator,<<,>>,2,0.084258474,x <mask> 6," b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x<mask>6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
     "
2164,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22303,22306,BinaryOperatorMutator,<<,>>>,3,0.051838107,x <mask> 6," b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x<mask>6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
     "
2165,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22303,22306,BinaryOperatorMutator,<<,*,4,0.031752646,x <mask> 6," b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x<mask>6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
     "
2166,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22302,22302,IdentifierMutator-Variable,x,result,1,0.015783014,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2167,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22302,22302,IdentifierMutator-Variable,x,1,2,0.0072304574,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2168,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22302,22302,IdentifierMutator-Variable,x,b,3,0.006456256,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2169,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22302,22302,IdentifierMutator-Variable,x,0,4,0.005090533,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2170,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22302,22302,FieldReferenceMutator,x,result,1,0.015783014,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2171,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22302,22302,FieldReferenceMutator,x,1,2,0.0072304574,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2172,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22302,22302,FieldReferenceMutator,x,b,3,0.006456256,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2173,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22302,22302,FieldReferenceMutator,x,0,4,0.005090533,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2174,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22307,22307,IdentifierMutator-Literal,6,4,0,0.44843903,<mask>," = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x <<<mask>) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
      "
2175,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22307,22307,IdentifierMutator-Literal,6,1,1,0.09024653,<mask>," = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x <<<mask>) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
      "
2176,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22307,22307,IdentifierMutator-Literal,6,3,2,0.08693968,<mask>," = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x <<<mask>) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
      "
2177,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22307,22307,IdentifierMutator-Literal,6,8,3,0.07948491,<mask>," = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x <<<mask>) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
      "
2178,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22307,22307,IdentifierMutator-Literal,6,2,4,0.069562554,<mask>," = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x <<<mask>) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
      "
2179,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22312,22317,IdentifierMutator-Variable,result,1,1,0.05820676,<mask>,"inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) +<mask>;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
         "
2180,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22312,22317,IdentifierMutator-Variable,result,b,2,0.015669588,<mask>,"inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) +<mask>;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
         "
2181,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22312,22317,IdentifierMutator-Variable,result,x,3,0.0086542955,<mask>,"inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) +<mask>;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
         "
2182,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,559,22312,22317,IdentifierMutator-Variable,result,y,4,0.004624361,<mask>,"inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) +<mask>;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
         "
2183,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,560,22355,22358,BinaryOperatorMutator,==,>,1,0.29054463,modulus <mask> 0,"           // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus<mask>0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base"
2184,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,560,22355,22358,BinaryOperatorMutator,==,>,2,0.08662433,modulus <mask> 0,"           // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus<mask>0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base"
2185,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,560,22355,22358,BinaryOperatorMutator,==,=,3,0.034526546,modulus <mask> 0,"           // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus<mask>0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base"
2186,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,560,22348,22354,IdentifierMutator-Variable,modulus,result,0,0.88740814,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2187,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,560,22348,22354,IdentifierMutator-Variable,modulus,x,1,0.05656922,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2188,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,560,22348,22354,IdentifierMutator-Variable,modulus,b,2,0.011772414,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2189,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,560,22348,22354,IdentifierMutator-Variable,modulus,i,3,0.0038203106,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2190,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,560,22348,22354,IdentifierMutator-Variable,modulus,bit,4,0.0012361062,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2191,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,560,22348,22354,FieldReferenceMutator,modulus,result,0,0.88740814,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2192,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,560,22348,22354,FieldReferenceMutator,modulus,x,1,0.05656922,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2193,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,560,22348,22354,FieldReferenceMutator,modulus,b,2,0.011772414,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2194,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,560,22348,22354,FieldReferenceMutator,modulus,i,3,0.0038203106,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2195,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,560,22348,22354,FieldReferenceMutator,modulus,bit,4,0.0012361062,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2196,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,560,22359,22359,IdentifierMutator-Literal,0,4,1,0.10988745,<mask>,"          // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus ==<mask>) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64"
2197,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,560,22359,22359,IdentifierMutator-Literal,0,1,2,0.08169701,<mask>,"          // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus ==<mask>) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64"
2198,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,560,22359,22359,IdentifierMutator-Literal,0,2,3,0.02699835,<mask>,"          // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus ==<mask>) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64"
2199,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,560,22359,22359,IdentifierMutator-Literal,0,7,4,0.024858033,<mask>,"          // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus ==<mask>) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64"
2200,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22405,22405,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),|,0,0.7883253,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
   "
2201,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22405,22405,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),^,1,0.15358827,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
   "
2202,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22405,22405,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),*,2,0.016799748,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
   "
2203,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22405,22405,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),&,3,0.011472154,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
   "
2204,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22405,22405,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),<<,4,0.0063417032,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
   "
2205,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22399,22403,ArrayAccessMutator,pos++,pos,0,0.9990188,buffer[<mask>]," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2206,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22399,22403,ArrayAccessMutator,pos++,++,1,1.1636751E-4,buffer[<mask>]," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2207,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22399,22403,ArrayAccessMutator,pos++,push,2,8.2507315E-5,buffer[<mask>]," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2208,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22399,22403,ArrayAccessMutator,pos++,offset,3,6.0640832E-5,buffer[<mask>]," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2209,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22399,22403,ArrayAccessMutator,pos++,neg,4,4.973425E-5,buffer[<mask>]," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2210,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22392,22397,IdentifierMutator-Variable,buffer,byte,2,1.990669E-4,<mask>,"       // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream."
2211,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22392,22397,IdentifierMutator-Variable,buffer,buf,3,9.610359E-5,<mask>,"       // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream."
2212,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22392,22397,IdentifierMutator-Variable,buffer,Buffer,4,8.506287E-5,<mask>,"       // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream."
2213,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22392,22397,FieldReferenceMutator,buffer,byte,2,1.990669E-4,<mask>,"       // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream."
2214,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22392,22397,FieldReferenceMutator,buffer,buf,3,9.610359E-5,<mask>,"       // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream."
2215,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22392,22397,FieldReferenceMutator,buffer,Buffer,4,8.506287E-5,<mask>,"       // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream."
2216,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22402,22403,UnaryOperatorMutator,++,+,1,1.15085466E-4,pos<mask>,";
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2217,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22402,22403,UnaryOperatorMutator,++,++;,3,3.9837236E-5,pos<mask>,";
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2218,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22402,22403,UnaryOperatorMutator,++,--,4,3.7068556E-5,pos<mask>,";
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2219,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22399,22401,IdentifierMutator-Variable,pos,size,1,2.9646139E-5,<mask>," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
 "
2220,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22399,22401,IdentifierMutator-Variable,pos,len,2,1.6531529E-5,<mask>," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
 "
2221,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22399,22401,IdentifierMutator-Variable,pos,offset,3,1.652951E-5,<mask>," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
 "
2222,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22399,22401,FieldReferenceMutator,pos,size,1,2.9646139E-5,<mask>," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
 "
2223,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22399,22401,FieldReferenceMutator,pos,len,2,1.6531529E-5,<mask>," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
 "
2224,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22399,22401,FieldReferenceMutator,pos,offset,3,1.652951E-5,<mask>," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
 "
2225,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22425,22427,BinaryOperatorMutator,&,|,1,0.0027280087,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"       break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '"
2226,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22425,22427,BinaryOperatorMutator,&,^,3,2.0136025E-4,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"       break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '"
2227,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22425,22427,BinaryOperatorMutator,&,+,4,8.5965905E-5,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"       break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '"
2228,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22418,22421,BinaryOperatorMutator,>>,<<,2,0.033759512,x <mask> 16,"          break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach"
2229,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22418,22421,BinaryOperatorMutator,>>,<<,3,0.025514338,x <mask> 16,"          break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach"
2230,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22418,22421,BinaryOperatorMutator,>>,>>>,4,0.015062867,x <mask> 16,"          break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach"
2231,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22417,22417,IdentifierMutator-Variable,x,X,2,4.5287445E-5,<mask>,"           break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This"
2232,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22417,22417,IdentifierMutator-Variable,x,xx,3,4.1739215E-5,<mask>,"           break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This"
2233,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22417,22417,IdentifierMutator-Variable,x,y,4,3.968694E-5,<mask>,"           break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This"
2234,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22417,22417,FieldReferenceMutator,x,X,2,4.5287445E-5,<mask>,"           break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This"
2235,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22417,22417,FieldReferenceMutator,x,xx,3,4.1739215E-5,<mask>,"           break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This"
2236,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22417,22417,FieldReferenceMutator,x,y,4,3.968694E-5,<mask>,"           break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This"
2237,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22422,22423,IdentifierMutator-Literal,16,8,0,0.75472903,<mask>,"         break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes"
2238,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22422,22423,IdentifierMutator-Literal,16,6,2,0.036264252,<mask>,"         break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes"
2239,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22422,22423,IdentifierMutator-Literal,16,4,3,0.03212222,<mask>,"         break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes"
2240,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22422,22423,IdentifierMutator-Literal,16,7,4,0.028541556,<mask>,"         break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes"
2241,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22428,22437,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,255,0,0.14948566,<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2242,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22428,22437,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,mask,1,0.08499066,<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2243,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22428,22437,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,7,2,0.08133535,<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2244,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22428,22437,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,1,3,0.066104494,<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2245,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22428,22437,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,bits,4,0.0607781,<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2246,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22428,22437,FieldReferenceMutator,MASK_8BITS,255,0,0.14948566,org.apache.commons.codec.binary.Base64.<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2247,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22428,22437,FieldReferenceMutator,MASK_8BITS,mask,1,0.08499066,org.apache.commons.codec.binary.Base64.<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2248,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22428,22437,FieldReferenceMutator,MASK_8BITS,7,2,0.08133535,org.apache.commons.codec.binary.Base64.<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2249,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22428,22437,FieldReferenceMutator,MASK_8BITS,1,3,0.066104494,org.apache.commons.codec.binary.Base64.<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2250,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,561,22428,22437,FieldReferenceMutator,MASK_8BITS,bits,4,0.0607781,org.apache.commons.codec.binary.Base64.<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2251,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22482,22482,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),|,0,0.8389776,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x"
2252,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22482,22482,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),^,1,0.12039612,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x"
2253,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22482,22482,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),&,2,0.012774434,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x"
2254,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22482,22482,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),*,3,0.010213691,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x"
2255,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22482,22482,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),>>>,4,0.0031001964,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x"
2256,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22476,22480,ArrayAccessMutator,pos++,pos,0,0.98214793,buffer[<mask>],"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x ="
2257,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22476,22480,ArrayAccessMutator,pos++,++,1,0.007879785,buffer[<mask>],"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x ="
2258,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22476,22480,ArrayAccessMutator,pos++,push,2,0.0012770474,buffer[<mask>],"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x ="
2259,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22476,22480,ArrayAccessMutator,pos++,neg,3,6.286654E-4,buffer[<mask>],"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x ="
2260,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22476,22480,ArrayAccessMutator,pos++,offset,4,5.8595935E-4,buffer[<mask>],"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x ="
2261,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22469,22474,IdentifierMutator-Variable,buffer,Buffer,2,8.9295744E-4,<mask>,"
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
          "
2262,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22469,22474,IdentifierMutator-Variable,buffer,byte,3,3.595063E-4,<mask>,"
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
          "
2263,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22469,22474,IdentifierMutator-Variable,buffer,Buffer,4,3.2872977E-4,<mask>,"
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
          "
2264,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22469,22474,FieldReferenceMutator,buffer,Buffer,2,8.9295744E-4,<mask>,"
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
          "
2265,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22469,22474,FieldReferenceMutator,buffer,byte,3,3.595063E-4,<mask>,"
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
          "
2266,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22469,22474,FieldReferenceMutator,buffer,Buffer,4,3.2872977E-4,<mask>,"
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
          "
2267,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22479,22480,UnaryOperatorMutator,++,--,2,1.13688664E-4,pos<mask>," if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x ="
2268,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22479,22480,UnaryOperatorMutator,++,+,3,9.612885E-5,pos<mask>," if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x ="
2269,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22479,22480,UnaryOperatorMutator,++,++;,4,5.7112193E-5,pos<mask>," if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x ="
2270,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22476,22478,IdentifierMutator-Variable,pos,size,1,6.337805E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x"
2271,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22476,22478,IdentifierMutator-Variable,pos,len,2,6.262522E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x"
2272,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22476,22478,IdentifierMutator-Variable,pos,neg,3,3.7189377E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x"
2273,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22476,22478,IdentifierMutator-Variable,pos,offset,4,2.81423E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x"
2274,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22476,22478,FieldReferenceMutator,pos,size,1,6.337805E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x"
2275,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22476,22478,FieldReferenceMutator,pos,len,2,6.262522E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x"
2276,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22476,22478,FieldReferenceMutator,pos,neg,3,3.7189377E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x"
2277,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22476,22478,FieldReferenceMutator,pos,offset,4,2.81423E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x"
2278,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22501,22503,BinaryOperatorMutator,&,|,1,0.0023307954,(x >> 8) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8)<mask>MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
      "
2279,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22501,22503,BinaryOperatorMutator,&,^,3,1.1731665E-4,(x >> 8) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8)<mask>MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
      "
2280,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22501,22503,BinaryOperatorMutator,&,~,4,3.150262E-5,(x >> 8) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8)<mask>MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
      "
2281,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22495,22498,BinaryOperatorMutator,>>,>>>,1,0.004907417,x <mask> 8," DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x<mask>8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
   "
2282,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22495,22498,BinaryOperatorMutator,>>,<<,2,0.0030416495,x <mask> 8," DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x<mask>8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
   "
2283,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22495,22498,BinaryOperatorMutator,>>,<<,4,2.6276414E-4,x <mask> 8," DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x<mask>8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
   "
2284,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22494,22494,IdentifierMutator-Variable,x,y,1,3.100178E-5,<mask>," < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
  "
2285,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22494,22494,IdentifierMutator-Variable,x,X,3,9.633936E-6,<mask>," < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
  "
2286,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22494,22494,IdentifierMutator-Variable,x,xx,4,9.050591E-6,<mask>," < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
  "
2287,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22494,22494,FieldReferenceMutator,x,y,1,3.100178E-5,<mask>," < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
  "
2288,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22494,22494,FieldReferenceMutator,x,X,3,9.633936E-6,<mask>," < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
  "
2289,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22494,22494,FieldReferenceMutator,x,xx,4,9.050591E-6,<mask>," < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
  "
2290,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22499,22499,IdentifierMutator-Literal,8,16,1,0.060984537,<mask>,"ODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
    "
2291,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22499,22499,IdentifierMutator-Literal,8,6,2,0.059271604,<mask>,"ODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
    "
2292,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22499,22499,IdentifierMutator-Literal,8,12,3,0.02665442,<mask>,"ODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
    "
2293,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22499,22499,IdentifierMutator-Literal,8,24,4,0.022162337,<mask>,"ODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
    "
2294,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22504,22513,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,mask,0,0.2646979,<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch"
2295,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22504,22513,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,255,1,0.09865997,<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch"
2296,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22504,22513,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,7,2,0.09700977,<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch"
2297,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22504,22513,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,bits,3,0.07334332,<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch"
2298,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22504,22513,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,1,4,0.07235031,<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch"
2299,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22504,22513,FieldReferenceMutator,MASK_8BITS,mask,0,0.2646979,org.apache.commons.codec.binary.Base64.<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch"
2300,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22504,22513,FieldReferenceMutator,MASK_8BITS,255,1,0.09865997,org.apache.commons.codec.binary.Base64.<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch"
2301,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22504,22513,FieldReferenceMutator,MASK_8BITS,7,2,0.09700977,org.apache.commons.codec.binary.Base64.<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch"
2302,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22504,22513,FieldReferenceMutator,MASK_8BITS,bits,3,0.07334332,org.apache.commons.codec.binary.Base64.<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch"
2303,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,562,22504,22513,FieldReferenceMutator,MASK_8BITS,1,4,0.07235031,org.apache.commons.codec.binary.Base64.<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch"
2304,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22558,22558,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),|,0,0.75556177,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"               if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
         "
2305,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22558,22558,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),^,1,0.21661416,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"               if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
         "
2306,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22558,22558,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),&,2,0.009636219,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"               if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
         "
2307,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22558,22558,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),*,3,0.0068808,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"               if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
         "
2308,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22558,22558,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),<<,4,0.0022781645,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"               if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
         "
2309,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22552,22556,ArrayAccessMutator,pos++,pos,0,0.9795802,buffer[<mask>],"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
        "
2310,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22552,22556,ArrayAccessMutator,pos++,++,1,0.007851064,buffer[<mask>],"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
        "
2311,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22552,22556,ArrayAccessMutator,pos++,len,2,9.968332E-4,buffer[<mask>],"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
        "
2312,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22552,22556,ArrayAccessMutator,pos++,neg,3,9.062024E-4,buffer[<mask>],"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
        "
2313,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22552,22556,ArrayAccessMutator,pos++,push,4,6.109888E-4,buffer[<mask>],"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
        "
2314,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22545,22550,IdentifierMutator-Variable,buffer,Buffer,2,5.232729E-4,<mask>,"                  int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
     "
2315,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22545,22550,IdentifierMutator-Variable,buffer,byte,3,4.8989954E-4,<mask>,"                  int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
     "
2316,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22545,22550,IdentifierMutator-Variable,buffer,buf,4,2.9256E-4,<mask>,"                  int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
     "
2317,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22545,22550,FieldReferenceMutator,buffer,Buffer,2,5.232729E-4,<mask>,"                  int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
     "
2318,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22545,22550,FieldReferenceMutator,buffer,byte,3,4.8989954E-4,<mask>,"                  int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
     "
2319,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22545,22550,FieldReferenceMutator,buffer,buf,4,2.9256E-4,<mask>,"                  int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
     "
2320,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22555,22556,UnaryOperatorMutator,++,--,2,9.434044E-5,pos<mask>,"                 if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
        "
2321,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22555,22556,UnaryOperatorMutator,++,++;,3,8.6512395E-5,pos<mask>,"                 if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
        "
2322,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22555,22556,UnaryOperatorMutator,++,+,4,6.915112E-5,pos<mask>,"                 if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
        "
2323,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22552,22554,IdentifierMutator-Variable,pos,len,1,2.3194835E-4,<mask>,"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
       "
2324,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22552,22554,IdentifierMutator-Variable,pos,neg,2,1.137785E-4,<mask>,"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
       "
2325,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22552,22554,IdentifierMutator-Variable,pos,size,3,1.0372106E-4,<mask>,"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
       "
2326,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22552,22554,FieldReferenceMutator,pos,len,1,2.3194835E-4,<mask>,"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
       "
2327,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22552,22554,FieldReferenceMutator,pos,neg,2,1.137785E-4,<mask>,"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
       "
2328,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22552,22554,FieldReferenceMutator,pos,size,3,1.0372106E-4,<mask>,"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
       "
2329,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22570,22572,BinaryOperatorMutator,&,<<,2,0.019685136,x <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"         if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x<mask>MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                "
2330,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22570,22572,BinaryOperatorMutator,&,|,3,0.016432012,x <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"         if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x<mask>MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                "
2331,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22570,22572,BinaryOperatorMutator,&,>>>,4,0.010052391,x <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"         if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x<mask>MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                "
2332,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22569,22569,IdentifierMutator-Variable,x,result,1,8.98134E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
               "
2333,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22569,22569,IdentifierMutator-Variable,x,y,2,5.4889685E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
               "
2334,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22569,22569,IdentifierMutator-Variable,x,xx,3,5.072633E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
               "
2335,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22569,22569,IdentifierMutator-Variable,x,rx,4,2.5918902E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
               "
2336,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22569,22569,FieldReferenceMutator,x,result,1,8.98134E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
               "
2337,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22569,22569,FieldReferenceMutator,x,y,2,5.4889685E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
               "
2338,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22569,22569,FieldReferenceMutator,x,xx,3,5.072633E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
               "
2339,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22569,22569,FieldReferenceMutator,x,rx,4,2.5918902E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
               "
2340,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22573,22582,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,7,0,0.23336297,<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x"
2341,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22573,22582,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,255,1,0.1271447,<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x"
2342,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22573,22582,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,1,2,0.1231531,<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x"
2343,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22573,22582,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,63,3,0.11567761,<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x"
2344,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22573,22582,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,3,4,0.086207554,<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x"
2345,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22573,22582,FieldReferenceMutator,MASK_8BITS,7,0,0.23336297,org.apache.commons.codec.binary.Base64.<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x"
2346,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22573,22582,FieldReferenceMutator,MASK_8BITS,255,1,0.1271447,org.apache.commons.codec.binary.Base64.<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x"
2347,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22573,22582,FieldReferenceMutator,MASK_8BITS,1,2,0.1231531,org.apache.commons.codec.binary.Base64.<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x"
2348,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22573,22582,FieldReferenceMutator,MASK_8BITS,63,3,0.11567761,org.apache.commons.codec.binary.Base64.<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x"
2349,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,563,22573,22582,FieldReferenceMutator,MASK_8BITS,3,4,0.086207554,org.apache.commons.codec.binary.Base64.<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x"
2350,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22920,22923,BinaryOperatorMutator,&&,_,0,0.29004794,eof <mask> (modulus != 0),"                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof<mask>modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS"
2351,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22920,22923,BinaryOperatorMutator,&&,|,2,0.08610199,eof <mask> (modulus != 0),"                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof<mask>modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS"
2352,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22920,22923,BinaryOperatorMutator,&&,+,3,0.08556239,eof <mask> (modulus != 0),"                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof<mask>modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS"
2353,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22920,22923,BinaryOperatorMutator,&&,/,4,0.08469405,eof <mask> (modulus != 0),"                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof<mask>modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS"
2354,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22917,22919,IdentifierMutator-Variable,eof,x,0,0.55860037,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2355,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22917,22919,IdentifierMutator-Variable,eof,bit,1,0.040398978,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2356,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22917,22919,IdentifierMutator-Variable,eof,binary,2,0.030616406,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2357,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22917,22919,IdentifierMutator-Variable,eof,true,3,0.016663434,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2358,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22917,22919,IdentifierMutator-Variable,eof,3,4,0.012141037,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2359,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22917,22919,FieldReferenceMutator,eof,x,0,0.55860037,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2360,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22917,22919,FieldReferenceMutator,eof,bit,1,0.040398978,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2361,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22917,22919,FieldReferenceMutator,eof,binary,2,0.030616406,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2362,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22917,22919,FieldReferenceMutator,eof,true,3,0.016663434,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2363,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22917,22919,FieldReferenceMutator,eof,3,4,0.012141037,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BIT"
2364,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22931,22934,BinaryOperatorMutator,!=,==,0,0.83771455,modulus <mask> 0,"                 buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus<mask>0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
 "
2365,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22931,22934,BinaryOperatorMutator,!=,>,1,0.05269187,modulus <mask> 0,"                 buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus<mask>0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
 "
2366,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22931,22934,BinaryOperatorMutator,!=,==,2,0.030930256,modulus <mask> 0,"                 buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus<mask>0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
 "
2367,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22931,22934,BinaryOperatorMutator,!=,>,3,0.028180856,modulus <mask> 0,"                 buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus<mask>0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
 "
2368,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22931,22934,BinaryOperatorMutator,!=,=,4,0.011776603,modulus <mask> 0,"                 buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus<mask>0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
 "
2369,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22924,22930,IdentifierMutator-Variable,modulus,x,0,0.9634035,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
"
2370,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22924,22930,IdentifierMutator-Variable,modulus,i,1,0.003158229,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
"
2371,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22924,22930,IdentifierMutator-Variable,modulus,pos,2,0.0022522036,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
"
2372,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22924,22930,IdentifierMutator-Variable,modulus,y,3,0.0017538172,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
"
2373,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22924,22930,IdentifierMutator-Variable,modulus,n,4,0.0016142967,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
"
2374,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22924,22930,FieldReferenceMutator,modulus,x,0,0.9634035,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
"
2375,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22924,22930,FieldReferenceMutator,modulus,i,1,0.003158229,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
"
2376,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22924,22930,FieldReferenceMutator,modulus,pos,2,0.0022522036,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
"
2377,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22924,22930,FieldReferenceMutator,modulus,y,3,0.0017538172,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
"
2378,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22924,22930,FieldReferenceMutator,modulus,n,4,0.0016142967,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
"
2379,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22935,22935,IdentifierMutator-Literal,0,2,1,0.26027256,<mask>,"                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus !=<mask>) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
  "
2380,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22935,22935,IdentifierMutator-Literal,0,1,2,0.17358439,<mask>,"                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus !=<mask>) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
  "
2381,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22935,22935,IdentifierMutator-Literal,0,3,3,0.11452348,<mask>,"                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus !=<mask>) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
  "
2382,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,573,22935,22935,IdentifierMutator-Literal,0,4,4,0.014491897,<mask>,"                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus !=<mask>) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
  "
2383,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22953,22953,AssignmentMutator,x=x<<6,|,0,0.5645065,x <mask>= x << 6,"[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x<mask>= x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2384,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22953,22953,AssignmentMutator,x=x<<6,^,1,0.3601929,x <mask>= x << 6,"[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x<mask>= x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2385,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22953,22953,AssignmentMutator,x=x<<6,*,2,0.035465036,x <mask>= x << 6,"[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x<mask>= x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2386,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22953,22953,AssignmentMutator,x=x<<6,>>,3,0.0074864733,x <mask>= x << 6,"[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x<mask>= x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2387,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22953,22953,AssignmentMutator,x=x<<6,&,4,0.004370354,x <mask>= x << 6,"[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x<mask>= x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2388,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22952,22952,IdentifierMutator-Variable,x,y,2,2.4330778E-4,<mask>,"             buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {<mask> = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2389,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22952,22952,IdentifierMutator-Variable,x,X,3,1.0927204E-4,<mask>,"             buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {<mask> = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2390,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22952,22952,IdentifierMutator-Variable,x,xx,4,8.6331645E-5,<mask>,"             buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {<mask> = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2391,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22952,22952,FieldReferenceMutator,x,y,2,2.4330778E-4,<mask>,"             buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {<mask> = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2392,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22952,22952,FieldReferenceMutator,x,X,3,1.0927204E-4,<mask>,"             buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {<mask> = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2393,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22952,22952,FieldReferenceMutator,x,xx,4,8.6331645E-5,<mask>,"             buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {<mask> = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2394,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22957,22960,BinaryOperatorMutator,<<,>>,2,0.07927711,x <mask> 6,"++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x<mask>6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break"
2395,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22957,22960,BinaryOperatorMutator,<<,>>>,3,0.048433498,x <mask> 6,"++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x<mask>6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break"
2396,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22957,22960,BinaryOperatorMutator,<<,>>,4,0.017768683,x <mask> 6,"++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x<mask>6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break"
2397,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22956,22956,IdentifierMutator-Variable,x,0,2,6.16476E-4,<mask>,"pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x =<mask> << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                   "
2398,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22956,22956,IdentifierMutator-Variable,x,y,3,2.4401673E-4,<mask>,"pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x =<mask> << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                   "
2399,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22956,22956,IdentifierMutator-Variable,x,1,4,1.1984133E-4,<mask>,"pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x =<mask> << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                   "
2400,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22956,22956,FieldReferenceMutator,x,0,2,6.16476E-4,<mask>,"pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x =<mask> << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                   "
2401,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22956,22956,FieldReferenceMutator,x,y,3,2.4401673E-4,<mask>,"pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x =<mask> << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                   "
2402,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22956,22956,FieldReferenceMutator,x,1,4,1.1984133E-4,<mask>,"pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x =<mask> << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                   "
2403,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22961,22961,IdentifierMutator-Literal,6,4,1,0.16554849,<mask>,"] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x <<<mask>;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;"
2404,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22961,22961,IdentifierMutator-Literal,6,2,2,0.11824472,<mask>,"] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x <<<mask>;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;"
2405,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22961,22961,IdentifierMutator-Literal,6,3,3,0.10561388,<mask>,"] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x <<<mask>;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;"
2406,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,574,22961,22961,IdentifierMutator-Literal,6,8,4,0.100312985,<mask>,"] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x <<<mask>;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;"
2407,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,575,22984,22990,IdentifierMutator-Variable,modulus,type,0,0.17410117,<mask>,"S);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2408,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,575,22984,22990,IdentifierMutator-Variable,modulus,mode,1,0.11525463,<mask>,"S);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2409,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,575,22984,22990,IdentifierMutator-Variable,modulus,version,2,0.04452824,<mask>,"S);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2410,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,575,22984,22990,IdentifierMutator-Variable,modulus,bit,3,0.04023259,<mask>,"S);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2411,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,575,22984,22990,IdentifierMutator-Variable,modulus,i,4,0.024481576,<mask>,"S);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2412,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,575,22984,22990,FieldReferenceMutator,modulus,type,0,0.17410117,<mask>,"S);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2413,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,575,22984,22990,FieldReferenceMutator,modulus,mode,1,0.11525463,<mask>,"S);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2414,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,575,22984,22990,FieldReferenceMutator,modulus,version,2,0.04452824,<mask>,"S);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2415,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,575,22984,22990,FieldReferenceMutator,modulus,bit,3,0.04023259,<mask>,"S);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2416,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,575,22984,22990,FieldReferenceMutator,modulus,i,4,0.024481576,<mask>,"S);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2417,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,576,23016,23016,IdentifierMutator-Literal,2,1,1,0.32934883,<mask>,"          buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case<mask> :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2418,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,576,23016,23016,IdentifierMutator-Literal,2,0,2,0.050497744,<mask>,"          buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case<mask> :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2419,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,576,23016,23016,IdentifierMutator-Literal,2,3,3,0.013033466,<mask>,"          buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case<mask> :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2420,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,576,23016,23016,IdentifierMutator-Literal,2,4,4,0.011100025,<mask>,"          buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case<mask> :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2421,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23041,23041,AssignmentMutator,x=x<<6,|,0,0.47029898,x <mask>= x << 6,"_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x<mask>= x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2422,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23041,23041,AssignmentMutator,x=x<<6,^,1,0.4592468,x <mask>= x << 6,"_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x<mask>= x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2423,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23041,23041,AssignmentMutator,x=x<<6,*,2,0.032663744,x <mask>= x << 6,"_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x<mask>= x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2424,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23041,23041,AssignmentMutator,x=x<<6,&,3,0.0055736154,x <mask>= x << 6,"_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x<mask>= x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2425,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23041,23041,AssignmentMutator,x=x<<6,>>,4,0.0043039466,x <mask>= x << 6,"_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x<mask>= x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2426,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23040,23040,IdentifierMutator-Variable,x,y,2,9.1374206E-4,<mask>,"        buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :<mask> = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2427,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23040,23040,IdentifierMutator-Variable,x,xx,3,6.973234E-4,<mask>,"        buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :<mask> = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2428,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23040,23040,IdentifierMutator-Variable,x,X,4,2.468298E-4,<mask>,"        buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :<mask> = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2429,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23040,23040,FieldReferenceMutator,x,y,2,9.1374206E-4,<mask>,"        buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :<mask> = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2430,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23040,23040,FieldReferenceMutator,x,xx,3,6.973234E-4,<mask>,"        buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :<mask> = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2431,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23040,23040,FieldReferenceMutator,x,X,4,2.468298E-4,<mask>,"        buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :<mask> = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2432,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23045,23048,BinaryOperatorMutator,<<,>>,2,0.123944506,x <mask> 6,"BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x<mask>6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2433,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23045,23048,BinaryOperatorMutator,<<,>>,3,0.076361746,x <mask> 6,"BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x<mask>6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2434,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23045,23048,BinaryOperatorMutator,<<,>>>,4,0.06876927,x <mask> 6,"BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x<mask>6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2435,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23044,23044,IdentifierMutator-Variable,x,y,1,3.0577008E-4,<mask>,"8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x =<mask> << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2436,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23044,23044,IdentifierMutator-Variable,x,0,2,2.972445E-4,<mask>,"8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x =<mask> << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2437,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23044,23044,IdentifierMutator-Variable,x,1,4,1.9687138E-4,<mask>,"8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x =<mask> << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2438,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23044,23044,FieldReferenceMutator,x,y,1,3.0577008E-4,<mask>,"8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x =<mask> << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2439,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23044,23044,FieldReferenceMutator,x,0,2,2.972445E-4,<mask>,"8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x =<mask> << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2440,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23044,23044,FieldReferenceMutator,x,1,4,1.9687138E-4,<mask>,"8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x =<mask> << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2441,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23049,23049,IdentifierMutator-Literal,6,8,1,0.1765445,<mask>,"S);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x <<<mask>;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2442,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23049,23049,IdentifierMutator-Literal,6,7,2,0.08843348,<mask>,"S);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x <<<mask>;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2443,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23049,23049,IdentifierMutator-Literal,6,4,3,0.065152556,<mask>,"S);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x <<<mask>;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2444,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,577,23049,23049,IdentifierMutator-Literal,6,16,4,0.061840817,<mask>,"S);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x <<<mask>;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2445,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23085,23085,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),|,0,0.75876904,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2446,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23085,23085,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),^,1,0.20492694,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2447,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23085,23085,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),&,2,0.012497239,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2448,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23085,23085,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),*,3,0.008705944,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2449,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23085,23085,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),~,4,0.0021807721,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2450,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23079,23083,ArrayAccessMutator,pos++,pos,0,0.99469215,buffer[<mask>],"   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2451,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23079,23083,ArrayAccessMutator,pos++,++,1,0.0010640397,buffer[<mask>],"   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2452,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23079,23083,ArrayAccessMutator,pos++,push,2,3.9140772E-4,buffer[<mask>],"   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2453,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23079,23083,ArrayAccessMutator,pos++,0,3,3.360055E-4,buffer[<mask>],"   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2454,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23079,23083,ArrayAccessMutator,pos++,position,4,2.718944E-4,buffer[<mask>],"   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2455,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23072,23077,IdentifierMutator-Variable,buffer,buf,2,1.5229556E-4,<mask>,"
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2456,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23072,23077,IdentifierMutator-Variable,buffer,byte,3,9.379678E-5,<mask>,"
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2457,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23072,23077,IdentifierMutator-Variable,buffer,stream,4,7.267891E-5,<mask>,"
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2458,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23072,23077,FieldReferenceMutator,buffer,buf,2,1.5229556E-4,<mask>,"
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2459,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23072,23077,FieldReferenceMutator,buffer,byte,3,9.379678E-5,<mask>,"
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2460,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23072,23077,FieldReferenceMutator,buffer,stream,4,7.267891E-5,<mask>,"
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2461,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23082,23083,UnaryOperatorMutator,++,+,2,8.881559E-5,pos<mask>,"  }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2462,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23082,23083,UnaryOperatorMutator,++,++;,3,5.8551E-5,pos<mask>,"  }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2463,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23082,23083,UnaryOperatorMutator,++,--,4,3.6678244E-5,pos<mask>,"  }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2464,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23079,23081,IdentifierMutator-Variable,pos,size,1,5.4471384E-5,<mask>,"   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2465,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23079,23081,IdentifierMutator-Variable,pos,len,2,3.5583937E-5,<mask>,"   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2466,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23079,23081,IdentifierMutator-Variable,pos,offset,3,2.8320248E-5,<mask>,"   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2467,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23079,23081,IdentifierMutator-Variable,pos,position,4,2.2566255E-5,<mask>,"   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2468,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23079,23081,FieldReferenceMutator,pos,size,1,5.4471384E-5,<mask>,"   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2469,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23079,23081,FieldReferenceMutator,pos,len,2,3.5583937E-5,<mask>,"   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2470,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23079,23081,FieldReferenceMutator,pos,offset,3,2.8320248E-5,<mask>,"   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2471,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23079,23081,FieldReferenceMutator,pos,position,4,2.2566255E-5,<mask>,"   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2472,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23105,23107,BinaryOperatorMutator,&,|,2,9.360647E-4,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"            }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2473,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23105,23107,BinaryOperatorMutator,&,^,3,1.2134036E-4,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"            }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2474,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23105,23107,BinaryOperatorMutator,&,~,4,4.1347965E-5,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"            }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2475,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23098,23101,BinaryOperatorMutator,>>,<<,1,0.16968854,x <mask> 16,"               }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2476,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23098,23101,BinaryOperatorMutator,>>,<<,3,0.03028898,x <mask> 16,"               }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2477,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23098,23101,BinaryOperatorMutator,>>,>>>,4,0.010512007,x <mask> 16,"               }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2478,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23097,23097,IdentifierMutator-Variable,x,X,2,9.962524E-6,<mask>,"                }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2479,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23097,23097,IdentifierMutator-Variable,x,xx,3,7.340596E-6,<mask>,"                }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2480,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23097,23097,IdentifierMutator-Variable,x,y,4,5.042525E-6,<mask>,"                }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2481,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23097,23097,FieldReferenceMutator,x,X,2,9.962524E-6,<mask>,"                }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2482,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23097,23097,FieldReferenceMutator,x,xx,3,7.340596E-6,<mask>,"                }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2483,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23097,23097,FieldReferenceMutator,x,y,4,5.042525E-6,<mask>,"                }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2484,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23102,23103,IdentifierMutator-Literal,16,24,1,0.2757707,<mask>,"              }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2485,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23102,23103,IdentifierMutator-Literal,16,8,2,0.14248872,<mask>,"              }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2486,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23102,23103,IdentifierMutator-Literal,16,4,3,0.056275222,<mask>,"              }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2487,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23102,23103,IdentifierMutator-Literal,16,6,4,0.03040149,<mask>,"              }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2488,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23108,23117,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,mask,0,0.30069628,<mask>,"           }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2489,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23108,23117,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,255,1,0.12108801,<mask>,"           }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2490,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23108,23117,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,7,2,0.09479016,<mask>,"           }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2491,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23108,23117,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,1,3,0.07062462,<mask>,"           }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2492,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23108,23117,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,bits,4,0.04270621,<mask>,"           }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2493,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23108,23117,FieldReferenceMutator,MASK_8BITS,mask,0,0.30069628,org.apache.commons.codec.binary.Base64.<mask>,"           }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2494,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23108,23117,FieldReferenceMutator,MASK_8BITS,255,1,0.12108801,org.apache.commons.codec.binary.Base64.<mask>,"           }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2495,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23108,23117,FieldReferenceMutator,MASK_8BITS,7,2,0.09479016,org.apache.commons.codec.binary.Base64.<mask>,"           }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2496,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23108,23117,FieldReferenceMutator,MASK_8BITS,1,3,0.07062462,org.apache.commons.codec.binary.Base64.<mask>,"           }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2497,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,578,23108,23117,FieldReferenceMutator,MASK_8BITS,bits,4,0.04270621,org.apache.commons.codec.binary.Base64.<mask>,"           }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2498,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,580,23169,23169,IdentifierMutator-Literal,3,1,1,0.11614961,<mask>,"    }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case<mask> :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2499,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,580,23169,23169,IdentifierMutator-Literal,3,4,2,0.07917483,<mask>,"    }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case<mask> :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2500,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,580,23169,23169,IdentifierMutator-Literal,3,5,3,0.021335747,<mask>,"    }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case<mask> :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2501,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,580,23169,23169,IdentifierMutator-Literal,3,6,4,0.016938401,<mask>,"    }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case<mask> :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2502,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23206,23206,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),|,0,0.8096894,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),": actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2503,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23206,23206,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),^,1,0.10580981,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),": actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2504,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23206,23206,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),*,2,0.028292675,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),": actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2505,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23206,23206,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),<<,3,0.013489206,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),": actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2506,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23206,23206,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),&,4,0.0107366,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),": actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2507,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23200,23204,ArrayAccessMutator,pos++,pos,0,0.99544936,buffer[<mask>],"oder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2508,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23200,23204,ArrayAccessMutator,pos++,++,1,6.301509E-4,buffer[<mask>],"oder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2509,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23200,23204,ArrayAccessMutator,pos++,push,2,4.7685739E-4,buffer[<mask>],"oder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2510,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23200,23204,ArrayAccessMutator,pos++,position,3,3.8178105E-4,buffer[<mask>],"oder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2511,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23200,23204,ArrayAccessMutator,pos++,offset,4,1.4214944E-4,buffer[<mask>],"oder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2512,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23193,23198,IdentifierMutator-Variable,buffer,byte,2,0.0012330441,<mask>,"  }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2513,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23193,23198,IdentifierMutator-Variable,buffer,Buffer,3,6.4508594E-4,<mask>,"  }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2514,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23193,23198,IdentifierMutator-Variable,buffer,Buffer,4,5.789781E-4,<mask>,"  }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2515,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23193,23198,FieldReferenceMutator,buffer,byte,2,0.0012330441,<mask>,"  }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2516,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23193,23198,FieldReferenceMutator,buffer,Buffer,3,6.4508594E-4,<mask>,"  }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2517,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23193,23198,FieldReferenceMutator,buffer,Buffer,4,5.789781E-4,<mask>,"  }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2518,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23203,23204,UnaryOperatorMutator,++,+,1,2.1939285E-4,pos<mask>," is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2519,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23203,23204,UnaryOperatorMutator,++,--,2,2.0854507E-4,pos<mask>," is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2520,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23203,23204,UnaryOperatorMutator,++,++;,4,7.245476E-5,pos<mask>," is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2521,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23200,23202,IdentifierMutator-Variable,pos,size,1,4.3829088E-5,<mask>,"oder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2522,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23200,23202,IdentifierMutator-Variable,pos,position,2,3.4115903E-5,<mask>,"oder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2523,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23200,23202,IdentifierMutator-Variable,pos,len,3,2.9197136E-5,<mask>,"oder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2524,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23200,23202,IdentifierMutator-Variable,pos,offset,4,1.869162E-5,<mask>,"oder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2525,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23200,23202,FieldReferenceMutator,pos,size,1,4.3829088E-5,<mask>,"oder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2526,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23200,23202,FieldReferenceMutator,pos,position,2,3.4115903E-5,<mask>,"oder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2527,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23200,23202,FieldReferenceMutator,pos,len,3,2.9197136E-5,<mask>,"oder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2528,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23200,23202,FieldReferenceMutator,pos,offset,4,1.869162E-5,<mask>,"oder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2529,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23226,23228,BinaryOperatorMutator,&,|,1,0.006273231,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"  // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2530,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23226,23228,BinaryOperatorMutator,&,^,3,6.434106E-4,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"  // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2531,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23226,23228,BinaryOperatorMutator,&,~,4,2.3897387E-4,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"  // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2532,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23219,23222,BinaryOperatorMutator,>>,<<,2,0.014570521,x <mask> 16,"     // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2533,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23219,23222,BinaryOperatorMutator,>>,<<,3,0.003958645,x <mask> 16,"     // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2534,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23219,23222,BinaryOperatorMutator,>>,>>>,4,0.0021630768,x <mask> 16,"     // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2535,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23218,23218,IdentifierMutator-Variable,x,y,2,5.664546E-6,<mask>,"      // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2536,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23218,23218,IdentifierMutator-Variable,x,X,3,5.5576434E-6,<mask>,"      // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2537,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23218,23218,IdentifierMutator-Variable,x,rx,4,2.421374E-6,<mask>,"      // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2538,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23218,23218,FieldReferenceMutator,x,y,2,5.664546E-6,<mask>,"      // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2539,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23218,23218,FieldReferenceMutator,x,X,3,5.5576434E-6,<mask>,"      // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2540,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23218,23218,FieldReferenceMutator,x,rx,4,2.421374E-6,<mask>,"      // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2541,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23223,23224,IdentifierMutator-Literal,16,24,1,0.016591713,<mask>,"    // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2542,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23223,23224,IdentifierMutator-Literal,16,8,2,0.004353169,<mask>,"    // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2543,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23223,23224,IdentifierMutator-Literal,16,6,3,0.003836459,<mask>,"    // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2544,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23223,23224,IdentifierMutator-Literal,16,4,4,0.003566328,<mask>,"    // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2545,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23229,23238,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,bits,0,0.096656024,<mask>," // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2546,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23229,23238,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,16,1,0.095051125,<mask>," // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2547,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23229,23238,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,mask,2,0.08268634,<mask>," // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2548,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23229,23238,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,7,3,0.06074877,<mask>," // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2549,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23229,23238,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,CRC,4,0.04746552,<mask>," // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2550,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23229,23238,FieldReferenceMutator,MASK_8BITS,bits,0,0.096656024,org.apache.commons.codec.binary.Base64.<mask>," // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2551,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23229,23238,FieldReferenceMutator,MASK_8BITS,16,1,0.095051125,org.apache.commons.codec.binary.Base64.<mask>," // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2552,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23229,23238,FieldReferenceMutator,MASK_8BITS,mask,2,0.08268634,org.apache.commons.codec.binary.Base64.<mask>," // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2553,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23229,23238,FieldReferenceMutator,MASK_8BITS,7,3,0.06074877,org.apache.commons.codec.binary.Base64.<mask>," // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2554,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,581,23229,23238,FieldReferenceMutator,MASK_8BITS,CRC,4,0.04746552,org.apache.commons.codec.binary.Base64.<mask>," // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2555,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23275,23275,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),|,0,0.7879205,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS))," padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2556,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23275,23275,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),^,1,0.17711945,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS))," padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2557,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23275,23275,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),&,2,0.008558956,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS))," padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2558,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23275,23275,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),*,3,0.008353308,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS))," padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2559,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23275,23275,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),<<,4,0.0045696986,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS))," padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2560,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23269,23273,ArrayAccessMutator,pos++,pos,0,0.9858688,buffer[<mask>]," the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2561,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23269,23273,ArrayAccessMutator,pos++,++,1,0.0024318073,buffer[<mask>]," the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2562,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23269,23273,ArrayAccessMutator,pos++,len,2,0.0012061578,buffer[<mask>]," the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2563,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23269,23273,ArrayAccessMutator,pos++,neg,3,0.0010468813,buffer[<mask>]," the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2564,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23269,23273,ArrayAccessMutator,pos++,size,4,5.982365E-4,buffer[<mask>]," the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2565,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23262,23267,IdentifierMutator-Variable,buffer,stream,2,8.592429E-4,<mask>," first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2566,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23262,23267,IdentifierMutator-Variable,buffer,byte,3,7.738842E-4,<mask>," first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2567,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23262,23267,IdentifierMutator-Variable,buffer,buf,4,7.1398943E-4,<mask>," first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2568,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23262,23267,FieldReferenceMutator,buffer,stream,2,8.592429E-4,<mask>," first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2569,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23262,23267,FieldReferenceMutator,buffer,byte,3,7.738842E-4,<mask>," first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2570,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23262,23267,FieldReferenceMutator,buffer,buf,4,7.1398943E-4,<mask>," first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2571,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23272,23273,UnaryOperatorMutator,++,--,2,1.8688876E-4,pos<mask>," '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2572,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23272,23273,UnaryOperatorMutator,++,++;,3,1.0811198E-4,pos<mask>," '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2573,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23272,23273,UnaryOperatorMutator,++,+,4,6.486276E-5,pos<mask>," '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2574,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23269,23271,IdentifierMutator-Variable,pos,len,1,3.3545794E-4,<mask>," the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2575,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23269,23271,IdentifierMutator-Variable,pos,neg,2,2.0266147E-4,<mask>," the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2576,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23269,23271,IdentifierMutator-Variable,pos,size,3,1.6514047E-4,<mask>," the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2577,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23269,23271,IdentifierMutator-Variable,pos,end,4,7.234426E-5,<mask>," the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2578,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23269,23271,FieldReferenceMutator,pos,len,1,3.3545794E-4,<mask>," the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2579,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23269,23271,FieldReferenceMutator,pos,neg,2,2.0266147E-4,<mask>," the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2580,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23269,23271,FieldReferenceMutator,pos,size,3,1.6514047E-4,<mask>," the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2581,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23269,23271,FieldReferenceMutator,pos,end,4,7.234426E-5,<mask>," the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2582,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23294,23296,BinaryOperatorMutator,&,|,1,0.0037078243,(x >> 8) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"     if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8)<mask>MASK_8BITS);
                    break;
            }
        }
   "
2583,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23294,23296,BinaryOperatorMutator,&,^,3,3.2291198E-4,(x >> 8) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"     if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8)<mask>MASK_8BITS);
                    break;
            }
        }
   "
2584,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23294,23296,BinaryOperatorMutator,&,~,4,7.0723334E-5,(x >> 8) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"     if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8)<mask>MASK_8BITS);
                    break;
            }
        }
   "
2585,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23288,23291,BinaryOperatorMutator,>>,<<,2,0.032240853,x <mask> 8,"        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x<mask>8) & MASK_8BITS);
                    break;
            }
        }
   "
2586,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23288,23291,BinaryOperatorMutator,>>,<<,3,0.022156933,x <mask> 8,"        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x<mask>8) & MASK_8BITS);
                    break;
            }
        }
   "
2587,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23288,23291,BinaryOperatorMutator,>>,>>>,4,0.016682716,x <mask> 8,"        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x<mask>8) & MASK_8BITS);
                    break;
            }
        }
   "
2588,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23287,23287,IdentifierMutator-Variable,x,y,2,2.5954327E-5,<mask>,"
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2589,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23287,23287,IdentifierMutator-Variable,x,xx,3,1.717231E-5,<mask>,"
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2590,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23287,23287,IdentifierMutator-Variable,x,rx,4,1.0573521E-5,<mask>,"
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2591,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23287,23287,FieldReferenceMutator,x,y,2,2.5954327E-5,<mask>,"
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2592,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23287,23287,FieldReferenceMutator,x,xx,3,1.717231E-5,<mask>,"
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2593,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23287,23287,FieldReferenceMutator,x,rx,4,1.0573521E-5,<mask>,"
        if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2594,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23292,23292,IdentifierMutator-Literal,8,16,1,0.34515354,<mask>,"       if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    break;
            }
        }
   "
2595,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23292,23292,IdentifierMutator-Literal,8,6,2,0.06343948,<mask>,"       if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    break;
            }
        }
   "
2596,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23292,23292,IdentifierMutator-Literal,8,24,3,0.02610129,<mask>,"       if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    break;
            }
        }
   "
2597,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23292,23292,IdentifierMutator-Literal,8,12,4,0.020138377,<mask>,"       if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    break;
            }
        }
   "
2598,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23297,23306,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,mask,0,0.19936746,<mask>,"    if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2599,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23297,23306,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,255,1,0.16521256,<mask>,"    if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2600,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23297,23306,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,1,2,0.099789456,<mask>,"    if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2601,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23297,23306,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,7,3,0.09019225,<mask>,"    if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2602,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23297,23306,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,WHITE,4,0.04086253,<mask>,"    if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2603,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23297,23306,FieldReferenceMutator,MASK_8BITS,mask,0,0.19936746,org.apache.commons.codec.binary.Base64.<mask>,"    if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2604,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23297,23306,FieldReferenceMutator,MASK_8BITS,255,1,0.16521256,org.apache.commons.codec.binary.Base64.<mask>,"    if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2605,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23297,23306,FieldReferenceMutator,MASK_8BITS,1,2,0.099789456,org.apache.commons.codec.binary.Base64.<mask>,"    if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2606,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23297,23306,FieldReferenceMutator,MASK_8BITS,7,3,0.09019225,org.apache.commons.codec.binary.Base64.<mask>,"    if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2607,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",538,582,23297,23306,FieldReferenceMutator,MASK_8BITS,WHITE,4,0.04086253,org.apache.commons.codec.binary.Base64.<mask>,"    if (eof && modulus != 0) {
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2608,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23739,23742,BinaryOperatorMutator,||,OR,1,0.023899864,(octet == org.apache.commons.codec.binary.Base64.PAD) <mask> (((octet >= 0) && (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)) && (org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] != (-1))),"boolean isBase64(byte octet) {
        return octet == PAD<mask>(octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2609,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23739,23742,BinaryOperatorMutator,||,^,3,0.002628525,(octet == org.apache.commons.codec.binary.Base64.PAD) <mask> (((octet >= 0) && (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)) && (org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] != (-1))),"boolean isBase64(byte octet) {
        return octet == PAD<mask>(octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2610,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23739,23742,BinaryOperatorMutator,||,OR,4,0.0026178379,(octet == org.apache.commons.codec.binary.Base64.PAD) <mask> (((octet >= 0) && (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)) && (org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] != (-1))),"boolean isBase64(byte octet) {
        return octet == PAD<mask>(octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2611,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23732,23735,BinaryOperatorMutator,==,<,1,0.07549561,octet <mask> org.apache.commons.codec.binary.Base64.PAD,"boolean isBase64(byte octet) {
        return octet<mask>PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2612,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23732,23735,BinaryOperatorMutator,==,<,3,0.056596793,octet <mask> org.apache.commons.codec.binary.Base64.PAD,"boolean isBase64(byte octet) {
        return octet<mask>PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2613,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23732,23735,BinaryOperatorMutator,==,>=,4,0.042312745,octet <mask> org.apache.commons.codec.binary.Base64.PAD,"boolean isBase64(byte octet) {
        return octet<mask>PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2614,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23727,23731,IdentifierMutator-Variable,octet,mode,0,0.118902214,<mask>,"boolean isBase64(byte octet) {
        return<mask> == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2615,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23727,23731,IdentifierMutator-Variable,octet,padding,1,0.082646616,<mask>,"boolean isBase64(byte octet) {
        return<mask> == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2616,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23727,23731,IdentifierMutator-Variable,octet,type,2,0.07587567,<mask>,"boolean isBase64(byte octet) {
        return<mask> == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2617,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23727,23731,IdentifierMutator-Variable,octet,pad,3,0.0528352,<mask>,"boolean isBase64(byte octet) {
        return<mask> == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2618,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23727,23731,IdentifierMutator-Variable,octet,modifier,4,0.0295703,<mask>,"boolean isBase64(byte octet) {
        return<mask> == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2619,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23736,23738,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,0,0,0.6760146,<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2620,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23736,23738,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,127,1,0.12894018,<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2621,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23736,23738,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,1,2,0.050043073,<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2622,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23736,23738,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,128,3,0.015066694,<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2623,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23736,23738,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,8,4,0.012161313,<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2624,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23736,23738,FieldReferenceMutator,PAD,0,0,0.6760146,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2625,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23736,23738,FieldReferenceMutator,PAD,127,1,0.12894018,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2626,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23736,23738,FieldReferenceMutator,PAD,1,2,0.050043073,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2627,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23736,23738,FieldReferenceMutator,PAD,128,3,0.015066694,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2628,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23736,23738,FieldReferenceMutator,PAD,8,4,0.012161313,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2629,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23785,23788,BinaryOperatorMutator,&&,),2,0.015546207,((octet >= 0) && (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)) <mask> (org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] != (-1)),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length<mask>DECODE_TABLE[octet] != -1);
    }"
2630,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23785,23788,BinaryOperatorMutator,&&,&,3,0.009839209,((octet >= 0) && (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)) <mask> (org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] != (-1)),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length<mask>DECODE_TABLE[octet] != -1);
    }"
2631,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23785,23788,BinaryOperatorMutator,&&,)(,4,0.0053272173,((octet >= 0) && (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)) <mask> (org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] != (-1)),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length<mask>DECODE_TABLE[octet] != -1);
    }"
2632,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23754,23757,BinaryOperatorMutator,&&,&,1,0.007764951,(octet >= 0) <mask> (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0<mask>octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2633,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23754,23757,BinaryOperatorMutator,&&,;,2,0.0037008193,(octet >= 0) <mask> (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0<mask>octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2634,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23754,23757,BinaryOperatorMutator,&&,x,4,6.8869506E-4,(octet >= 0) <mask> (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0<mask>octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2635,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23749,23752,BinaryOperatorMutator,>=,>,1,0.26759663,octet <mask> 0,"boolean isBase64(byte octet) {
        return octet == PAD || (octet<mask>0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2636,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23749,23752,BinaryOperatorMutator,>=,>,2,0.11323387,octet <mask> 0,"boolean isBase64(byte octet) {
        return octet == PAD || (octet<mask>0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2637,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23749,23752,BinaryOperatorMutator,>=,!=,3,0.037270978,octet <mask> 0,"boolean isBase64(byte octet) {
        return octet == PAD || (octet<mask>0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2638,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23749,23752,BinaryOperatorMutator,>=,==,4,0.003949202,octet <mask> 0,"boolean isBase64(byte octet) {
        return octet == PAD || (octet<mask>0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2639,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23744,23748,IdentifierMutator-Variable,octet,offset,0,0.34123796,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (<mask> >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2640,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23744,23748,IdentifierMutator-Variable,octet,oct,1,0.031099137,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (<mask> >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2641,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23744,23748,IdentifierMutator-Variable,octet,byte,2,0.03070193,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (<mask> >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2642,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23744,23748,IdentifierMutator-Variable,octet,length,3,0.026934959,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (<mask> >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2643,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23744,23748,IdentifierMutator-Variable,octet,token,4,0.026479842,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (<mask> >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2644,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23753,23753,IdentifierMutator-Literal,0,65,1,0.05318131,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >=<mask> && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2645,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23753,23753,IdentifierMutator-Literal,0,91,2,0.032727174,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >=<mask> && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2646,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23753,23753,IdentifierMutator-Literal,0,128,3,0.024104824,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >=<mask> && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2647,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23753,23753,IdentifierMutator-Literal,0,32,4,0.023525674,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >=<mask> && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2648,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23763,23765,BinaryOperatorMutator,<,<=,2,0.015910402,octet <mask> org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet<mask>DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2649,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23763,23765,BinaryOperatorMutator,<,!=,3,0.0011444645,octet <mask> org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet<mask>DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2650,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23763,23765,BinaryOperatorMutator,<,</,4,2.0202502E-4,octet <mask> org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet<mask>DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2651,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23758,23762,IdentifierMutator-Variable,octet,offset,0,0.20411907,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 &&<mask> < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2652,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23758,23762,IdentifierMutator-Variable,octet,0,1,0.085765444,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 &&<mask> < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2653,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23758,23762,IdentifierMutator-Variable,octet,oct,2,0.071607515,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 &&<mask> < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2654,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23758,23762,IdentifierMutator-Variable,octet,it,3,0.058209114,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 &&<mask> < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2655,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23758,23762,IdentifierMutator-Variable,octet,index,4,0.035735756,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 &&<mask> < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2656,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23766,23784,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,127,0,0.27685216,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask> && DECODE_TABLE[octet] != -1);
    }"
2657,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23766,23784,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,256,1,0.13589524,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask> && DECODE_TABLE[octet] != -1);
    }"
2658,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23766,23784,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,255,2,0.13157357,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask> && DECODE_TABLE[octet] != -1);
    }"
2659,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23766,23784,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,128,3,0.04964197,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask> && DECODE_TABLE[octet] != -1);
    }"
2660,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23766,23784,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,9,4,0.04771063,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask> && DECODE_TABLE[octet] != -1);
    }"
2661,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23766,23777,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,bytes,0,0.159239,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2662,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23766,23777,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,decode,1,0.077534094,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2663,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23766,23777,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,alphabet,2,0.07610612,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2664,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23766,23777,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,code,3,0.038576912,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2665,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23766,23777,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,encoded,4,0.036381837,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2666,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23766,23777,FieldReferenceMutator,DECODE_TABLE,bytes,0,0.159239,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2667,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23766,23777,FieldReferenceMutator,DECODE_TABLE,decode,1,0.077534094,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2668,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23766,23777,FieldReferenceMutator,DECODE_TABLE,alphabet,2,0.07610612,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2669,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23766,23777,FieldReferenceMutator,DECODE_TABLE,code,3,0.038576912,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2670,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23766,23777,FieldReferenceMutator,DECODE_TABLE,encoded,4,0.036381837,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2671,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23779,23784,FieldReferenceMutator,length,SIZE,2,0.0028505826,org.apache.commons.codec.binary.Base64.DECODE_TABLE.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.<mask> && DECODE_TABLE[octet] != -1);
    }"
2672,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23779,23784,FieldReferenceMutator,length,Length,3,0.0016526881,org.apache.commons.codec.binary.Base64.DECODE_TABLE.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.<mask> && DECODE_TABLE[octet] != -1);
    }"
2673,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23779,23784,FieldReferenceMutator,length,size,4,8.5723493E-4,org.apache.commons.codec.binary.Base64.DECODE_TABLE.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.<mask> && DECODE_TABLE[octet] != -1);
    }"
2674,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23808,23811,BinaryOperatorMutator,!=,==,1,0.23318279,org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] <mask> (-1),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet]<mask>-1);
    }"
2675,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23808,23811,BinaryOperatorMutator,!=,==,2,0.119848505,org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] <mask> (-1),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet]<mask>-1);
    }"
2676,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23808,23811,BinaryOperatorMutator,!=,>,3,0.058224294,org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] <mask> (-1),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet]<mask>-1);
    }"
2677,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23808,23811,BinaryOperatorMutator,!=,>,4,0.043894295,org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] <mask> (-1),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet]<mask>-1);
    }"
2678,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23802,23806,ArrayAccessMutator,octet,oct,0,0.5286201,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2679,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23802,23806,ArrayAccessMutator,octet,offset,1,0.07834759,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2680,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23802,23806,ArrayAccessMutator,octet,letter,2,0.02860076,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2681,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23802,23806,ArrayAccessMutator,octet,0,3,0.027785495,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2682,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23802,23806,ArrayAccessMutator,octet,et,4,0.026095012,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2683,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23789,23800,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,table,0,0.19627516,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2684,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23789,23800,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,bytes,1,0.09361875,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2685,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23789,23800,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,decode,2,0.07034788,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2686,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23789,23800,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,codes,3,0.045413338,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2687,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23789,23800,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,alphabet,4,0.038723953,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2688,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23789,23800,FieldReferenceMutator,DECODE_TABLE,table,0,0.19627516,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2689,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23789,23800,FieldReferenceMutator,DECODE_TABLE,bytes,1,0.09361875,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2690,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23789,23800,FieldReferenceMutator,DECODE_TABLE,decode,2,0.07034788,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2691,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23789,23800,FieldReferenceMutator,DECODE_TABLE,codes,3,0.045413338,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2692,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23789,23800,FieldReferenceMutator,DECODE_TABLE,alphabet,4,0.038723953,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2693,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23802,23806,IdentifierMutator-Variable,octet,oct,0,0.5286201,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2694,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23802,23806,IdentifierMutator-Variable,octet,offset,1,0.07834759,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2695,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23802,23806,IdentifierMutator-Variable,octet,letter,2,0.02860076,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2696,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23802,23806,IdentifierMutator-Variable,octet,0,3,0.027785495,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2697,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23802,23806,IdentifierMutator-Variable,octet,et,4,0.026095012,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2698,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23812,23812,UnaryOperatorMutator,-,$,1,0.22919798,<mask>1,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] !=<mask>1);
    }"
2699,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23812,23812,UnaryOperatorMutator,-,B,2,0.03972629,<mask>1,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] !=<mask>1);
    }"
2700,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23812,23812,UnaryOperatorMutator,-,SHA,3,0.03684826,<mask>1,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] !=<mask>1);
    }"
2701,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23812,23812,UnaryOperatorMutator,-,D,4,0.025036473,<mask>1,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] !=<mask>1);
    }"
2702,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23813,23813,IdentifierMutator-Literal,1,127,2,0.012477205,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -<mask>);
    }"
2703,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23813,23813,IdentifierMutator-Literal,1,2,3,0.0048761726,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -<mask>);
    }"
2704,Base64.java,isBase64,boolean isBase64(byte octet),596,597,23813,23813,IdentifierMutator-Literal,1,xff,4,0.004373362,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -<mask>);
    }"
2705,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24309,24309,IdentifierMutator-Literal,0,1,2,0.0035594685,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i =<mask>; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2706,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24309,24309,IdentifierMutator-Literal,0,2,3,2.1800085E-4,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i =<mask>; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2707,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24309,24309,IdentifierMutator-Literal,0,1,4,1.453953E-4,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i =<mask>; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2708,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24313,24315,BinaryOperatorMutator,<,++,2,0.0028799244,i <mask> arrayOctet.length,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i<mask>arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2709,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24313,24315,BinaryOperatorMutator,<,==,3,0.0025075444,i <mask> arrayOctet.length,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i<mask>arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2710,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24313,24315,BinaryOperatorMutator,<,+=,4,9.984601E-4,i <mask> arrayOctet.length,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i<mask>arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2711,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24312,24312,IdentifierMutator-Variable,i,I,2,3.408563E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0;<mask> < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2712,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24312,24312,IdentifierMutator-Variable,i,0,3,1.4784161E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0;<mask> < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2713,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24312,24312,IdentifierMutator-Variable,i,j,4,1.0816622E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0;<mask> < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2714,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24316,24332,IdentifierMutator-Variable,arrayOctet.length,length,0,0.122951746,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2715,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24316,24332,IdentifierMutator-Variable,arrayOctet.length,256,1,0.12235578,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2716,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24316,24332,IdentifierMutator-Variable,arrayOctet.length,8,2,0.09216603,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2717,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24316,24332,IdentifierMutator-Variable,arrayOctet.length,4,3,0.08148522,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2718,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24316,24332,IdentifierMutator-Variable,arrayOctet.length,size,4,0.052057322,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2719,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24316,24325,IdentifierMutator-Variable,arrayOctet,array,0,0.67766297,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2720,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24316,24325,IdentifierMutator-Variable,arrayOctet,array,1,0.08930929,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2721,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24316,24325,IdentifierMutator-Variable,arrayOctet,Array,2,0.07441305,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2722,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24316,24325,IdentifierMutator-Variable,arrayOctet,string,3,0.027874095,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2723,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24316,24325,IdentifierMutator-Variable,arrayOctet,byte,4,0.018235441,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2724,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24327,24332,FieldReferenceMutator,length,size,1,2.1429358E-4,arrayOctet.<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2725,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24327,24332,FieldReferenceMutator,length,Length,2,1.12722926E-4,arrayOctet.<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2726,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24327,24332,FieldReferenceMutator,length,count,4,3.9862476E-5,arrayOctet.<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2727,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24336,24337,UnaryOperatorMutator,++,++),2,0.0077910745,i<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i<mask>) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2728,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24336,24337,UnaryOperatorMutator,++,++;,3,3.7385066E-4,i<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i<mask>) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2729,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24336,24337,UnaryOperatorMutator,++,*/,4,3.1063764E-4,i<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i<mask>) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2730,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24335,24335,IdentifierMutator-Variable,i,,2,2.6425332E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length;<mask>++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2731,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24335,24335,IdentifierMutator-Variable,i,I,3,2.2259237E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length;<mask>++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2732,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,610,24335,24335,IdentifierMutator-Variable,i,j,4,1.6588043E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length;<mask>++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2733,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24382,24385,BinaryOperatorMutator,&&,||,2,0.009330965,(!org.apache.commons.codec.binary.Base64.isBase64(arrayOctet[i])) <mask> (!org.apache.commons.codec.binary.Base64.isWhiteSpace(arrayOctet[i])),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i])<mask>!isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2734,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24382,24385,BinaryOperatorMutator,&&,&,3,0.0022995754,(!org.apache.commons.codec.binary.Base64.isBase64(arrayOctet[i])) <mask> (!org.apache.commons.codec.binary.Base64.isWhiteSpace(arrayOctet[i])),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i])<mask>!isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2735,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24382,24385,BinaryOperatorMutator,&&,|,4,4.6147482E-4,(!org.apache.commons.codec.binary.Base64.isBase64(arrayOctet[i])) <mask> (!org.apache.commons.codec.binary.Base64.isWhiteSpace(arrayOctet[i])),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i])<mask>!isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2736,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24358,24358,UnaryOperatorMutator,!,(!,2,1.0556497E-4,<mask>org.apache.commons.codec.binary.Base64.isBase64(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2737,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24358,24358,UnaryOperatorMutator,!,!!,3,8.949993E-5,<mask>org.apache.commons.codec.binary.Base64.isBase64(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2738,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24358,24358,UnaryOperatorMutator,!,...,4,8.819677E-5,<mask>org.apache.commons.codec.binary.Base64.isBase64(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2739,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24359,24366,MethodCallMutator,isBase64,empty,0,0.37880233,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!<mask>(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2740,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24359,24366,MethodCallMutator,isBase64,blank,1,0.09612266,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!<mask>(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2741,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24359,24366,MethodCallMutator,isBase64,alpha,2,0.089658916,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!<mask>(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2742,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24359,24366,MethodCallMutator,isBase64,space,3,0.07828203,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!<mask>(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2743,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24359,24366,MethodCallMutator,isBase64,is,4,0.06573088,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!<mask>(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2744,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24379,24379,ArrayAccessMutator,i,0,1,8.791312E-5,arrayOctet[<mask>],"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[<mask>]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2745,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24379,24379,ArrayAccessMutator,i,j,3,2.9202614E-5,arrayOctet[<mask>],"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[<mask>]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2746,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24379,24379,ArrayAccessMutator,i,I,4,2.7298442E-5,arrayOctet[<mask>],"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[<mask>]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2747,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24368,24377,IdentifierMutator-Variable,arrayOctet,array,0,0.5709966,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(<mask>[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2748,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24368,24377,IdentifierMutator-Variable,arrayOctet,string,1,0.07290433,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(<mask>[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2749,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24368,24377,IdentifierMutator-Variable,arrayOctet,byte,2,0.050841868,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(<mask>[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2750,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24368,24377,IdentifierMutator-Variable,arrayOctet,Array,3,0.045269314,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(<mask>[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2751,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24368,24377,IdentifierMutator-Variable,arrayOctet,data,4,0.039686188,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(<mask>[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2752,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24379,24379,IdentifierMutator-Variable,i,0,1,8.791312E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[<mask>]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2753,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24379,24379,IdentifierMutator-Variable,i,j,3,2.9202614E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[<mask>]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2754,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24379,24379,IdentifierMutator-Variable,i,I,4,2.7298442E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[<mask>]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2755,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24386,24386,UnaryOperatorMutator,!,(!,1,0.34020975,<mask>org.apache.commons.codec.binary.Base64.isWhiteSpace(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) &&<mask>isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2756,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24386,24386,UnaryOperatorMutator,!,(,2,0.0019162291,<mask>org.apache.commons.codec.binary.Base64.isWhiteSpace(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) &&<mask>isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2757,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24386,24386,UnaryOperatorMutator,!,!!,4,8.7095425E-5,<mask>org.apache.commons.codec.binary.Base64.isWhiteSpace(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) &&<mask>isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2758,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24387,24398,MethodCallMutator,isWhiteSpace,empty,0,0.17688563,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !<mask>(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2759,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24387,24398,MethodCallMutator,isWhiteSpace,is,1,0.06621986,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !<mask>(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2760,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24387,24398,MethodCallMutator,isWhiteSpace,array,2,0.0343685,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !<mask>(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2761,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24387,24398,MethodCallMutator,isWhiteSpace,digit,3,0.030788166,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !<mask>(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2762,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24387,24398,MethodCallMutator,isWhiteSpace,bytes,4,0.030544871,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !<mask>(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2763,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24411,24411,ArrayAccessMutator,i,j,1,1.4602471E-4,arrayOctet[<mask>],"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[<mask>])) {
                return false;
            }
        }
        return true;
    }"
2764,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24411,24411,ArrayAccessMutator,i,I,3,7.9151854E-5,arrayOctet[<mask>],"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[<mask>])) {
                return false;
            }
        }
        return true;
    }"
2765,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24411,24411,ArrayAccessMutator,i,0,4,5.552991E-5,arrayOctet[<mask>],"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[<mask>])) {
                return false;
            }
        }
        return true;
    }"
2766,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24400,24409,IdentifierMutator-Variable,arrayOctet,array,0,0.45342407,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(<mask>[i])) {
                return false;
            }
        }
        return true;
    }"
2767,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24400,24409,IdentifierMutator-Variable,arrayOctet,string,1,0.13066486,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(<mask>[i])) {
                return false;
            }
        }
        return true;
    }"
2768,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24400,24409,IdentifierMutator-Variable,arrayOctet,byte,2,0.052330207,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(<mask>[i])) {
                return false;
            }
        }
        return true;
    }"
2769,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24400,24409,IdentifierMutator-Variable,arrayOctet,Array,3,0.039709173,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(<mask>[i])) {
                return false;
            }
        }
        return true;
    }"
2770,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24400,24409,IdentifierMutator-Variable,arrayOctet,data,4,0.031672865,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(<mask>[i])) {
                return false;
            }
        }
        return true;
    }"
2771,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24411,24411,IdentifierMutator-Variable,i,j,1,1.4602471E-4,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[<mask>])) {
                return false;
            }
        }
        return true;
    }"
2772,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24411,24411,IdentifierMutator-Variable,i,I,3,7.9151854E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[<mask>])) {
                return false;
            }
        }
        return true;
    }"
2773,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,611,24411,24411,IdentifierMutator-Variable,i,0,4,5.552991E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[<mask>])) {
                return false;
            }
        }
        return true;
    }"
2774,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,612,24441,24445,IdentifierMutator-Literal,false,true,1,0.049490158,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return<mask>;
            }
        }
        return true;
    }"
2775,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,612,24441,24445,IdentifierMutator-Literal,false,FALSE,2,2.4336837E-4,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return<mask>;
            }
        }
        return true;
    }"
2776,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,612,24441,24445,IdentifierMutator-Literal,false,0,3,1.917821E-4,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return<mask>;
            }
        }
        return true;
    }"
2777,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,612,24441,24445,IdentifierMutator-Literal,false,False,4,1.7795908E-4,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return<mask>;
            }
        }
        return true;
    }"
2778,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,615,24487,24490,IdentifierMutator-Literal,true,false,1,0.04038392,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return<mask>;
    }"
2779,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,615,24487,24490,IdentifierMutator-Literal,true,null,2,1.8374268E-4,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return<mask>;
    }"
2780,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,615,24487,24490,IdentifierMutator-Literal,true,1,3,1.7323364E-4,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return<mask>;
    }"
2781,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),609,615,24487,24490,IdentifierMutator-Literal,true,0,4,1.436519E-4,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return<mask>;
    }"
2782,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24882,24882,IdentifierMutator-Literal,0,1,2,0.003959158,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i =<mask>; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2783,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24882,24882,IdentifierMutator-Literal,0,2,3,2.262098E-4,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i =<mask>; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2784,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24882,24882,IdentifierMutator-Literal,0,1,4,1.558296E-4,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i =<mask>; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2785,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24886,24888,BinaryOperatorMutator,<,++,2,0.0026359782,i <mask> arrayOctet.length,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i<mask>arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2786,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24886,24888,BinaryOperatorMutator,<,==,3,0.0019484478,i <mask> arrayOctet.length,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i<mask>arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2787,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24886,24888,BinaryOperatorMutator,<,+=,4,9.264703E-4,i <mask> arrayOctet.length,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i<mask>arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2788,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24885,24885,IdentifierMutator-Variable,i,I,2,3.6854744E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0;<mask> < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2789,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24885,24885,IdentifierMutator-Variable,i,0,3,1.640468E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0;<mask> < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2790,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24885,24885,IdentifierMutator-Variable,i,j,4,1.3535984E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0;<mask> < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2791,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24889,24905,IdentifierMutator-Variable,arrayOctet.length,256,0,0.14680465,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2792,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24889,24905,IdentifierMutator-Variable,arrayOctet.length,8,1,0.11345136,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2793,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24889,24905,IdentifierMutator-Variable,arrayOctet.length,length,2,0.087559626,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2794,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24889,24905,IdentifierMutator-Variable,arrayOctet.length,4,3,0.07424522,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2795,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24889,24905,IdentifierMutator-Variable,arrayOctet.length,32,4,0.046386782,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2796,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24889,24898,IdentifierMutator-Variable,arrayOctet,array,0,0.72395766,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2797,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24889,24898,IdentifierMutator-Variable,arrayOctet,byte,1,0.044849873,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2798,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24889,24898,IdentifierMutator-Variable,arrayOctet,string,2,0.023763862,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2799,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24889,24898,IdentifierMutator-Variable,arrayOctet,Array,3,0.019308094,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2800,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24889,24898,IdentifierMutator-Variable,arrayOctet,buffer,4,0.019216686,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2801,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24900,24905,FieldReferenceMutator,length,size,1,1.707799E-4,arrayOctet.<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2802,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24900,24905,FieldReferenceMutator,length,Length,3,9.1871945E-5,arrayOctet.<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2803,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24900,24905,FieldReferenceMutator,length,count,4,3.4216948E-5,arrayOctet.<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2804,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24909,24910,UnaryOperatorMutator,++,++),2,0.0064816885,i<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i<mask>) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2805,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24909,24910,UnaryOperatorMutator,++,*/,3,3.7730436E-4,i<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i<mask>) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2806,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24909,24910,UnaryOperatorMutator,++,++;,4,3.5322306E-4,i<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i<mask>) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2807,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24908,24908,IdentifierMutator-Variable,i,I,2,3.095618E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length;<mask>++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2808,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24908,24908,IdentifierMutator-Variable,i,,3,1.6567137E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length;<mask>++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2809,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,626,24908,24908,IdentifierMutator-Variable,i,j,4,1.5247159E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length;<mask>++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2810,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,627,24931,24938,MethodCallMutator,isBase64,bytes,0,0.05634457,<mask>(arrayOctet[i]),"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2811,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,627,24931,24938,MethodCallMutator,isBase64,check,1,0.051514942,<mask>(arrayOctet[i]),"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2812,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,627,24931,24938,MethodCallMutator,isBase64,match,2,0.0469116,<mask>(arrayOctet[i]),"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2813,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,627,24931,24938,MethodCallMutator,isBase64,is,3,0.045205876,<mask>(arrayOctet[i]),"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2814,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,627,24931,24938,MethodCallMutator,isBase64,contains,4,0.043610103,<mask>(arrayOctet[i]),"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2815,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,627,24951,24951,ArrayAccessMutator,i,0,2,1.6736319E-4,arrayOctet[<mask>],"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[<mask>])) {
                return true;
            }
        }
        return false;
    }"
2816,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,627,24951,24951,ArrayAccessMutator,i,I,3,1.6114512E-4,arrayOctet[<mask>],"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[<mask>])) {
                return true;
            }
        }
        return false;
    }"
2817,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,627,24951,24951,ArrayAccessMutator,i,j,4,2.1005095E-5,arrayOctet[<mask>],"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[<mask>])) {
                return true;
            }
        }
        return false;
    }"
2818,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,627,24940,24949,IdentifierMutator-Variable,arrayOctet,array,0,0.24167866,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(<mask>[i])) {
                return true;
            }
        }
        return false;
    }"
2819,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,627,24940,24949,IdentifierMutator-Variable,arrayOctet,byte,1,0.2171457,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(<mask>[i])) {
                return true;
            }
        }
        return false;
    }"
2820,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,627,24940,24949,IdentifierMutator-Variable,arrayOctet,data,2,0.076957785,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(<mask>[i])) {
                return true;
            }
        }
        return false;
    }"
2821,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,627,24940,24949,IdentifierMutator-Variable,arrayOctet,buffer,3,0.0666544,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(<mask>[i])) {
                return true;
            }
        }
        return false;
    }"
2822,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,627,24940,24949,IdentifierMutator-Variable,arrayOctet,string,4,0.05060413,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(<mask>[i])) {
                return true;
            }
        }
        return false;
    }"
2823,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,627,24951,24951,IdentifierMutator-Variable,i,0,2,1.6736319E-4,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[<mask>])) {
                return true;
            }
        }
        return false;
    }"
2824,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,627,24951,24951,IdentifierMutator-Variable,i,I,3,1.6114512E-4,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[<mask>])) {
                return true;
            }
        }
        return false;
    }"
2825,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,627,24951,24951,IdentifierMutator-Variable,i,j,4,2.1005095E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[<mask>])) {
                return true;
            }
        }
        return false;
    }"
2826,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,628,24981,24984,IdentifierMutator-Literal,true,i,1,0.0021050747,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return<mask>;
            }
        }
        return false;
    }"
2827,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,628,24981,24984,IdentifierMutator-Literal,true,false,2,0.0015918087,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return<mask>;
            }
        }
        return false;
    }"
2828,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,628,24981,24984,IdentifierMutator-Literal,true,1,3,9.919776E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return<mask>;
            }
        }
        return false;
    }"
2829,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,628,24981,24984,IdentifierMutator-Literal,true,True,4,9.051935E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return<mask>;
            }
        }
        return false;
    }"
2830,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,631,25026,25030,IdentifierMutator-Literal,false,true,1,0.005027194,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return<mask>;
    }"
2831,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,631,25026,25030,IdentifierMutator-Literal,false,False,2,2.1422916E-4,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return<mask>;
    }"
2832,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,631,25026,25030,IdentifierMutator-Literal,false,null,3,1.6523841E-4,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return<mask>;
    }"
2833,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),625,631,25026,25030,IdentifierMutator-Literal,false,undefined,4,8.806465E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return<mask>;
    }"
2834,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),641,642,25370,25381,MethodCallMutator,encodeBase64,encode,0,0.94405687,"<mask>(binaryData, false)","byte[] encodeBase64(byte[] binaryData) {
        return<mask>(binaryData, false);
    }"
2835,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),641,642,25370,25381,MethodCallMutator,encodeBase64,decode,1,0.039374847,"<mask>(binaryData, false)","byte[] encodeBase64(byte[] binaryData) {
        return<mask>(binaryData, false);
    }"
2836,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),641,642,25370,25381,MethodCallMutator,encodeBase64,encrypt,2,0.0022694818,"<mask>(binaryData, false)","byte[] encodeBase64(byte[] binaryData) {
        return<mask>(binaryData, false);
    }"
2837,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),641,642,25370,25381,MethodCallMutator,encodeBase64,write,3,0.0014574287,"<mask>(binaryData, false)","byte[] encodeBase64(byte[] binaryData) {
        return<mask>(binaryData, false);
    }"
2838,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),641,642,25370,25381,MethodCallMutator,encodeBase64,convert,4,0.0012849576,"<mask>(binaryData, false)","byte[] encodeBase64(byte[] binaryData) {
        return<mask>(binaryData, false);
    }"
2839,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),641,642,25383,25392,IdentifierMutator-Variable,binaryData,data,0,0.56965536,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(<mask>, false);
    }"
2840,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),641,642,25383,25392,IdentifierMutator-Variable,binaryData,binary,1,0.34878767,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(<mask>, false);
    }"
2841,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),641,642,25383,25392,IdentifierMutator-Variable,binaryData,bin,2,0.014435808,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(<mask>, false);
    }"
2842,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),641,642,25383,25392,IdentifierMutator-Variable,binaryData,bytes,3,0.011640079,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(<mask>, false);
    }"
2843,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),641,642,25383,25392,IdentifierMutator-Variable,binaryData,input,4,0.006641374,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(<mask>, false);
    }"
2844,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),641,642,25395,25399,IdentifierMutator-Literal,false,true,0,0.41194126,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2845,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),641,642,25395,25399,IdentifierMutator-Literal,false,encoding,1,0.18011749,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2846,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),641,642,25395,25399,IdentifierMutator-Literal,false,enc,3,0.026365332,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2847,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),641,642,25395,25399,IdentifierMutator-Literal,false,null,4,0.02244457,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2848,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25762,25774,MethodCallMutator,newStringUtf8,escape,0,0.23996378,"StringUtils.<mask>(encodeBase64(binaryData, true))","String encodeBase64String(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, true));
    }"
2849,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25762,25774,MethodCallMutator,newStringUtf8,strip,1,0.11445843,"StringUtils.<mask>(encodeBase64(binaryData, true))","String encodeBase64String(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, true));
    }"
2850,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25762,25774,MethodCallMutator,newStringUtf8,format,2,0.06323431,"StringUtils.<mask>(encodeBase64(binaryData, true))","String encodeBase64String(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, true));
    }"
2851,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25762,25774,MethodCallMutator,newStringUtf8,str,3,0.054342475,"StringUtils.<mask>(encodeBase64(binaryData, true))","String encodeBase64String(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, true));
    }"
2852,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25762,25774,MethodCallMutator,newStringUtf8,copy,4,0.051807296,"StringUtils.<mask>(encodeBase64(binaryData, true))","String encodeBase64String(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, true));
    }"
2853,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25776,25787,MethodCallMutator,encodeBase64,string,0,0.111390665,"<mask>(binaryData, true)","String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, true));
    }"
2854,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25776,25787,MethodCallMutator,encodeBase64,append,1,0.09226089,"<mask>(binaryData, true)","String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, true));
    }"
2855,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25776,25787,MethodCallMutator,encodeBase64,escape,2,0.08700019,"<mask>(binaryData, true)","String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, true));
    }"
2856,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25776,25787,MethodCallMutator,encodeBase64,bytes,3,0.07304816,"<mask>(binaryData, true)","String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, true));
    }"
2857,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25776,25787,MethodCallMutator,encodeBase64,binary,4,0.06661077,"<mask>(binaryData, true)","String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, true));
    }"
2858,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25789,25798,IdentifierMutator-Variable,binaryData,data,0,0.6838374,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, true));
    }"
2859,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25789,25798,IdentifierMutator-Variable,binaryData,binary,1,0.22291455,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, true));
    }"
2860,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25789,25798,IdentifierMutator-Variable,binaryData,bytes,2,0.014530242,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, true));
    }"
2861,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25789,25798,IdentifierMutator-Variable,binaryData,bin,3,0.011179527,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, true));
    }"
2862,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25789,25798,IdentifierMutator-Variable,binaryData,input,4,0.007105408,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, true));
    }"
2863,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25801,25804,IdentifierMutator-Literal,true,encoding,1,0.30814728,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>));
    }"
2864,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25801,25804,IdentifierMutator-Literal,true,false,2,0.12737432,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>));
    }"
2865,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25801,25804,IdentifierMutator-Literal,true,16,3,0.023923935,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>));
    }"
2866,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),653,654,25801,25804,IdentifierMutator-Literal,true,null,4,0.018529011,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>));
    }"
2867,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),666,667,26274,26285,MethodCallMutator,encodeBase64,encode,0,0.9291539,"<mask>(binaryData, false, true)","byte[] encodeBase64URLSafe(byte[] binaryData) {
        return<mask>(binaryData, false, true);
    }"
2868,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),666,667,26274,26285,MethodCallMutator,encodeBase64,decode,1,0.04959106,"<mask>(binaryData, false, true)","byte[] encodeBase64URLSafe(byte[] binaryData) {
        return<mask>(binaryData, false, true);
    }"
2869,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),666,667,26274,26285,MethodCallMutator,encodeBase64,encrypt,2,0.0033817214,"<mask>(binaryData, false, true)","byte[] encodeBase64URLSafe(byte[] binaryData) {
        return<mask>(binaryData, false, true);
    }"
2870,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),666,667,26274,26285,MethodCallMutator,encodeBase64,escape,3,0.0017478258,"<mask>(binaryData, false, true)","byte[] encodeBase64URLSafe(byte[] binaryData) {
        return<mask>(binaryData, false, true);
    }"
2871,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),666,667,26274,26285,MethodCallMutator,encodeBase64,convert,4,0.001501609,"<mask>(binaryData, false, true)","byte[] encodeBase64URLSafe(byte[] binaryData) {
        return<mask>(binaryData, false, true);
    }"
2872,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),666,667,26287,26296,IdentifierMutator-Variable,binaryData,data,0,0.57694554,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(<mask>, false, true);
    }"
2873,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),666,667,26287,26296,IdentifierMutator-Variable,binaryData,binary,1,0.35582703,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(<mask>, false, true);
    }"
2874,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),666,667,26287,26296,IdentifierMutator-Variable,binaryData,bin,2,0.010326671,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(<mask>, false, true);
    }"
2875,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),666,667,26287,26296,IdentifierMutator-Variable,binaryData,bytes,3,0.00878207,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(<mask>, false, true);
    }"
2876,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),666,667,26287,26296,IdentifierMutator-Variable,binaryData,input,4,0.007093513,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(<mask>, false, true);
    }"
2877,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),666,667,26299,26303,IdentifierMutator-Literal,false,true,0,0.33701757,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>, true);
    }"
2878,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),666,667,26299,26303,IdentifierMutator-Literal,false,null,2,0.077673286,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>, true);
    }"
2879,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),666,667,26299,26303,IdentifierMutator-Literal,false,encoding,3,0.064455956,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>, true);
    }"
2880,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),666,667,26299,26303,IdentifierMutator-Literal,false,0,4,0.026886055,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>, true);
    }"
2881,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),666,667,26306,26309,IdentifierMutator-Literal,true,false,1,0.2752255,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData, false,<mask>);
    }"
2882,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),666,667,26306,26309,IdentifierMutator-Literal,true,encoding,2,0.037517346,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData, false,<mask>);
    }"
2883,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),666,667,26306,26309,IdentifierMutator-Literal,true,null,3,0.028304271,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData, false,<mask>);
    }"
2884,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),666,667,26306,26309,IdentifierMutator-Literal,true,0,4,0.02069018,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData, false,<mask>);
    }"
2885,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26764,26776,MethodCallMutator,newStringUtf8,escape,0,0.27712065,"StringUtils.<mask>(encodeBase64(binaryData, false, true))","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false, true));
    }"
2886,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26764,26776,MethodCallMutator,newStringUtf8,strip,1,0.15997787,"StringUtils.<mask>(encodeBase64(binaryData, false, true))","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false, true));
    }"
2887,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26764,26776,MethodCallMutator,newStringUtf8,String,2,0.051742323,"StringUtils.<mask>(encodeBase64(binaryData, false, true))","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false, true));
    }"
2888,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26764,26776,MethodCallMutator,newStringUtf8,str,3,0.039697804,"StringUtils.<mask>(encodeBase64(binaryData, false, true))","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false, true));
    }"
2889,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26764,26776,MethodCallMutator,newStringUtf8,copy,4,0.03933654,"StringUtils.<mask>(encodeBase64(binaryData, false, true))","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false, true));
    }"
2890,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26778,26789,MethodCallMutator,encodeBase64,append,0,0.13126743,"<mask>(binaryData, false, true)","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false, true));
    }"
2891,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26778,26789,MethodCallMutator,encodeBase64,escape,1,0.101710126,"<mask>(binaryData, false, true)","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false, true));
    }"
2892,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26778,26789,MethodCallMutator,encodeBase64,string,2,0.07036338,"<mask>(binaryData, false, true)","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false, true));
    }"
2893,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26778,26789,MethodCallMutator,encodeBase64,copy,3,0.0588506,"<mask>(binaryData, false, true)","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false, true));
    }"
2894,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26778,26789,MethodCallMutator,encodeBase64,bytes,4,0.053650454,"<mask>(binaryData, false, true)","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false, true));
    }"
2895,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26791,26800,IdentifierMutator-Variable,binaryData,data,0,0.7014834,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false, true));
    }"
2896,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26791,26800,IdentifierMutator-Variable,binaryData,binary,1,0.21778993,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false, true));
    }"
2897,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26791,26800,IdentifierMutator-Variable,binaryData,bytes,2,0.01396412,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false, true));
    }"
2898,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26791,26800,IdentifierMutator-Variable,binaryData,bin,3,0.006630474,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false, true));
    }"
2899,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26791,26800,IdentifierMutator-Variable,binaryData,input,4,0.005561476,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false, true));
    }"
2900,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26803,26807,IdentifierMutator-Literal,false,true,0,0.5513804,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>, true));
    }"
2901,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26803,26807,IdentifierMutator-Literal,false,encoding,2,0.04882754,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>, true));
    }"
2902,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26803,26807,IdentifierMutator-Literal,false,null,3,0.04679208,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>, true));
    }"
2903,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26803,26807,IdentifierMutator-Literal,false,16,4,0.013512293,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>, true));
    }"
2904,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26810,26813,IdentifierMutator-Literal,true,false,0,0.40773466,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData, false,<mask>));
    }"
2905,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26810,26813,IdentifierMutator-Literal,true,encoding,2,0.04217342,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData, false,<mask>));
    }"
2906,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26810,26813,IdentifierMutator-Literal,true,null,3,0.032313563,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData, false,<mask>));
    }"
2907,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),679,680,26810,26813,IdentifierMutator-Literal,true,0,4,0.016010568,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData, false,<mask>));
    }"
2908,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),690,691,27172,27183,MethodCallMutator,encodeBase64,encode,0,0.82261014,"<mask>(binaryData, true)","byte[] encodeBase64Chunked(byte[] binaryData) {
        return<mask>(binaryData, true);
    }"
2909,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),690,691,27172,27183,MethodCallMutator,encodeBase64,decode,1,0.09652989,"<mask>(binaryData, true)","byte[] encodeBase64Chunked(byte[] binaryData) {
        return<mask>(binaryData, true);
    }"
2910,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),690,691,27172,27183,MethodCallMutator,encodeBase64,chunk,2,0.022350585,"<mask>(binaryData, true)","byte[] encodeBase64Chunked(byte[] binaryData) {
        return<mask>(binaryData, true);
    }"
2911,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),690,691,27172,27183,MethodCallMutator,encodeBase64,write,3,0.006138433,"<mask>(binaryData, true)","byte[] encodeBase64Chunked(byte[] binaryData) {
        return<mask>(binaryData, true);
    }"
2912,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),690,691,27172,27183,MethodCallMutator,encodeBase64,compress,4,0.0039744885,"<mask>(binaryData, true)","byte[] encodeBase64Chunked(byte[] binaryData) {
        return<mask>(binaryData, true);
    }"
2913,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),690,691,27185,27194,IdentifierMutator-Variable,binaryData,data,0,0.6595072,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(<mask>, true);
    }"
2914,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),690,691,27185,27194,IdentifierMutator-Variable,binaryData,binary,1,0.26427338,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(<mask>, true);
    }"
2915,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),690,691,27185,27194,IdentifierMutator-Variable,binaryData,bin,2,0.013548699,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(<mask>, true);
    }"
2916,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),690,691,27185,27194,IdentifierMutator-Variable,binaryData,bytes,3,0.011362956,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(<mask>, true);
    }"
2917,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),690,691,27185,27194,IdentifierMutator-Variable,binaryData,input,4,0.005645278,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(<mask>, true);
    }"
2918,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),690,691,27197,27200,IdentifierMutator-Literal,true,chunk,1,0.22533223,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2919,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),690,691,27197,27200,IdentifierMutator-Literal,true,false,2,0.14861713,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2920,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),690,691,27197,27200,IdentifierMutator-Literal,true,chunks,3,0.067457154,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2921,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),690,691,27197,27200,IdentifierMutator-Literal,true,encoding,4,0.027869578,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2922,Base64.java,decode,byte[] decode(String pArray),722,723,28484,28489,MethodCallMutator,decode,encode,1,0.004830821,<mask>(StringUtils.getBytesUtf8(pArray)),"byte[] decode(String pArray) {
        return<mask>(StringUtils.getBytesUtf8(pArray));
    }"
2923,Base64.java,decode,byte[] decode(String pArray),722,723,28484,28489,MethodCallMutator,decode,parse,2,1.7826313E-4,<mask>(StringUtils.getBytesUtf8(pArray)),"byte[] decode(String pArray) {
        return<mask>(StringUtils.getBytesUtf8(pArray));
    }"
2924,Base64.java,decode,byte[] decode(String pArray),722,723,28484,28489,MethodCallMutator,decode,dec,3,1.3111597E-4,<mask>(StringUtils.getBytesUtf8(pArray)),"byte[] decode(String pArray) {
        return<mask>(StringUtils.getBytesUtf8(pArray));
    }"
2925,Base64.java,decode,byte[] decode(String pArray),722,723,28484,28489,MethodCallMutator,decode,convert,4,9.6891796E-5,<mask>(StringUtils.getBytesUtf8(pArray)),"byte[] decode(String pArray) {
        return<mask>(StringUtils.getBytesUtf8(pArray));
    }"
2926,Base64.java,decode,byte[] decode(String pArray),722,723,28503,28514,MethodCallMutator,getBytesUtf8,split,0,0.28131217,StringUtils.<mask>(pArray),"byte[] decode(String pArray) {
        return decode(StringUtils.<mask>(pArray));
    }"
2927,Base64.java,decode,byte[] decode(String pArray),722,723,28503,28514,MethodCallMutator,getBytesUtf8,escape,1,0.15086763,StringUtils.<mask>(pArray),"byte[] decode(String pArray) {
        return decode(StringUtils.<mask>(pArray));
    }"
2928,Base64.java,decode,byte[] decode(String pArray),722,723,28503,28514,MethodCallMutator,getBytesUtf8,copy,2,0.09991636,StringUtils.<mask>(pArray),"byte[] decode(String pArray) {
        return decode(StringUtils.<mask>(pArray));
    }"
2929,Base64.java,decode,byte[] decode(String pArray),722,723,28503,28514,MethodCallMutator,getBytesUtf8,bytes,3,0.07844052,StringUtils.<mask>(pArray),"byte[] decode(String pArray) {
        return decode(StringUtils.<mask>(pArray));
    }"
2930,Base64.java,decode,byte[] decode(String pArray),722,723,28503,28514,MethodCallMutator,getBytesUtf8,strip,4,0.056334697,StringUtils.<mask>(pArray),"byte[] decode(String pArray) {
        return decode(StringUtils.<mask>(pArray));
    }"
2931,Base64.java,decode,byte[] decode(String pArray),722,723,28516,28521,IdentifierMutator-Variable,pArray,Array,0,0.48545185,<mask>,"byte[] decode(String pArray) {
        return decode(StringUtils.getBytesUtf8(<mask>));
    }"
2932,Base64.java,decode,byte[] decode(String pArray),722,723,28516,28521,IdentifierMutator-Variable,pArray,array,1,0.47099465,<mask>,"byte[] decode(String pArray) {
        return decode(StringUtils.getBytesUtf8(<mask>));
    }"
2933,Base64.java,decode,byte[] decode(String pArray),722,723,28516,28521,IdentifierMutator-Variable,pArray,string,2,0.017953781,<mask>,"byte[] decode(String pArray) {
        return decode(StringUtils.getBytesUtf8(<mask>));
    }"
2934,Base64.java,decode,byte[] decode(String pArray),722,723,28516,28521,IdentifierMutator-Variable,pArray,arr,3,0.0070915967,<mask>,"byte[] decode(String pArray) {
        return decode(StringUtils.getBytesUtf8(<mask>));
    }"
2935,Base64.java,decode,byte[] decode(String pArray),722,723,28516,28521,IdentifierMutator-Variable,pArray,p,4,0.0027387305,<mask>,"byte[] decode(String pArray) {
        return decode(StringUtils.getBytesUtf8(<mask>));
    }"
2936,Base64.java,decode,byte[] decode(byte[] pArray),733,734,28824,28828,MethodCallMutator,reset,close,0,0.29311025,<mask>(),"byte[] decode(byte[] pArray) {<mask>();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2937,Base64.java,decode,byte[] decode(byte[] pArray),733,734,28824,28828,MethodCallMutator,reset,flush,1,0.22567762,<mask>(),"byte[] decode(byte[] pArray) {<mask>();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2938,Base64.java,decode,byte[] decode(byte[] pArray),733,734,28824,28828,MethodCallMutator,reset,cleanup,2,0.040211882,<mask>(),"byte[] decode(byte[] pArray) {<mask>();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2939,Base64.java,decode,byte[] decode(byte[] pArray),733,734,28824,28828,MethodCallMutator,reset,init,4,0.019027384,<mask>(),"byte[] decode(byte[] pArray) {<mask>();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2940,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28859,28862,BinaryOperatorMutator,||,|,2,0.001427604,(pArray == null) <mask> (pArray.length == 0),"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null<mask>pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2941,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28859,28862,BinaryOperatorMutator,||,/,3,7.403621E-4,(pArray == null) <mask> (pArray.length == 0),"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null<mask>pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2942,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28859,28862,BinaryOperatorMutator,||,.,4,5.871437E-4,(pArray == null) <mask> (pArray.length == 0),"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null<mask>pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2943,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28851,28854,BinaryOperatorMutator,==,=,2,0.0023566228,pArray <mask> null,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray<mask>null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2944,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28851,28854,BinaryOperatorMutator,==,===,3,4.4237502E-4,pArray <mask> null,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray<mask>null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2945,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28851,28854,BinaryOperatorMutator,==,!=,4,3.2553056E-4,pArray <mask> null,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray<mask>null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2946,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28845,28850,IdentifierMutator-Variable,pArray,array,0,0.6440706,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2947,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28845,28850,IdentifierMutator-Variable,pArray,Array,1,0.15573049,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2948,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28845,28850,IdentifierMutator-Variable,pArray,p,2,0.020875828,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2949,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28845,28850,IdentifierMutator-Variable,pArray,buf,3,0.016114723,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2950,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28845,28850,IdentifierMutator-Variable,pArray,null,4,0.014322291,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2951,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28855,28858,IdentifierMutator-Literal,null,NULL,1,3.2657746E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2952,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28855,28858,IdentifierMutator-Literal,null,nil,2,2.4082862E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2953,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28855,28858,IdentifierMutator-Literal,null,undefined,3,5.1762367E-5,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2954,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28876,28879,BinaryOperatorMutator,==,<=,2,0.021815151,pArray.length <mask> 0,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length<mask>0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2955,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28876,28879,BinaryOperatorMutator,==,>,3,0.0137489615,pArray.length <mask> 0,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length<mask>0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2956,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28876,28879,BinaryOperatorMutator,==,=,4,0.0066935173,pArray.length <mask> 0,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length<mask>0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2957,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28863,28875,IdentifierMutator-Variable,pArray.length,len,0,0.6492807,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2958,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28863,28875,IdentifierMutator-Variable,pArray.length,pos,1,0.13718276,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2959,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28863,28875,IdentifierMutator-Variable,pArray.length,length,2,0.044427995,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2960,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28863,28875,IdentifierMutator-Variable,pArray.length,size,3,0.013606399,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2961,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28863,28875,IdentifierMutator-Variable,pArray.length,n,4,0.011469467,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2962,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28863,28868,IdentifierMutator-Variable,pArray,array,0,0.654248,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2963,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28863,28868,IdentifierMutator-Variable,pArray,Array,1,0.12155765,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2964,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28863,28868,IdentifierMutator-Variable,pArray,Array,2,0.10531302,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2965,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28863,28868,IdentifierMutator-Variable,pArray,p,3,0.055892926,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2966,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28863,28868,IdentifierMutator-Variable,pArray,arr,4,0.022102147,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2967,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28870,28875,FieldReferenceMutator,length,size,1,1.00654135E-4,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.<mask> == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2968,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28870,28875,FieldReferenceMutator,length,count,2,7.356181E-5,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.<mask> == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2969,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28870,28875,FieldReferenceMutator,length,len,4,5.5381715E-5,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.<mask> == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2970,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28880,28880,IdentifierMutator-Literal,0,1,1,0.0038162712,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2971,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28880,28880,IdentifierMutator-Literal,0,3,2,0.0034057563,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2972,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28880,28880,IdentifierMutator-Literal,0,4,3,0.002279608,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2973,Base64.java,decode,byte[] decode(byte[] pArray),733,735,28880,28880,IdentifierMutator-Literal,0,2,4,7.9594256E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2974,Base64.java,decode,byte[] decode(byte[] pArray),733,736,28904,28909,IdentifierMutator-Variable,pArray,null,0,0.90077907,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2975,Base64.java,decode,byte[] decode(byte[] pArray),733,736,28904,28909,IdentifierMutator-Variable,pArray,"""""",1,0.01694632,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2976,Base64.java,decode,byte[] decode(byte[] pArray),733,736,28904,28909,IdentifierMutator-Variable,pArray,array,2,0.012491131,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2977,Base64.java,decode,byte[] decode(byte[] pArray),733,736,28904,28909,IdentifierMutator-Variable,pArray,[],3,0.008028291,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2978,Base64.java,decode,byte[] decode(byte[] pArray),733,736,28904,28909,IdentifierMutator-Variable,pArray,false,4,0.0068730284,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2979,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28960,28962,BinaryOperatorMutator,/,*,0,0.38207403,(pArray.length * 3) <mask> 4,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3)<mask>4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2980,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28960,28962,BinaryOperatorMutator,/,**,2,0.10835841,(pArray.length * 3) <mask> 4,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3)<mask>4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2981,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28960,28962,BinaryOperatorMutator,/,^,4,0.04042175,(pArray.length * 3) <mask> 4,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3)<mask>4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2982,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28955,28957,BinaryOperatorMutator,*,/,2,0.11176675,pArray.length <mask> 3,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length<mask>3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2983,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28955,28957,BinaryOperatorMutator,*,**,3,0.10790839,pArray.length <mask> 3,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length<mask>3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2984,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28955,28957,BinaryOperatorMutator,*,+,4,0.062860705,pArray.length <mask> 3,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length<mask>3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2985,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28942,28954,IdentifierMutator-Variable,pArray.length,pos,0,0.7825447,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask> * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2986,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28942,28954,IdentifierMutator-Variable,pArray.length,len,1,0.03910921,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask> * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2987,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28942,28954,IdentifierMutator-Variable,pArray.length,size,2,0.017186545,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask> * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2988,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28942,28954,IdentifierMutator-Variable,pArray.length,length,3,0.013432003,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask> * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2989,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28942,28954,IdentifierMutator-Variable,pArray.length,position,4,0.008809444,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask> * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2990,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28942,28947,IdentifierMutator-Variable,pArray,Array,0,0.73206896,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask>.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2991,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28942,28947,IdentifierMutator-Variable,pArray,array,1,0.14223102,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask>.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2992,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28942,28947,IdentifierMutator-Variable,pArray,buf,2,0.045471475,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask>.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2993,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28942,28947,IdentifierMutator-Variable,pArray,buffer,3,0.013771095,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask>.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2994,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28942,28947,IdentifierMutator-Variable,pArray,Buffer,4,0.011538839,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask>.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2995,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28949,28954,FieldReferenceMutator,length,size,1,1.8882744E-4,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.<mask> * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2996,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28949,28954,FieldReferenceMutator,length,len,3,4.3324453E-5,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.<mask> * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2997,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28949,28954,FieldReferenceMutator,length,Length,4,3.256458E-5,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.<mask> * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2998,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28958,28958,IdentifierMutator-Literal,3,4,0,0.7973908,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length *<mask>) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2999,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28958,28958,IdentifierMutator-Literal,3,2,1,0.09884618,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length *<mask>) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3000,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28958,28958,IdentifierMutator-Literal,3,8,3,0.020916928,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length *<mask>) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3001,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28958,28958,IdentifierMutator-Literal,3,5,4,0.010882504,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length *<mask>) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3002,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28963,28963,IdentifierMutator-Literal,4,3,0,0.4723877,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) /<mask>;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3003,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28963,28963,IdentifierMutator-Literal,4,2,2,0.1703532,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) /<mask>;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3004,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28963,28963,IdentifierMutator-Literal,4,5,3,0.012801542,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) /<mask>;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3005,Base64.java,decode,byte[] decode(byte[] pArray),733,738,28963,28963,IdentifierMutator-Literal,4,8,4,0.009204588,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) /<mask>;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3006,Base64.java,decode,byte[] decode(byte[] pArray),733,739,28996,29004,IdentifierMutator-Variable,((int)(len)),len,0,0.97318876,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3007,Base64.java,decode,byte[] decode(byte[] pArray),733,739,28996,29004,IdentifierMutator-Variable,((int)(len)),Len,1,0.012246223,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3008,Base64.java,decode,byte[] decode(byte[] pArray),733,739,28996,29004,IdentifierMutator-Variable,((int)(len)),len,2,0.0025785384,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3009,Base64.java,decode,byte[] decode(byte[] pArray),733,739,28996,29004,IdentifierMutator-Variable,((int)(len)),8,3,9.5274363E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3010,Base64.java,decode,byte[] decode(byte[] pArray),733,739,28996,29004,IdentifierMutator-Variable,((int)(len)),pos,4,9.202035E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3011,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29016,29031,MethodCallMutator,setInitialBuffer,decode,0,0.75707847,"<mask>(buf, 0, buf.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3012,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29016,29031,MethodCallMutator,setInitialBuffer,encode,1,0.15612443,"<mask>(buf, 0, buf.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3013,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29016,29031,MethodCallMutator,setInitialBuffer,write,2,0.045522977,"<mask>(buf, 0, buf.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3014,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29016,29031,MethodCallMutator,setInitialBuffer,read,3,0.008943793,"<mask>(buf, 0, buf.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3015,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29016,29031,MethodCallMutator,setInitialBuffer,copy,4,0.005535366,"<mask>(buf, 0, buf.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3016,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29033,29035,IdentifierMutator-Variable,buf,buffer,1,0.0077944896,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(<mask>, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3017,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29033,29035,IdentifierMutator-Variable,buf,buff,2,0.001584308,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(<mask>, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3018,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29033,29035,IdentifierMutator-Variable,buf,uf,4,4.233095E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(<mask>, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3019,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29038,29038,IdentifierMutator-Literal,0,len,1,0.022269534,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf,<mask>, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3020,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29038,29038,IdentifierMutator-Literal,0,pos,2,0.004915987,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf,<mask>, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3021,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29038,29038,IdentifierMutator-Literal,0,1,3,0.0020303703,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf,<mask>, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3022,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29038,29038,IdentifierMutator-Literal,0,2,4,0.0017054862,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf,<mask>, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3023,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29041,29050,IdentifierMutator-Variable,buf.length,len,0,0.96348965,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3024,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29041,29050,IdentifierMutator-Variable,buf.length,0,1,0.022022992,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3025,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29041,29050,IdentifierMutator-Variable,buf.length,pos,2,0.003061171,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3026,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29041,29050,IdentifierMutator-Variable,buf.length,length,3,9.949489E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3027,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29041,29050,IdentifierMutator-Variable,buf.length,1,4,9.2737755E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3028,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29041,29043,IdentifierMutator-Variable,buf,buffer,1,0.00790834,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3029,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29041,29043,IdentifierMutator-Variable,buf,array,3,8.9608645E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3030,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29041,29043,IdentifierMutator-Variable,buf,Buffer,4,5.894584E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3031,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29045,29050,FieldReferenceMutator,length,position,1,2.5898602E-4,buf.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.<mask>);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3032,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29045,29050,FieldReferenceMutator,length,capacity,2,1.1189465E-4,buf.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.<mask>);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3033,Base64.java,decode,byte[] decode(byte[] pArray),733,740,29045,29050,FieldReferenceMutator,length,limit,4,5.524563E-5,buf.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.<mask>);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3034,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29062,29067,MethodCallMutator,decode,encode,0,0.57853675,"<mask>(pArray, 0, pArray.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);<mask>(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3035,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29062,29067,MethodCallMutator,decode,write,2,0.060283706,"<mask>(pArray, 0, pArray.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);<mask>(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3036,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29062,29067,MethodCallMutator,decode,read,3,0.010713613,"<mask>(pArray, 0, pArray.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);<mask>(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3037,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29062,29067,MethodCallMutator,decode,copy,4,0.0045376318,"<mask>(pArray, 0, pArray.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);<mask>(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3038,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29069,29074,IdentifierMutator-Variable,pArray,buf,0,0.9961629,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(<mask>, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3039,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29069,29074,IdentifierMutator-Variable,pArray,buff,1,0.0019237438,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(<mask>, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3040,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29069,29074,IdentifierMutator-Variable,pArray,buffer,2,8.664793E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(<mask>, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3041,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29069,29074,IdentifierMutator-Variable,pArray,buf,3,2.1638506E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(<mask>, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3042,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29069,29074,IdentifierMutator-Variable,pArray,uf,4,2.0816692E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(<mask>, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3043,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29077,29077,IdentifierMutator-Literal,0,1,1,0.018857978,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray,<mask>, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3044,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29077,29077,IdentifierMutator-Literal,0,2,2,0.008514455,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray,<mask>, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3045,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29077,29077,IdentifierMutator-Literal,0,pos,3,0.002415152,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray,<mask>, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3046,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29077,29077,IdentifierMutator-Literal,0,4,4,0.0017652753,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray,<mask>, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3047,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29080,29092,IdentifierMutator-Variable,pArray.length,buf,0,0.739257,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3048,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29080,29092,IdentifierMutator-Variable,pArray.length,0,1,0.1110485,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3049,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29080,29092,IdentifierMutator-Variable,pArray.length,len,2,0.03518577,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3050,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29080,29092,IdentifierMutator-Variable,pArray.length,1,3,0.026180904,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3051,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29080,29092,IdentifierMutator-Variable,pArray.length,pos,4,0.025970452,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3052,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29080,29085,IdentifierMutator-Variable,pArray,buf,0,0.99489355,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3053,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29080,29085,IdentifierMutator-Variable,pArray,buf,1,0.0019086293,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3054,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29080,29085,IdentifierMutator-Variable,pArray,buffer,2,0.0018892701,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3055,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29080,29085,IdentifierMutator-Variable,pArray,buff,3,2.3934359E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3056,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29080,29085,IdentifierMutator-Variable,pArray,tmp,4,5.5140918E-5,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3057,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29087,29092,FieldReferenceMutator,length,position,1,6.5589865E-4,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3058,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29087,29092,FieldReferenceMutator,length,count,2,1.07720836E-4,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3059,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29087,29092,FieldReferenceMutator,length,offset,3,7.518692E-5,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3060,Base64.java,decode,byte[] decode(byte[] pArray),733,741,29087,29092,FieldReferenceMutator,length,buffer,4,7.3997544E-5,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3061,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29104,29109,MethodCallMutator,decode,encode,1,0.2324727,"<mask>(pArray, 0, -1)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3062,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29104,29109,MethodCallMutator,decode,write,2,0.107024305,"<mask>(pArray, 0, -1)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3063,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29104,29109,MethodCallMutator,decode,read,3,0.028653799,"<mask>(pArray, 0, -1)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3064,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29104,29109,MethodCallMutator,decode,end,4,0.015619144,"<mask>(pArray, 0, -1)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3065,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29111,29116,IdentifierMutator-Variable,pArray,buf,0,0.9869573,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(<mask>, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3066,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29111,29116,IdentifierMutator-Variable,pArray,buffer,1,0.0026390755,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(<mask>, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3067,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29111,29116,IdentifierMutator-Variable,pArray,buff,2,0.002300166,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(<mask>, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3068,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29111,29116,IdentifierMutator-Variable,pArray,buf,3,6.250636E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(<mask>, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3069,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29111,29116,IdentifierMutator-Variable,pArray,uf,4,5.632952E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(<mask>, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3070,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29119,29119,IdentifierMutator-Literal,0,pos,1,0.24137343,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray,<mask>, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3071,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29119,29119,IdentifierMutator-Literal,0,buf,2,0.1430198,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray,<mask>, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3072,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29119,29119,IdentifierMutator-Literal,0,1,3,0.04150583,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray,<mask>, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3073,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29119,29119,IdentifierMutator-Literal,0,2,4,0.013553122,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray,<mask>, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3074,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29122,29122,UnaryOperatorMutator,-,pos,0,0.38719437,<mask>1,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0,<mask>1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3075,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29122,29122,UnaryOperatorMutator,-,len,2,0.029224245,<mask>1,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0,<mask>1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3076,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29122,29122,UnaryOperatorMutator,-,+,3,0.027765863,<mask>1,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0,<mask>1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3077,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29122,29122,UnaryOperatorMutator,-,buf,4,0.024901174,<mask>1,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0,<mask>1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3078,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29123,29123,IdentifierMutator-Literal,1,len,2,0.020640587,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -<mask>); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3079,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29123,29123,IdentifierMutator-Literal,1,2,3,0.012736833,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -<mask>); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3080,Base64.java,decode,byte[] decode(byte[] pArray),733,742,29123,29123,IdentifierMutator-Literal,1,pos,4,0.007357698,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -<mask>); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3081,Base64.java,decode,byte[] decode(byte[] pArray),733,750,29540,29542,IdentifierMutator-Variable,pos,2,0,0.18372501,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3082,Base64.java,decode,byte[] decode(byte[] pArray),733,750,29540,29542,IdentifierMutator-Variable,pos,32,1,0.07036458,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3083,Base64.java,decode,byte[] decode(byte[] pArray),733,750,29540,29542,IdentifierMutator-Variable,pos,4,2,0.060960602,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3084,Base64.java,decode,byte[] decode(byte[] pArray),733,750,29540,29542,IdentifierMutator-Variable,pos,3,3,0.047790106,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3085,Base64.java,decode,byte[] decode(byte[] pArray),733,750,29540,29542,IdentifierMutator-Variable,pos,1,4,0.046757415,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3086,Base64.java,decode,byte[] decode(byte[] pArray),733,750,29540,29542,FieldReferenceMutator,pos,2,0,0.18372501,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3087,Base64.java,decode,byte[] decode(byte[] pArray),733,750,29540,29542,FieldReferenceMutator,pos,32,1,0.07036458,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3088,Base64.java,decode,byte[] decode(byte[] pArray),733,750,29540,29542,FieldReferenceMutator,pos,4,2,0.060960602,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3089,Base64.java,decode,byte[] decode(byte[] pArray),733,750,29540,29542,FieldReferenceMutator,pos,3,3,0.047790106,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3090,Base64.java,decode,byte[] decode(byte[] pArray),733,750,29540,29542,FieldReferenceMutator,pos,1,4,0.046757415,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3091,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29554,29564,MethodCallMutator,readResults,decode,0,0.8743439,"<mask>(result, 0, result.length)","     return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];<mask>(result, 0, result.length);
        return result;
    }"
3092,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29554,29564,MethodCallMutator,readResults,encode,1,0.06933877,"<mask>(result, 0, result.length)","     return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];<mask>(result, 0, result.length);
        return result;
    }"
3093,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29554,29564,MethodCallMutator,readResults,write,2,0.013498469,"<mask>(result, 0, result.length)","     return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];<mask>(result, 0, result.length);
        return result;
    }"
3094,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29554,29564,MethodCallMutator,readResults,copy,3,0.0070073027,"<mask>(result, 0, result.length)","     return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];<mask>(result, 0, result.length);
        return result;
    }"
3095,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29554,29564,MethodCallMutator,readResults,get,4,0.0034166859,"<mask>(result, 0, result.length)","     return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];<mask>(result, 0, result.length);
        return result;
    }"
3096,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29566,29571,IdentifierMutator-Variable,result,buf,1,0.01754705,<mask>,"      }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(<mask>, 0, result.length);
        return result;
    }"
3097,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29566,29571,IdentifierMutator-Variable,result,buffer,2,0.013947579,<mask>,"      }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(<mask>, 0, result.length);
        return result;
    }"
3098,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29566,29571,IdentifierMutator-Variable,result,Result,3,0.0017252263,<mask>,"      }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(<mask>, 0, result.length);
        return result;
    }"
3099,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29574,29574,IdentifierMutator-Literal,0,pos,0,0.5303586,<mask>,"    }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result,<mask>, result.length);
        return result;
    }"
3100,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29574,29574,IdentifierMutator-Literal,0,buf,2,0.04631783,<mask>,"    }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result,<mask>, result.length);
        return result;
    }"
3101,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29574,29574,IdentifierMutator-Literal,0,position,3,0.009556857,<mask>,"    }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result,<mask>, result.length);
        return result;
    }"
3102,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29574,29574,IdentifierMutator-Literal,0,1,4,0.0064126896,<mask>,"    }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result,<mask>, result.length);
        return result;
    }"
3103,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29577,29589,IdentifierMutator-Variable,result.length,pos,0,0.8234639,<mask>,"  }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0,<mask>);
        return result;
    }"
3104,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29577,29589,IdentifierMutator-Variable,result.length,buf,1,0.05307799,<mask>,"  }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0,<mask>);
        return result;
    }"
3105,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29577,29589,IdentifierMutator-Variable,result.length,len,2,0.010301085,<mask>,"  }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0,<mask>);
        return result;
    }"
3106,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29577,29589,IdentifierMutator-Variable,result.length,position,3,0.008760195,<mask>,"  }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0,<mask>);
        return result;
    }"
3107,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29577,29589,IdentifierMutator-Variable,result.length,result,4,0.008323859,<mask>,"  }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0,<mask>);
        return result;
    }"
3108,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29577,29582,IdentifierMutator-Variable,result,Result,2,0.0022663448,<mask>,"  }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0,<mask>.length);
        return result;
    }"
3109,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29577,29582,IdentifierMutator-Variable,result,buf,3,0.0019676678,<mask>,"  }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0,<mask>.length);
        return result;
    }"
3110,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29577,29582,IdentifierMutator-Variable,result,results,4,0.0013248664,<mask>,"  }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0,<mask>.length);
        return result;
    }"
3111,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29584,29589,FieldReferenceMutator,length,class,2,8.59496E-5,result.<mask>,"
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.<mask>);
        return result;
    }"
3112,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29584,29589,FieldReferenceMutator,length,shape,3,2.2123924E-5,result.<mask>,"
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.<mask>);
        return result;
    }"
3113,Base64.java,decode,byte[] decode(byte[] pArray),733,751,29584,29589,FieldReferenceMutator,length,read,4,2.1257874E-5,result.<mask>,"
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.<mask>);
        return result;
    }"
3114,Base64.java,decode,byte[] decode(byte[] pArray),733,752,29608,29613,IdentifierMutator-Variable,result,buf,1,0.001439841,<mask>," (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return<mask>;
    }"
3115,Base64.java,decode,byte[] decode(byte[] pArray),733,752,29608,29613,IdentifierMutator-Variable,result,null,2,9.912705E-4,<mask>," (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return<mask>;
    }"
3116,Base64.java,decode,byte[] decode(byte[] pArray),733,752,29608,29613,IdentifierMutator-Variable,result,buffer,3,8.04314E-4,<mask>," (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return<mask>;
    }"
3117,Base64.java,decode,byte[] decode(byte[] pArray),733,752,29608,29613,IdentifierMutator-Variable,result,true,4,4.7972254E-4,<mask>," (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return<mask>;
    }"
3118,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30248,30259,MethodCallMutator,encodeBase64,encode,0,0.96945983,"<mask>(binaryData, isChunked, false)","byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return<mask>(binaryData, isChunked, false);
    }"
3119,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30248,30259,MethodCallMutator,encodeBase64,decode,1,0.017711729,"<mask>(binaryData, isChunked, false)","byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return<mask>(binaryData, isChunked, false);
    }"
3120,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30248,30259,MethodCallMutator,encodeBase64,convert,2,0.0014596981,"<mask>(binaryData, isChunked, false)","byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return<mask>(binaryData, isChunked, false);
    }"
3121,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30248,30259,MethodCallMutator,encodeBase64,encrypt,3,0.0013073772,"<mask>(binaryData, isChunked, false)","byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return<mask>(binaryData, isChunked, false);
    }"
3122,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30248,30259,MethodCallMutator,encodeBase64,write,4,7.6936977E-4,"<mask>(binaryData, isChunked, false)","byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return<mask>(binaryData, isChunked, false);
    }"
3123,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30261,30270,IdentifierMutator-Variable,binaryData,data,0,0.6559646,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(<mask>, isChunked, false);
    }"
3124,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30261,30270,IdentifierMutator-Variable,binaryData,binary,1,0.2709676,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(<mask>, isChunked, false);
    }"
3125,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30261,30270,IdentifierMutator-Variable,binaryData,bytes,2,0.011036762,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(<mask>, isChunked, false);
    }"
3126,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30261,30270,IdentifierMutator-Variable,binaryData,bin,3,0.00727332,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(<mask>, isChunked, false);
    }"
3127,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30261,30270,IdentifierMutator-Variable,binaryData,null,4,0.006988416,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(<mask>, isChunked, false);
    }"
3128,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30273,30281,IdentifierMutator-Variable,isChunked,true,0,0.3742739,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData,<mask>, false);
    }"
3129,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30273,30281,IdentifierMutator-Variable,isChunked,false,1,0.21662262,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData,<mask>, false);
    }"
3130,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30273,30281,IdentifierMutator-Variable,isChunked,chunk,2,0.067907944,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData,<mask>, false);
    }"
3131,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30273,30281,IdentifierMutator-Variable,isChunked,null,3,0.051294964,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData,<mask>, false);
    }"
3132,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30273,30281,IdentifierMutator-Variable,isChunked,encoding,4,0.037491746,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData,<mask>, false);
    }"
3133,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30284,30288,IdentifierMutator-Literal,false,true,0,0.41044897,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData, isChunked,<mask>);
    }"
3134,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30284,30288,IdentifierMutator-Literal,false,null,2,0.05827159,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData, isChunked,<mask>);
    }"
3135,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30284,30288,IdentifierMutator-Literal,false,encoding,3,0.040970728,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData, isChunked,<mask>);
    }"
3136,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",766,767,30284,30288,IdentifierMutator-Literal,false,0,4,0.02338439,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData, isChunked,<mask>);
    }"
3137,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31092,31103,MethodCallMutator,encodeBase64,encode,0,0.97584516,"<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3138,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31092,31103,MethodCallMutator,encodeBase64,decode,1,0.013778917,"<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3139,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31092,31103,MethodCallMutator,encodeBase64,encrypt,2,0.0018567225,"<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3140,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31092,31103,MethodCallMutator,encodeBase64,convert,3,9.6652255E-4,"<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3141,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31092,31103,MethodCallMutator,encodeBase64,encoded,4,6.6856673E-4,"<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3142,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31105,31114,IdentifierMutator-Variable,binaryData,binary,0,0.4719807,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(<mask>, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3143,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31105,31114,IdentifierMutator-Variable,binaryData,data,1,0.46579558,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(<mask>, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3144,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31105,31114,IdentifierMutator-Variable,binaryData,bytes,2,0.010550368,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(<mask>, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3145,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31105,31114,IdentifierMutator-Variable,binaryData,this,3,0.008777915,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(<mask>, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3146,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31105,31114,IdentifierMutator-Variable,binaryData,bin,4,0.0063010533,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(<mask>, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3147,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31117,31125,IdentifierMutator-Variable,isChunked,chunk,0,0.33446503,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData,<mask>, urlSafe, Integer.MAX_VALUE);
    }"
3148,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31117,31125,IdentifierMutator-Variable,isChunked,true,1,0.20736079,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData,<mask>, urlSafe, Integer.MAX_VALUE);
    }"
3149,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31117,31125,IdentifierMutator-Variable,isChunked,false,2,0.19937013,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData,<mask>, urlSafe, Integer.MAX_VALUE);
    }"
3150,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31117,31125,IdentifierMutator-Variable,isChunked,chunks,3,0.04113835,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData,<mask>, urlSafe, Integer.MAX_VALUE);
    }"
3151,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31117,31125,IdentifierMutator-Variable,isChunked,encoded,4,0.021251934,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData,<mask>, urlSafe, Integer.MAX_VALUE);
    }"
3152,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31128,31134,IdentifierMutator-Variable,urlSafe,url,0,0.3277066,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked,<mask>, Integer.MAX_VALUE);
    }"
3153,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31128,31134,IdentifierMutator-Variable,urlSafe,false,1,0.29387927,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked,<mask>, Integer.MAX_VALUE);
    }"
3154,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31128,31134,IdentifierMutator-Variable,urlSafe,true,2,0.25466722,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked,<mask>, Integer.MAX_VALUE);
    }"
3155,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31128,31134,IdentifierMutator-Variable,urlSafe,null,3,0.05202581,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked,<mask>, Integer.MAX_VALUE);
    }"
3156,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31128,31134,IdentifierMutator-Variable,urlSafe,0,4,0.011407451,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked,<mask>, Integer.MAX_VALUE);
    }"
3157,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31137,31153,IdentifierMutator-Variable,java.lang.Integer.MAX_VALUE,true,0,0.46313015,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe,<mask>);
    }"
3158,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31137,31153,IdentifierMutator-Variable,java.lang.Integer.MAX_VALUE,false,1,0.30426246,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe,<mask>);
    }"
3159,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31137,31153,IdentifierMutator-Variable,java.lang.Integer.MAX_VALUE,null,2,0.05156211,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe,<mask>);
    }"
3160,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31137,31153,IdentifierMutator-Variable,java.lang.Integer.MAX_VALUE,encoding,3,0.046732217,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe,<mask>);
    }"
3161,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31137,31153,IdentifierMutator-Variable,java.lang.Integer.MAX_VALUE,0,4,0.012317601,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe,<mask>);
    }"
3162,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31145,31153,FieldReferenceMutator,MAX_VALUE,MAX,0,0.81098574,java.lang.Integer.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe, Integer.<mask>);
    }"
3163,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31145,31153,FieldReferenceMutator,MAX_VALUE,class,1,0.040453304,java.lang.Integer.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe, Integer.<mask>);
    }"
3164,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31145,31153,FieldReferenceMutator,MAX_VALUE,MIN,2,0.035998788,java.lang.Integer.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe, Integer.<mask>);
    }"
3165,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31145,31153,FieldReferenceMutator,MAX_VALUE,VALUE,3,0.026722755,java.lang.Integer.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe, Integer.<mask>);
    }"
3166,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",784,785,31145,31153,FieldReferenceMutator,MAX_VALUE,SIZE,4,0.0136624,java.lang.Integer.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe, Integer.<mask>);
    }"
3167,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32060,32063,BinaryOperatorMutator,||,/,2,0.005513404,(binaryData == null) <mask> (binaryData.length == 0),"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null<mask>binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3168,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32060,32063,BinaryOperatorMutator,||,|,3,0.004834904,(binaryData == null) <mask> (binaryData.length == 0),"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null<mask>binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3169,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32060,32063,BinaryOperatorMutator,||,.,4,0.0011687954,(binaryData == null) <mask> (binaryData.length == 0),"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null<mask>binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3170,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32052,32055,BinaryOperatorMutator,==,=,2,0.0018032846,binaryData <mask> null,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData<mask>null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3171,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32052,32055,BinaryOperatorMutator,==,===,3,2.123499E-4,binaryData <mask> null,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData<mask>null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3172,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32052,32055,BinaryOperatorMutator,==,!=,4,1.6308347E-4,binaryData <mask> null,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData<mask>null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3173,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32042,32051,IdentifierMutator-Variable,binaryData,data,0,0.6846548,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (<mask> == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3174,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32042,32051,IdentifierMutator-Variable,binaryData,binary,1,0.075843774,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (<mask> == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3175,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32042,32051,IdentifierMutator-Variable,binaryData,input,2,0.037709523,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (<mask> == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3176,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32042,32051,IdentifierMutator-Variable,binaryData,bytes,3,0.014730184,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (<mask> == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3177,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32042,32051,IdentifierMutator-Variable,binaryData,null,4,0.014099972,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (<mask> == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3178,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32056,32059,IdentifierMutator-Literal,null,NULL,1,2.8594543E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData ==<mask> || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3179,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32056,32059,IdentifierMutator-Literal,null,nil,2,1.2392618E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData ==<mask> || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3180,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32056,32059,IdentifierMutator-Literal,null,undefined,4,2.5577001E-5,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData ==<mask> || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3181,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32081,32084,BinaryOperatorMutator,==,>,2,0.0434223,binaryData.length <mask> 0,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length<mask>0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3182,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32081,32084,BinaryOperatorMutator,==,<=,3,0.015858267,binaryData.length <mask> 0,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length<mask>0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3183,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32081,32084,BinaryOperatorMutator,==,=,4,0.012013998,binaryData.length <mask> 0,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length<mask>0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3184,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32064,32080,IdentifierMutator-Variable,binaryData.length,len,0,0.8343025,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3185,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32064,32080,IdentifierMutator-Variable,binaryData.length,length,1,0.102243446,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3186,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32064,32080,IdentifierMutator-Variable,binaryData.length,size,2,0.01954414,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3187,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32064,32080,IdentifierMutator-Variable,binaryData.length,count,3,0.006644811,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3188,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32064,32080,IdentifierMutator-Variable,binaryData.length,n,4,0.0024149641,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3189,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32064,32073,IdentifierMutator-Variable,binaryData,data,0,0.57785994,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask>.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3190,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32064,32073,IdentifierMutator-Variable,binaryData,bytes,1,0.100990154,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask>.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3191,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32064,32073,IdentifierMutator-Variable,binaryData,input,2,0.0647768,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask>.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3192,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32064,32073,IdentifierMutator-Variable,binaryData,arguments,3,0.060042646,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask>.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3193,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32064,32073,IdentifierMutator-Variable,binaryData,buffer,4,0.041799277,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask>.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3194,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32075,32080,FieldReferenceMutator,length,len,2,1.659158E-4,binaryData.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3195,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32075,32080,FieldReferenceMutator,length,size,3,7.590603E-5,binaryData.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3196,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32075,32080,FieldReferenceMutator,length,Length,4,4.646419E-5,binaryData.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3197,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32085,32085,IdentifierMutator-Literal,0,1,1,0.002286727,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length ==<mask>) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3198,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32085,32085,IdentifierMutator-Literal,0,length,2,7.6405273E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length ==<mask>) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3199,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32085,32085,IdentifierMutator-Literal,0,512,3,6.4358837E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length ==<mask>) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3200,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,805,32085,32085,IdentifierMutator-Literal,0,size,4,5.80814E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length ==<mask>) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3201,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,806,32109,32118,IdentifierMutator-Variable,binaryData,null,0,0.88793594,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return<mask>;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3202,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,806,32109,32118,IdentifierMutator-Variable,binaryData,"""""",1,0.06073041,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return<mask>;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3203,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,806,32109,32118,IdentifierMutator-Variable,binaryData,bytes,2,0.006368174,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return<mask>;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3204,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,806,32109,32118,IdentifierMutator-Variable,binaryData,NULL,3,0.006117436,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return<mask>;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3205,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,806,32109,32118,IdentifierMutator-Variable,binaryData,"''",4,0.004637158,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return<mask>;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3206,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32151,32165,MethodCallMutator,getEncodeLength,encode,0,0.35341853,"<mask>(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len =<mask>(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3207,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32151,32165,MethodCallMutator,getEncodeLength,len,1,0.19772491,"<mask>(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len =<mask>(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3208,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32151,32165,MethodCallMutator,getEncodeLength,length,2,0.082717806,"<mask>(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len =<mask>(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3209,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32151,32165,MethodCallMutator,getEncodeLength,decode,3,0.056109104,"<mask>(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len =<mask>(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3210,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32151,32165,MethodCallMutator,getEncodeLength,size,4,0.035552848,"<mask>(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len =<mask>(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3211,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32167,32176,IdentifierMutator-Variable,binaryData,input,0,0.3853428,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(<mask>, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3212,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32167,32176,IdentifierMutator-Variable,binaryData,data,1,0.1833335,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(<mask>, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3213,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32167,32176,IdentifierMutator-Variable,binaryData,array,2,0.044193484,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(<mask>, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3214,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32167,32176,IdentifierMutator-Variable,binaryData,in,3,0.04182663,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(<mask>, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3215,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32167,32176,IdentifierMutator-Variable,binaryData,bytes,4,0.038405195,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(<mask>, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3216,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32179,32188,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SIZE,0,0,0.58408165,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3217,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32179,32188,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SIZE,true,1,0.079815425,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3218,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32179,32188,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SIZE,false,2,0.06417632,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3219,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32179,32188,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SIZE,null,3,0.015368145,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3220,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32179,32188,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SIZE,encoding,4,0.009270011,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3221,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32179,32188,FieldReferenceMutator,CHUNK_SIZE,0,0,0.58408165,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3222,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32179,32188,FieldReferenceMutator,CHUNK_SIZE,true,1,0.079815425,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3223,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32179,32188,FieldReferenceMutator,CHUNK_SIZE,false,2,0.06417632,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3224,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32179,32188,FieldReferenceMutator,CHUNK_SIZE,null,3,0.015368145,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3225,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32179,32188,FieldReferenceMutator,CHUNK_SIZE,encoding,4,0.009270011,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3226,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32191,32205,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,true,0,0.44191638,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3227,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32191,32205,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,false,1,0.25328088,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3228,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32191,32205,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,0,2,0.035557114,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3229,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32191,32205,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,encoding,3,0.015597109,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3230,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32191,32205,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,null,4,0.011833278,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3231,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32191,32205,FieldReferenceMutator,CHUNK_SEPARATOR,true,0,0.44191638,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3232,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32191,32205,FieldReferenceMutator,CHUNK_SEPARATOR,false,1,0.25328088,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3233,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32191,32205,FieldReferenceMutator,CHUNK_SEPARATOR,0,2,0.035557114,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3234,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32191,32205,FieldReferenceMutator,CHUNK_SEPARATOR,encoding,3,0.015597109,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3235,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,809,32191,32205,FieldReferenceMutator,CHUNK_SEPARATOR,null,4,0.011833278,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3236,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,810,32224,32226,BinaryOperatorMutator,>,<,2,0.023840997,len <mask> maxResultSize,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len<mask>maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3237,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,810,32224,32226,BinaryOperatorMutator,>,>=,3,0.01601852,len <mask> maxResultSize,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len<mask>maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3238,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,810,32224,32226,BinaryOperatorMutator,>,<=,4,0.00499191,len <mask> maxResultSize,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len<mask>maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3239,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,810,32221,32223,IdentifierMutator-Variable,len,Len,2,2.7088827E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (<mask> > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3240,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,810,32221,32223,IdentifierMutator-Variable,len,length,3,5.3054828E-5,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (<mask> > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3241,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,810,32221,32223,IdentifierMutator-Variable,len,en,4,2.6407204E-5,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (<mask> > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3242,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,810,32227,32239,IdentifierMutator-Variable,maxResultSize,max,0,0.27626842,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len ><mask>) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3243,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,810,32227,32239,IdentifierMutator-Variable,maxResultSize,1024,1,0.061727528,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len ><mask>) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3244,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,810,32227,32239,IdentifierMutator-Variable,maxResultSize,limit,2,0.05560293,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len ><mask>) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3245,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,810,32227,32239,IdentifierMutator-Variable,maxResultSize,512,3,0.05120521,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len ><mask>) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3246,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,810,32227,32239,IdentifierMutator-Variable,maxResultSize,64,4,0.04744912,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len ><mask>) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3247,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,813,32427,32445,BinaryOperatorMutator,+,"""+",2,0.051905937,"((""Input array too big, the output array would be bigger ("" + len) + "") than the specified maxium size of "") <mask> maxResultSize","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of ""<mask>maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3248,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,813,32427,32445,BinaryOperatorMutator,+,+(,3,0.006360943,"((""Input array too big, the output array would be bigger ("" + len) + "") than the specified maxium size of "") <mask> maxResultSize","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of ""<mask>maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3249,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,813,32427,32445,BinaryOperatorMutator,+,)+,4,6.130338E-4,"((""Input array too big, the output array would be bigger ("" + len) + "") than the specified maxium size of "") <mask> maxResultSize","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of ""<mask>maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3250,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,812,32370,32388,BinaryOperatorMutator,+,"\",2,0.004274368,"(""Input array too big, the output array would be bigger ("" + len) <mask> "") than the specified maxium size of ""","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len<mask>"") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3251,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,812,32370,32388,BinaryOperatorMutator,+,)+,3,0.0030717144,"(""Input array too big, the output array would be bigger ("" + len) <mask> "") than the specified maxium size of ""","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len<mask>"") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3252,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,812,32370,32388,BinaryOperatorMutator,+,"\",4,0.0012053845,"(""Input array too big, the output array would be bigger ("" + len) <mask> "") than the specified maxium size of ""","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len<mask>"") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3253,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,811,32348,32366,BinaryOperatorMutator,+,+(,2,0.001723163,"""Input array too big, the output array would be bigger ("" <mask> len","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger (""<mask>len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3254,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,811,32348,32366,BinaryOperatorMutator,+,"""+",3,7.1583193E-4,"""Input array too big, the output array would be bigger ("" <mask> len","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger (""<mask>len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3255,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,811,32348,32366,BinaryOperatorMutator,+,*,4,1.1483618E-4,"""Input array too big, the output array would be bigger ("" <mask> len","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger (""<mask>len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3256,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,811,32291,32347,IdentifierMutator-Literal,"""Inputarraytoobig,theoutputarraywouldbebigger(""","(""",0,0.5723723,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(<mask> +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3257,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,811,32291,32347,IdentifierMutator-Literal,"""Inputarraytoobig,theoutputarraywouldbebigger(""","""",1,0.057103187,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(<mask> +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3258,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,811,32291,32347,IdentifierMutator-Literal,"""Inputarraytoobig,theoutputarraywouldbebigger(""","{""",2,0.04291409,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(<mask> +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3259,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,811,32291,32347,IdentifierMutator-Literal,"""Inputarraytoobig,theoutputarraywouldbebigger(""","""""",3,0.040300027,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(<mask> +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3260,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,811,32291,32347,IdentifierMutator-Literal,"""Inputarraytoobig,theoutputarraywouldbebigger(""","""",4,0.033257306,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(<mask> +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3261,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,812,32367,32369,IdentifierMutator-Variable,len,length,1,9.002632E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +<mask> +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3262,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,812,32367,32369,IdentifierMutator-Variable,len,str,2,4.839666E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +<mask> +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3263,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,812,32367,32369,IdentifierMutator-Variable,len,"""""",4,3.6722294E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +<mask> +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3264,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,813,32389,32426,IdentifierMutator-Literal,""")thanthespecifiedmaxiumsizeof""",//,0,0.40369475,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +<mask> +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3265,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,813,32389,32426,IdentifierMutator-Literal,""")thanthespecifiedmaxiumsizeof""","""",1,0.14209723,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +<mask> +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3266,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,813,32389,32426,IdentifierMutator-Literal,""")thanthespecifiedmaxiumsizeof""",,2,0.061228722,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +<mask> +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3267,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,813,32389,32426,IdentifierMutator-Literal,""")thanthespecifiedmaxiumsizeof""",),3,0.056410473,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +<mask> +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3268,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,813,32389,32426,IdentifierMutator-Literal,""")thanthespecifiedmaxiumsizeof""","""""",4,0.05293273,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +<mask> +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3269,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,814,32446,32458,IdentifierMutator-Variable,maxResultSize,len,0,0.43280038,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +<mask>);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3270,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,814,32446,32458,IdentifierMutator-Variable,maxResultSize,size,1,0.090327516,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +<mask>);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3271,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,814,32446,32458,IdentifierMutator-Variable,maxResultSize,max,2,0.06769917,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +<mask>);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3272,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,814,32446,32458,IdentifierMutator-Variable,maxResultSize,1,3,0.036117792,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +<mask>);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3273,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,814,32446,32458,IdentifierMutator-Variable,maxResultSize,length,4,0.034054887,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +<mask>);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3274,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32510,32582,IdentifierMutator-Conditional,"(isChunked)?neworg.apache.commons.codec.binary.Base64(urlSafe):neworg.apache.commons.codec.binary.Base64(0,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,urlSafe)",null,0,0.8707608,<mask>,"byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask>;
        return b64.encode(binaryData);
    }"
3275,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32510,32582,IdentifierMutator-Conditional,"(isChunked)?neworg.apache.commons.codec.binary.Base64(urlSafe):neworg.apache.commons.codec.binary.Base64(0,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,urlSafe)",this,1,0.05551981,<mask>,"byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask>;
        return b64.encode(binaryData);
    }"
3276,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32510,32582,IdentifierMutator-Conditional,"(isChunked)?neworg.apache.commons.codec.binary.Base64(urlSafe):neworg.apache.commons.codec.binary.Base64(0,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,urlSafe)",NULL,2,0.020864613,<mask>,"byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask>;
        return b64.encode(binaryData);
    }"
3277,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32510,32582,IdentifierMutator-Conditional,"(isChunked)?neworg.apache.commons.codec.binary.Base64(urlSafe):neworg.apache.commons.codec.binary.Base64(0,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,urlSafe)","""""",3,0.009523718,<mask>,"byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask>;
        return b64.encode(binaryData);
    }"
3278,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32510,32582,IdentifierMutator-Conditional,"(isChunked)?neworg.apache.commons.codec.binary.Base64(urlSafe):neworg.apache.commons.codec.binary.Base64(0,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,urlSafe)",64,4,0.00247991,<mask>,"byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask>;
        return b64.encode(binaryData);
    }"
3279,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32510,32518,IdentifierMutator-Variable,isChunked,secure,0,0.23460151,<mask>,"byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask> ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3280,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32510,32518,IdentifierMutator-Variable,isChunked,safe,1,0.18841559,<mask>,"byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask> ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3281,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32510,32518,IdentifierMutator-Variable,isChunked,escaped,2,0.053986553,<mask>,"byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask> ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3282,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32510,32518,IdentifierMutator-Variable,isChunked,encoded,3,0.048843257,<mask>,"byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask> ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3283,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32510,32518,IdentifierMutator-Variable,isChunked,secured,4,0.0331558,<mask>,"byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask> ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3284,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32533,32539,IdentifierMutator-Variable,urlSafe,0,0,0.15418899,<mask>,"ed, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(<mask>) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3285,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32533,32539,IdentifierMutator-Variable,urlSafe,512,1,0.072115466,<mask>,"ed, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(<mask>) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3286,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32533,32539,IdentifierMutator-Variable,urlSafe,64,2,0.05408518,<mask>,"ed, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(<mask>) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3287,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32533,32539,IdentifierMutator-Variable,urlSafe,len,3,0.052351307,<mask>,"ed, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(<mask>) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3288,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32533,32539,IdentifierMutator-Variable,urlSafe,1024,4,0.043578357,<mask>,"ed, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(<mask>) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3289,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32555,32555,IdentifierMutator-Literal,0,data,0,0.25479066,<mask>,"ResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(<mask>, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3290,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32555,32555,IdentifierMutator-Literal,0,bytes,1,0.18567502,<mask>,"ResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(<mask>, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3291,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32555,32555,IdentifierMutator-Literal,0,string,2,0.04071277,<mask>,"ResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(<mask>, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3292,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32555,32555,IdentifierMutator-Literal,0,src,3,0.040581904,<mask>,"ResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(<mask>, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3293,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32555,32555,IdentifierMutator-Literal,0,binary,4,0.027675405,<mask>,"ResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(<mask>, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3294,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32558,32572,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,len,0,0.6382919,<mask>,") {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3295,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32558,32572,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,0,1,0.13012321,<mask>,") {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3296,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32558,32572,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,length,2,0.019825881,<mask>,") {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3297,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32558,32572,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,null,3,0.018968174,<mask>,") {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3298,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32558,32572,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,"''",4,0.013701015,<mask>,") {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3299,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32558,32572,FieldReferenceMutator,CHUNK_SEPARATOR,len,0,0.6382919,org.apache.commons.codec.binary.Base64.<mask>,") {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3300,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32558,32572,FieldReferenceMutator,CHUNK_SEPARATOR,0,1,0.13012321,org.apache.commons.codec.binary.Base64.<mask>,") {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3301,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32558,32572,FieldReferenceMutator,CHUNK_SEPARATOR,length,2,0.019825881,org.apache.commons.codec.binary.Base64.<mask>,") {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3302,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32558,32572,FieldReferenceMutator,CHUNK_SEPARATOR,null,3,0.018968174,org.apache.commons.codec.binary.Base64.<mask>,") {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3303,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32558,32572,FieldReferenceMutator,CHUNK_SEPARATOR,"''",4,0.013701015,org.apache.commons.codec.binary.Base64.<mask>,") {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3304,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32575,32581,IdentifierMutator-Variable,urlSafe,len,0,0.25918934,<mask>,"   if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR,<mask>);
        return b64.encode(binaryData);
    }"
3305,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32575,32581,IdentifierMutator-Variable,urlSafe,0,1,0.10612669,<mask>,"   if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR,<mask>);
        return b64.encode(binaryData);
    }"
3306,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32575,32581,IdentifierMutator-Variable,urlSafe,"''",2,0.054071672,<mask>,"   if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR,<mask>);
        return b64.encode(binaryData);
    }"
3307,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32575,32581,IdentifierMutator-Variable,urlSafe,true,3,0.048525084,<mask>,"   if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR,<mask>);
        return b64.encode(binaryData);
    }"
3308,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,817,32575,32581,IdentifierMutator-Variable,urlSafe,null,4,0.039569415,<mask>,"   if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR,<mask>);
        return b64.encode(binaryData);
    }"
3309,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,818,32604,32609,MethodCallMutator,encode,write,0,0.44001675,b64.<mask>(binaryData),") {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.<mask>(binaryData);
    }"
3310,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,818,32604,32609,MethodCallMutator,encode,code,1,0.1588464,b64.<mask>(binaryData),") {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.<mask>(binaryData);
    }"
3311,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,818,32604,32609,MethodCallMutator,encode,update,2,0.04049882,b64.<mask>(binaryData),") {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.<mask>(binaryData);
    }"
3312,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,818,32604,32609,MethodCallMutator,encode,copy,3,0.03796234,b64.<mask>(binaryData),") {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.<mask>(binaryData);
    }"
3313,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,818,32604,32609,MethodCallMutator,encode,export,4,0.036456812,b64.<mask>(binaryData),") {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.<mask>(binaryData);
    }"
3314,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,818,32600,32602,IdentifierMutator-Variable,b64,enc,0,0.44333124,<mask>,"length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return<mask>.encode(binaryData);
    }"
3315,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,818,32600,32602,IdentifierMutator-Variable,b64,codec,1,0.14237066,<mask>,"length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return<mask>.encode(binaryData);
    }"
3316,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,818,32600,32602,IdentifierMutator-Variable,b64,super,2,0.06326305,<mask>,"length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return<mask>.encode(binaryData);
    }"
3317,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,818,32600,32602,IdentifierMutator-Variable,b64,this,3,0.026910754,<mask>,"length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return<mask>.encode(binaryData);
    }"
3318,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,818,32600,32602,IdentifierMutator-Variable,b64,bos,4,0.02198934,<mask>,"length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return<mask>.encode(binaryData);
    }"
3319,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,818,32611,32620,IdentifierMutator-Variable,binaryData,output,0,0.14566961,<mask>,"            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(<mask>);
    }"
3320,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,818,32611,32620,IdentifierMutator-Variable,binaryData,data,1,0.09396279,<mask>,"            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(<mask>);
    }"
3321,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,818,32611,32620,IdentifierMutator-Variable,binaryData,null,2,0.08384894,<mask>,"            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(<mask>);
    }"
3322,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,818,32611,32620,IdentifierMutator-Variable,binaryData,bytes,3,0.067823075,<mask>,"            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(<mask>);
    }"
3323,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",804,818,32611,32620,IdentifierMutator-Variable,binaryData,string,4,0.055993196,<mask>,"            return binaryData;
        }

        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(<mask>);
    }"
3324,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),829,830,32925,32930,MethodCallMutator,decode,read,0,0.23005044,new Base64().<mask>(base64String),"byte[] decodeBase64(String base64String) {
        return new Base64().<mask>(base64String);
    }"
3325,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),829,830,32925,32930,MethodCallMutator,decode,ode,2,0.13044131,new Base64().<mask>(base64String),"byte[] decodeBase64(String base64String) {
        return new Base64().<mask>(base64String);
    }"
3326,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),829,830,32925,32930,MethodCallMutator,decode,load,3,0.113766424,new Base64().<mask>(base64String),"byte[] decodeBase64(String base64String) {
        return new Base64().<mask>(base64String);
    }"
3327,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),829,830,32925,32930,MethodCallMutator,decode,dec,4,0.08550016,new Base64().<mask>(base64String),"byte[] decodeBase64(String base64String) {
        return new Base64().<mask>(base64String);
    }"
3328,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),829,830,32932,32943,IdentifierMutator-Variable,base64String,string,0,0.51462966,<mask>,"byte[] decodeBase64(String base64String) {
        return new Base64().decode(<mask>);
    }"
3329,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),829,830,32932,32943,IdentifierMutator-Variable,base64String,bytes,1,0.14441289,<mask>,"byte[] decodeBase64(String base64String) {
        return new Base64().decode(<mask>);
    }"
3330,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),829,830,32932,32943,IdentifierMutator-Variable,base64String,input,2,0.050064214,<mask>,"byte[] decodeBase64(String base64String) {
        return new Base64().decode(<mask>);
    }"
3331,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),829,830,32932,32943,IdentifierMutator-Variable,base64String,data,3,0.043782957,<mask>,"byte[] decodeBase64(String base64String) {
        return new Base64().decode(<mask>);
    }"
3332,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),829,830,32932,32943,IdentifierMutator-Variable,base64String,str,4,0.033860866,<mask>,"byte[] decodeBase64(String base64String) {
        return new Base64().decode(<mask>);
    }"
3333,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),840,841,33227,33232,MethodCallMutator,decode,read,0,0.16027991,new Base64().<mask>(base64Data),"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().<mask>(base64Data);
    }"
3334,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),840,841,33227,33232,MethodCallMutator,decode,split,2,0.117556654,new Base64().<mask>(base64Data),"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().<mask>(base64Data);
    }"
3335,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),840,841,33227,33232,MethodCallMutator,decode,load,3,0.0880729,new Base64().<mask>(base64Data),"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().<mask>(base64Data);
    }"
3336,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),840,841,33227,33232,MethodCallMutator,decode,ode,4,0.08669638,new Base64().<mask>(base64Data),"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().<mask>(base64Data);
    }"
3337,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),840,841,33234,33243,IdentifierMutator-Variable,base64Data,data,0,0.84126043,<mask>,"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().decode(<mask>);
    }"
3338,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),840,841,33234,33243,IdentifierMutator-Variable,base64Data,bytes,1,0.039528534,<mask>,"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().decode(<mask>);
    }"
3339,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),840,841,33234,33243,IdentifierMutator-Variable,base64Data,input,2,0.023998328,<mask>,"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().decode(<mask>);
    }"
3340,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),840,841,33234,33243,IdentifierMutator-Variable,base64Data,buffer,3,0.013202573,<mask>,"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().decode(<mask>);
    }"
3341,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),840,841,33234,33243,IdentifierMutator-Variable,base64Data,raw,4,0.008954871,<mask>,"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().decode(<mask>);
    }"
3342,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,853,33630,33640,IdentifierMutator-Variable,data.length,size,0,0.088934466,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3343,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,853,33630,33640,IdentifierMutator-Variable,data.length,0,1,0.07688801,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3344,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,853,33630,33640,IdentifierMutator-Variable,data.length,1024,2,0.07662493,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3345,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,853,33630,33640,IdentifierMutator-Variable,data.length,1,3,0.038702115,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3346,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,853,33630,33640,IdentifierMutator-Variable,data.length,16,4,0.037849266,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3347,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,853,33630,33633,IdentifierMutator-Variable,data,Data,2,7.707885E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3348,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,853,33630,33633,IdentifierMutator-Variable,data,DATA,3,1.8118248E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3349,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,853,33630,33633,IdentifierMutator-Variable,data,string,4,1.207517E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3350,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,853,33635,33640,FieldReferenceMutator,length,size,1,4.4816086E-5,data.<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3351,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,853,33635,33640,FieldReferenceMutator,length,len,3,1.0469613E-5,data.<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3352,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,853,33635,33640,FieldReferenceMutator,length,count,4,6.2486515E-6,data.<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3353,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,854,33670,33670,IdentifierMutator-Literal,0,1,1,0.037395295,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied =<mask>;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3354,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,854,33670,33670,IdentifierMutator-Literal,0,2,2,0.0011831039,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied =<mask>;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3355,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,854,33670,33670,IdentifierMutator-Literal,0,4,3,4.8331072E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied =<mask>;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3356,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33694,33694,IdentifierMutator-Literal,0,1,1,0.0064545837,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i =<mask>; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3357,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33694,33694,IdentifierMutator-Literal,0,i,3,2.7148053E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i =<mask>; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3358,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33694,33694,IdentifierMutator-Literal,0,2,4,2.3112416E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i =<mask>; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3359,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33698,33700,BinaryOperatorMutator,<,++,2,0.0012738135,i <mask> data.length,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i<mask>data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3360,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33698,33700,BinaryOperatorMutator,<,==,3,6.527805E-4,i <mask> data.length,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i<mask>data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3361,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33698,33700,BinaryOperatorMutator,<,.<,4,5.5742805E-4,i <mask> data.length,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i<mask>data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3362,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33697,33697,IdentifierMutator-Variable,i,I,2,8.1750586E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0;<mask> < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3363,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33697,33697,IdentifierMutator-Variable,i,0,3,4.6001685E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0;<mask> < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3364,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33697,33697,IdentifierMutator-Variable,i,I,4,3.5065892E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0;<mask> < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3365,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33701,33711,IdentifierMutator-Variable,data.length,length,0,0.20823966,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3366,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33701,33711,IdentifierMutator-Variable,data.length,size,1,0.14010033,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3367,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33701,33711,IdentifierMutator-Variable,data.length,len,2,0.10720097,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3368,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33701,33711,IdentifierMutator-Variable,data.length,n,3,0.046964757,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3369,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33701,33711,IdentifierMutator-Variable,data.length,256,4,0.04154463,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3370,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33701,33704,IdentifierMutator-Variable,data,buffer,2,1.7749013E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3371,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33701,33704,IdentifierMutator-Variable,data,Data,3,1.2010338E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3372,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33701,33704,IdentifierMutator-Variable,data,input,4,9.787504E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3373,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33706,33711,FieldReferenceMutator,length,size,2,1.1294446E-5,data.<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3374,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33706,33711,FieldReferenceMutator,length,Length,3,5.3892527E-6,data.<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3375,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33706,33711,FieldReferenceMutator,length,position,4,4.986031E-6,data.<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3376,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33715,33716,UnaryOperatorMutator,++,++),2,0.004225447,i<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i<mask>) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3377,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33715,33716,UnaryOperatorMutator,++,++;,3,2.2569772E-4,i<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i<mask>) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3378,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33715,33716,UnaryOperatorMutator,++,--,4,1.2584057E-4,i<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i<mask>) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3379,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33714,33714,IdentifierMutator-Variable,i,I,2,2.4985928E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length;<mask>++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3380,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33714,33714,IdentifierMutator-Variable,i,++,3,1.842373E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length;<mask>++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3381,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,855,33714,33714,IdentifierMutator-Variable,i,,4,1.6523276E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length;<mask>++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3382,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,856,33746,33746,ArrayAccessMutator,i,I,2,4.016381E-5,data[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[<mask>]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3383,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,856,33746,33746,ArrayAccessMutator,i,0,3,2.2881375E-5,data[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[<mask>]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3384,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,856,33746,33746,ArrayAccessMutator,i,j,4,9.057474E-6,data[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[<mask>]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3385,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,856,33741,33744,IdentifierMutator-Variable,data,input,2,1.8172493E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (<mask>[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3386,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,856,33741,33744,IdentifierMutator-Variable,data,string,3,1.7926209E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (<mask>[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3387,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,856,33741,33744,IdentifierMutator-Variable,data,Data,4,1.5542985E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (<mask>[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3388,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,856,33746,33746,IdentifierMutator-Variable,i,I,2,4.016381E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[<mask>]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3389,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,856,33746,33746,IdentifierMutator-Variable,i,0,3,2.2881375E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[<mask>]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3390,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,856,33746,33746,IdentifierMutator-Variable,i,j,4,9.057474E-6,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[<mask>]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3391,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,857,33773,33775,IdentifierMutator-Literal,"''",0,1,0.08244818,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case<mask> :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3392,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,857,33773,33775,IdentifierMutator-Literal,"''",127,2,0.06145017,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case<mask> :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3393,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,857,33773,33775,IdentifierMutator-Literal,"''",null,3,0.0526348,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case<mask> :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3394,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,857,33773,33775,IdentifierMutator-Literal,"''","'",4,0.041249163,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case<mask> :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3395,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,858,33800,33803,IdentifierMutator-Literal,"'\n'","''",0,0.28521597,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case<mask> :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3396,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,858,33800,33803,IdentifierMutator-Literal,"'\n'",0,1,0.089137726,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case<mask> :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3397,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,858,33800,33803,IdentifierMutator-Literal,"'\n'",null,2,0.04380775,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case<mask> :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3398,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,858,33800,33803,IdentifierMutator-Literal,"'\n'","'",3,0.029761141,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case<mask> :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3399,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,858,33800,33803,IdentifierMutator-Literal,"'\n'",32,4,0.029639969,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case<mask> :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3400,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,859,33828,33831,IdentifierMutator-Literal,"'\r'","''",0,0.5357186,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case<mask> :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3401,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,859,33828,33831,IdentifierMutator-Literal,"'\r'",0,1,0.065153934,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case<mask> :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3402,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,859,33828,33831,IdentifierMutator-Literal,"'\r'",null,2,0.048696417,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case<mask> :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3403,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,859,33828,33831,IdentifierMutator-Literal,"'\r'",undefined,3,0.012858429,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case<mask> :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3404,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,859,33828,33831,IdentifierMutator-Literal,"'\r'",2,4,0.01121744,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case<mask> :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3405,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,860,33856,33859,IdentifierMutator-Literal,"'\t'","''",0,0.6441391,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case<mask> :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3406,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,860,33856,33859,IdentifierMutator-Literal,"'\t'",null,1,0.116853796,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case<mask> :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3407,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,860,33856,33859,IdentifierMutator-Literal,"'\t'",undefined,2,0.038914785,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case<mask> :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3408,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,860,33856,33859,IdentifierMutator-Literal,"'\t'",0,3,0.022741282,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case<mask> :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3409,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,860,33856,33859,IdentifierMutator-Literal,"'\t'",false,4,0.015436804,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case<mask> :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3410,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33962,33962,AssignmentMutator,groomedData[bytesCopied++]=data[i],^,0,0.6197974,groomedData[bytesCopied++] <mask>= data[i],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++]<mask>= data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3411,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33962,33962,AssignmentMutator,groomedData[bytesCopied++]=data[i],|,1,0.33990026,groomedData[bytesCopied++] <mask>= data[i],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++]<mask>= data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3412,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33962,33962,AssignmentMutator,groomedData[bytesCopied++]=data[i],*,2,0.012758829,groomedData[bytesCopied++] <mask>= data[i],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++]<mask>= data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3413,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33962,33962,AssignmentMutator,groomedData[bytesCopied++]=data[i],&,3,0.0063087577,groomedData[bytesCopied++] <mask>= data[i],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++]<mask>= data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3414,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33962,33962,AssignmentMutator,groomedData[bytesCopied++]=data[i],.,4,0.0041533955,groomedData[bytesCopied++] <mask>= data[i],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++]<mask>= data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3415,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33948,33960,ArrayAccessMutator,bytesCopied++,i,0,0.99585956,groomedData[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3416,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33948,33960,ArrayAccessMutator,bytesCopied++,i,1,7.5192103E-4,groomedData[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3417,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33948,33960,ArrayAccessMutator,bytesCopied++,0,2,5.581337E-4,groomedData[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3418,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33948,33960,ArrayAccessMutator,bytesCopied++,j,3,5.111515E-4,groomedData[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3419,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33948,33960,ArrayAccessMutator,bytesCopied++,1,4,1.2407721E-4,groomedData[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3420,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33936,33946,IdentifierMutator-Variable,groomedData,data,0,0.5821798,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :<mask>[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3421,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33936,33946,IdentifierMutator-Variable,groomedData,buffer,1,0.035347022,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :<mask>[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3422,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33936,33946,IdentifierMutator-Variable,groomedData,data,2,0.028639225,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :<mask>[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3423,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33936,33946,IdentifierMutator-Variable,groomedData,bytes,3,0.025771677,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :<mask>[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3424,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33936,33946,IdentifierMutator-Variable,groomedData,byte,4,0.025038369,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :<mask>[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3425,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33959,33960,UnaryOperatorMutator,++,][,2,0.053754125,bytesCopied<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3426,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33959,33960,UnaryOperatorMutator,++,Index,3,0.0029078415,bytesCopied<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3427,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33959,33960,UnaryOperatorMutator,++,:,4,0.0018770318,bytesCopied<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3428,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33948,33958,IdentifierMutator-Variable,bytesCopied,i,0,0.9793088,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3429,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33948,33958,IdentifierMutator-Variable,bytesCopied,j,1,0.0033990694,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3430,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33948,33958,IdentifierMutator-Variable,bytesCopied,c,2,0.0017561538,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3431,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33948,33958,IdentifierMutator-Variable,bytesCopied,i,3,0.0016460998,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3432,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33948,33958,IdentifierMutator-Variable,bytesCopied,d,4,0.0010722802,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3433,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33970,33970,ArrayAccessMutator,i,j,2,1.691398E-4,data[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[<mask>];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3434,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33970,33970,ArrayAccessMutator,i,I,3,1.0576023E-4,data[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[<mask>];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3435,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33970,33970,ArrayAccessMutator,i,c,4,3.8448088E-5,data[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[<mask>];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3436,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33965,33968,IdentifierMutator-Variable,data,buffer,2,9.732032E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] =<mask>[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3437,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33965,33968,IdentifierMutator-Variable,data,text,3,9.033422E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] =<mask>[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3438,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33965,33968,IdentifierMutator-Variable,data,input,4,4.8283306E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] =<mask>[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3439,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33970,33970,IdentifierMutator-Variable,i,j,2,1.691398E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[<mask>];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3440,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33970,33970,IdentifierMutator-Variable,i,I,3,1.0576023E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[<mask>];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3441,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,863,33970,33970,IdentifierMutator-Variable,i,c,4,3.8448088E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[<mask>];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3442,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,866,34035,34045,IdentifierMutator-Variable,bytesCopied,0,0,0.16547705,<mask>,"        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[<mask>];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3443,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,866,34035,34045,IdentifierMutator-Variable,bytesCopied,1024,1,0.08230046,<mask>,"        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[<mask>];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3444,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,866,34035,34045,IdentifierMutator-Variable,bytesCopied,size,2,0.075461954,<mask>,"        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[<mask>];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3445,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,866,34035,34045,IdentifierMutator-Variable,bytesCopied,1,3,0.044450767,<mask>,"        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[<mask>];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3446,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,866,34035,34045,IdentifierMutator-Variable,bytesCopied,64,4,0.03297563,<mask>,"        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[<mask>];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3447,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34064,34072,MethodCallMutator,arraycopy,copy,0,0.98436165,"System.<mask>(groomedData, 0, packedData, 0, bytesCopied)","
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.<mask>(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3448,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34064,34072,MethodCallMutator,arraycopy,dump,1,0.0050194873,"System.<mask>(groomedData, 0, packedData, 0, bytesCopied)","
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.<mask>(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3449,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34064,34072,MethodCallMutator,arraycopy,printf,2,0.0035116472,"System.<mask>(groomedData, 0, packedData, 0, bytesCopied)","
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.<mask>(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3450,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34064,34072,MethodCallMutator,arraycopy,array,3,0.002767085,"System.<mask>(groomedData, 0, packedData, 0, bytesCopied)","
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.<mask>(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3451,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34064,34072,MethodCallMutator,arraycopy,write,4,5.26446E-4,"System.<mask>(groomedData, 0, packedData, 0, bytesCopied)","
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.<mask>(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3452,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34074,34084,IdentifierMutator-Variable,groomedData,data,0,0.98286706,<mask>,"      for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(<mask>, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3453,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34074,34084,IdentifierMutator-Variable,groomedData,buffer,1,0.0033180923,<mask>,"      for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(<mask>, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3454,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34074,34084,IdentifierMutator-Variable,groomedData,bytes,2,0.0025030847,<mask>,"      for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(<mask>, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3455,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34074,34084,IdentifierMutator-Variable,groomedData,DATA,3,7.962062E-4,<mask>,"      for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(<mask>, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3456,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34074,34084,IdentifierMutator-Variable,groomedData,buf,4,5.89633E-4,<mask>,"      for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(<mask>, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3457,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34087,34087,IdentifierMutator-Literal,0,1,1,0.011507818,<mask>," for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData,<mask>, packedData, 0, bytesCopied);
        return packedData;
    }"
3458,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34087,34087,IdentifierMutator-Literal,0,i,3,0.0029997528,<mask>," for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData,<mask>, packedData, 0, bytesCopied);
        return packedData;
    }"
3459,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34087,34087,IdentifierMutator-Literal,0,2,4,0.0010386878,<mask>," for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData,<mask>, packedData, 0, bytesCopied);
        return packedData;
    }"
3460,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34090,34099,IdentifierMutator-Variable,packedData,data,0,0.89924085,<mask>,"int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0,<mask>, 0, bytesCopied);
        return packedData;
    }"
3461,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34090,34099,IdentifierMutator-Variable,packedData,packed,1,0.033504687,<mask>,"int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0,<mask>, 0, bytesCopied);
        return packedData;
    }"
3462,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34090,34099,IdentifierMutator-Variable,packedData,array,2,0.007896026,<mask>,"int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0,<mask>, 0, bytesCopied);
        return packedData;
    }"
3463,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34090,34099,IdentifierMutator-Variable,packedData,tmp,3,0.0047962023,<mask>,"int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0,<mask>, 0, bytesCopied);
        return packedData;
    }"
3464,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34090,34099,IdentifierMutator-Variable,packedData,buf,4,0.0030134527,<mask>,"int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0,<mask>, 0, bytesCopied);
        return packedData;
    }"
3465,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34102,34102,IdentifierMutator-Literal,0,1,1,0.011871785,<mask>," 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData,<mask>, bytesCopied);
        return packedData;
    }"
3466,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34102,34102,IdentifierMutator-Literal,0,i,3,7.7413017E-4,<mask>," 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData,<mask>, bytesCopied);
        return packedData;
    }"
3467,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34102,34102,IdentifierMutator-Literal,0,2,4,7.4331305E-4,<mask>," 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData,<mask>, bytesCopied);
        return packedData;
    }"
3468,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34105,34115,IdentifierMutator-Variable,bytesCopied,length,0,0.16044208,<mask>," i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0,<mask>);
        return packedData;
    }"
3469,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34105,34115,IdentifierMutator-Variable,bytesCopied,len,1,0.1513442,<mask>," i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0,<mask>);
        return packedData;
    }"
3470,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34105,34115,IdentifierMutator-Variable,bytesCopied,n,2,0.10035997,<mask>," i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0,<mask>);
        return packedData;
    }"
3471,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34105,34115,IdentifierMutator-Variable,bytesCopied,count,3,0.07970854,<mask>," i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0,<mask>);
        return packedData;
    }"
3472,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,867,34105,34115,IdentifierMutator-Variable,bytesCopied,bytes,4,0.07962785,<mask>," i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0,<mask>);
        return packedData;
    }"
3473,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,868,34134,34143,IdentifierMutator-Variable,packedData,0,0,0.1298416,<mask>,"         switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return<mask>;
    }"
3474,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,868,34134,34143,IdentifierMutator-Variable,packedData,data,1,0.11107518,<mask>,"         switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return<mask>;
    }"
3475,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,868,34134,34143,IdentifierMutator-Variable,packedData,true,2,0.099648565,<mask>,"         switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return<mask>;
    }"
3476,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,868,34134,34143,IdentifierMutator-Variable,packedData,null,3,0.08064939,<mask>,"         switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return<mask>;
    }"
3477,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),852,868,34134,34143,IdentifierMutator-Variable,packedData,"""""",4,0.0639,<mask>,"         switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return<mask>;
    }"
3478,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,879,34426,34436,IdentifierMutator-Variable,byteToCheck,byte,0,0.87689835,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (<mask>) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3479,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,879,34426,34436,IdentifierMutator-Variable,byteToCheck,char,1,0.041675314,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (<mask>) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3480,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,879,34426,34436,IdentifierMutator-Variable,byteToCheck,token,2,0.011559272,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (<mask>) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3481,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,879,34426,34436,IdentifierMutator-Variable,byteToCheck,character,3,0.0059702797,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (<mask>) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3482,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,879,34426,34436,IdentifierMutator-Variable,byteToCheck,letter,4,0.0045639197,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (<mask>) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3483,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,880,34458,34460,IdentifierMutator-Literal,"''",127,1,0.11638416,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case<mask> :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3484,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,880,34458,34460,IdentifierMutator-Literal,"''","'",2,0.100291535,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case<mask> :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3485,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,880,34458,34460,IdentifierMutator-Literal,"''",0,3,0.07361801,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case<mask> :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3486,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,880,34458,34460,IdentifierMutator-Literal,"''",null,4,0.030010344,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case<mask> :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3487,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,881,34481,34484,IdentifierMutator-Literal,"'\n'","''",0,0.31404096,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case<mask> :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3488,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,881,34481,34484,IdentifierMutator-Literal,"'\n'",0,1,0.06704349,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case<mask> :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3489,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,881,34481,34484,IdentifierMutator-Literal,"'\n'","'",2,0.048901446,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case<mask> :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3490,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,881,34481,34484,IdentifierMutator-Literal,"'\n'",null,3,0.04076971,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case<mask> :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3491,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,881,34481,34484,IdentifierMutator-Literal,"'\n'",127,4,0.030773241,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case<mask> :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3492,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,882,34505,34508,IdentifierMutator-Literal,"'\r'","''",0,0.31427732,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case<mask> :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3493,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,882,34505,34508,IdentifierMutator-Literal,"'\r'",0,1,0.070253536,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case<mask> :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3494,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,882,34505,34508,IdentifierMutator-Literal,"'\r'",127,2,0.041286614,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case<mask> :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3495,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,882,34505,34508,IdentifierMutator-Literal,"'\r'",null,3,0.0325793,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case<mask> :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3496,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,882,34505,34508,IdentifierMutator-Literal,"'\r'",13,4,0.030142767,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case<mask> :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3497,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,883,34529,34532,IdentifierMutator-Literal,"'\t'","''",0,0.3427563,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case<mask> :
                return true;
            default :
                return false;
        }
    }"
3498,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,883,34529,34532,IdentifierMutator-Literal,"'\t'",0,1,0.13208826,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case<mask> :
                return true;
            default :
                return false;
        }
    }"
3499,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,883,34529,34532,IdentifierMutator-Literal,"'\t'",127,2,0.042970426,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case<mask> :
                return true;
            default :
                return false;
        }
    }"
3500,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,883,34529,34532,IdentifierMutator-Literal,"'\t'",null,3,0.040649995,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case<mask> :
                return true;
            default :
                return false;
        }
    }"
3501,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,883,34529,34532,IdentifierMutator-Literal,"'\t'",128,4,0.03007783,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case<mask> :
                return true;
            default :
                return false;
        }
    }"
3502,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,884,34559,34562,IdentifierMutator-Literal,true,false,1,0.228241,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return<mask>;
            default :
                return false;
        }
    }"
3503,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,884,34559,34562,IdentifierMutator-Literal,true,1,2,3.5760348E-4,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return<mask>;
            default :
                return false;
        }
    }"
3504,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,884,34559,34562,IdentifierMutator-Literal,true,0,3,2.4162118E-4,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return<mask>;
            default :
                return false;
        }
    }"
3505,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,884,34559,34562,IdentifierMutator-Literal,true,null,4,1.45996E-4,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return<mask>;
            default :
                return false;
        }
    }"
3506,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,886,34610,34614,IdentifierMutator-Literal,false,true,1,0.34868783,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return<mask>;
        }
    }"
3507,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,886,34610,34614,IdentifierMutator-Literal,false,null,2,4.913496E-4,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return<mask>;
        }
    }"
3508,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,886,34610,34614,IdentifierMutator-Literal,false,0,3,1.580537E-4,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return<mask>;
        }
    }"
3509,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),878,886,34610,34614,IdentifierMutator-Literal,false,undefined,4,1.2972756E-4,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return<mask>;
        }
    }"
3510,Base64.java,encodeToString,String encodeToString(byte[] pArray),917,918,35852,35864,MethodCallMutator,newStringUtf8,escape,0,0.32738858,StringUtils.<mask>(encode(pArray)),"String encodeToString(byte[] pArray) {
        return StringUtils.<mask>(encode(pArray));
    }"
3511,Base64.java,encodeToString,String encodeToString(byte[] pArray),917,918,35852,35864,MethodCallMutator,newStringUtf8,format,1,0.12487902,StringUtils.<mask>(encode(pArray)),"String encodeToString(byte[] pArray) {
        return StringUtils.<mask>(encode(pArray));
    }"
3512,Base64.java,encodeToString,String encodeToString(byte[] pArray),917,918,35852,35864,MethodCallMutator,newStringUtf8,str,2,0.06766904,StringUtils.<mask>(encode(pArray)),"String encodeToString(byte[] pArray) {
        return StringUtils.<mask>(encode(pArray));
    }"
3513,Base64.java,encodeToString,String encodeToString(byte[] pArray),917,918,35852,35864,MethodCallMutator,newStringUtf8,string,3,0.051101003,StringUtils.<mask>(encode(pArray)),"String encodeToString(byte[] pArray) {
        return StringUtils.<mask>(encode(pArray));
    }"
3514,Base64.java,encodeToString,String encodeToString(byte[] pArray),917,918,35852,35864,MethodCallMutator,newStringUtf8,strip,4,0.043724347,StringUtils.<mask>(encode(pArray)),"String encodeToString(byte[] pArray) {
        return StringUtils.<mask>(encode(pArray));
    }"
3515,Base64.java,encodeToString,String encodeToString(byte[] pArray),917,918,35866,35871,MethodCallMutator,encode,string,0,0.22253141,<mask>(pArray),"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(<mask>(pArray));
    }"
3516,Base64.java,encodeToString,String encodeToString(byte[] pArray),917,918,35866,35871,MethodCallMutator,encode,append,1,0.08873156,<mask>(pArray),"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(<mask>(pArray));
    }"
3517,Base64.java,encodeToString,String encodeToString(byte[] pArray),917,918,35866,35871,MethodCallMutator,encode,format,2,0.07343348,<mask>(pArray),"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(<mask>(pArray));
    }"
3518,Base64.java,encodeToString,String encodeToString(byte[] pArray),917,918,35866,35871,MethodCallMutator,encode,bytes,3,0.04928849,<mask>(pArray),"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(<mask>(pArray));
    }"
3519,Base64.java,encodeToString,String encodeToString(byte[] pArray),917,918,35866,35871,MethodCallMutator,encode,code,4,0.03977998,<mask>(pArray),"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(<mask>(pArray));
    }"
3520,Base64.java,encodeToString,String encodeToString(byte[] pArray),917,918,35873,35878,IdentifierMutator-Variable,pArray,array,0,0.53259575,<mask>,"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(encode(<mask>));
    }"
3521,Base64.java,encodeToString,String encodeToString(byte[] pArray),917,918,35873,35878,IdentifierMutator-Variable,pArray,Array,1,0.43346334,<mask>,"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(encode(<mask>));
    }"
3522,Base64.java,encodeToString,String encodeToString(byte[] pArray),917,918,35873,35878,IdentifierMutator-Variable,pArray,arr,2,0.009440454,<mask>,"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(encode(<mask>));
    }"
3523,Base64.java,encodeToString,String encodeToString(byte[] pArray),917,918,35873,35878,IdentifierMutator-Variable,pArray,p,3,0.0037139037,<mask>,"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(encode(<mask>));
    }"
3524,Base64.java,encodeToString,String encodeToString(byte[] pArray),917,918,35873,35878,IdentifierMutator-Variable,pArray,[],4,0.0021142324,<mask>,"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(encode(<mask>));
    }"
3525,Base64.java,encode,byte[] encode(byte[] pArray),928,929,36213,36217,MethodCallMutator,reset,close,0,0.18403377,<mask>(),"byte[] encode(byte[] pArray) {<mask>();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3526,Base64.java,encode,byte[] encode(byte[] pArray),928,929,36213,36217,MethodCallMutator,reset,flush,1,0.17889532,<mask>(),"byte[] encode(byte[] pArray) {<mask>();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3527,Base64.java,encode,byte[] encode(byte[] pArray),928,929,36213,36217,MethodCallMutator,reset,encode,3,0.07837346,<mask>(),"byte[] encode(byte[] pArray) {<mask>();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3528,Base64.java,encode,byte[] encode(byte[] pArray),928,929,36213,36217,MethodCallMutator,reset,init,4,0.04114957,<mask>(),"byte[] encode(byte[] pArray) {<mask>();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3529,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36256,36259,BinaryOperatorMutator,||,|,2,0.0017302204,(pArray == null) <mask> (pArray.length == 0),"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null<mask>pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3530,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36256,36259,BinaryOperatorMutator,||,/,3,0.0012025622,(pArray == null) <mask> (pArray.length == 0),"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null<mask>pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3531,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36256,36259,BinaryOperatorMutator,||,.,4,7.580271E-4,(pArray == null) <mask> (pArray.length == 0),"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null<mask>pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3532,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36248,36251,BinaryOperatorMutator,==,=,2,0.0022956578,pArray <mask> null,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray<mask>null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3533,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36248,36251,BinaryOperatorMutator,==,===,3,7.174533E-4,pArray <mask> null,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray<mask>null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3534,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36248,36251,BinaryOperatorMutator,==,!=,4,2.94983E-4,pArray <mask> null,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray<mask>null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3535,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36242,36247,IdentifierMutator-Variable,pArray,array,0,0.71901965,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3536,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36242,36247,IdentifierMutator-Variable,pArray,Array,1,0.09658609,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3537,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36242,36247,IdentifierMutator-Variable,pArray,null,2,0.014638863,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3538,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36242,36247,IdentifierMutator-Variable,pArray,buffer,3,0.014314994,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3539,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36242,36247,IdentifierMutator-Variable,pArray,p,4,0.009570836,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3540,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36252,36255,IdentifierMutator-Literal,null,nil,1,4.71504E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3541,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36252,36255,IdentifierMutator-Literal,null,NULL,2,3.6917403E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3542,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36252,36255,IdentifierMutator-Literal,null,undefined,3,5.5898658E-5,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3543,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36252,36255,IdentifierMutator-Literal,null,this,4,4.4438122E-5,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3544,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36273,36276,BinaryOperatorMutator,==,>,2,0.026826035,pArray.length <mask> 0,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length<mask>0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3545,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36273,36276,BinaryOperatorMutator,==,=,3,0.014689336,pArray.length <mask> 0,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length<mask>0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3546,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36273,36276,BinaryOperatorMutator,==,<=,4,0.010090298,pArray.length <mask> 0,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length<mask>0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3547,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36260,36272,IdentifierMutator-Variable,pArray.length,len,0,0.85593456,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3548,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36260,36272,IdentifierMutator-Variable,pArray.length,length,1,0.039462417,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3549,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36260,36272,IdentifierMutator-Variable,pArray.length,pos,2,0.0181243,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3550,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36260,36272,IdentifierMutator-Variable,pArray.length,size,3,0.010762559,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3551,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36260,36272,IdentifierMutator-Variable,pArray.length,n,4,0.00906403,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3552,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36260,36265,IdentifierMutator-Variable,pArray,array,0,0.75577193,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3553,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36260,36265,IdentifierMutator-Variable,pArray,Array,1,0.076330476,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3554,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36260,36265,IdentifierMutator-Variable,pArray,Array,2,0.05373317,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3555,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36260,36265,IdentifierMutator-Variable,pArray,p,3,0.052107297,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3556,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36260,36265,IdentifierMutator-Variable,pArray,arr,4,0.014707325,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3557,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36267,36272,FieldReferenceMutator,length,size,2,1.1174611E-4,pArray.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.<mask> == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3558,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36267,36272,FieldReferenceMutator,length,count,3,6.355502E-5,pArray.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.<mask> == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3559,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36267,36272,FieldReferenceMutator,length,len,4,5.9652735E-5,pArray.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.<mask> == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3560,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36277,36277,IdentifierMutator-Literal,0,1,1,0.0023754218,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3561,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36277,36277,IdentifierMutator-Literal,0,length,2,4.6956152E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3562,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36277,36277,IdentifierMutator-Literal,0,len,3,4.4311158E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3563,Base64.java,encode,byte[] encode(byte[] pArray),928,930,36277,36277,IdentifierMutator-Literal,0,size,4,3.3578888E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3564,Base64.java,encode,byte[] encode(byte[] pArray),928,931,36301,36306,IdentifierMutator-Variable,pArray,null,0,0.8897896,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3565,Base64.java,encode,byte[] encode(byte[] pArray),928,931,36301,36306,IdentifierMutator-Variable,pArray,"""""",1,0.034184277,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3566,Base64.java,encode,byte[] encode(byte[] pArray),928,931,36301,36306,IdentifierMutator-Variable,pArray,[],2,0.008194483,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3567,Base64.java,encode,byte[] encode(byte[] pArray),928,931,36301,36306,IdentifierMutator-Variable,pArray,false,3,0.007817769,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3568,Base64.java,encode,byte[] encode(byte[] pArray),928,931,36301,36306,IdentifierMutator-Variable,pArray,"''",4,0.0072672525,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3569,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36338,36352,MethodCallMutator,getEncodeLength,encode,0,0.7486533,"<mask>(pArray, lineLength, lineSeparator)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len =<mask>(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3570,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36338,36352,MethodCallMutator,getEncodeLength,length,1,0.039110266,"<mask>(pArray, lineLength, lineSeparator)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len =<mask>(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3571,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36338,36352,MethodCallMutator,getEncodeLength,decode,2,0.026872428,"<mask>(pArray, lineLength, lineSeparator)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len =<mask>(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3572,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36338,36352,MethodCallMutator,getEncodeLength,len,3,0.016869586,"<mask>(pArray, lineLength, lineSeparator)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len =<mask>(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3573,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36338,36352,MethodCallMutator,getEncodeLength,write,4,0.014989316,"<mask>(pArray, lineLength, lineSeparator)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len =<mask>(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3574,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36354,36359,IdentifierMutator-Variable,pArray,buffer,0,0.15763839,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(<mask>, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3575,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36354,36359,IdentifierMutator-Variable,pArray,buf,1,0.03728291,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(<mask>, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3576,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36354,36359,IdentifierMutator-Variable,pArray,string,2,0.031882618,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(<mask>, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3577,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36354,36359,IdentifierMutator-Variable,pArray,output,3,0.030640168,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(<mask>, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3578,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36354,36359,IdentifierMutator-Variable,pArray,input,4,0.028715476,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(<mask>, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3579,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36362,36371,IdentifierMutator-Variable,lineLength,0,0,0.10290702,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3580,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36362,36371,IdentifierMutator-Variable,lineLength,encoding,1,0.10258092,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3581,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36362,36371,IdentifierMutator-Variable,lineLength,true,2,0.09282646,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3582,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36362,36371,IdentifierMutator-Variable,lineLength,pos,3,0.048901323,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3583,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36362,36371,IdentifierMutator-Variable,lineLength,false,4,0.0422479,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3584,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36362,36371,FieldReferenceMutator,lineLength,0,0,0.10290702,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3585,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36362,36371,FieldReferenceMutator,lineLength,encoding,1,0.10258092,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3586,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36362,36371,FieldReferenceMutator,lineLength,true,2,0.09282646,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3587,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36362,36371,FieldReferenceMutator,lineLength,pos,3,0.048901323,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3588,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36362,36371,FieldReferenceMutator,lineLength,false,4,0.0422479,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3589,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36374,36386,IdentifierMutator-Variable,lineSeparator,true,0,0.13959107,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3590,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36374,36386,IdentifierMutator-Variable,lineSeparator,false,1,0.07535797,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3591,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36374,36386,IdentifierMutator-Variable,lineSeparator,encoding,2,0.07353064,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3592,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36374,36386,IdentifierMutator-Variable,lineSeparator,0,3,0.051197574,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3593,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36374,36386,IdentifierMutator-Variable,lineSeparator,pos,4,0.0312302,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3594,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36374,36386,FieldReferenceMutator,lineSeparator,true,0,0.13959107,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3595,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36374,36386,FieldReferenceMutator,lineSeparator,false,1,0.07535797,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3596,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36374,36386,FieldReferenceMutator,lineSeparator,encoding,2,0.07353064,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3597,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36374,36386,FieldReferenceMutator,lineSeparator,0,3,0.051197574,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3598,Base64.java,encode,byte[] encode(byte[] pArray),928,933,36374,36386,FieldReferenceMutator,lineSeparator,pos,4,0.0312302,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3599,Base64.java,encode,byte[] encode(byte[] pArray),928,934,36420,36428,IdentifierMutator-Variable,((int)(len)),len,0,0.98003525,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3600,Base64.java,encode,byte[] encode(byte[] pArray),928,934,36420,36428,IdentifierMutator-Variable,((int)(len)),Len,1,0.011936,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3601,Base64.java,encode,byte[] encode(byte[] pArray),928,934,36420,36428,IdentifierMutator-Variable,((int)(len)),len,2,0.0036742173,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3602,Base64.java,encode,byte[] encode(byte[] pArray),928,934,36420,36428,IdentifierMutator-Variable,((int)(len)),ln,3,7.3071057E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3603,Base64.java,encode,byte[] encode(byte[] pArray),928,934,36420,36428,IdentifierMutator-Variable,((int)(len)),0,4,3.0638906E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3604,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36440,36455,MethodCallMutator,setInitialBuffer,encode,0,0.9292066,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3605,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36440,36455,MethodCallMutator,setInitialBuffer,decode,1,0.025281323,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3606,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36440,36455,MethodCallMutator,setInitialBuffer,write,2,0.02057634,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3607,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36440,36455,MethodCallMutator,setInitialBuffer,append,3,0.003173056,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3608,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36440,36455,MethodCallMutator,setInitialBuffer,copy,4,0.0027404733,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3609,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36457,36459,IdentifierMutator-Variable,buf,buffer,1,0.056994054,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(<mask>, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3610,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36457,36459,IdentifierMutator-Variable,buf,buff,2,0.0026912163,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(<mask>, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3611,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36457,36459,IdentifierMutator-Variable,buf,uf,4,7.963312E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(<mask>, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3612,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36462,36462,IdentifierMutator-Literal,0,len,1,0.020608135,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf,<mask>, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3613,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36462,36462,IdentifierMutator-Literal,0,pos,2,0.004751892,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf,<mask>, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3614,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36462,36462,IdentifierMutator-Literal,0,1,3,0.0015924738,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf,<mask>, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3615,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36462,36462,IdentifierMutator-Literal,0,start,4,8.2506455E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf,<mask>, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3616,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36465,36474,IdentifierMutator-Variable,buf.length,len,0,0.938327,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3617,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36465,36474,IdentifierMutator-Variable,buf.length,0,1,0.04104667,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3618,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36465,36474,IdentifierMutator-Variable,buf.length,pos,2,0.0035253768,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3619,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36465,36474,IdentifierMutator-Variable,buf.length,1,3,0.0015788804,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3620,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36465,36474,IdentifierMutator-Variable,buf.length,buf,4,0.0010132095,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3621,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36465,36467,IdentifierMutator-Variable,buf,buffer,1,0.027880393,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3622,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36465,36467,IdentifierMutator-Variable,buf,array,3,0.0015741392,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3623,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36465,36467,IdentifierMutator-Variable,buf,Buffer,4,6.6383515E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3624,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36469,36474,FieldReferenceMutator,length,position,1,1.8526975E-4,buf.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.<mask>);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3625,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36469,36474,FieldReferenceMutator,length,capacity,2,1.6082704E-4,buf.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.<mask>);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3626,Base64.java,encode,byte[] encode(byte[] pArray),928,935,36469,36474,FieldReferenceMutator,length,size,3,1.0297545E-4,buf.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.<mask>);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3627,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36486,36491,MethodCallMutator,encode,decode,1,0.065894336,"<mask>(pArray, 0, pArray.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);<mask>(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3628,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36486,36491,MethodCallMutator,encode,write,2,0.026327275,"<mask>(pArray, 0, pArray.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);<mask>(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3629,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36486,36491,MethodCallMutator,encode,append,3,0.0046206755,"<mask>(pArray, 0, pArray.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);<mask>(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3630,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36486,36491,MethodCallMutator,encode,copy,4,0.0033746345,"<mask>(pArray, 0, pArray.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);<mask>(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3631,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36493,36498,IdentifierMutator-Variable,pArray,buf,0,0.9947378,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(<mask>, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3632,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36493,36498,IdentifierMutator-Variable,pArray,buff,1,0.0021832928,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(<mask>, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3633,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36493,36498,IdentifierMutator-Variable,pArray,buffer,2,0.0018828341,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(<mask>, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3634,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36493,36498,IdentifierMutator-Variable,pArray,uf,3,3.7178094E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(<mask>, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3635,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36493,36498,IdentifierMutator-Variable,pArray,buf,4,2.1604789E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(<mask>, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3636,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36501,36501,IdentifierMutator-Literal,0,1,1,0.0071544494,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray,<mask>, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3637,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36501,36501,IdentifierMutator-Literal,0,buf,2,0.0047515724,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray,<mask>, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3638,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36501,36501,IdentifierMutator-Literal,0,pos,3,0.0023630587,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray,<mask>, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3639,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36501,36501,IdentifierMutator-Literal,0,2,4,0.0011671345,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray,<mask>, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3640,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36504,36516,IdentifierMutator-Variable,pArray.length,buf,0,0.41556606,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3641,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36504,36516,IdentifierMutator-Variable,pArray.length,len,1,0.27318123,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3642,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36504,36516,IdentifierMutator-Variable,pArray.length,0,2,0.17921081,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3643,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36504,36516,IdentifierMutator-Variable,pArray.length,1,3,0.04875989,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3644,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36504,36516,IdentifierMutator-Variable,pArray.length,pos,4,0.01580383,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3645,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36504,36509,IdentifierMutator-Variable,pArray,buf,0,0.99164456,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3646,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36504,36509,IdentifierMutator-Variable,pArray,buffer,1,0.0043817568,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3647,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36504,36509,IdentifierMutator-Variable,pArray,buf,2,0.0017551121,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3648,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36504,36509,IdentifierMutator-Variable,pArray,buff,3,3.2631852E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3649,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36504,36509,IdentifierMutator-Variable,pArray,doc,4,7.1575E-5,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3650,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36511,36516,FieldReferenceMutator,length,position,1,4.843831E-4,pArray.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3651,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36511,36516,FieldReferenceMutator,length,size,2,1.9318651E-4,pArray.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3652,Base64.java,encode,byte[] encode(byte[] pArray),928,936,36511,36516,FieldReferenceMutator,length,count,3,1.747663E-4,pArray.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3653,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36528,36533,MethodCallMutator,encode,decode,1,0.21052146,"<mask>(pArray, 0, -1)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3654,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36528,36533,MethodCallMutator,encode,write,2,0.0580373,"<mask>(pArray, 0, -1)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3655,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36528,36533,MethodCallMutator,encode,end,3,0.026063936,"<mask>(pArray, 0, -1)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3656,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36528,36533,MethodCallMutator,encode,reset,4,0.021791797,"<mask>(pArray, 0, -1)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3657,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36535,36540,IdentifierMutator-Variable,pArray,buf,0,0.96055716,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(<mask>, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3658,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36535,36540,IdentifierMutator-Variable,pArray,buffer,1,0.0221765,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(<mask>, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3659,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36535,36540,IdentifierMutator-Variable,pArray,buff,2,0.003422154,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(<mask>, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3660,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36535,36540,IdentifierMutator-Variable,pArray,buf,3,9.547964E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(<mask>, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3661,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36535,36540,IdentifierMutator-Variable,pArray,uf,4,6.9595134E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(<mask>, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3662,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36543,36543,IdentifierMutator-Literal,0,buf,1,0.18860859,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray,<mask>, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3663,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36543,36543,IdentifierMutator-Literal,0,len,2,0.020645466,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray,<mask>, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3664,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36543,36543,IdentifierMutator-Literal,0,1,3,0.018285898,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray,<mask>, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3665,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36543,36543,IdentifierMutator-Literal,0,pos,4,0.012795732,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray,<mask>, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3666,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36546,36546,UnaryOperatorMutator,-,pos,1,0.061359964,<mask>1,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0,<mask>1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3667,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36546,36546,UnaryOperatorMutator,-,+,2,0.039148774,<mask>1,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0,<mask>1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3668,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36546,36546,UnaryOperatorMutator,-,len,3,0.036212776,<mask>1,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0,<mask>1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3669,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36546,36546,UnaryOperatorMutator,-,buf,4,0.01959352,<mask>1,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0,<mask>1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3670,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36547,36547,IdentifierMutator-Literal,1,len,2,0.15058371,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -<mask>); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3671,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36547,36547,IdentifierMutator-Literal,1,len,3,0.012751501,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -<mask>); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3672,Base64.java,encode,byte[] encode(byte[] pArray),928,937,36547,36547,IdentifierMutator-Literal,1,2,4,0.009430359,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -<mask>); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3673,Base64.java,encode,byte[] encode(byte[] pArray),928,939,36666,36669,BinaryOperatorMutator,!=,==,1,0.21390529,buffer <mask> buf,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer<mask>buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3674,Base64.java,encode,byte[] encode(byte[] pArray),928,939,36666,36669,BinaryOperatorMutator,!=,==,2,0.019278448,buffer <mask> buf,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer<mask>buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3675,Base64.java,encode,byte[] encode(byte[] pArray),928,939,36666,36669,BinaryOperatorMutator,!=,>,3,0.00997514,buffer <mask> buf,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer<mask>buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3676,Base64.java,encode,byte[] encode(byte[] pArray),928,939,36666,36669,BinaryOperatorMutator,!=,<,4,0.009480504,buffer <mask> buf,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer<mask>buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3677,Base64.java,encode,byte[] encode(byte[] pArray),928,939,36660,36665,IdentifierMutator-Variable,buffer,null,0,0.5121809,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (<mask> != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3678,Base64.java,encode,byte[] encode(byte[] pArray),928,939,36660,36665,IdentifierMutator-Variable,buffer,buf,2,0.03223906,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (<mask> != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3679,Base64.java,encode,byte[] encode(byte[] pArray),928,939,36660,36665,IdentifierMutator-Variable,buffer,result,3,0.023289278,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (<mask> != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3680,Base64.java,encode,byte[] encode(byte[] pArray),928,939,36660,36665,IdentifierMutator-Variable,buffer,output,4,0.021177037,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (<mask> != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3681,Base64.java,encode,byte[] encode(byte[] pArray),928,939,36660,36665,FieldReferenceMutator,buffer,null,0,0.5121809,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (<mask> != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3682,Base64.java,encode,byte[] encode(byte[] pArray),928,939,36660,36665,FieldReferenceMutator,buffer,buf,2,0.03223906,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (<mask> != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3683,Base64.java,encode,byte[] encode(byte[] pArray),928,939,36660,36665,FieldReferenceMutator,buffer,result,3,0.023289278,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (<mask> != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3684,Base64.java,encode,byte[] encode(byte[] pArray),928,939,36660,36665,FieldReferenceMutator,buffer,output,4,0.021177037,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (<mask> != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3685,Base64.java,encode,byte[] encode(byte[] pArray),928,939,36670,36672,IdentifierMutator-Variable,buf,null,0,0.9957217,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer !=<mask>) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3686,Base64.java,encode,byte[] encode(byte[] pArray),928,939,36670,36672,IdentifierMutator-Variable,buf,nil,1,0.001192651,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer !=<mask>) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3687,Base64.java,encode,byte[] encode(byte[] pArray),928,939,36670,36672,IdentifierMutator-Variable,buf,undefined,2,5.7657657E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer !=<mask>) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3688,Base64.java,encode,byte[] encode(byte[] pArray),928,939,36670,36672,IdentifierMutator-Variable,buf,NULL,3,4.950443E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer !=<mask>) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3689,Base64.java,encode,byte[] encode(byte[] pArray),928,939,36670,36672,IdentifierMutator-Variable,buf,0,4,4.4660014E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer !=<mask>) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3690,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36689,36699,MethodCallMutator,readResults,encode,0,0.59357977,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {<mask>(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3691,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36689,36699,MethodCallMutator,readResults,write,1,0.1326764,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {<mask>(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3692,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36689,36699,MethodCallMutator,readResults,resize,2,0.034464166,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {<mask>(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3693,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36689,36699,MethodCallMutator,readResults,update,3,0.03120528,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {<mask>(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3694,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36689,36699,MethodCallMutator,readResults,append,4,0.023523957,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {<mask>(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3695,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36701,36703,IdentifierMutator-Variable,buf,buffer,0,0.87012833,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(<mask>, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3696,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36701,36703,IdentifierMutator-Variable,buf,buff,2,0.008435173,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(<mask>, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3697,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36701,36703,IdentifierMutator-Variable,buf,Buffer,3,0.0023671323,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(<mask>, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3698,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36701,36703,IdentifierMutator-Variable,buf,result,4,0.0021841053,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(<mask>, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3699,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36706,36706,IdentifierMutator-Literal,0,pos,1,0.09735707,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf,<mask>, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3700,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36706,36706,IdentifierMutator-Literal,0,offset,2,0.004747197,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf,<mask>, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3701,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36706,36706,IdentifierMutator-Literal,0,buf,3,0.0029934542,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf,<mask>, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3702,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36706,36706,IdentifierMutator-Literal,0,false,4,0.002116439,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf,<mask>, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3703,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36709,36718,IdentifierMutator-Variable,buf.length,pos,0,0.64038384,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0,<mask>);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3704,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36709,36718,IdentifierMutator-Variable,buf.length,len,1,0.18239662,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0,<mask>);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3705,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36709,36718,IdentifierMutator-Variable,buf.length,0,2,0.03290623,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0,<mask>);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3706,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36709,36718,IdentifierMutator-Variable,buf.length,true,3,0.016878948,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0,<mask>);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3707,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36709,36718,IdentifierMutator-Variable,buf.length,false,4,0.008555808,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0,<mask>);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3708,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36709,36711,IdentifierMutator-Variable,buf,buffer,1,0.055511158,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0,<mask>.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3709,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36709,36711,IdentifierMutator-Variable,buf,buff,3,0.0010387725,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0,<mask>.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3710,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36709,36711,IdentifierMutator-Variable,buf,result,4,9.929256E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0,<mask>.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3711,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36713,36718,FieldReferenceMutator,length,position,1,1.218735E-4,buf.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.<mask>);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3712,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36713,36718,FieldReferenceMutator,length,limit,2,6.5920234E-5,buf.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.<mask>);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3713,Base64.java,encode,byte[] encode(byte[] pArray),928,940,36713,36718,FieldReferenceMutator,length,size,3,4.357593E-5,buf.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.<mask>);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3714,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36874,36877,BinaryOperatorMutator,&&,||,2,0.04039839,isUrlSafe() <mask> (pos < buf.length),"      return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe()<mask>pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3715,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36874,36877,BinaryOperatorMutator,&&,&,3,0.0094228685,isUrlSafe() <mask> (pos < buf.length),"      return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe()<mask>pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3716,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36874,36877,BinaryOperatorMutator,&&,|,4,0.005010417,isUrlSafe() <mask> (pos < buf.length),"      return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe()<mask>pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3717,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36863,36871,MethodCallMutator,isUrlSafe,valid,0,0.08341828,<mask>(),"          return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (<mask>() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3718,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36863,36871,MethodCallMutator,isUrlSafe,fill,1,0.06756462,<mask>(),"          return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (<mask>() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3719,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36863,36871,MethodCallMutator,isUrlSafe,complete,2,0.056307018,<mask>(),"          return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (<mask>() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3720,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36863,36871,MethodCallMutator,isUrlSafe,pad,3,0.041950103,<mask>(),"          return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (<mask>() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3721,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36863,36871,MethodCallMutator,isUrlSafe,found,4,0.037518505,<mask>(),"          return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (<mask>() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3722,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36881,36883,BinaryOperatorMutator,<,>,2,0.08232825,pos <mask> buf.length,"    return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos<mask>buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3723,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36881,36883,BinaryOperatorMutator,<,==,3,0.069434926,pos <mask> buf.length,"    return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos<mask>buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3724,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36881,36883,BinaryOperatorMutator,<,>=,4,0.034890406,pos <mask> buf.length,"    return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos<mask>buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3725,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36878,36880,IdentifierMutator-Variable,pos,position,1,0.0011137011,<mask>,"     return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() &&<mask> < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3726,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36878,36880,IdentifierMutator-Variable,pos,length,2,6.8538514E-4,<mask>,"     return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() &&<mask> < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3727,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36878,36880,IdentifierMutator-Variable,pos,len,3,6.3545624E-4,<mask>,"     return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() &&<mask> < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3728,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36878,36880,IdentifierMutator-Variable,pos,0,4,6.144849E-4,<mask>,"     return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() &&<mask> < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3729,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36878,36880,FieldReferenceMutator,pos,position,1,0.0011137011,<mask>,"     return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() &&<mask> < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3730,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36878,36880,FieldReferenceMutator,pos,length,2,6.8538514E-4,<mask>,"     return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() &&<mask> < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3731,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36878,36880,FieldReferenceMutator,pos,len,3,6.3545624E-4,<mask>,"     return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() &&<mask> < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3732,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36878,36880,FieldReferenceMutator,pos,0,4,6.144849E-4,<mask>,"     return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() &&<mask> < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3733,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36884,36893,IdentifierMutator-Variable,buf.length,pos,0,0.39003676,<mask>,"   return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos <<mask>) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3734,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36884,36893,IdentifierMutator-Variable,buf.length,limit,1,0.17485829,<mask>,"   return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos <<mask>) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3735,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36884,36893,IdentifierMutator-Variable,buf.length,len,2,0.07201824,<mask>,"   return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos <<mask>) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3736,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36884,36893,IdentifierMutator-Variable,buf.length,0,3,0.07188184,<mask>,"   return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos <<mask>) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3737,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36884,36893,IdentifierMutator-Variable,buf.length,length,4,0.059752215,<mask>,"   return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos <<mask>) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3738,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36884,36886,IdentifierMutator-Variable,buf,buffer,1,0.019129004,<mask>,"   return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos <<mask>.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3739,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36884,36886,IdentifierMutator-Variable,buf,buff,2,5.358572E-4,<mask>,"   return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos <<mask>.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3740,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36884,36886,IdentifierMutator-Variable,buf,bytes,4,3.5769597E-4,<mask>,"   return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos <<mask>.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3741,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36888,36893,FieldReferenceMutator,length,position,1,1.2339954E-4,buf.<mask>," return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.<mask>) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3742,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36888,36893,FieldReferenceMutator,length,size,3,5.3257227E-5,buf.<mask>," return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.<mask>) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3743,Base64.java,encode,byte[] encode(byte[] pArray),928,944,36888,36893,FieldReferenceMutator,length,len,4,1.8789742E-5,buf.<mask>," return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.<mask>) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3744,Base64.java,encode,byte[] encode(byte[] pArray),928,945,36939,36941,IdentifierMutator-Variable,pos,len,1,0.0636243,<mask>," getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[<mask>];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3745,Base64.java,encode,byte[] encode(byte[] pArray),928,945,36939,36941,IdentifierMutator-Variable,pos,Pos,3,0.0085509075,<mask>," getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[<mask>];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3746,Base64.java,encode,byte[] encode(byte[] pArray),928,945,36939,36941,IdentifierMutator-Variable,pos,36,4,0.00836993,<mask>," getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[<mask>];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3747,Base64.java,encode,byte[] encode(byte[] pArray),928,945,36939,36941,FieldReferenceMutator,pos,len,1,0.0636243,<mask>," getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[<mask>];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3748,Base64.java,encode,byte[] encode(byte[] pArray),928,945,36939,36941,FieldReferenceMutator,pos,Pos,3,0.0085509075,<mask>," getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[<mask>];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3749,Base64.java,encode,byte[] encode(byte[] pArray),928,945,36939,36941,FieldReferenceMutator,pos,36,4,0.00836993,<mask>," getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[<mask>];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3750,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36964,36972,MethodCallMutator,arraycopy,copy,0,0.9945293,"System.<mask>(buf, 0, smallerBuf, 0, pos)","
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.<mask>(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3751,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36964,36972,MethodCallMutator,arraycopy,printf,1,0.0010614535,"System.<mask>(buf, 0, smallerBuf, 0, pos)","
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.<mask>(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3752,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36964,36972,MethodCallMutator,arraycopy,bytes,2,7.698833E-4,"System.<mask>(buf, 0, smallerBuf, 0, pos)","
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.<mask>(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3753,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36964,36972,MethodCallMutator,arraycopy,fill,3,4.7762858E-4,"System.<mask>(buf, 0, smallerBuf, 0, pos)","
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.<mask>(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3754,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36964,36972,MethodCallMutator,arraycopy,select,4,4.285479E-4,"System.<mask>(buf, 0, smallerBuf, 0, pos)","
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.<mask>(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3755,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36974,36976,IdentifierMutator-Variable,buf,buffer,1,0.03447243,<mask>,"      byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(<mask>, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3756,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36974,36976,IdentifierMutator-Variable,buf,buff,2,0.005214485,<mask>,"      byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(<mask>, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3757,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36974,36976,IdentifierMutator-Variable,buf,uf,4,6.4921775E-4,<mask>,"      byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(<mask>, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3758,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36979,36979,IdentifierMutator-Literal,0,pos,1,0.0475297,<mask>,"    byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf,<mask>, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3759,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36979,36979,IdentifierMutator-Literal,0,1,2,0.0016725685,<mask>,"    byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf,<mask>, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3760,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36979,36979,IdentifierMutator-Literal,0,offset,3,8.7842956E-4,<mask>,"    byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf,<mask>, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3761,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36979,36979,IdentifierMutator-Literal,0,position,4,6.6203217E-4,<mask>,"    byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf,<mask>, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3762,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36982,36991,IdentifierMutator-Variable,smallerBuf,buf,0,0.9738713,<mask>,"  byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0,<mask>, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3763,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36982,36991,IdentifierMutator-Variable,smallerBuf,buffer,1,0.015700055,<mask>,"  byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0,<mask>, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3764,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36982,36991,IdentifierMutator-Variable,smallerBuf,tmp,2,0.0018027059,<mask>,"  byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0,<mask>, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3765,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36982,36991,IdentifierMutator-Variable,smallerBuf,buf,3,7.042586E-4,<mask>,"  byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0,<mask>, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3766,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36982,36991,IdentifierMutator-Variable,smallerBuf,buff,4,5.279646E-4,<mask>,"  byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0,<mask>, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3767,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36994,36994,IdentifierMutator-Literal,0,pos,1,0.014930364,<mask>," = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf,<mask>, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3768,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36994,36994,IdentifierMutator-Literal,0,1,2,0.002016201,<mask>," = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf,<mask>, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3769,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36994,36994,IdentifierMutator-Literal,0,offset,3,0.0017210206,<mask>," = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf,<mask>, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3770,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36994,36994,IdentifierMutator-Literal,0,start,4,0.0011133956,<mask>," = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf,<mask>, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3771,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36997,36999,IdentifierMutator-Variable,pos,len,2,0.0027678926,<mask>," byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0,<mask>);
            buf = smallerBuf;
        }
        return buf;        
    }"
3772,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36997,36999,IdentifierMutator-Variable,pos,position,3,6.8004883E-4,<mask>," byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0,<mask>);
            buf = smallerBuf;
        }
        return buf;        
    }"
3773,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36997,36999,IdentifierMutator-Variable,pos,buf,4,4.821293E-4,<mask>," byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0,<mask>);
            buf = smallerBuf;
        }
        return buf;        
    }"
3774,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36997,36999,FieldReferenceMutator,pos,len,2,0.0027678926,<mask>," byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0,<mask>);
            buf = smallerBuf;
        }
        return buf;        
    }"
3775,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36997,36999,FieldReferenceMutator,pos,position,3,6.8004883E-4,<mask>," byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0,<mask>);
            buf = smallerBuf;
        }
        return buf;        
    }"
3776,Base64.java,encode,byte[] encode(byte[] pArray),928,946,36997,36999,FieldReferenceMutator,pos,buf,4,4.821293E-4,<mask>," byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0,<mask>);
            buf = smallerBuf;
        }
        return buf;        
    }"
3777,Base64.java,encode,byte[] encode(byte[] pArray),928,947,37018,37018,AssignmentMutator,buf=smallerBuf,^,0,0.22511418,buf <mask>= smallerBuf," setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf<mask>= smallerBuf;
        }
        return buf;        
    }"
3778,Base64.java,encode,byte[] encode(byte[] pArray),928,947,37018,37018,AssignmentMutator,buf=smallerBuf,|,1,0.21868436,buf <mask>= smallerBuf," setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf<mask>= smallerBuf;
        }
        return buf;        
    }"
3779,Base64.java,encode,byte[] encode(byte[] pArray),928,947,37018,37018,AssignmentMutator,buf=smallerBuf,[],2,0.20682831,buf <mask>= smallerBuf," setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf<mask>= smallerBuf;
        }
        return buf;        
    }"
3780,Base64.java,encode,byte[] encode(byte[] pArray),928,947,37018,37018,AssignmentMutator,buf=smallerBuf,.,3,0.10443374,buf <mask>= smallerBuf," setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf<mask>= smallerBuf;
        }
        return buf;        
    }"
3781,Base64.java,encode,byte[] encode(byte[] pArray),928,947,37018,37018,AssignmentMutator,buf=smallerBuf,*,4,0.066237435,buf <mask>= smallerBuf," setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf<mask>= smallerBuf;
        }
        return buf;        
    }"
3782,Base64.java,encode,byte[] encode(byte[] pArray),928,947,37015,37017,IdentifierMutator-Variable,buf,buffer,1,0.019510556,<mask>,"(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);<mask> = smallerBuf;
        }
        return buf;        
    }"
3783,Base64.java,encode,byte[] encode(byte[] pArray),928,947,37015,37017,IdentifierMutator-Variable,buf,pos,3,8.7812694E-4,<mask>,"(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);<mask> = smallerBuf;
        }
        return buf;        
    }"
3784,Base64.java,encode,byte[] encode(byte[] pArray),928,947,37015,37017,IdentifierMutator-Variable,buf,buff,4,6.554376E-4,<mask>,"(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);<mask> = smallerBuf;
        }
        return buf;        
    }"
3785,Base64.java,encode,byte[] encode(byte[] pArray),928,947,37021,37030,IdentifierMutator-Variable,smallerBuf,null,0,0.64716446,<mask>,"InitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf =<mask>;
        }
        return buf;        
    }"
3786,Base64.java,encode,byte[] encode(byte[] pArray),928,947,37021,37030,IdentifierMutator-Variable,smallerBuf,tmp,1,0.04206172,<mask>,"InitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf =<mask>;
        }
        return buf;        
    }"
3787,Base64.java,encode,byte[] encode(byte[] pArray),928,947,37021,37030,IdentifierMutator-Variable,smallerBuf,"""""",2,0.036717545,<mask>,"InitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf =<mask>;
        }
        return buf;        
    }"
3788,Base64.java,encode,byte[] encode(byte[] pArray),928,947,37021,37030,IdentifierMutator-Variable,smallerBuf,"''",3,0.030381972,<mask>,"InitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf =<mask>;
        }
        return buf;        
    }"
3789,Base64.java,encode,byte[] encode(byte[] pArray),928,947,37021,37030,IdentifierMutator-Variable,smallerBuf,undefined,4,0.029968875,<mask>,"InitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf =<mask>;
        }
        return buf;        
    }"
3790,Base64.java,encode,byte[] encode(byte[] pArray),928,949,37058,37060,IdentifierMutator-Variable,buf,null,1,0.018238561,<mask>,"Array, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return<mask>;        
    }"
3791,Base64.java,encode,byte[] encode(byte[] pArray),928,949,37058,37060,IdentifierMutator-Variable,buf,buffer,2,0.014618746,<mask>,"Array, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return<mask>;        
    }"
3792,Base64.java,encode,byte[] encode(byte[] pArray),928,949,37058,37060,IdentifierMutator-Variable,buf,true,3,0.012997434,<mask>,"Array, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return<mask>;        
    }"
3793,Base64.java,encode,byte[] encode(byte[] pArray),928,949,37058,37060,IdentifierMutator-Variable,buf,pos,4,0.010081948,<mask>,"Array, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return<mask>;        
    }"
3794,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37808,37808,AssignmentMutator,chunkSize=(chunkSize/4)*4,*,0,0.757699,chunkSize <mask>= (chunkSize / 4) * 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize<mask>= (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3795,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37808,37808,AssignmentMutator,chunkSize=(chunkSize/4)*4,/,1,0.084082216,chunkSize <mask>= (chunkSize / 4) * 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize<mask>= (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3796,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37808,37808,AssignmentMutator,chunkSize=(chunkSize/4)*4,//,2,0.03792095,chunkSize <mask>= (chunkSize / 4) * 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize<mask>= (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3797,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37808,37808,AssignmentMutator,chunkSize=(chunkSize/4)*4,|,3,0.025838248,chunkSize <mask>= (chunkSize / 4) * 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize<mask>= (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3798,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37808,37808,AssignmentMutator,chunkSize=(chunkSize/4)*4,^,4,0.01236561,chunkSize <mask>= (chunkSize / 4) * 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize<mask>= (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3799,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37799,37807,IdentifierMutator-Variable,chunkSize,len,0,0.28523907,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.<mask> = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3800,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37799,37807,IdentifierMutator-Variable,chunkSize,int,1,0.11599006,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.<mask> = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3801,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37799,37807,IdentifierMutator-Variable,chunkSize,len,2,0.054348,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.<mask> = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3802,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37799,37807,IdentifierMutator-Variable,chunkSize,div,3,0.04248994,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.<mask> = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3803,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37799,37807,IdentifierMutator-Variable,chunkSize,//,4,0.03864612,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.<mask> = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3804,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37826,37828,BinaryOperatorMutator,*,/,2,0.095027745,(chunkSize / 4) <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4)<mask>4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3805,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37826,37828,BinaryOperatorMutator,*,/,3,0.04321274,(chunkSize / 4) <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4)<mask>4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3806,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37826,37828,BinaryOperatorMutator,*,%,4,0.04270596,(chunkSize / 4) <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4)<mask>4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3807,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37821,37823,BinaryOperatorMutator,/,*,1,0.08277949,chunkSize <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize<mask>4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3808,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37821,37823,BinaryOperatorMutator,/,*,3,0.03368062,chunkSize <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize<mask>4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3809,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37821,37823,BinaryOperatorMutator,/,)/,4,0.019451067,chunkSize <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize<mask>4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3810,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37812,37820,IdentifierMutator-Variable,chunkSize,4,0,0.15232132,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (<mask> / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3811,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37812,37820,IdentifierMutator-Variable,chunkSize,3,1,0.12016192,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (<mask> / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3812,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37812,37820,IdentifierMutator-Variable,chunkSize,1,2,0.05391293,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (<mask> / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3813,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37812,37820,IdentifierMutator-Variable,chunkSize,bytes,3,0.05169963,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (<mask> / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3814,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37812,37820,IdentifierMutator-Variable,chunkSize,32,4,0.04886875,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (<mask> / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3815,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37824,37824,IdentifierMutator-Literal,4,3,1,0.30965114,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize /<mask>) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3816,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37824,37824,IdentifierMutator-Literal,4,2,2,0.08291702,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize /<mask>) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3817,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37824,37824,IdentifierMutator-Literal,4,8,3,0.019172817,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize /<mask>) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3818,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37824,37824,IdentifierMutator-Literal,4,5,4,0.010471348,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize /<mask>) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3819,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37829,37829,IdentifierMutator-Literal,4,3,1,0.26828933,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) *<mask>;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3820,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37829,37829,IdentifierMutator-Literal,4,2,2,0.09560742,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) *<mask>;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3821,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37829,37829,IdentifierMutator-Literal,4,8,3,0.016020432,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) *<mask>;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3822,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,965,37829,37829,IdentifierMutator-Literal,4,5,4,0.0140400315,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) *<mask>;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3823,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37871,37873,BinaryOperatorMutator,/,*,0,0.4006437,(pArray.length * 4) <mask> 3,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4)<mask>3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3824,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37871,37873,BinaryOperatorMutator,/,*,1,0.20103638,(pArray.length * 4) <mask> 3,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4)<mask>3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3825,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37871,37873,BinaryOperatorMutator,/,**,4,0.031025715,(pArray.length * 4) <mask> 3,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4)<mask>3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3826,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37866,37868,BinaryOperatorMutator,*,/,1,0.25892794,pArray.length <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length<mask>4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3827,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37866,37868,BinaryOperatorMutator,*,**,3,0.030127496,pArray.length <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length<mask>4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3828,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37866,37868,BinaryOperatorMutator,*,-,4,0.012048614,pArray.length <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length<mask>4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3829,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37853,37865,IdentifierMutator-Variable,pArray.length,len,0,0.33022672,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3830,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37853,37865,IdentifierMutator-Variable,pArray.length,4,1,0.09437993,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3831,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37853,37865,IdentifierMutator-Variable,pArray.length,length,2,0.03643782,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3832,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37853,37865,IdentifierMutator-Variable,pArray.length,32,3,0.033453718,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3833,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37853,37865,IdentifierMutator-Variable,pArray.length,16,4,0.032144215,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3834,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37853,37858,IdentifierMutator-Variable,pArray,Array,0,0.6888457,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask>.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3835,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37853,37858,IdentifierMutator-Variable,pArray,array,1,0.27955845,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask>.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3836,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37853,37858,IdentifierMutator-Variable,pArray,buffer,2,0.0035116186,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask>.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3837,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37853,37858,IdentifierMutator-Variable,pArray,this,3,0.002345703,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask>.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3838,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37853,37858,IdentifierMutator-Variable,pArray,data,4,0.0019203473,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask>.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3839,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37860,37865,FieldReferenceMutator,length,size,1,2.642277E-4,pArray.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3840,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37860,37865,FieldReferenceMutator,length,len,3,1.5998367E-4,pArray.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3841,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37860,37865,FieldReferenceMutator,length,Length,4,4.6745114E-5,pArray.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3842,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37869,37869,IdentifierMutator-Literal,4,3,1,0.35696718,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length *<mask>) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3843,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37869,37869,IdentifierMutator-Literal,4,2,2,0.085122965,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length *<mask>) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3844,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37869,37869,IdentifierMutator-Literal,4,5,3,0.008801148,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length *<mask>) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3845,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37869,37869,IdentifierMutator-Literal,4,8,4,0.0048501487,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length *<mask>) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3846,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37874,37874,IdentifierMutator-Literal,3,4,0,0.9792214,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) /<mask>;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3847,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37874,37874,IdentifierMutator-Literal,3,8,1,0.004820542,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) /<mask>;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3848,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37874,37874,IdentifierMutator-Literal,3,2,2,0.004698203,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) /<mask>;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3849,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,967,37874,37874,IdentifierMutator-Literal,3,5,4,0.0013046103,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) /<mask>;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3850,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,968,37899,37901,BinaryOperatorMutator,%,/,2,0.044680826,len <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len<mask>4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3851,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,968,37899,37901,BinaryOperatorMutator,%,*,3,0.013669026,len <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len<mask>4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3852,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,968,37899,37901,BinaryOperatorMutator,%,/,4,0.003808918,len <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len<mask>4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3853,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,968,37896,37898,IdentifierMutator-Variable,len,length,2,1.7645262E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod =<mask> % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3854,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,968,37896,37898,IdentifierMutator-Variable,len,Len,3,1.1776573E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod =<mask> % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3855,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,968,37896,37898,IdentifierMutator-Variable,len,0,4,4.061957E-5,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod =<mask> % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3856,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,968,37902,37902,IdentifierMutator-Literal,4,3,1,0.093714364,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len %<mask>;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3857,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,968,37902,37902,IdentifierMutator-Literal,4,2,2,0.02227574,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len %<mask>;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3858,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,968,37902,37902,IdentifierMutator-Literal,4,32,3,0.014692254,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len %<mask>;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3859,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,968,37902,37902,IdentifierMutator-Literal,4,8,4,0.009212671,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len %<mask>;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3860,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,969,37920,37923,BinaryOperatorMutator,!=,==,0,0.40180746,mod <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod<mask>0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3861,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,969,37920,37923,BinaryOperatorMutator,!=,>,1,0.31130987,mod <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod<mask>0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3862,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,969,37920,37923,BinaryOperatorMutator,!=,>,2,0.16050862,mod <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod<mask>0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3863,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,969,37920,37923,BinaryOperatorMutator,!=,<,4,0.02190726,mod <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod<mask>0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3864,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,969,37917,37919,IdentifierMutator-Variable,mod,Mod,2,1.6270451E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (<mask> != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3865,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,969,37917,37919,IdentifierMutator-Variable,mod,MOD,3,1.3211368E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (<mask> != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3866,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,969,37917,37919,IdentifierMutator-Variable,mod,div,4,1.2680917E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (<mask> != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3867,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,969,37924,37924,IdentifierMutator-Literal,0,len,1,0.03223993,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod !=<mask>) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3868,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,969,37924,37924,IdentifierMutator-Literal,0,1,2,0.011239246,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod !=<mask>) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3869,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,969,37924,37924,IdentifierMutator-Literal,0,4,3,0.008156157,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod !=<mask>) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3870,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,969,37924,37924,IdentifierMutator-Literal,0,mod,4,0.004971297,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod !=<mask>) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3871,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37944,37944,AssignmentMutator,len+=4-mod,*,0,0.6208573,len <mask>= 4 - mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len<mask>+= 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3872,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37944,37944,AssignmentMutator,len+=4-mod,/,1,0.20294932,len <mask>= 4 - mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len<mask>+= 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3873,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37944,37944,AssignmentMutator,len+=4-mod,//,2,0.043565005,len <mask>= 4 - mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len<mask>+= 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3874,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37944,37944,AssignmentMutator,len+=4-mod,|,3,0.028616333,len <mask>= 4 - mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len<mask>+= 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3875,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37944,37944,AssignmentMutator,len+=4-mod,%,4,0.016350625,len <mask>= 4 - mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len<mask>+= 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3876,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37941,37943,IdentifierMutator-Variable,len,Len,2,0.003104103,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {<mask> += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3877,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37941,37943,IdentifierMutator-Variable,len,length,3,0.0010736735,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {<mask> += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3878,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37941,37943,IdentifierMutator-Variable,len,err,4,7.8696647E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {<mask> += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3879,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37949,37951,BinaryOperatorMutator,-,*,0,0.9141032,4 <mask> mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4<mask>mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3880,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37949,37951,BinaryOperatorMutator,-,*,1,0.028346602,4 <mask> mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4<mask>mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3881,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37949,37951,BinaryOperatorMutator,-,**,3,0.014989038,4 <mask> mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4<mask>mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3882,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37949,37951,BinaryOperatorMutator,-,+,4,0.004105301,4 <mask> mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4<mask>mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3883,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37948,37948,IdentifierMutator-Literal,4,32,1,0.08176036,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len +=<mask> - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3884,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37948,37948,IdentifierMutator-Literal,4,len,2,0.05865364,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len +=<mask> - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3885,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37948,37948,IdentifierMutator-Literal,4,64,3,0.03778266,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len +=<mask> - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3886,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37948,37948,IdentifierMutator-Literal,4,8,4,0.02173213,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len +=<mask> - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3887,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37952,37954,IdentifierMutator-Variable,mod,Mod,1,7.1611453E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 -<mask>;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3888,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37952,37954,IdentifierMutator-Variable,mod,1,2,5.1725365E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 -<mask>;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3889,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37952,37954,IdentifierMutator-Variable,mod,div,3,4.6540948E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 -<mask>;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3890,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,970,37952,37954,IdentifierMutator-Variable,mod,dec,4,4.5103315E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 -<mask>;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3891,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,972,37988,37990,BinaryOperatorMutator,>,==,0,0.42665642,chunkSize <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize<mask>0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3892,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,972,37988,37990,BinaryOperatorMutator,>,!=,3,0.02422497,chunkSize <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize<mask>0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3893,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,972,37988,37990,BinaryOperatorMutator,>,==,4,0.016458822,chunkSize <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize<mask>0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3894,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,972,37979,37987,IdentifierMutator-Variable,chunkSize,len,0,0.97435886,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (<mask> > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3895,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,972,37979,37987,IdentifierMutator-Variable,chunkSize,length,1,0.002224858,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (<mask> > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3896,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,972,37979,37987,IdentifierMutator-Variable,chunkSize,Len,2,0.0020340185,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (<mask> > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3897,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,972,37979,37987,IdentifierMutator-Variable,chunkSize,mod,3,0.0010735629,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (<mask> > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3898,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,972,37979,37987,IdentifierMutator-Variable,chunkSize,len,4,6.814558E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (<mask> > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3899,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,972,37991,37991,IdentifierMutator-Literal,0,1,1,0.106186375,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize ><mask>) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3900,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,972,37991,37991,IdentifierMutator-Literal,0,4,2,0.07249552,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize ><mask>) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3901,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,972,37991,37991,IdentifierMutator-Literal,0,2,3,0.028006159,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize ><mask>) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3902,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,972,37991,37991,IdentifierMutator-Literal,0,3,4,0.022125917,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize ><mask>) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3903,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,973,38052,38055,BinaryOperatorMutator,==,!=,1,0.117873356,(len % chunkSize) <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize<mask>0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3904,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,973,38052,38055,BinaryOperatorMutator,==,=,3,0.021738809,(len % chunkSize) <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize<mask>0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3905,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,973,38052,38055,BinaryOperatorMutator,==,>,4,0.017359745,(len % chunkSize) <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize<mask>0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3906,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,973,38040,38042,BinaryOperatorMutator,%,/,2,0.1369017,len <mask> chunkSize,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len<mask>chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3907,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,973,38040,38042,BinaryOperatorMutator,%,-$,3,0.004605716,len <mask> chunkSize,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len<mask>chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3908,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,973,38040,38042,BinaryOperatorMutator,%,*,4,0.0044896216,len <mask> chunkSize,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len<mask>chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3909,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,973,38037,38039,IdentifierMutator-Variable,len,length,2,8.675184E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly =<mask> % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3910,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,973,38037,38039,IdentifierMutator-Variable,len,0,3,1.0422285E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly =<mask> % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3911,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,973,38037,38039,IdentifierMutator-Variable,len,Len,4,8.851278E-5,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly =<mask> % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3912,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,973,38043,38051,IdentifierMutator-Variable,chunkSize,4,0,0.88476956,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len %<mask> == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3913,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,973,38043,38051,IdentifierMutator-Variable,chunkSize,3,1,0.032893747,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len %<mask> == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3914,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,973,38043,38051,IdentifierMutator-Variable,chunkSize,2,2,0.031356677,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len %<mask> == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3915,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,973,38043,38051,IdentifierMutator-Variable,chunkSize,8,3,0.0075453436,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len %<mask> == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3916,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,973,38043,38051,IdentifierMutator-Variable,chunkSize,5,4,0.005714381,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len %<mask> == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3917,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,973,38056,38056,IdentifierMutator-Literal,0,1,1,0.021548418,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize ==<mask>;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3918,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,973,38056,38056,IdentifierMutator-Literal,0,2,2,0.0014325888,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize ==<mask>;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3919,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,973,38056,38056,IdentifierMutator-Literal,0,4,3,6.348271E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize ==<mask>;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3920,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,973,38056,38056,IdentifierMutator-Literal,0,3,4,5.438567E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize ==<mask>;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3921,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38074,38074,AssignmentMutator,len+=(len/chunkSize)*chunkSeparator.length,*,0,0.38173753,len <mask>= (len / chunkSize) * chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len<mask>+= (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3922,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38074,38074,AssignmentMutator,len+=(len/chunkSize)*chunkSeparator.length,//,1,0.07163011,len <mask>= (len / chunkSize) * chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len<mask>+= (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3923,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38074,38074,AssignmentMutator,len+=(len/chunkSize)*chunkSeparator.length,,2,0.05592861,len <mask>= (len / chunkSize) * chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len<mask>+= (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3924,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38074,38074,AssignmentMutator,len+=(len/chunkSize)*chunkSeparator.length,*,3,0.040907517,len <mask>= (len / chunkSize) * chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len<mask>+= (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3925,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38074,38074,AssignmentMutator,len+=(len/chunkSize)*chunkSeparator.length,+,4,0.039499134,len <mask>= (len / chunkSize) * chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len<mask>+= (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3926,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38071,38073,IdentifierMutator-Variable,len,//,1,0.17717728,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;<mask> += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3927,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38071,38073,IdentifierMutator-Variable,len,,3,0.0069302907,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;<mask> += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3928,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38071,38073,IdentifierMutator-Variable,len,pos,4,0.0057359356,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;<mask> += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3929,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38095,38097,BinaryOperatorMutator,*,+,2,0.019141003,(len / chunkSize) <mask> chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize)<mask>chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3930,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38095,38097,BinaryOperatorMutator,*,/,3,0.017518666,(len / chunkSize) <mask> chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize)<mask>chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3931,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38095,38097,BinaryOperatorMutator,*,^,4,0.010515787,(len / chunkSize) <mask> chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize)<mask>chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3932,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38082,38084,BinaryOperatorMutator,/,)/,1,0.07492397,len <mask> chunkSize,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len<mask>chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3933,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38082,38084,BinaryOperatorMutator,/,%,2,0.055136304,len <mask> chunkSize,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len<mask>chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3934,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38082,38084,BinaryOperatorMutator,/,*,4,0.04294577,len <mask> chunkSize,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len<mask>chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3935,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38079,38081,IdentifierMutator-Variable,len,Len,2,6.170651E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (<mask> / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3936,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38079,38081,IdentifierMutator-Variable,len,fin,3,8.2147235E-5,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (<mask> / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3937,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38079,38081,IdentifierMutator-Variable,len,0,4,7.993763E-5,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (<mask> / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3938,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38085,38093,IdentifierMutator-Variable,chunkSize,4,0,0.80962336,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len /<mask>) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3939,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38085,38093,IdentifierMutator-Variable,chunkSize,3,1,0.08805891,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len /<mask>) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3940,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38085,38093,IdentifierMutator-Variable,chunkSize,2,2,0.055543303,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len /<mask>) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3941,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38085,38093,IdentifierMutator-Variable,chunkSize,8,3,0.006437249,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len /<mask>) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3942,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38085,38093,IdentifierMutator-Variable,chunkSize,chunk,4,0.003611176,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len /<mask>) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3943,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38098,38118,IdentifierMutator-Variable,chunkSeparator.length,4,0,0.76078147,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3944,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38098,38118,IdentifierMutator-Variable,chunkSeparator.length,3,1,0.06535143,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3945,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38098,38118,IdentifierMutator-Variable,chunkSeparator.length,2,2,0.057437994,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3946,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38098,38118,IdentifierMutator-Variable,chunkSeparator.length,mod,3,0.017319407,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3947,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38098,38118,IdentifierMutator-Variable,chunkSeparator.length,8,4,0.012866691,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3948,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38098,38111,IdentifierMutator-Variable,chunkSeparator,array,0,0.38937578,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3949,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38098,38111,IdentifierMutator-Variable,chunkSeparator,arr,1,0.10213026,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3950,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38098,38111,IdentifierMutator-Variable,chunkSeparator,Array,2,0.08558387,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3951,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38098,38111,IdentifierMutator-Variable,chunkSeparator,buffer,3,0.04623182,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3952,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38098,38111,IdentifierMutator-Variable,chunkSeparator,Array,4,0.029352197,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3953,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38113,38118,FieldReferenceMutator,length,len,1,0.0011182418,chunkSeparator.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3954,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38113,38118,FieldReferenceMutator,length,width,2,1.1393922E-4,chunkSeparator.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3955,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38113,38118,FieldReferenceMutator,length,size,3,9.849639E-5,chunkSeparator.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3956,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,974,38113,38118,FieldReferenceMutator,length,count,4,5.8391033E-5,chunkSeparator.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3957,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,975,38137,38137,UnaryOperatorMutator,!,--,2,0.009289978,<mask>lenChunksPerfectly,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (<mask>lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3958,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,975,38137,38137,UnaryOperatorMutator,!,...,3,0.006332605,<mask>lenChunksPerfectly,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (<mask>lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3959,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,975,38137,38137,UnaryOperatorMutator,!,!!,4,0.002312401,<mask>lenChunksPerfectly,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (<mask>lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3960,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,975,38138,38155,IdentifierMutator-Variable,lenChunksPerfectly,broken,0,0.05640271,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!<mask>) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3961,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,975,38138,38155,IdentifierMutator-Variable,lenChunksPerfectly,break,1,0.047219757,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!<mask>) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3962,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,975,38138,38155,IdentifierMutator-Variable,lenChunksPerfectly,reverse,2,0.03924868,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!<mask>) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3963,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,975,38138,38155,IdentifierMutator-Variable,lenChunksPerfectly,fast,3,0.03328369,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!<mask>) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3964,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,975,38138,38155,IdentifierMutator-Variable,lenChunksPerfectly,slow,4,0.029463543,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!<mask>) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3965,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38179,38179,AssignmentMutator,len+=chunkSeparator.length,*,0,0.82963556,len <mask>= chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len<mask>+= chunkSeparator.length;
            }
        }
        return len;
    }"
3966,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38179,38179,AssignmentMutator,len+=chunkSeparator.length,/,1,0.10925856,len <mask>= chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len<mask>+= chunkSeparator.length;
            }
        }
        return len;
    }"
3967,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38179,38179,AssignmentMutator,len+=chunkSeparator.length,//,2,0.018342782,len <mask>= chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len<mask>+= chunkSeparator.length;
            }
        }
        return len;
    }"
3968,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38179,38179,AssignmentMutator,len+=chunkSeparator.length,|,3,0.009996202,len <mask>= chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len<mask>+= chunkSeparator.length;
            }
        }
        return len;
    }"
3969,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38179,38179,AssignmentMutator,len+=chunkSeparator.length,*,4,0.0037754227,len <mask>= chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len<mask>+= chunkSeparator.length;
            }
        }
        return len;
    }"
3970,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38176,38178,IdentifierMutator-Variable,len,Len,2,0.0014724658,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {<mask> += chunkSeparator.length;
            }
        }
        return len;
    }"
3971,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38176,38178,IdentifierMutator-Variable,len,str,3,8.6564856E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {<mask> += chunkSeparator.length;
            }
        }
        return len;
    }"
3972,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38176,38178,IdentifierMutator-Variable,len,length,4,7.715416E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {<mask> += chunkSeparator.length;
            }
        }
        return len;
    }"
3973,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38183,38203,IdentifierMutator-Variable,chunkSeparator.length,mod,0,0.5163985,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>;
            }
        }
        return len;
    }"
3974,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38183,38203,IdentifierMutator-Variable,chunkSeparator.length,1,1,0.20487992,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>;
            }
        }
        return len;
    }"
3975,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38183,38203,IdentifierMutator-Variable,chunkSeparator.length,4,2,0.064282306,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>;
            }
        }
        return len;
    }"
3976,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38183,38203,IdentifierMutator-Variable,chunkSeparator.length,3,3,0.03824685,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>;
            }
        }
        return len;
    }"
3977,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38183,38203,IdentifierMutator-Variable,chunkSeparator.length,2,4,0.028362343,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>;
            }
        }
        return len;
    }"
3978,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38183,38196,IdentifierMutator-Variable,chunkSeparator,array,0,0.21368952,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>.length;
            }
        }
        return len;
    }"
3979,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38183,38196,IdentifierMutator-Variable,chunkSeparator,buffer,1,0.11163643,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>.length;
            }
        }
        return len;
    }"
3980,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38183,38196,IdentifierMutator-Variable,chunkSeparator,arr,2,0.06837422,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>.length;
            }
        }
        return len;
    }"
3981,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38183,38196,IdentifierMutator-Variable,chunkSeparator,buf,3,0.045161966,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>.length;
            }
        }
        return len;
    }"
3982,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38183,38196,IdentifierMutator-Variable,chunkSeparator,Array,4,0.038819157,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>.length;
            }
        }
        return len;
    }"
3983,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38198,38203,FieldReferenceMutator,length,len,1,4.7619356E-4,chunkSeparator.<mask>,"codeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.<mask>;
            }
        }
        return len;
    }"
3984,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38198,38203,FieldReferenceMutator,length,width,2,6.557313E-5,chunkSeparator.<mask>,"codeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.<mask>;
            }
        }
        return len;
    }"
3985,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,976,38198,38203,FieldReferenceMutator,length,size,4,3.7971742E-5,chunkSeparator.<mask>,"codeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.<mask>;
            }
        }
        return len;
    }"
3986,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,979,38245,38247,IdentifierMutator-Variable,len,0,1,0.031097928,<mask>,"odes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return<mask>;
    }"
3987,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,979,38245,38247,IdentifierMutator-Variable,len,true,2,0.016361566,<mask>,"odes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return<mask>;
    }"
3988,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,979,38245,38247,IdentifierMutator-Variable,len,ret,3,0.014006297,<mask>,"odes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return<mask>;
    }"
3989,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",963,979,38245,38247,IdentifierMutator-Variable,len,"''",4,0.009495319,<mask>,"odes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return<mask>;
    }"
3990,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),991,992,38658,38658,IdentifierMutator-Literal,1,base,0,0.0871249,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(<mask>, decodeBase64(pArray));
    }"
3991,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),991,992,38658,38658,IdentifierMutator-Literal,1,1024,1,0.08487986,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(<mask>, decodeBase64(pArray));
    }"
3992,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),991,992,38658,38658,IdentifierMutator-Literal,1,0,2,0.07982505,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(<mask>, decodeBase64(pArray));
    }"
3993,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),991,992,38658,38658,IdentifierMutator-Literal,1,10,4,0.0697782,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(<mask>, decodeBase64(pArray));
    }"
3994,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),991,992,38661,38672,MethodCallMutator,decodeBase64,decode,0,0.9825644,<mask>(pArray),"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1,<mask>(pArray));
    }"
3995,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),991,992,38661,38672,MethodCallMutator,decodeBase64,encode,1,0.00430283,<mask>(pArray),"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1,<mask>(pArray));
    }"
3996,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),991,992,38661,38672,MethodCallMutator,decodeBase64,dec,2,0.0021592102,<mask>(pArray),"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1,<mask>(pArray));
    }"
3997,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),991,992,38661,38672,MethodCallMutator,decodeBase64,reverse,3,0.0016701736,<mask>(pArray),"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1,<mask>(pArray));
    }"
3998,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),991,992,38661,38672,MethodCallMutator,decodeBase64,decrypt,4,9.45154E-4,<mask>(pArray),"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1,<mask>(pArray));
    }"
3999,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),991,992,38674,38679,IdentifierMutator-Variable,pArray,array,0,0.55204374,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1, decodeBase64(<mask>));
    }"
4000,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),991,992,38674,38679,IdentifierMutator-Variable,pArray,Array,1,0.36896852,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1, decodeBase64(<mask>));
    }"
4001,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),991,992,38674,38679,IdentifierMutator-Variable,pArray,p,2,0.019651005,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1, decodeBase64(<mask>));
    }"
4002,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),991,992,38674,38679,IdentifierMutator-Variable,pArray,arr,3,0.012463191,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1, decodeBase64(<mask>));
    }"
4003,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),991,992,38674,38679,IdentifierMutator-Variable,pArray,buffer,4,0.0044633653,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1, decodeBase64(<mask>));
    }"
4004,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1006,39101,39104,BinaryOperatorMutator,==,=,2,0.030335454,bigInt <mask> null,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt<mask>null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4005,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1006,39101,39104,BinaryOperatorMutator,==,||,3,0.0037420779,bigInt <mask> null,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt<mask>null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4006,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1006,39101,39104,BinaryOperatorMutator,==,_,4,9.858963E-4,bigInt <mask> null,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt<mask>null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4007,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1006,39095,39100,IdentifierMutator-Variable,bigInt,Parameter,0,0.11120432,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (<mask> == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4008,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1006,39095,39100,IdentifierMutator-Variable,bigInt,arg,1,0.093337074,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (<mask> == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4009,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1006,39095,39100,IdentifierMutator-Variable,bigInt,int,2,0.09172699,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (<mask> == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4010,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1006,39095,39100,IdentifierMutator-Variable,bigInt,params,3,0.0786028,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (<mask> == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4011,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1006,39095,39100,IdentifierMutator-Variable,bigInt,param,4,0.066067465,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (<mask> == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4012,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1006,39105,39108,IdentifierMutator-Literal,null,NULL,1,7.713278E-4,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt ==<mask>) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4013,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1006,39105,39108,IdentifierMutator-Literal,null,0,2,2.384645E-4,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt ==<mask>) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4014,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1006,39105,39108,IdentifierMutator-Literal,null,this,3,5.929655E-5,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt ==<mask>) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4015,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1006,39105,39108,IdentifierMutator-Literal,null,nil,4,3.7733767E-5,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt ==<mask>) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4016,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1007,39156,39197,IdentifierMutator-Literal,"""encodeIntegercalledwithnullparameter""",null,0,0.6568566,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(<mask>);
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4017,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1007,39156,39197,IdentifierMutator-Literal,"""encodeIntegercalledwithnullparameter""",this,1,0.10882717,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(<mask>);
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4018,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1007,39156,39197,IdentifierMutator-Literal,"""encodeIntegercalledwithnullparameter""",int,2,0.040326968,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(<mask>);
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4019,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1007,39156,39197,IdentifierMutator-Literal,"""encodeIntegercalledwithnullparameter""",string,3,0.0266979,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(<mask>);
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4020,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1007,39156,39197,IdentifierMutator-Literal,"""encodeIntegercalledwithnullparameter""",0,4,0.015059375,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(<mask>);
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4021,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39226,39237,MethodCallMutator,encodeBase64,encode,0,0.9373801,"<mask>(toIntegerBytes(bigInt), false)","byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return<mask>(toIntegerBytes(bigInt), false);
    }"
4022,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39226,39237,MethodCallMutator,encodeBase64,decode,1,0.023692034,"<mask>(toIntegerBytes(bigInt), false)","byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return<mask>(toIntegerBytes(bigInt), false);
    }"
4023,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39226,39237,MethodCallMutator,encodeBase64,append,2,0.009296445,"<mask>(toIntegerBytes(bigInt), false)","byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return<mask>(toIntegerBytes(bigInt), false);
    }"
4024,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39226,39237,MethodCallMutator,encodeBase64,write,3,0.007480262,"<mask>(toIntegerBytes(bigInt), false)","byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return<mask>(toIntegerBytes(bigInt), false);
    }"
4025,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39226,39237,MethodCallMutator,encodeBase64,pack,4,0.003138791,"<mask>(toIntegerBytes(bigInt), false)","byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return<mask>(toIntegerBytes(bigInt), false);
    }"
4026,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39239,39252,MethodCallMutator,toIntegerBytes,bytes,0,0.44908607,<mask>(bigInt),"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(<mask>(bigInt), false);
    }"
4027,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39239,39252,MethodCallMutator,toIntegerBytes,bits,1,0.0917492,<mask>(bigInt),"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(<mask>(bigInt), false);
    }"
4028,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39239,39252,MethodCallMutator,toIntegerBytes,format,2,0.054781564,<mask>(bigInt),"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(<mask>(bigInt), false);
    }"
4029,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39239,39252,MethodCallMutator,toIntegerBytes,string,3,0.04108071,<mask>(bigInt),"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(<mask>(bigInt), false);
    }"
4030,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39239,39252,MethodCallMutator,toIntegerBytes,wrap,4,0.038791526,<mask>(bigInt),"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(<mask>(bigInt), false);
    }"
4031,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39254,39259,IdentifierMutator-Variable,bigInt,int,0,0.6725798,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(<mask>), false);
    }"
4032,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39254,39259,IdentifierMutator-Variable,bigInt,Integer,1,0.0748183,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(<mask>), false);
    }"
4033,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39254,39259,IdentifierMutator-Variable,bigInt,integer,2,0.06649796,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(<mask>), false);
    }"
4034,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39254,39259,IdentifierMutator-Variable,bigInt,i,3,0.012533095,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(<mask>), false);
    }"
4035,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39254,39259,IdentifierMutator-Variable,bigInt,in,4,0.011997879,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(<mask>), false);
    }"
4036,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39263,39267,IdentifierMutator-Literal,false,true,0,0.27569658,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt),<mask>);
    }"
4037,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39263,39267,IdentifierMutator-Literal,false,encoding,1,0.25120947,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt),<mask>);
    }"
4038,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39263,39267,IdentifierMutator-Literal,false,null,3,0.03534399,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt),<mask>);
    }"
4039,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1005,1009,39263,39267,IdentifierMutator-Literal,false,codec,4,0.021135336,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt),<mask>);
    }"
4040,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1020,39624,39632,MethodCallMutator,bitLength,length,0,0.48251987,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.<mask>();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4041,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1020,39624,39632,MethodCallMutator,bitLength,bits,1,0.38687202,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.<mask>();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4042,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1020,39624,39632,MethodCallMutator,bitLength,size,2,0.07385074,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.<mask>();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4043,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1020,39624,39632,MethodCallMutator,bitLength,value,3,0.0109686665,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.<mask>();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4044,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1020,39624,39632,MethodCallMutator,bitLength,len,4,0.0062536923,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.<mask>();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4045,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1020,39617,39622,IdentifierMutator-Variable,bigInt,int,0,0.18107656,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen =<mask>.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4046,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1020,39617,39622,IdentifierMutator-Variable,bigInt,big,1,0.12825333,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen =<mask>.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4047,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1020,39617,39622,IdentifierMutator-Variable,bigInt,this,2,0.12717226,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen =<mask>.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4048,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1020,39617,39622,IdentifierMutator-Variable,bigInt,Integer,3,0.09035175,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen =<mask>.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4049,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1020,39617,39622,IdentifierMutator-Variable,bigInt,Int,4,0.04822755,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen =<mask>.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4050,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39675,39675,AssignmentMutator,bitlen=((bitlen+7)>>3)<<3,|,0,0.43720365,bitlen <mask>= ((bitlen + 7) >> 3) << 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen<mask>= ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4051,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39675,39675,AssignmentMutator,bitlen=((bitlen+7)>>3)<<3,^,1,0.18715443,bitlen <mask>= ((bitlen + 7) >> 3) << 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen<mask>= ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4052,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39675,39675,AssignmentMutator,bitlen=((bitlen+7)>>3)<<3,*,2,0.10112992,bitlen <mask>= ((bitlen + 7) >> 3) << 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen<mask>= ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4053,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39675,39675,AssignmentMutator,bitlen=((bitlen+7)>>3)<<3,/,3,0.088297136,bitlen <mask>= ((bitlen + 7) >> 3) << 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen<mask>= ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4054,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39675,39675,AssignmentMutator,bitlen=((bitlen+7)>>3)<<3,//,4,0.049632814,bitlen <mask>= ((bitlen + 7) >> 3) << 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen<mask>= ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4055,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39669,39674,IdentifierMutator-Variable,bitlen,bits,0,0.08313724,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen<mask> = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4056,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39669,39674,IdentifierMutator-Variable,bitlen,len,1,0.059650324,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen<mask> = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4057,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39669,39674,IdentifierMutator-Variable,bitlen,int,2,0.04552535,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen<mask> = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4058,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39669,39674,IdentifierMutator-Variable,bitlen,to,3,0.041318376,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen<mask> = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4059,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39669,39674,IdentifierMutator-Variable,bitlen,*,4,0.02975418,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen<mask> = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4060,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39697,39700,BinaryOperatorMutator,<<,&,1,0.19580212,((bitlen + 7) >> 3) <mask> 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3)<mask>3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4061,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39697,39700,BinaryOperatorMutator,<<,^,2,0.1060897,((bitlen + 7) >> 3) <mask> 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3)<mask>3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4062,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39697,39700,BinaryOperatorMutator,<<,*,3,0.09870726,((bitlen + 7) >> 3) <mask> 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3)<mask>3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4063,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39691,39694,BinaryOperatorMutator,>>,>>>,1,0.14948852,(bitlen + 7) <mask> 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7)<mask>3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4064,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39691,39694,BinaryOperatorMutator,>>,<<,2,0.11032278,(bitlen + 7) <mask> 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7)<mask>3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4065,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39691,39694,BinaryOperatorMutator,>>,*,4,0.08248834,(bitlen + 7) <mask> 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7)<mask>3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4066,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39686,39688,BinaryOperatorMutator,+,/,0,0.18338405,bitlen <mask> 7,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen<mask>7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4067,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39686,39688,BinaryOperatorMutator,+,>>>,2,0.120289825,bitlen <mask> 7,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen<mask>7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4068,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39686,39688,BinaryOperatorMutator,+,%,3,0.09331382,bitlen <mask> 7,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen<mask>7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4069,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39686,39688,BinaryOperatorMutator,+,/,4,0.068242244,bitlen <mask> 7,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen<mask>7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4070,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39680,39685,IdentifierMutator-Variable,bitlen,8,0,0.27621976,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((<mask> + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4071,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39680,39685,IdentifierMutator-Variable,bitlen,len,1,0.12567848,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((<mask> + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4072,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39680,39685,IdentifierMutator-Variable,bitlen,7,2,0.07215883,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((<mask> + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4073,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39680,39685,IdentifierMutator-Variable,bitlen,1,3,0.057754982,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((<mask> + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4074,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39680,39685,IdentifierMutator-Variable,bitlen,16,4,0.03745065,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((<mask> + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4075,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39689,39689,IdentifierMutator-Literal,7,1,0,0.5781683,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen +<mask>) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4076,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39689,39689,IdentifierMutator-Literal,7,8,2,0.049941115,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen +<mask>) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4077,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39689,39689,IdentifierMutator-Literal,7,3,3,0.03981444,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen +<mask>) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4078,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39689,39689,IdentifierMutator-Literal,7,4,4,0.035863984,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen +<mask>) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4079,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39695,39695,IdentifierMutator-Literal,3,6,1,0.07721478,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >><mask>) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4080,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39695,39695,IdentifierMutator-Literal,3,1,2,0.07711057,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >><mask>) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4081,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39695,39695,IdentifierMutator-Literal,3,2,3,0.07223876,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >><mask>) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4082,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39695,39695,IdentifierMutator-Literal,3,4,4,0.0714804,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >><mask>) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4083,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39701,39701,IdentifierMutator-Literal,3,1,1,0.0855002,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) <<<mask>;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4084,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39701,39701,IdentifierMutator-Literal,3,7,2,0.06189106,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) <<<mask>;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4085,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39701,39701,IdentifierMutator-Literal,3,4,3,0.060085412,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) <<<mask>;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4086,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1022,39701,39701,IdentifierMutator-Literal,3,2,4,0.051770635,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) <<<mask>;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4087,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1023,39737,39747,MethodCallMutator,toByteArray,bytes,0,0.9154517,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.<mask>();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4088,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1023,39737,39747,MethodCallMutator,toByteArray,bits,1,0.019694937,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.<mask>();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4089,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1023,39737,39747,MethodCallMutator,toByteArray,Bytes,2,0.012274291,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.<mask>();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4090,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1023,39737,39747,MethodCallMutator,toByteArray,bin,3,0.008588914,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.<mask>();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4091,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1023,39737,39747,MethodCallMutator,toByteArray,value,4,0.007243815,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.<mask>();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4092,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1023,39730,39735,IdentifierMutator-Variable,bigInt,big,0,0.19933367,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes =<mask>.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4093,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1023,39730,39735,IdentifierMutator-Variable,bigInt,input,1,0.06758484,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes =<mask>.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4094,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1023,39730,39735,IdentifierMutator-Variable,bigInt,bytes,2,0.059770394,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes =<mask>.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4095,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1023,39730,39735,IdentifierMutator-Variable,bigInt,this,3,0.057770573,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes =<mask>.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4096,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1023,39730,39735,IdentifierMutator-Variable,bigInt,bits,4,0.051053487,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes =<mask>.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4097,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39796,39799,BinaryOperatorMutator,&&,&,2,0.031849235,((bigInt.bitLength() % 8) != 0) <mask> (((bigInt.bitLength() / 8) + 1) == (bitlen / 8)),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0)<mask>(((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4098,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39796,39799,BinaryOperatorMutator,&&,&,3,0.01671658,((bigInt.bitLength() % 8) != 0) <mask> (((bigInt.bitLength() / 8) + 1) == (bitlen / 8)),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0)<mask>(((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4099,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39796,39799,BinaryOperatorMutator,&&,//,4,0.0063783694,((bigInt.bitLength() % 8) != 0) <mask> (((bigInt.bitLength() / 8) + 1) == (bitlen / 8)),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0)<mask>(((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4100,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39790,39793,BinaryOperatorMutator,!=,==,0,0.77037054,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8)<mask>0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4101,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39790,39793,BinaryOperatorMutator,!=,==,1,0.12744549,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8)<mask>0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4102,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39790,39793,BinaryOperatorMutator,!=,>,2,0.05485525,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8)<mask>0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4103,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39790,39793,BinaryOperatorMutator,!=,>,4,0.015251417,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8)<mask>0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4104,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39785,39787,BinaryOperatorMutator,%,/,0,0.5188738,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength()<mask>8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4105,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39785,39787,BinaryOperatorMutator,%,/,2,0.16815417,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength()<mask>8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4106,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39785,39787,BinaryOperatorMutator,%,)/,4,0.012889168,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength()<mask>8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4107,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39774,39782,MethodCallMutator,bitLength,length,0,0.9163653,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.<mask>() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4108,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39774,39782,MethodCallMutator,bitLength,bits,1,0.051798075,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.<mask>() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4109,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39774,39782,MethodCallMutator,bitLength,Length,2,0.009550717,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.<mask>() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4110,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39774,39782,MethodCallMutator,bitLength,bit,3,0.004910234,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.<mask>() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4111,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39774,39782,MethodCallMutator,bitLength,value,4,0.0023052199,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.<mask>() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4112,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39767,39772,IdentifierMutator-Variable,bigInt,int,0,0.746823,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((<mask>.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4113,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39767,39772,IdentifierMutator-Variable,bigInt,Int,1,0.1649221,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((<mask>.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4114,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39767,39772,IdentifierMutator-Variable,bigInt,Integer,2,0.0139945075,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((<mask>.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4115,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39767,39772,IdentifierMutator-Variable,bigInt,big,3,0.013856921,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((<mask>.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4116,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39767,39772,IdentifierMutator-Variable,bigInt,long,4,0.006214563,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((<mask>.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4117,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39788,39788,IdentifierMutator-Literal,8,7,1,0.005530607,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() %<mask>) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4118,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39788,39788,IdentifierMutator-Literal,8,2,2,9.932129E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() %<mask>) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4119,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39788,39788,IdentifierMutator-Literal,8,4,3,9.187786E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() %<mask>) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4120,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39788,39788,IdentifierMutator-Literal,8,16,4,8.816952E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() %<mask>) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4121,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39794,39794,IdentifierMutator-Literal,0,1,1,0.01637059,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) !=<mask>) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4122,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39794,39794,IdentifierMutator-Literal,0,8,2,0.0014612796,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) !=<mask>) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4123,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39794,39794,IdentifierMutator-Literal,0,7,3,9.844551E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) !=<mask>) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4124,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39794,39794,IdentifierMutator-Literal,0,2,4,5.684401E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) !=<mask>) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4125,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39831,39834,BinaryOperatorMutator,==,<,0,0.33627945,((bigInt.bitLength() / 8) + 1) <mask> (bitlen / 8),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1)<mask>(bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4126,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39831,39834,BinaryOperatorMutator,==,<=,3,0.07669811,((bigInt.bitLength() / 8) + 1) <mask> (bitlen / 8),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1)<mask>(bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4127,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39831,39834,BinaryOperatorMutator,==,>,4,0.07506787,((bigInt.bitLength() / 8) + 1) <mask> (bitlen / 8),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1)<mask>(bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4128,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39826,39828,BinaryOperatorMutator,+,-,0,0.4067248,(bigInt.bitLength() / 8) <mask> 1,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8)<mask>1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4129,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39826,39828,BinaryOperatorMutator,+,-,2,0.09282907,(bigInt.bitLength() / 8) <mask> 1,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8)<mask>1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4130,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39826,39828,BinaryOperatorMutator,+,**,4,0.021640921,(bigInt.bitLength() / 8) <mask> 1,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8)<mask>1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4131,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39821,39823,BinaryOperatorMutator,/,%,0,0.5219178,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength()<mask>8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4132,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39821,39823,BinaryOperatorMutator,/,//,3,0.044786364,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength()<mask>8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4133,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39821,39823,BinaryOperatorMutator,/,%,4,0.0199752,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength()<mask>8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4134,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39810,39818,MethodCallMutator,bitLength,bits,0,0.51306206,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.<mask>() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4135,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39810,39818,MethodCallMutator,bitLength,length,1,0.34586373,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.<mask>() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4136,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39810,39818,MethodCallMutator,bitLength,size,2,0.038241714,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.<mask>() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4137,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39810,39818,MethodCallMutator,bitLength,value,3,0.02103165,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.<mask>() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4138,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39810,39818,MethodCallMutator,bitLength,bytes,4,0.012758481,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.<mask>() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4139,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39803,39808,IdentifierMutator-Variable,bigInt,int,0,0.6868534,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((<mask>.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4140,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39803,39808,IdentifierMutator-Variable,bigInt,Int,1,0.17645743,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((<mask>.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4141,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39803,39808,IdentifierMutator-Variable,bigInt,big,2,0.022624277,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((<mask>.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4142,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39803,39808,IdentifierMutator-Variable,bigInt,Integer,3,0.011915404,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((<mask>.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4143,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39803,39808,IdentifierMutator-Variable,bigInt,long,4,0.011535025,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((<mask>.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4144,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39824,39824,IdentifierMutator-Literal,8,7,1,0.0014157639,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() /<mask>) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4145,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39824,39824,IdentifierMutator-Literal,8,2,2,3.993033E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() /<mask>) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4146,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39824,39824,IdentifierMutator-Literal,8,4,4,2.617816E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() /<mask>) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4147,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39829,39829,IdentifierMutator-Literal,1,7,0,0.53698957,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) +<mask>) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4148,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39829,39829,IdentifierMutator-Literal,1,8,2,0.04494058,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) +<mask>) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4149,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39829,39829,IdentifierMutator-Literal,1,6,3,0.021930046,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) +<mask>) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4150,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39829,39829,IdentifierMutator-Literal,1,3,4,0.013008297,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) +<mask>) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4151,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39842,39844,BinaryOperatorMutator,/,%,1,0.08506532,bitlen <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen<mask>8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4152,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39842,39844,BinaryOperatorMutator,/,%,3,0.050874334,bitlen <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen<mask>8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4153,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39842,39844,BinaryOperatorMutator,/,)/,4,0.029188493,bitlen <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen<mask>8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4154,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39836,39841,IdentifierMutator-Variable,bitlen,len,0,0.7807609,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (<mask> / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4155,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39836,39841,IdentifierMutator-Variable,bitlen,8,1,0.037611578,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (<mask> / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4156,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39836,39841,IdentifierMutator-Variable,bitlen,1,2,0.020053845,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (<mask> / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4157,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39836,39841,IdentifierMutator-Variable,bitlen,length,3,0.01008563,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (<mask> / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4158,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39836,39841,IdentifierMutator-Variable,bitlen,255,4,0.008992478,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (<mask> / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4159,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39845,39845,IdentifierMutator-Literal,8,7,1,0.0122226635,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen /<mask>))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4160,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39845,39845,IdentifierMutator-Literal,8,2,2,0.011287117,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen /<mask>))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4161,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39845,39845,IdentifierMutator-Literal,8,4,3,0.005160084,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen /<mask>))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4162,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1025,39845,39845,IdentifierMutator-Literal,8,6,4,0.002372981,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen /<mask>))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4163,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1026,39871,39878,IdentifierMutator-Variable,bigBytes,null,0,0.8249167,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return<mask>;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4164,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1026,39871,39878,IdentifierMutator-Variable,bigBytes,bytes,1,0.041228767,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return<mask>;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4165,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1026,39871,39878,IdentifierMutator-Variable,bigBytes,"""""",2,0.024125043,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return<mask>;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4166,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1026,39871,39878,IdentifierMutator-Variable,bigBytes,0,3,0.018363696,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return<mask>;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4167,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1026,39871,39878,IdentifierMutator-Variable,bigBytes,false,4,0.009283522,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return<mask>;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4168,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1029,39975,39975,IdentifierMutator-Literal,0,1,1,0.021016305,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc =<mask>;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4169,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1029,39975,39975,IdentifierMutator-Literal,0,2,2,0.0048450893,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc =<mask>;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4170,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1029,39975,39975,IdentifierMutator-Literal,0,8,3,0.0010382727,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc =<mask>;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4171,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1029,39975,39975,IdentifierMutator-Literal,0,3,4,8.4656867E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc =<mask>;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4172,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1030,39996,40010,IdentifierMutator-Variable,bigBytes.length,0,0,0.30062032,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4173,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1030,39996,40010,IdentifierMutator-Variable,bigBytes.length,8,1,0.19684462,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4174,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1030,39996,40010,IdentifierMutator-Variable,bigBytes.length,1,2,0.16209225,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4175,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1030,39996,40010,IdentifierMutator-Variable,bigBytes.length,7,3,0.038919616,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4176,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1030,39996,40010,IdentifierMutator-Variable,bigBytes.length,2,4,0.036710225,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4177,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1030,39996,40003,IdentifierMutator-Variable,bigBytes,bytes,0,0.37873113,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4178,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1030,39996,40003,IdentifierMutator-Variable,bigBytes,src,1,0.16859323,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4179,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1030,39996,40003,IdentifierMutator-Variable,bigBytes,bits,2,0.07624572,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4180,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1030,39996,40003,IdentifierMutator-Variable,bigBytes,data,3,0.037784383,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4181,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1030,39996,40003,IdentifierMutator-Variable,bigBytes,arr,4,0.034755036,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4182,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1030,40005,40010,FieldReferenceMutator,length,size,1,0.006459289,bigBytes.<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4183,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1030,40005,40010,FieldReferenceMutator,length,len,2,0.0028275007,bigBytes.<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4184,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1030,40005,40010,FieldReferenceMutator,length,Length,4,1.4477444E-4,bigBytes.<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4185,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40122,40125,BinaryOperatorMutator,==,!=,1,0.050353006,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8)<mask>0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4186,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40122,40125,BinaryOperatorMutator,==,>,2,0.022252146,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8)<mask>0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4187,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40122,40125,BinaryOperatorMutator,==,=,4,0.004793392,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8)<mask>0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4188,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40117,40119,BinaryOperatorMutator,%,/,2,0.013124464,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength()<mask>8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4189,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40117,40119,BinaryOperatorMutator,%,/,3,0.0021349713,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength()<mask>8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4190,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40117,40119,BinaryOperatorMutator,%,)/,4,0.0010469529,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength()<mask>8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4191,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40106,40114,MethodCallMutator,bitLength,length,0,0.9524557,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.<mask>() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4192,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40106,40114,MethodCallMutator,bitLength,bits,1,0.027737807,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.<mask>() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4193,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40106,40114,MethodCallMutator,bitLength,len,2,0.004314162,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.<mask>() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4194,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40106,40114,MethodCallMutator,bitLength,Length,3,0.0022060445,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.<mask>() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4195,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40106,40114,MethodCallMutator,bitLength,value,4,0.0018004113,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.<mask>() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4196,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40099,40104,IdentifierMutator-Variable,bigInt,len,0,0.48073485,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((<mask>.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4197,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40099,40104,IdentifierMutator-Variable,bigInt,int,1,0.09259159,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((<mask>.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4198,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40099,40104,IdentifierMutator-Variable,bigInt,this,2,0.043618537,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((<mask>.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4199,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40099,40104,IdentifierMutator-Variable,bigInt,src,3,0.025487807,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((<mask>.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4200,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40099,40104,IdentifierMutator-Variable,bigInt,self,4,0.019777497,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((<mask>.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4201,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40120,40120,IdentifierMutator-Literal,8,7,1,0.007750802,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() %<mask>) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4202,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40120,40120,IdentifierMutator-Literal,8,2,2,0.007257772,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() %<mask>) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4203,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40120,40120,IdentifierMutator-Literal,8,4,3,0.0055588605,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() %<mask>) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4204,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40120,40120,IdentifierMutator-Literal,8,16,4,0.0032617177,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() %<mask>) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4205,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40126,40126,IdentifierMutator-Literal,0,1,1,0.017934965,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) ==<mask>) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4206,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40126,40126,IdentifierMutator-Literal,0,8,2,0.0029667788,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) ==<mask>) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4207,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40126,40126,IdentifierMutator-Literal,0,2,3,7.5614953E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) ==<mask>) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4208,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1033,40126,40126,IdentifierMutator-Literal,0,7,4,4.5119293E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) ==<mask>) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4209,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1034,40151,40151,AssignmentMutator,startSrc=1,*,0,0.3484217,startSrc <mask>= 1,"
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc<mask>= 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4210,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1034,40151,40151,AssignmentMutator,startSrc=1,<<,1,0.3361942,startSrc <mask>= 1,"
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc<mask>= 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4211,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1034,40151,40151,AssignmentMutator,startSrc=1,|,2,0.19524975,startSrc <mask>= 1,"
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc<mask>= 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4212,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1034,40151,40151,AssignmentMutator,startSrc=1,>>,3,0.05596123,startSrc <mask>= 1,"
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc<mask>= 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4213,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1034,40151,40151,AssignmentMutator,startSrc=1,^,4,0.012988011,startSrc <mask>= 1,"
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc<mask>= 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4214,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1034,40143,40150,IdentifierMutator-Variable,startSrc,len,0,0.94888735,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {<mask> = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4215,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1034,40143,40150,IdentifierMutator-Variable,startSrc,len,1,0.017293142,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {<mask> = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4216,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1034,40143,40150,IdentifierMutator-Variable,startSrc,Len,2,0.0066153617,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {<mask> = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4217,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1034,40143,40150,IdentifierMutator-Variable,startSrc,src,3,0.0021479556,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {<mask> = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4218,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1034,40143,40150,IdentifierMutator-Variable,startSrc,pos,4,0.0011132794,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {<mask> = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4219,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1034,40154,40154,IdentifierMutator-Literal,1,0,0,0.81215477,<mask>,"        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc =<mask>;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4220,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1034,40154,40154,IdentifierMutator-Literal,1,len,1,0.06501877,<mask>,"        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc =<mask>;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4221,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1034,40154,40154,IdentifierMutator-Literal,1,i,3,0.014734172,<mask>,"        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc =<mask>;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4222,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1034,40154,40154,IdentifierMutator-Literal,1,pos,4,0.008305038,<mask>,"        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc =<mask>;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4223,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1035,40172,40174,UnaryOperatorMutator,--,++;,0,0.8438007,len<mask>,"Length();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len<mask>
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4224,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1035,40172,40174,UnaryOperatorMutator,--,=,1,0.081237845,len<mask>,"Length();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len<mask>
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4225,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1035,40172,40174,UnaryOperatorMutator,--,;,3,0.0130390255,len<mask>,"Length();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len<mask>
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4226,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1035,40172,40174,UnaryOperatorMutator,--,++,4,0.010570115,len<mask>,"Length();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len<mask>
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4227,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1035,40169,40171,IdentifierMutator-Variable,len,Len,2,0.0030426686,<mask>,"      int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;<mask>--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4228,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1035,40169,40171,IdentifierMutator-Variable,len,pos,3,6.6311454E-4,<mask>,"      int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;<mask>--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4229,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1035,40169,40171,IdentifierMutator-Variable,len,length,4,4.54495E-4,<mask>,"      int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;<mask>--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4230,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40219,40221,BinaryOperatorMutator,-,*,0,0.47997975,(bitlen / 8) <mask> len," + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8<mask>len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4231,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40219,40221,BinaryOperatorMutator,-,.,1,0.16752994,(bitlen / 8) <mask> len," + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8<mask>len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4232,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40219,40221,BinaryOperatorMutator,-,+,2,0.12269536,(bitlen / 8) <mask> len," + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8<mask>len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4233,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40219,40221,BinaryOperatorMutator,-,^,4,0.02007228,(bitlen / 8) <mask> len," + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8<mask>len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4234,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40215,40217,BinaryOperatorMutator,/,)/,2,0.005524496,bitlen <mask> 8,"bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen<mask>8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4235,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40215,40217,BinaryOperatorMutator,/,%,3,0.0047038374,bitlen <mask> 8,"bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen<mask>8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4236,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40215,40217,BinaryOperatorMutator,/,*,4,0.004628589,bitlen <mask> 8,"bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen<mask>8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4237,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40209,40214,IdentifierMutator-Variable,bitlen,len,0,0.24148533,<mask>," = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst =<mask> / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4238,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40209,40214,IdentifierMutator-Variable,bitlen,src,1,0.12174079,<mask>," = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst =<mask> / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4239,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40209,40214,IdentifierMutator-Variable,bitlen,64,2,0.052029595,<mask>," = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst =<mask> / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4240,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40209,40214,IdentifierMutator-Variable,bitlen,8,3,0.03793712,<mask>," = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst =<mask> / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4241,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40209,40214,IdentifierMutator-Variable,bitlen,size,4,0.033401415,<mask>," = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst =<mask> / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4242,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40218,40218,IdentifierMutator-Literal,8,2,1,0.01293465,<mask>,"len + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen /<mask> - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4243,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40218,40218,IdentifierMutator-Literal,8,4,2,0.005816742,<mask>,"len + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen /<mask> - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4244,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40218,40218,IdentifierMutator-Literal,8,7,3,0.0017996825,<mask>,"len + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen /<mask> - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4245,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40218,40218,IdentifierMutator-Literal,8,3,4,0.0014576969,<mask>,"len + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen /<mask> - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4246,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40222,40224,IdentifierMutator-Variable,len,1,0,0.704221,<mask>," 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 -<mask>; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4247,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40222,40224,IdentifierMutator-Variable,len,2,2,0.031460054,<mask>," 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 -<mask>; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4248,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40222,40224,IdentifierMutator-Variable,len,4,3,0.0065544904,<mask>," 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 -<mask>; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4249,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1037,40222,40224,IdentifierMutator-Variable,len,0,4,0.0050731213,<mask>," 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 -<mask>; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4250,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1038,40303,40305,BinaryOperatorMutator,/,*,1,0.081972696,bitlen <mask> 8,"      if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen<mask>8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4251,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1038,40303,40305,BinaryOperatorMutator,/,)/,2,0.011129106,bitlen <mask> 8,"      if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen<mask>8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4252,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1038,40303,40305,BinaryOperatorMutator,/,+,3,0.009592882,bitlen <mask> 8,"      if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen<mask>8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4253,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1038,40297,40302,IdentifierMutator-Variable,bitlen,len,0,0.97348195,<mask>,"        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[<mask> / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4254,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1038,40297,40302,IdentifierMutator-Variable,bitlen,Len,1,0.004694517,<mask>,"        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[<mask> / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4255,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1038,40297,40302,IdentifierMutator-Variable,bitlen,8,2,0.003338404,<mask>,"        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[<mask> / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4256,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1038,40297,40302,IdentifierMutator-Variable,bitlen,len,3,0.002493743,<mask>,"        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[<mask> / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4257,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1038,40297,40302,IdentifierMutator-Variable,bitlen,64,4,0.0013884339,<mask>,"        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[<mask> / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4258,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1038,40306,40306,IdentifierMutator-Literal,8,2,1,0.012058348,<mask>,"     if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen /<mask>];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4259,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1038,40306,40306,IdentifierMutator-Literal,8,4,2,0.0110394545,<mask>,"     if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen /<mask>];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4260,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1038,40306,40306,IdentifierMutator-Literal,8,6,3,0.0028689392,<mask>,"     if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen /<mask>];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4261,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1038,40306,40306,IdentifierMutator-Literal,8,16,4,0.002247962,<mask>,"     if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen /<mask>];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4262,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40325,40333,MethodCallMutator,arraycopy,copy,0,0.99759585,"System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len)","() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4263,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40325,40333,MethodCallMutator,arraycopy,array,1,3.2043117E-4,"System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len)","() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4264,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40325,40333,MethodCallMutator,arraycopy,fill,2,3.0976618E-4,"System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len)","() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4265,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40325,40333,MethodCallMutator,arraycopy,abs,3,2.5887712E-4,"System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len)","() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4266,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40325,40333,MethodCallMutator,arraycopy,printf,4,2.1275487E-4,"System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len)","() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4267,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40335,40342,IdentifierMutator-Variable,bigBytes,bytes,0,0.6258725,<mask>,") != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(<mask>, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4268,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40335,40342,IdentifierMutator-Variable,bigBytes,buf,1,0.07608221,<mask>,") != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(<mask>, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4269,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40335,40342,IdentifierMutator-Variable,bigBytes,data,2,0.06558221,<mask>,") != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(<mask>, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4270,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40335,40342,IdentifierMutator-Variable,bigBytes,buffer,3,0.037495412,<mask>,") != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(<mask>, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4271,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40335,40342,IdentifierMutator-Variable,bigBytes,array,4,0.03456289,<mask>,") != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(<mask>, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4272,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40345,40352,IdentifierMutator-Variable,startSrc,0,0,0.9043985,<mask>,") && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes,<mask>, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4273,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40345,40352,IdentifierMutator-Variable,startSrc,src,1,0.037909202,<mask>,") && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes,<mask>, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4274,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40345,40352,IdentifierMutator-Variable,startSrc,start,2,0.01425248,<mask>,") && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes,<mask>, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4275,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40345,40352,IdentifierMutator-Variable,startSrc,offset,3,0.008289592,<mask>,") && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes,<mask>, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4276,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40345,40352,IdentifierMutator-Variable,startSrc,0,4,0.0057999636,<mask>,") && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes,<mask>, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4277,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40355,40366,IdentifierMutator-Variable,resizedBytes,bytes,0,0.7497938,<mask>,"bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc,<mask>, startDst, len);
        return resizedBytes;
    }"
4278,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40355,40366,IdentifierMutator-Variable,resizedBytes,data,1,0.023462327,<mask>,"bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc,<mask>, startDst, len);
        return resizedBytes;
    }"
4279,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40355,40366,IdentifierMutator-Variable,resizedBytes,arr,2,0.0233899,<mask>,"bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc,<mask>, startDst, len);
        return resizedBytes;
    }"
4280,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40355,40366,IdentifierMutator-Variable,resizedBytes,buf,3,0.022987185,<mask>,"bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc,<mask>, startDst, len);
        return resizedBytes;
    }"
4281,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40355,40366,IdentifierMutator-Variable,resizedBytes,array,4,0.018114606,<mask>,"bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc,<mask>, startDst, len);
        return resizedBytes;
    }"
4282,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40369,40376,IdentifierMutator-Variable,startDst,0,0,0.9683424,<mask>,"Length() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes,<mask>, len);
        return resizedBytes;
    }"
4283,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40369,40376,IdentifierMutator-Variable,startDst,off,1,0.0064939056,<mask>,"Length() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes,<mask>, len);
        return resizedBytes;
    }"
4284,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40369,40376,IdentifierMutator-Variable,startDst,1,2,0.0051957383,<mask>,"Length() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes,<mask>, len);
        return resizedBytes;
    }"
4285,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40369,40376,IdentifierMutator-Variable,startDst,offset,3,0.004979938,<mask>,"Length() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes,<mask>, len);
        return resizedBytes;
    }"
4286,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40369,40376,IdentifierMutator-Variable,startDst,start,4,0.004014385,<mask>,"Length() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes,<mask>, len);
        return resizedBytes;
    }"
4287,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40379,40381,IdentifierMutator-Variable,len,Len,2,0.0011227366,<mask>,") + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst,<mask>);
        return resizedBytes;
    }"
4288,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40379,40381,IdentifierMutator-Variable,len,length,3,4.8368544E-4,<mask>,") + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst,<mask>);
        return resizedBytes;
    }"
4289,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1039,40379,40381,IdentifierMutator-Variable,len,n,4,3.130909E-4,<mask>,") + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst,<mask>);
        return resizedBytes;
    }"
4290,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1040,40400,40411,IdentifierMutator-Variable,resizedBytes,true,0,0.16599308,<mask>," {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return<mask>;
    }"
4291,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1040,40400,40411,IdentifierMutator-Variable,resizedBytes,ret,1,0.1373218,<mask>," {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return<mask>;
    }"
4292,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1040,40400,40411,IdentifierMutator-Variable,resizedBytes,0,2,0.11892544,<mask>," {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return<mask>;
    }"
4293,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1040,40400,40411,IdentifierMutator-Variable,resizedBytes,len,3,0.10996403,<mask>," {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return<mask>;
    }"
4294,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1019,1040,40400,40411,IdentifierMutator-Variable,resizedBytes,res,4,0.077649586,<mask>," {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return<mask>;
    }"
4295,Base64.java,reset,void reset(),1046,1047,40551,40551,AssignmentMutator,buffer=null,Data,0,0.07159031,buffer <mask>= null,"void reset() {
        buffer<mask>= null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4296,Base64.java,reset,void reset(),1046,1047,40551,40551,AssignmentMutator,buffer=null,List,1,0.068108216,buffer <mask>= null,"void reset() {
        buffer<mask>= null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4297,Base64.java,reset,void reset(),1046,1047,40551,40551,AssignmentMutator,buffer=null,_,2,0.06616849,buffer <mask>= null,"void reset() {
        buffer<mask>= null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4298,Base64.java,reset,void reset(),1046,1047,40551,40551,AssignmentMutator,buffer=null,Pool,3,0.06374878,buffer <mask>= null,"void reset() {
        buffer<mask>= null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4299,Base64.java,reset,void reset(),1046,1047,40551,40551,AssignmentMutator,buffer=null,Info,4,0.031458925,buffer <mask>= null,"void reset() {
        buffer<mask>= null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4300,Base64.java,reset,void reset(),1046,1047,40545,40550,IdentifierMutator-Variable,buffer,reader,1,0.07818558,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4301,Base64.java,reset,void reset(),1046,1047,40545,40550,IdentifierMutator-Variable,buffer,line,2,0.049444243,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4302,Base64.java,reset,void reset(),1046,1047,40545,40550,IdentifierMutator-Variable,buffer,file,3,0.034612086,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4303,Base64.java,reset,void reset(),1046,1047,40545,40550,IdentifierMutator-Variable,buffer,stream,4,0.033980455,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4304,Base64.java,reset,void reset(),1046,1047,40545,40550,FieldReferenceMutator,buffer,reader,1,0.07818558,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4305,Base64.java,reset,void reset(),1046,1047,40545,40550,FieldReferenceMutator,buffer,line,2,0.049444243,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4306,Base64.java,reset,void reset(),1046,1047,40545,40550,FieldReferenceMutator,buffer,file,3,0.034612086,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4307,Base64.java,reset,void reset(),1046,1047,40545,40550,FieldReferenceMutator,buffer,stream,4,0.033980455,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4308,Base64.java,reset,void reset(),1046,1047,40554,40557,IdentifierMutator-Literal,null,"""""",1,0.07173865,<mask>,"void reset() {
        buffer =<mask>;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4309,Base64.java,reset,void reset(),1046,1047,40554,40557,IdentifierMutator-Literal,null,0,2,0.029990716,<mask>,"void reset() {
        buffer =<mask>;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4310,Base64.java,reset,void reset(),1046,1047,40554,40557,IdentifierMutator-Literal,null,"''",3,0.020619337,<mask>,"void reset() {
        buffer =<mask>;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4311,Base64.java,reset,void reset(),1046,1047,40554,40557,IdentifierMutator-Literal,null,false,4,0.004369159,<mask>,"void reset() {
        buffer =<mask>;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4312,Base64.java,reset,void reset(),1046,1048,40571,40571,AssignmentMutator,pos=0,|,0,0.4901789,pos <mask>= 0,"void reset() {
        buffer = null;
        pos<mask>= 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4313,Base64.java,reset,void reset(),1046,1048,40571,40571,AssignmentMutator,pos=0,*,1,0.14493254,pos <mask>= 0,"void reset() {
        buffer = null;
        pos<mask>= 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4314,Base64.java,reset,void reset(),1046,1048,40571,40571,AssignmentMutator,pos=0,>>,2,0.07640264,pos <mask>= 0,"void reset() {
        buffer = null;
        pos<mask>= 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4315,Base64.java,reset,void reset(),1046,1048,40571,40571,AssignmentMutator,pos=0,<<,3,0.05094505,pos <mask>= 0,"void reset() {
        buffer = null;
        pos<mask>= 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4316,Base64.java,reset,void reset(),1046,1048,40571,40571,AssignmentMutator,pos=0,&,4,0.042873614,pos <mask>= 0,"void reset() {
        buffer = null;
        pos<mask>= 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4317,Base64.java,reset,void reset(),1046,1048,40568,40570,IdentifierMutator-Variable,pos,offset,0,0.27125272,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4318,Base64.java,reset,void reset(),1046,1048,40568,40570,IdentifierMutator-Variable,pos,position,2,0.12208049,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4319,Base64.java,reset,void reset(),1046,1048,40568,40570,IdentifierMutator-Variable,pos,length,3,0.09401891,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4320,Base64.java,reset,void reset(),1046,1048,40568,40570,IdentifierMutator-Variable,pos,count,4,0.032574717,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4321,Base64.java,reset,void reset(),1046,1048,40568,40570,FieldReferenceMutator,pos,offset,0,0.27125272,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4322,Base64.java,reset,void reset(),1046,1048,40568,40570,FieldReferenceMutator,pos,position,2,0.12208049,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4323,Base64.java,reset,void reset(),1046,1048,40568,40570,FieldReferenceMutator,pos,length,3,0.09401891,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4324,Base64.java,reset,void reset(),1046,1048,40568,40570,FieldReferenceMutator,pos,count,4,0.032574717,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4325,Base64.java,reset,void reset(),1046,1048,40574,40574,IdentifierMutator-Literal,0,null,1,0.012261926,<mask>,"void reset() {
        buffer = null;
        pos =<mask>;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4326,Base64.java,reset,void reset(),1046,1048,40574,40574,IdentifierMutator-Literal,0,1,2,0.004182846,<mask>,"void reset() {
        buffer = null;
        pos =<mask>;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4327,Base64.java,reset,void reset(),1046,1048,40574,40574,IdentifierMutator-Literal,0,pos,3,0.002392879,<mask>,"void reset() {
        buffer = null;
        pos =<mask>;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4328,Base64.java,reset,void reset(),1046,1048,40574,40574,IdentifierMutator-Literal,0,false,4,0.0019585544,<mask>,"void reset() {
        buffer = null;
        pos =<mask>;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4329,Base64.java,reset,void reset(),1046,1049,40592,40592,AssignmentMutator,readPos=0,|,0,0.42254975,readPos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos<mask>= 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4330,Base64.java,reset,void reset(),1046,1049,40592,40592,AssignmentMutator,readPos=0,*,1,0.1987296,readPos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos<mask>= 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4331,Base64.java,reset,void reset(),1046,1049,40592,40592,AssignmentMutator,readPos=0,&,2,0.071804106,readPos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos<mask>= 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4332,Base64.java,reset,void reset(),1046,1049,40592,40592,AssignmentMutator,readPos=0,<<,3,0.070528805,readPos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos<mask>= 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4333,Base64.java,reset,void reset(),1046,1049,40592,40592,AssignmentMutator,readPos=0,/,4,0.039192457,readPos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos<mask>= 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4334,Base64.java,reset,void reset(),1046,1049,40585,40591,IdentifierMutator-Variable,readPos,length,0,0.15366279,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4335,Base64.java,reset,void reset(),1046,1049,40585,40591,IdentifierMutator-Variable,readPos,line,1,0.10980444,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4336,Base64.java,reset,void reset(),1046,1049,40585,40591,IdentifierMutator-Variable,readPos,offset,2,0.08136528,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4337,Base64.java,reset,void reset(),1046,1049,40585,40591,IdentifierMutator-Variable,readPos,len,3,0.03876669,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4338,Base64.java,reset,void reset(),1046,1049,40585,40591,IdentifierMutator-Variable,readPos,index,4,0.028189087,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4339,Base64.java,reset,void reset(),1046,1049,40585,40591,FieldReferenceMutator,readPos,length,0,0.15366279,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4340,Base64.java,reset,void reset(),1046,1049,40585,40591,FieldReferenceMutator,readPos,line,1,0.10980444,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4341,Base64.java,reset,void reset(),1046,1049,40585,40591,FieldReferenceMutator,readPos,offset,2,0.08136528,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4342,Base64.java,reset,void reset(),1046,1049,40585,40591,FieldReferenceMutator,readPos,len,3,0.03876669,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4343,Base64.java,reset,void reset(),1046,1049,40585,40591,FieldReferenceMutator,readPos,index,4,0.028189087,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4344,Base64.java,reset,void reset(),1046,1049,40595,40595,IdentifierMutator-Literal,0,null,1,0.0055957786,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos =<mask>;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4345,Base64.java,reset,void reset(),1046,1049,40595,40595,IdentifierMutator-Literal,0,1,2,0.0045285965,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos =<mask>;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4346,Base64.java,reset,void reset(),1046,1049,40595,40595,IdentifierMutator-Literal,0,false,3,0.0026240894,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos =<mask>;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4347,Base64.java,reset,void reset(),1046,1049,40595,40595,IdentifierMutator-Literal,0,zero,4,5.8432756E-4,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos =<mask>;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4348,Base64.java,reset,void reset(),1046,1050,40620,40620,AssignmentMutator,currentLinePos=0,|,0,0.3252196,currentLinePos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos<mask>= 0;
        modulus = 0;
        eof = false;
    }"
4349,Base64.java,reset,void reset(),1046,1050,40620,40620,AssignmentMutator,currentLinePos=0,*,1,0.21810818,currentLinePos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos<mask>= 0;
        modulus = 0;
        eof = false;
    }"
4350,Base64.java,reset,void reset(),1046,1050,40620,40620,AssignmentMutator,currentLinePos=0,<<,2,0.116552,currentLinePos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos<mask>= 0;
        modulus = 0;
        eof = false;
    }"
4351,Base64.java,reset,void reset(),1046,1050,40620,40620,AssignmentMutator,currentLinePos=0,||,3,0.07053653,currentLinePos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos<mask>= 0;
        modulus = 0;
        eof = false;
    }"
4352,Base64.java,reset,void reset(),1046,1050,40620,40620,AssignmentMutator,currentLinePos=0,&,4,0.049070105,currentLinePos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos<mask>= 0;
        modulus = 0;
        eof = false;
    }"
4353,Base64.java,reset,void reset(),1046,1050,40606,40619,IdentifierMutator-Variable,currentLinePos,length,0,0.12613648,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4354,Base64.java,reset,void reset(),1046,1050,40606,40619,IdentifierMutator-Variable,currentLinePos,offset,1,0.06150515,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4355,Base64.java,reset,void reset(),1046,1050,40606,40619,IdentifierMutator-Variable,currentLinePos,len,2,0.05087585,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4356,Base64.java,reset,void reset(),1046,1050,40606,40619,IdentifierMutator-Variable,currentLinePos,size,3,0.04989753,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4357,Base64.java,reset,void reset(),1046,1050,40606,40619,IdentifierMutator-Variable,currentLinePos,count,4,0.04040517,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4358,Base64.java,reset,void reset(),1046,1050,40606,40619,FieldReferenceMutator,currentLinePos,length,0,0.12613648,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4359,Base64.java,reset,void reset(),1046,1050,40606,40619,FieldReferenceMutator,currentLinePos,offset,1,0.06150515,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4360,Base64.java,reset,void reset(),1046,1050,40606,40619,FieldReferenceMutator,currentLinePos,len,2,0.05087585,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4361,Base64.java,reset,void reset(),1046,1050,40606,40619,FieldReferenceMutator,currentLinePos,size,3,0.04989753,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4362,Base64.java,reset,void reset(),1046,1050,40606,40619,FieldReferenceMutator,currentLinePos,count,4,0.04040517,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4363,Base64.java,reset,void reset(),1046,1050,40623,40623,IdentifierMutator-Literal,0,null,1,0.012948825,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos =<mask>;
        modulus = 0;
        eof = false;
    }"
4364,Base64.java,reset,void reset(),1046,1050,40623,40623,IdentifierMutator-Literal,0,1,2,0.00658629,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos =<mask>;
        modulus = 0;
        eof = false;
    }"
4365,Base64.java,reset,void reset(),1046,1050,40623,40623,IdentifierMutator-Literal,0,false,3,0.0038040658,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos =<mask>;
        modulus = 0;
        eof = false;
    }"
4366,Base64.java,reset,void reset(),1046,1050,40623,40623,IdentifierMutator-Literal,0,undefined,4,0.0011471427,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos =<mask>;
        modulus = 0;
        eof = false;
    }"
4367,Base64.java,reset,void reset(),1046,1051,40641,40641,AssignmentMutator,modulus=0,|,0,0.37451282,modulus <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus<mask>= 0;
        eof = false;
    }"
4368,Base64.java,reset,void reset(),1046,1051,40641,40641,AssignmentMutator,modulus=0,*,1,0.3215155,modulus <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus<mask>= 0;
        eof = false;
    }"
4369,Base64.java,reset,void reset(),1046,1051,40641,40641,AssignmentMutator,modulus=0,^,2,0.12662207,modulus <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus<mask>= 0;
        eof = false;
    }"
4370,Base64.java,reset,void reset(),1046,1051,40641,40641,AssignmentMutator,modulus=0,&,3,0.059786137,modulus <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus<mask>= 0;
        eof = false;
    }"
4371,Base64.java,reset,void reset(),1046,1051,40641,40641,AssignmentMutator,modulus=0,<<,4,0.023140948,modulus <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus<mask>= 0;
        eof = false;
    }"
4372,Base64.java,reset,void reset(),1046,1051,40634,40640,IdentifierMutator-Variable,modulus,pos,0,0.21849275,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4373,Base64.java,reset,void reset(),1046,1051,40634,40640,IdentifierMutator-Variable,modulus,line,1,0.14301813,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4374,Base64.java,reset,void reset(),1046,1051,40634,40640,IdentifierMutator-Variable,modulus,offset,2,0.11567888,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4375,Base64.java,reset,void reset(),1046,1051,40634,40640,IdentifierMutator-Variable,modulus,length,3,0.08439825,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4376,Base64.java,reset,void reset(),1046,1051,40634,40640,IdentifierMutator-Variable,modulus,index,4,0.028484449,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4377,Base64.java,reset,void reset(),1046,1051,40634,40640,FieldReferenceMutator,modulus,pos,0,0.21849275,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4378,Base64.java,reset,void reset(),1046,1051,40634,40640,FieldReferenceMutator,modulus,line,1,0.14301813,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4379,Base64.java,reset,void reset(),1046,1051,40634,40640,FieldReferenceMutator,modulus,offset,2,0.11567888,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4380,Base64.java,reset,void reset(),1046,1051,40634,40640,FieldReferenceMutator,modulus,length,3,0.08439825,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4381,Base64.java,reset,void reset(),1046,1051,40634,40640,FieldReferenceMutator,modulus,index,4,0.028484449,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4382,Base64.java,reset,void reset(),1046,1051,40644,40644,IdentifierMutator-Literal,0,1,1,0.099731855,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus =<mask>;
        eof = false;
    }"
4383,Base64.java,reset,void reset(),1046,1051,40644,40644,IdentifierMutator-Literal,0,null,2,0.010692796,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus =<mask>;
        eof = false;
    }"
4384,Base64.java,reset,void reset(),1046,1051,40644,40644,IdentifierMutator-Literal,0,false,3,0.0062312614,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus =<mask>;
        eof = false;
    }"
4385,Base64.java,reset,void reset(),1046,1051,40644,40644,IdentifierMutator-Literal,0,2,4,0.005245677,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus =<mask>;
        eof = false;
    }"
4386,Base64.java,reset,void reset(),1046,1052,40658,40658,AssignmentMutator,eof=false,Flag,0,0.15248011,eof <mask>= false,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof<mask>= false;
    }"
4387,Base64.java,reset,void reset(),1046,1052,40658,40658,AssignmentMutator,eof=false,Found,1,0.08163081,eof <mask>= false,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof<mask>= false;
    }"
4388,Base64.java,reset,void reset(),1046,1052,40658,40658,AssignmentMutator,eof=false,flag,2,0.041007932,eof <mask>= false,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof<mask>= false;
    }"
4389,Base64.java,reset,void reset(),1046,1052,40658,40658,AssignmentMutator,eof=false,Ok,3,0.038225308,eof <mask>= false,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof<mask>= false;
    }"
4390,Base64.java,reset,void reset(),1046,1052,40658,40658,AssignmentMutator,eof=false,Match,4,0.03317603,eof <mask>= false,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof<mask>= false;
    }"
4391,Base64.java,reset,void reset(),1046,1052,40655,40657,IdentifierMutator-Variable,eof,valid,0,0.05957121,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4392,Base64.java,reset,void reset(),1046,1052,40655,40657,IdentifierMutator-Variable,eof,modified,1,0.034466684,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4393,Base64.java,reset,void reset(),1046,1052,40655,40657,IdentifierMutator-Variable,eof,done,2,0.031822406,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4394,Base64.java,reset,void reset(),1046,1052,40655,40657,IdentifierMutator-Variable,eof,changed,3,0.024370342,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4395,Base64.java,reset,void reset(),1046,1052,40655,40657,IdentifierMutator-Variable,eof,initialized,4,0.023468198,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4396,Base64.java,reset,void reset(),1046,1052,40655,40657,FieldReferenceMutator,eof,valid,0,0.05957121,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4397,Base64.java,reset,void reset(),1046,1052,40655,40657,FieldReferenceMutator,eof,modified,1,0.034466684,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4398,Base64.java,reset,void reset(),1046,1052,40655,40657,FieldReferenceMutator,eof,done,2,0.031822406,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4399,Base64.java,reset,void reset(),1046,1052,40655,40657,FieldReferenceMutator,eof,changed,3,0.024370342,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4400,Base64.java,reset,void reset(),1046,1052,40655,40657,FieldReferenceMutator,eof,initialized,4,0.023468198,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4401,Base64.java,reset,void reset(),1046,1052,40661,40665,IdentifierMutator-Literal,false,true,0,0.4440178,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof =<mask>;
    }"
4402,Base64.java,reset,void reset(),1046,1052,40661,40665,IdentifierMutator-Literal,false,0,2,0.18760204,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof =<mask>;
    }"
4403,Base64.java,reset,void reset(),1046,1052,40661,40665,IdentifierMutator-Literal,false,null,3,0.02340096,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof =<mask>;
    }"
4404,Base64.java,reset,void reset(),1046,1052,40661,40665,IdentifierMutator-Literal,false,1,4,0.0042812945,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof =<mask>;
    }"
