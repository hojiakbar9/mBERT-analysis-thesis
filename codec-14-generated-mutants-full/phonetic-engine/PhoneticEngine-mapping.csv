id,classname,method_name,method_sig,method_def_line,mut_location,mut_start,mut_end,mut_operator,orig_token,pred_token,pred_pos,pred_score,masked_expr,masked_seq
0,PhoneticEngine.java,empty,PhonemeBuilder empty(final Languages.LanguageSet languages),71,72,2798,2799,IdentifierMutator-Literal,"""""",rule,0,0.59201354,<mask>,"PhonemeBuilder empty(final Languages.LanguageSet languages) {
            return new PhonemeBuilder(new Rule.Phoneme(<mask>, languages));
        }"
1,PhoneticEngine.java,empty,PhonemeBuilder empty(final Languages.LanguageSet languages),71,72,2798,2799,IdentifierMutator-Literal,"""""",name,1,0.06412517,<mask>,"PhonemeBuilder empty(final Languages.LanguageSet languages) {
            return new PhonemeBuilder(new Rule.Phoneme(<mask>, languages));
        }"
2,PhoneticEngine.java,empty,PhonemeBuilder empty(final Languages.LanguageSet languages),71,72,2798,2799,IdentifierMutator-Literal,"""""",this,2,0.052378338,<mask>,"PhonemeBuilder empty(final Languages.LanguageSet languages) {
            return new PhonemeBuilder(new Rule.Phoneme(<mask>, languages));
        }"
3,PhoneticEngine.java,empty,PhonemeBuilder empty(final Languages.LanguageSet languages),71,72,2798,2799,IdentifierMutator-Literal,"""""",null,3,0.05085778,<mask>,"PhonemeBuilder empty(final Languages.LanguageSet languages) {
            return new PhonemeBuilder(new Rule.Phoneme(<mask>, languages));
        }"
4,PhoneticEngine.java,empty,PhonemeBuilder empty(final Languages.LanguageSet languages),71,72,2798,2799,IdentifierMutator-Literal,"""""",rules,4,0.04503898,<mask>,"PhonemeBuilder empty(final Languages.LanguageSet languages) {
            return new PhonemeBuilder(new Rule.Phoneme(<mask>, languages));
        }"
5,PhoneticEngine.java,empty,PhonemeBuilder empty(final Languages.LanguageSet languages),71,72,2802,2810,IdentifierMutator-Variable,languages,"""""",1,0.13484327,<mask>,"PhonemeBuilder empty(final Languages.LanguageSet languages) {
            return new PhonemeBuilder(new Rule.Phoneme("""",<mask>));
        }"
6,PhoneticEngine.java,empty,PhonemeBuilder empty(final Languages.LanguageSet languages),71,72,2802,2810,IdentifierMutator-Variable,languages,null,2,0.09412886,<mask>,"PhonemeBuilder empty(final Languages.LanguageSet languages) {
            return new PhonemeBuilder(new Rule.Phoneme("""",<mask>));
        }"
7,PhoneticEngine.java,empty,PhonemeBuilder empty(final Languages.LanguageSet languages),71,72,2802,2810,IdentifierMutator-Variable,languages,empty,3,0.051006146,<mask>,"PhonemeBuilder empty(final Languages.LanguageSet languages) {
            return new PhonemeBuilder(new Rule.Phoneme("""",<mask>));
        }"
8,PhoneticEngine.java,empty,PhonemeBuilder empty(final Languages.LanguageSet languages),71,72,2802,2810,IdentifierMutator-Variable,languages,"''",4,0.05035795,<mask>,"PhonemeBuilder empty(final Languages.LanguageSet languages) {
            return new PhonemeBuilder(new Rule.Phoneme("""",<mask>));
        }"
9,PhoneticEngine.java,append,void append(final CharSequence str),91,92,3469,3481,IdentifierMutator-Variable,this.phonemes,rules,0,0.34900326,<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph :<mask>) {
                ph.append(str);
            }
        }"
10,PhoneticEngine.java,append,void append(final CharSequence str),91,92,3469,3481,IdentifierMutator-Variable,this.phonemes,patterns,1,0.04486026,<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph :<mask>) {
                ph.append(str);
            }
        }"
11,PhoneticEngine.java,append,void append(final CharSequence str),91,92,3469,3481,IdentifierMutator-Variable,this.phonemes,this,2,0.04314815,<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph :<mask>) {
                ph.append(str);
            }
        }"
12,PhoneticEngine.java,append,void append(final CharSequence str),91,92,3469,3481,IdentifierMutator-Variable,this.phonemes,list,3,0.03360724,<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph :<mask>) {
                ph.append(str);
            }
        }"
13,PhoneticEngine.java,append,void append(final CharSequence str),91,92,3469,3481,IdentifierMutator-Variable,this.phonemes,rule,4,0.03271503,<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph :<mask>) {
                ph.append(str);
            }
        }"
14,PhoneticEngine.java,append,void append(final CharSequence str),91,92,3469,3472,IdentifierMutator-ThisAccess,this,rule,0,0.7314038,<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph :<mask>.phonemes) {
                ph.append(str);
            }
        }"
15,PhoneticEngine.java,append,void append(final CharSequence str),91,92,3469,3472,IdentifierMutator-ThisAccess,this,Rule,2,0.009431424,<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph :<mask>.phonemes) {
                ph.append(str);
            }
        }"
16,PhoneticEngine.java,append,void append(final CharSequence str),91,92,3469,3472,IdentifierMutator-ThisAccess,this,rules,3,0.009235569,<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph :<mask>.phonemes) {
                ph.append(str);
            }
        }"
17,PhoneticEngine.java,append,void append(final CharSequence str),91,92,3469,3472,IdentifierMutator-ThisAccess,this,Rule,4,0.0059147794,<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph :<mask>.phonemes) {
                ph.append(str);
            }
        }"
18,PhoneticEngine.java,append,void append(final CharSequence str),91,92,3474,3481,FieldReferenceMutator,phonemes,children,0,0.28914797,this.<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph : this.<mask>) {
                ph.append(str);
            }
        }"
19,PhoneticEngine.java,append,void append(final CharSequence str),91,92,3474,3481,FieldReferenceMutator,phonemes,rules,1,0.20089221,this.<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph : this.<mask>) {
                ph.append(str);
            }
        }"
20,PhoneticEngine.java,append,void append(final CharSequence str),91,92,3474,3481,FieldReferenceMutator,phonemes,parents,2,0.09303768,this.<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph : this.<mask>) {
                ph.append(str);
            }
        }"
21,PhoneticEngine.java,append,void append(final CharSequence str),91,92,3474,3481,FieldReferenceMutator,phonemes,params,3,0.050733376,this.<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph : this.<mask>) {
                ph.append(str);
            }
        }"
22,PhoneticEngine.java,append,void append(final CharSequence str),91,92,3474,3481,FieldReferenceMutator,phonemes,pages,4,0.03721871,this.<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph : this.<mask>) {
                ph.append(str);
            }
        }"
23,PhoneticEngine.java,append,void append(final CharSequence str),91,93,3505,3510,MethodCallMutator,append,end,1,0.0015036176,ph.<mask>(str),"void append(final CharSequence str) {
            for (final Rule.Phoneme ph : this.phonemes) {
                ph.<mask>(str);
            }
        }"
24,PhoneticEngine.java,append,void append(final CharSequence str),91,93,3505,3510,MethodCallMutator,append,add,2,0.0014984471,ph.<mask>(str),"void append(final CharSequence str) {
            for (final Rule.Phoneme ph : this.phonemes) {
                ph.<mask>(str);
            }
        }"
25,PhoneticEngine.java,append,void append(final CharSequence str),91,93,3505,3510,MethodCallMutator,append,write,4,0.0011541155,ph.<mask>(str),"void append(final CharSequence str) {
            for (final Rule.Phoneme ph : this.phonemes) {
                ph.<mask>(str);
            }
        }"
26,PhoneticEngine.java,append,void append(final CharSequence str),91,93,3502,3503,IdentifierMutator-Variable,ph,pp,2,1.0607383E-5,<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph : this.phonemes) {<mask>.append(str);
            }
        }"
27,PhoneticEngine.java,append,void append(final CharSequence str),91,93,3502,3503,IdentifierMutator-Variable,ph,p,3,7.66814E-6,<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph : this.phonemes) {<mask>.append(str);
            }
        }"
28,PhoneticEngine.java,append,void append(final CharSequence str),91,93,3502,3503,IdentifierMutator-Variable,ph,pl,4,7.6339775E-6,<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph : this.phonemes) {<mask>.append(str);
            }
        }"
29,PhoneticEngine.java,append,void append(final CharSequence str),91,93,3512,3514,IdentifierMutator-Variable,str,Str,1,0.0012645294,<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph : this.phonemes) {
                ph.append(<mask>);
            }
        }"
30,PhoneticEngine.java,append,void append(final CharSequence str),91,93,3512,3514,IdentifierMutator-Variable,str,string,3,1.3958213E-4,<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph : this.phonemes) {
                ph.append(<mask>);
            }
        }"
31,PhoneticEngine.java,append,void append(final CharSequence str),91,93,3512,3514,IdentifierMutator-Variable,str,STR,4,3.6883717E-5,<mask>,"void append(final CharSequence str) {
            for (final Rule.Phoneme ph : this.phonemes) {
                ph.append(<mask>);
            }
        }"
32,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,107,4124,4134,IdentifierMutator-Variable,maxPhonemes,0,0,0.23816901,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(<mask>);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
    "
33,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,107,4124,4134,IdentifierMutator-Variable,maxPhonemes,1,1,0.20445791,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(<mask>);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
    "
34,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,107,4124,4134,IdentifierMutator-Variable,maxPhonemes,10,2,0.05991118,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(<mask>);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
    "
35,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,107,4124,4134,IdentifierMutator-Variable,maxPhonemes,6,3,0.05323958,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(<mask>);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
    "
36,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,107,4124,4134,IdentifierMutator-Variable,maxPhonemes,2,4,0.038172696,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(<mask>);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
    "
37,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,109,4188,4200,IdentifierMutator-Variable,this.phonemes,this,0,0.4190385,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left :<mask>) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
     "
38,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,109,4188,4200,IdentifierMutator-Variable,this.phonemes,rules,1,0.3414878,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left :<mask>) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
     "
39,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,109,4188,4200,IdentifierMutator-Variable,this.phonemes,grammar,2,0.012639406,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left :<mask>) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
     "
40,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,109,4188,4200,IdentifierMutator-Variable,this.phonemes,this,3,0.009090246,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left :<mask>) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
     "
41,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,109,4188,4200,IdentifierMutator-Variable,this.phonemes,list,4,0.008421257,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left :<mask>) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
     "
42,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,109,4188,4191,IdentifierMutator-ThisAccess,this,rule,1,0.11922987,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left :<mask>.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
43,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,109,4188,4191,IdentifierMutator-ThisAccess,this,self,2,0.026357856,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left :<mask>.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
44,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,109,4188,4191,IdentifierMutator-ThisAccess,this,root,3,0.00782775,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left :<mask>.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
45,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,109,4193,4200,FieldReferenceMutator,phonemes,rules,0,0.4894564,this.<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.<mask>) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
   "
46,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,109,4193,4200,FieldReferenceMutator,phonemes,children,1,0.07354071,this.<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.<mask>) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
   "
47,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,109,4193,4200,FieldReferenceMutator,phonemes,left,2,0.04109937,this.<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.<mask>) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
   "
48,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,109,4193,4200,FieldReferenceMutator,phonemes,groups,3,0.033606768,this.<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.<mask>) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
   "
49,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,109,4193,4200,FieldReferenceMutator,phonemes,list,4,0.03328779,this.<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.<mask>) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
   "
50,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,110,4265,4275,MethodCallMutator,getPhonemes,values,0,0.36494288,phonemeExpr.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.<mask>()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
    "
51,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,110,4265,4275,MethodCallMutator,getPhonemes,split,1,0.12615144,phonemeExpr.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.<mask>()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
    "
52,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,110,4265,4275,MethodCallMutator,getPhonemes,reverse,2,0.094709136,phonemeExpr.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.<mask>()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
    "
53,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,110,4265,4275,MethodCallMutator,getPhonemes,groups,3,0.084816925,phonemeExpr.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.<mask>()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
    "
54,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,110,4265,4275,MethodCallMutator,getPhonemes,children,4,0.054072753,phonemeExpr.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.<mask>()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
    "
55,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,110,4253,4263,IdentifierMutator-Variable,phonemeExpr,left,0,0.9748355,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right :<mask>.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
   "
56,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,110,4253,4263,IdentifierMutator-Variable,phonemeExpr,right,1,0.015523058,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right :<mask>.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
   "
57,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,110,4253,4263,IdentifierMutator-Variable,phonemeExpr,left,2,0.0044323783,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right :<mask>.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
   "
58,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,110,4253,4263,IdentifierMutator-Variable,phonemeExpr,this,3,0.002180053,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right :<mask>.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
   "
59,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,110,4253,4263,IdentifierMutator-Variable,phonemeExpr,Left,4,5.8869994E-4,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right :<mask>.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
   "
60,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4352,4361,MethodCallMutator,restrictTo,union,0,0.5506087,left.getLanguages().<mask>(right.getLanguages()),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().<mask>(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
  "
61,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4352,4361,MethodCallMutator,restrictTo,join,1,0.1389854,left.getLanguages().<mask>(right.getLanguages()),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().<mask>(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
  "
62,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4352,4361,MethodCallMutator,restrictTo,add,2,0.11803369,left.getLanguages().<mask>(right.getLanguages()),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().<mask>(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
  "
63,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4352,4361,MethodCallMutator,restrictTo,and,3,0.019298408,left.getLanguages().<mask>(right.getLanguages()),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().<mask>(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
  "
64,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4352,4361,MethodCallMutator,restrictTo,with,4,0.014144841,left.getLanguages().<mask>(right.getLanguages()),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().<mask>(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
  "
65,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4337,4348,MethodCallMutator,getLanguages,language,0,0.84735084,left.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.<mask>().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
  "
66,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4337,4348,MethodCallMutator,getLanguages,get,1,0.078952074,left.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.<mask>().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
  "
67,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4337,4348,MethodCallMutator,getLanguages,anguages,2,0.00931989,left.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.<mask>().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
  "
68,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4337,4348,MethodCallMutator,getLanguages,groups,3,0.0056674704,left.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.<mask>().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
  "
69,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4337,4348,MethodCallMutator,getLanguages,values,4,0.0052980008,left.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.<mask>().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
  "
70,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4332,4335,IdentifierMutator-Variable,left,Left,2,5.176955E-4,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages =<mask>.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
71,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4332,4335,IdentifierMutator-Variable,left,right,3,2.8018252E-4,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages =<mask>.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
72,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4332,4335,IdentifierMutator-Variable,left,Left,4,1.6001679E-4,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages =<mask>.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
73,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4369,4380,MethodCallMutator,getLanguages,language,0,0.78009486,right.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.<mask>());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
  "
74,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4369,4380,MethodCallMutator,getLanguages,get,1,0.12977399,right.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.<mask>());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
  "
75,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4369,4380,MethodCallMutator,getLanguages,guard,2,0.009881496,right.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.<mask>());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
  "
76,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4369,4380,MethodCallMutator,getLanguages,keys,3,0.004879786,right.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.<mask>());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
  "
77,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4369,4380,MethodCallMutator,getLanguages,values,4,0.0044380226,right.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.<mask>());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
  "
78,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4363,4367,IdentifierMutator-Variable,right,Right,2,4.1252337E-4,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(<mask>.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
79,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4363,4367,IdentifierMutator-Variable,right,left,3,1.7582087E-4,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(<mask>.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
80,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,111,4363,4367,IdentifierMutator-Variable,right,join,4,4.021731E-5,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(<mask>.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
81,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,112,4410,4410,UnaryOperatorMutator,!,...,2,0.0015882003,<mask>languages.isEmpty(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (<mask>languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }"
82,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,112,4410,4410,UnaryOperatorMutator,!,!!,3,5.342572E-4,<mask>languages.isEmpty(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (<mask>languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }"
83,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,112,4410,4410,UnaryOperatorMutator,!,?,4,4.0913024E-4,<mask>languages.isEmpty(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (<mask>languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }"
84,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,112,4421,4427,MethodCallMutator,isEmpty,empty,0,0.9626312,languages.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.<mask>()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
 "
85,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,112,4421,4427,MethodCallMutator,isEmpty,Empty,1,0.021950593,languages.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.<mask>()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
 "
86,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,112,4421,4427,MethodCallMutator,isEmpty,nil,2,0.0021382757,languages.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.<mask>()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
 "
87,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,112,4421,4427,MethodCallMutator,isEmpty,clone,3,0.0018863236,languages.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.<mask>()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
 "
88,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,112,4421,4427,MethodCallMutator,isEmpty,null,4,0.0014239233,languages.<mask>(),"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.<mask>()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
 "
89,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,112,4411,4419,IdentifierMutator-Variable,languages,language,0,0.74152774,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!<mask>.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
 "
90,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,112,4411,4419,IdentifierMutator-Variable,languages,anguages,2,0.034934532,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!<mask>.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
 "
91,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,112,4411,4419,IdentifierMutator-Variable,languages,lang,3,0.02035204,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!<mask>.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
 "
92,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,112,4411,4419,IdentifierMutator-Variable,languages,plugins,4,0.014790433,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!<mask>.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
 "
93,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,113,4496,4499,IdentifierMutator-Variable,left,Left,2,2.4174829E-4,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(<mask>, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
94,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,113,4496,4499,IdentifierMutator-Variable,left,join,3,2.2671156E-4,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(<mask>, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
95,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,113,4496,4499,IdentifierMutator-Variable,left,this,4,8.584722E-5,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(<mask>, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
96,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,113,4502,4506,IdentifierMutator-Variable,right,Right,2,1.7041374E-4,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left,<mask>, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
97,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,113,4502,4506,IdentifierMutator-Variable,right,left,3,8.534394E-5,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left,<mask>, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
98,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,113,4502,4506,IdentifierMutator-Variable,right,Right,4,7.254944E-5,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left,<mask>, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
99,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,113,4509,4517,IdentifierMutator-Variable,languages,language,1,0.049762018,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right,<mask>);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
100,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,113,4509,4517,IdentifierMutator-Variable,languages,lang,2,0.0024958125,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right,<mask>);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
101,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,113,4509,4517,IdentifierMutator-Variable,languages,false,3,0.0022755798,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right,<mask>);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
102,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,113,4509,4517,IdentifierMutator-Variable,languages,true,4,0.0019268865,<mask>,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right,<mask>);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
"
103,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,114,4567,4569,BinaryOperatorMutator,<,>=,1,0.3284085,newPhonemes.size() <mask> maxPhonemes,"     final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size()<mask>maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();"
104,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,114,4567,4569,BinaryOperatorMutator,<,>,3,0.041741785,newPhonemes.size() <mask> maxPhonemes,"     final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size()<mask>maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();"
105,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,114,4567,4569,BinaryOperatorMutator,<,<=,4,0.031097703,newPhonemes.size() <mask> maxPhonemes,"     final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size()<mask>maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();"
106,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,114,4561,4564,MethodCallMutator,size,count,1,1.301179E-4,newPhonemes.<mask>(),"       final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.<mask>() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes."
107,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,114,4561,4564,MethodCallMutator,size,length,3,4.8467715E-5,newPhonemes.<mask>(),"       final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.<mask>() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes."
108,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,114,4561,4564,MethodCallMutator,size,position,4,2.338084E-5,newPhonemes.<mask>(),"       final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.<mask>() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes."
109,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,114,4549,4559,IdentifierMutator-Variable,newPhonemes,join,0,0.9951381,<mask>,"
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (<mask>.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonem"
110,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,114,4549,4559,IdentifierMutator-Variable,newPhonemes,joined,1,0.0014157399,<mask>,"
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (<mask>.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonem"
111,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,114,4549,4559,IdentifierMutator-Variable,newPhonemes,join,2,2.2853438E-4,<mask>,"
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (<mask>.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonem"
112,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,114,4549,4559,IdentifierMutator-Variable,newPhonemes,list,3,1.9495026E-4,<mask>,"
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (<mask>.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonem"
113,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,114,4549,4559,IdentifierMutator-Variable,newPhonemes,split,4,1.6887234E-4,<mask>,"
            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (<mask>.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonem"
114,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,114,4570,4580,IdentifierMutator-Variable,maxPhonemes,1,0,0.18934709,<mask>,"    final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() <<mask>) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
    "
115,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,114,4570,4580,IdentifierMutator-Variable,maxPhonemes,2,1,0.11046067,<mask>,"    final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() <<mask>) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
    "
116,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,114,4570,4580,IdentifierMutator-Variable,maxPhonemes,size,2,0.11028004,<mask>,"    final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() <<mask>) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
    "
117,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,114,4570,4580,IdentifierMutator-Variable,maxPhonemes,max,3,0.1035429,<mask>,"    final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() <<mask>) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
    "
118,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,114,4570,4580,IdentifierMutator-Variable,maxPhonemes,limit,4,0.09047241,<mask>,"    final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() <<mask>) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
    "
119,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,115,4625,4627,MethodCallMutator,add,push,1,0.025813248,newPhonemes.<mask>(join),"        EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.<mask>(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
120,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,115,4625,4627,MethodCallMutator,add,append,2,0.0065168217,newPhonemes.<mask>(join),"        EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.<mask>(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
121,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,115,4625,4627,MethodCallMutator,add,remove,3,0.0022391325,newPhonemes.<mask>(join),"        EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.<mask>(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
122,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,115,4613,4623,IdentifierMutator-Variable,newPhonemes,list,0,0.16318052,<mask>,".Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {<mask>.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
123,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,115,4613,4623,IdentifierMutator-Variable,newPhonemes,result,1,0.073959254,<mask>,".Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {<mask>.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
124,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,115,4613,4623,IdentifierMutator-Variable,newPhonemes,rules,2,0.029277531,<mask>,".Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {<mask>.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
125,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,115,4613,4623,IdentifierMutator-Variable,newPhonemes,nodes,3,0.02582585,<mask>,".Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {<mask>.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
126,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,115,4613,4623,IdentifierMutator-Variable,newPhonemes,set,4,0.016727684,<mask>,".Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);

            EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {<mask>.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
127,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,115,4629,4632,IdentifierMutator-Variable,join,right,1,5.7299377E-4,<mask>,"      EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(<mask>);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
128,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,115,4629,4632,IdentifierMutator-Variable,join,joined,3,2.5303126E-4,<mask>,"      EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(<mask>);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
129,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,115,4629,4632,IdentifierMutator-Variable,join,left,4,2.1761461E-4,<mask>,"      EXPR: for (final Rule.Phoneme left : this.phonemes) {
                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(<mask>);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
130,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,116,4686,4689,BinaryOperatorMutator,>=,>,0,0.30495742,newPhonemes.size() <mask> maxPhonemes,"   for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size()<mask>maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
131,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,116,4686,4689,BinaryOperatorMutator,>=,<,2,0.12890661,newPhonemes.size() <mask> maxPhonemes,"   for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size()<mask>maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
132,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,116,4686,4689,BinaryOperatorMutator,>=,==,3,0.106166214,newPhonemes.size() <mask> maxPhonemes,"   for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size()<mask>maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
133,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,116,4686,4689,BinaryOperatorMutator,>=,==,4,0.054298963,newPhonemes.size() <mask> maxPhonemes,"   for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size()<mask>maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
134,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,116,4680,4683,MethodCallMutator,size,count,1,2.847469E-4,newPhonemes.<mask>(),"     for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.<mask>() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
135,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,116,4680,4683,MethodCallMutator,size,length,3,7.321936E-5,newPhonemes.<mask>(),"     for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.<mask>() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
136,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,116,4680,4683,MethodCallMutator,size,position,4,4.187419E-5,newPhonemes.<mask>(),"     for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.<mask>() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
137,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,116,4668,4678,IdentifierMutator-Variable,newPhonemes,join,0,0.7113676,<mask>,"           for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (<mask>.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
138,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,116,4668,4678,IdentifierMutator-Variable,newPhonemes,new,1,0.09514807,<mask>,"           for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (<mask>.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
139,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,116,4668,4678,IdentifierMutator-Variable,newPhonemes,list,2,0.019079987,<mask>,"           for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (<mask>.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
140,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,116,4668,4678,IdentifierMutator-Variable,newPhonemes,result,3,0.012926871,<mask>,"           for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (<mask>.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
141,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,116,4668,4678,IdentifierMutator-Variable,newPhonemes,joined,4,0.0086854715,<mask>,"           for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (<mask>.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
142,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,116,4690,4700,IdentifierMutator-Variable,maxPhonemes,max,0,0.7580325,<mask>,"  for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >=<mask>) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
143,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,116,4690,4700,IdentifierMutator-Variable,maxPhonemes,limit,1,0.0963099,<mask>,"  for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >=<mask>) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
144,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,116,4690,4700,IdentifierMutator-Variable,maxPhonemes,count,2,0.014668198,<mask>,"  for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >=<mask>) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
145,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,116,4690,4700,IdentifierMutator-Variable,maxPhonemes,maximum,3,0.012727652,<mask>,"  for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >=<mask>) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
146,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,116,4690,4700,IdentifierMutator-Variable,maxPhonemes,1,4,0.007840494,<mask>,"  for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {
                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());
                    if (!languages.isEmpty()) {
                        final Rule.Phoneme join = new Phoneme(left, right, languages);
                        if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >=<mask>) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
147,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,124,4886,4890,MethodCallMutator,clear,sort,1,0.035323005,this.phonemes.<mask>(),".size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.<mask>();
            this.phonemes.addAll(newPhonemes);
       "
148,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,124,4886,4890,MethodCallMutator,clear,clone,2,0.0024316222,this.phonemes.<mask>(),".size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.<mask>();
            this.phonemes.addAll(newPhonemes);
       "
149,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,124,4886,4890,MethodCallMutator,clear,remove,4,0.0014378171,this.phonemes.<mask>(),".size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.<mask>();
            this.phonemes.addAll(newPhonemes);
       "
150,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,124,4872,4884,IdentifierMutator-Variable,this.phonemes,list,0,0.085880384,<mask>,"             if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }<mask>.clear();
            this.phonemes.addAll(newPhonemes);
       "
151,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,124,4872,4884,IdentifierMutator-Variable,this.phonemes,join,1,0.04246383,<mask>,"             if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }<mask>.clear();
            this.phonemes.addAll(newPhonemes);
       "
152,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,124,4872,4884,IdentifierMutator-Variable,this.phonemes,result,2,0.036096785,<mask>,"             if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }<mask>.clear();
            this.phonemes.addAll(newPhonemes);
       "
153,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,124,4872,4884,IdentifierMutator-Variable,this.phonemes,groups,3,0.023660459,<mask>,"             if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }<mask>.clear();
            this.phonemes.addAll(newPhonemes);
       "
154,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,124,4872,4884,IdentifierMutator-Variable,this.phonemes,this,4,0.021092528,<mask>,"             if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }<mask>.clear();
            this.phonemes.addAll(newPhonemes);
       "
155,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,124,4872,4875,IdentifierMutator-ThisAccess,this,This,2,7.0051843E-4,<mask>,"             if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }<mask>.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
156,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,124,4872,4875,IdentifierMutator-ThisAccess,this,This,3,1.3780287E-4,<mask>,"             if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }<mask>.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
157,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,124,4872,4875,IdentifierMutator-ThisAccess,this,parent,4,9.5300806E-5,<mask>,"             if (newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }<mask>.phonemes.clear();
            this.phonemes.addAll(newPhonemes);
       "
158,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,124,4877,4884,FieldReferenceMutator,phonemes,groups,0,0.13364026,this.<mask>,"newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.<mask>.clear();
            this.phonemes.addAll(newPhonemes);
       "
159,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,124,4877,4884,FieldReferenceMutator,phonemes,children,1,0.06293333,this.<mask>,"newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.<mask>.clear();
            this.phonemes.addAll(newPhonemes);
       "
160,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,124,4877,4884,FieldReferenceMutator,phonemes,lines,2,0.055002153,this.<mask>,"newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.<mask>.clear();
            this.phonemes.addAll(newPhonemes);
       "
161,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,124,4877,4884,FieldReferenceMutator,phonemes,members,3,0.0345469,this.<mask>,"newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.<mask>.clear();
            this.phonemes.addAll(newPhonemes);
       "
162,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,124,4877,4884,FieldReferenceMutator,phonemes,sections,4,0.027016409,this.<mask>,"newPhonemes.size() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.<mask>.clear();
            this.phonemes.addAll(newPhonemes);
       "
163,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4921,4926,MethodCallMutator,addAll,add,0,0.9843477,this.phonemes.<mask>(newPhonemes),"                   newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.<mask>(newPhonemes);
       "
164,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4921,4926,MethodCallMutator,addAll,set,1,0.0037715498,this.phonemes.<mask>(newPhonemes),"                   newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.<mask>(newPhonemes);
       "
165,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4921,4926,MethodCallMutator,addAll,append,2,0.0026237168,this.phonemes.<mask>(newPhonemes),"                   newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.<mask>(newPhonemes);
       "
166,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4921,4926,MethodCallMutator,addAll,push,3,0.0021566183,this.phonemes.<mask>(newPhonemes),"                   newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.<mask>(newPhonemes);
       "
167,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4921,4926,MethodCallMutator,addAll,update,4,7.390743E-4,this.phonemes.<mask>(newPhonemes),"                   newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.<mask>(newPhonemes);
       "
168,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4907,4919,IdentifierMutator-Variable,this.phonemes,result,0,0.2708844,<mask>,"() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();<mask>.addAll(newPhonemes);
       "
169,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4907,4919,IdentifierMutator-Variable,this.phonemes,list,1,0.14297222,<mask>,"() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();<mask>.addAll(newPhonemes);
       "
170,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4907,4919,IdentifierMutator-Variable,this.phonemes,this,2,0.06256766,<mask>,"() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();<mask>.addAll(newPhonemes);
       "
171,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4907,4919,IdentifierMutator-Variable,this.phonemes,groups,3,0.027067611,<mask>,"() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();<mask>.addAll(newPhonemes);
       "
172,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4907,4919,IdentifierMutator-Variable,this.phonemes,joined,4,0.01458187,<mask>,"() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();<mask>.addAll(newPhonemes);
       "
173,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4907,4910,IdentifierMutator-ThisAccess,this,This,2,2.9179497E-5,<mask>,"() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();<mask>.phonemes.addAll(newPhonemes);
       "
174,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4907,4910,IdentifierMutator-ThisAccess,this,This,3,1.42608515E-5,<mask>,"() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();<mask>.phonemes.addAll(newPhonemes);
       "
175,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4907,4910,IdentifierMutator-ThisAccess,this,super,4,1.2489804E-5,<mask>,"() < maxPhonemes) {
                            newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();<mask>.phonemes.addAll(newPhonemes);
       "
176,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4912,4919,FieldReferenceMutator,phonemes,list,0,0.14256932,this.<mask>,"                        newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.<mask>.addAll(newPhonemes);
       "
177,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4912,4919,FieldReferenceMutator,phonemes,children,1,0.105339386,this.<mask>,"                        newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.<mask>.addAll(newPhonemes);
       "
178,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4912,4919,FieldReferenceMutator,phonemes,parts,2,0.08587062,this.<mask>,"                        newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.<mask>.addAll(newPhonemes);
       "
179,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4912,4919,FieldReferenceMutator,phonemes,groups,3,0.067703016,this.<mask>,"                        newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.<mask>.addAll(newPhonemes);
       "
180,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4912,4919,FieldReferenceMutator,phonemes,result,4,0.03565603,this.<mask>,"                        newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.<mask>.addAll(newPhonemes);
       "
181,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4928,4938,IdentifierMutator-Variable,newPhonemes,join,0,0.6126982,<mask>,"                newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(<mask>);
       "
182,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4928,4938,IdentifierMutator-Variable,newPhonemes,list,1,0.0664062,<mask>,"                newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(<mask>);
       "
183,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4928,4938,IdentifierMutator-Variable,newPhonemes,new,2,0.03961651,<mask>,"                newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(<mask>);
       "
184,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4928,4938,IdentifierMutator-Variable,newPhonemes,parts,3,0.023747962,<mask>,"                newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(<mask>);
       "
185,PhoneticEngine.java,apply,"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes)",106,125,4928,4938,IdentifierMutator-Variable,newPhonemes,joined,4,0.0217578,<mask>,"                newPhonemes.add(join);
                            if (newPhonemes.size() >= maxPhonemes) {
                                break EXPR;
                            }
                        }
                    }
                }
            }

            this.phonemes.clear();
            this.phonemes.addAll(<mask>);
       "
186,PhoneticEngine.java,getPhonemes,Set<Rule.Phoneme> getPhonemes(),133,134,5153,5165,IdentifierMutator-Variable,this.phonemes,null,0,0.5280299,<mask>,"Set<Rule.Phoneme> getPhonemes() {
            return<mask>;
        }"
187,PhoneticEngine.java,getPhonemes,Set<Rule.Phoneme> getPhonemes(),133,134,5153,5165,IdentifierMutator-Variable,this.phonemes,set,1,0.21960904,<mask>,"Set<Rule.Phoneme> getPhonemes() {
            return<mask>;
        }"
188,PhoneticEngine.java,getPhonemes,Set<Rule.Phoneme> getPhonemes(),133,134,5153,5165,IdentifierMutator-Variable,this.phonemes,true,2,0.052033037,<mask>,"Set<Rule.Phoneme> getPhonemes() {
            return<mask>;
        }"
189,PhoneticEngine.java,getPhonemes,Set<Rule.Phoneme> getPhonemes(),133,134,5153,5165,IdentifierMutator-Variable,this.phonemes,rules,3,0.032230034,<mask>,"Set<Rule.Phoneme> getPhonemes() {
            return<mask>;
        }"
190,PhoneticEngine.java,getPhonemes,Set<Rule.Phoneme> getPhonemes(),133,134,5153,5165,IdentifierMutator-Variable,this.phonemes,sets,4,0.02357215,<mask>,"Set<Rule.Phoneme> getPhonemes() {
            return<mask>;
        }"
191,PhoneticEngine.java,getPhonemes,Set<Rule.Phoneme> getPhonemes(),133,134,5153,5156,IdentifierMutator-ThisAccess,this,rule,0,0.77826196,<mask>,"Set<Rule.Phoneme> getPhonemes() {
            return<mask>.phonemes;
        }"
192,PhoneticEngine.java,getPhonemes,Set<Rule.Phoneme> getPhonemes(),133,134,5153,5156,IdentifierMutator-ThisAccess,this,rules,2,0.03494074,<mask>,"Set<Rule.Phoneme> getPhonemes() {
            return<mask>.phonemes;
        }"
193,PhoneticEngine.java,getPhonemes,Set<Rule.Phoneme> getPhonemes(),133,134,5153,5156,IdentifierMutator-ThisAccess,this,Rule,3,0.006306688,<mask>,"Set<Rule.Phoneme> getPhonemes() {
            return<mask>.phonemes;
        }"
194,PhoneticEngine.java,getPhonemes,Set<Rule.Phoneme> getPhonemes(),133,134,5153,5156,IdentifierMutator-ThisAccess,this,Rule,4,0.002555026,<mask>,"Set<Rule.Phoneme> getPhonemes() {
            return<mask>.phonemes;
        }"
195,PhoneticEngine.java,getPhonemes,Set<Rule.Phoneme> getPhonemes(),133,134,5158,5165,FieldReferenceMutator,phonemes,set,0,0.27800992,this.<mask>,"Set<Rule.Phoneme> getPhonemes() {
            return this.<mask>;
        }"
196,PhoneticEngine.java,getPhonemes,Set<Rule.Phoneme> getPhonemes(),133,134,5158,5165,FieldReferenceMutator,phonemes,rules,1,0.22180827,this.<mask>,"Set<Rule.Phoneme> getPhonemes() {
            return this.<mask>;
        }"
197,PhoneticEngine.java,getPhonemes,Set<Rule.Phoneme> getPhonemes(),133,134,5158,5165,FieldReferenceMutator,phonemes,groups,2,0.052670218,this.<mask>,"Set<Rule.Phoneme> getPhonemes() {
            return this.<mask>;
        }"
198,PhoneticEngine.java,getPhonemes,Set<Rule.Phoneme> getPhonemes(),133,134,5158,5165,FieldReferenceMutator,phonemes,rule,3,0.043375283,this.<mask>,"Set<Rule.Phoneme> getPhonemes() {
            return this.<mask>;
        }"
199,PhoneticEngine.java,getPhonemes,Set<Rule.Phoneme> getPhonemes(),133,134,5158,5165,FieldReferenceMutator,phonemes,children,4,0.036765248,this.<mask>,"Set<Rule.Phoneme> getPhonemes() {
            return this.<mask>;
        }"
200,PhoneticEngine.java,makeString,String makeString(),144,147,5676,5688,IdentifierMutator-Variable,this.phonemes,rules,0,0.65000796,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph :<mask>) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
201,PhoneticEngine.java,makeString,String makeString(),144,147,5676,5688,IdentifierMutator-Variable,this.phonemes,paragraphs,1,0.049910493,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph :<mask>) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
202,PhoneticEngine.java,makeString,String makeString(),144,147,5676,5688,IdentifierMutator-Variable,this.phonemes,rule,2,0.035934027,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph :<mask>) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
203,PhoneticEngine.java,makeString,String makeString(),144,147,5676,5688,IdentifierMutator-Variable,this.phonemes,phrases,3,0.03439483,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph :<mask>) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
204,PhoneticEngine.java,makeString,String makeString(),144,147,5676,5688,IdentifierMutator-Variable,this.phonemes,patterns,4,0.020913888,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph :<mask>) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
205,PhoneticEngine.java,makeString,String makeString(),144,147,5676,5679,IdentifierMutator-ThisAccess,this,rule,0,0.7923786,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph :<mask>.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
206,PhoneticEngine.java,makeString,String makeString(),144,147,5676,5679,IdentifierMutator-ThisAccess,this,rules,2,0.02249645,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph :<mask>.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
207,PhoneticEngine.java,makeString,String makeString(),144,147,5676,5679,IdentifierMutator-ThisAccess,this,rule,3,0.013023735,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph :<mask>.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
208,PhoneticEngine.java,makeString,String makeString(),144,147,5676,5679,IdentifierMutator-ThisAccess,this,Rule,4,0.005714058,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph :<mask>.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
209,PhoneticEngine.java,makeString,String makeString(),144,147,5681,5688,FieldReferenceMutator,phonemes,rules,0,0.4137395,this.<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.<mask>) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
210,PhoneticEngine.java,makeString,String makeString(),144,147,5681,5688,FieldReferenceMutator,phonemes,children,1,0.12904328,this.<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.<mask>) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
211,PhoneticEngine.java,makeString,String makeString(),144,147,5681,5688,FieldReferenceMutator,phonemes,params,2,0.09753247,this.<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.<mask>) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
212,PhoneticEngine.java,makeString,String makeString(),144,147,5681,5688,FieldReferenceMutator,phonemes,properties,3,0.06763935,this.<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.<mask>) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
213,PhoneticEngine.java,makeString,String makeString(),144,147,5681,5688,FieldReferenceMutator,phonemes,rule,4,0.0282129,this.<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.<mask>) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
214,PhoneticEngine.java,makeString,String makeString(),144,148,5724,5726,BinaryOperatorMutator,>,==,1,0.36726397,sb.length() <mask> 0,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length()<mask>0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
215,PhoneticEngine.java,makeString,String makeString(),144,148,5724,5726,BinaryOperatorMutator,>,==,3,0.04234976,sb.length() <mask> 0,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length()<mask>0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
216,PhoneticEngine.java,makeString,String makeString(),144,148,5724,5726,BinaryOperatorMutator,>,=,4,0.0090782875,sb.length() <mask> 0,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length()<mask>0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
217,PhoneticEngine.java,makeString,String makeString(),144,148,5716,5721,MethodCallMutator,length,position,1,0.004511397,sb.<mask>(),"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.<mask>() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
218,PhoneticEngine.java,makeString,String makeString(),144,148,5716,5721,MethodCallMutator,length,size,2,0.0020729906,sb.<mask>(),"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.<mask>() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
219,PhoneticEngine.java,makeString,String makeString(),144,148,5716,5721,MethodCallMutator,length,len,3,6.7419244E-4,sb.<mask>(),"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.<mask>() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
220,PhoneticEngine.java,makeString,String makeString(),144,148,5716,5721,MethodCallMutator,length,width,4,3.3408066E-4,sb.<mask>(),"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.<mask>() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
221,PhoneticEngine.java,makeString,String makeString(),144,148,5713,5714,IdentifierMutator-Variable,sb,ph,1,0.13159052,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (<mask>.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
222,PhoneticEngine.java,makeString,String makeString(),144,148,5713,5714,IdentifierMutator-Variable,sb,bb,2,0.03807914,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (<mask>.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
223,PhoneticEngine.java,makeString,String makeString(),144,148,5713,5714,IdentifierMutator-Variable,sb,mb,3,0.026675964,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (<mask>.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
224,PhoneticEngine.java,makeString,String makeString(),144,148,5713,5714,IdentifierMutator-Variable,sb,pb,4,0.01878966,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (<mask>.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
225,PhoneticEngine.java,makeString,String makeString(),144,148,5727,5727,IdentifierMutator-Literal,0,1,1,0.033563666,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() ><mask>) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
226,PhoneticEngine.java,makeString,String makeString(),144,148,5727,5727,IdentifierMutator-Literal,0,2,2,0.00690922,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() ><mask>) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
227,PhoneticEngine.java,makeString,String makeString(),144,148,5727,5727,IdentifierMutator-Literal,0,50,3,0.0033929278,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() ><mask>) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
228,PhoneticEngine.java,makeString,String makeString(),144,148,5727,5727,IdentifierMutator-Literal,0,512,4,0.0032359122,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() ><mask>) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
229,PhoneticEngine.java,makeString,String makeString(),144,149,5755,5760,MethodCallMutator,append,push,1,0.0024726095,"sb.<mask>(""|"")","String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.<mask>(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
230,PhoneticEngine.java,makeString,String makeString(),144,149,5755,5760,MethodCallMutator,append,remove,2,3.0875462E-4,"sb.<mask>(""|"")","String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.<mask>(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
231,PhoneticEngine.java,makeString,String makeString(),144,149,5755,5760,MethodCallMutator,append,write,3,2.7309518E-4,"sb.<mask>(""|"")","String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.<mask>(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
232,PhoneticEngine.java,makeString,String makeString(),144,149,5755,5760,MethodCallMutator,append,end,4,2.5855098E-4,"sb.<mask>(""|"")","String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.<mask>(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
233,PhoneticEngine.java,makeString,String makeString(),144,149,5752,5753,IdentifierMutator-Variable,sb,SB,1,4.555326E-4,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {<mask>.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
234,PhoneticEngine.java,makeString,String makeString(),144,149,5752,5753,IdentifierMutator-Variable,sb,s,2,4.2388288E-4,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {<mask>.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
235,PhoneticEngine.java,makeString,String makeString(),144,149,5752,5753,IdentifierMutator-Variable,sb,b,3,3.8507217E-4,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {<mask>.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
236,PhoneticEngine.java,makeString,String makeString(),144,149,5752,5753,IdentifierMutator-Variable,sb,src,4,3.710963E-4,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {<mask>.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
237,PhoneticEngine.java,makeString,String makeString(),144,149,5762,5764,IdentifierMutator-Literal,"""|""",ph,0,0.8793289,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(<mask>);
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
238,PhoneticEngine.java,makeString,String makeString(),144,149,5762,5764,IdentifierMutator-Literal,"""|""",pp,1,0.019497028,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(<mask>);
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
239,PhoneticEngine.java,makeString,String makeString(),144,149,5762,5764,IdentifierMutator-Literal,"""|""",sb,2,0.014913176,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(<mask>);
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
240,PhoneticEngine.java,makeString,String makeString(),144,149,5762,5764,IdentifierMutator-Literal,"""|""",bb,3,0.004832042,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(<mask>);
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
241,PhoneticEngine.java,makeString,String makeString(),144,149,5762,5764,IdentifierMutator-Literal,"""|""",lp,4,0.003883499,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(<mask>);
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
242,PhoneticEngine.java,makeString,String makeString(),144,151,5805,5810,MethodCallMutator,append,end,2,2.1108371E-4,sb.<mask>(ph.getPhonemeText()),"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.<mask>(ph.getPhonemeText());
            }

            return sb.toString();
        }"
243,PhoneticEngine.java,makeString,String makeString(),144,151,5805,5810,MethodCallMutator,append,replace,3,1.3651587E-4,sb.<mask>(ph.getPhonemeText()),"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.<mask>(ph.getPhonemeText());
            }

            return sb.toString();
        }"
244,PhoneticEngine.java,makeString,String makeString(),144,151,5805,5810,MethodCallMutator,append,insert,4,1.3146545E-4,sb.<mask>(ph.getPhonemeText()),"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.<mask>(ph.getPhonemeText());
            }

            return sb.toString();
        }"
245,PhoneticEngine.java,makeString,String makeString(),144,151,5802,5803,IdentifierMutator-Variable,sb,SB,1,2.354653E-4,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }<mask>.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
246,PhoneticEngine.java,makeString,String makeString(),144,151,5802,5803,IdentifierMutator-Variable,sb,b,2,1.7969719E-4,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }<mask>.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
247,PhoneticEngine.java,makeString,String makeString(),144,151,5802,5803,IdentifierMutator-Variable,sb,SB,3,5.0873525E-5,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }<mask>.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
248,PhoneticEngine.java,makeString,String makeString(),144,151,5802,5803,IdentifierMutator-Variable,sb,bb,4,3.288315E-5,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }<mask>.append(ph.getPhonemeText());
            }

            return sb.toString();
        }"
249,PhoneticEngine.java,makeString,String makeString(),144,151,5815,5828,MethodCallMutator,getPhonemeText,get,0,0.18295519,ph.<mask>(),"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.<mask>());
            }

            return sb.toString();
        }"
250,PhoneticEngine.java,makeString,String makeString(),144,151,5815,5828,MethodCallMutator,getPhonemeText,name,1,0.121644974,ph.<mask>(),"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.<mask>());
            }

            return sb.toString();
        }"
251,PhoneticEngine.java,makeString,String makeString(),144,151,5815,5828,MethodCallMutator,getPhonemeText,string,2,0.047539826,ph.<mask>(),"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.<mask>());
            }

            return sb.toString();
        }"
252,PhoneticEngine.java,makeString,String makeString(),144,151,5815,5828,MethodCallMutator,getPhonemeText,value,3,0.03775933,ph.<mask>(),"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.<mask>());
            }

            return sb.toString();
        }"
253,PhoneticEngine.java,makeString,String makeString(),144,151,5815,5828,MethodCallMutator,getPhonemeText,word,4,0.037518866,ph.<mask>(),"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.<mask>());
            }

            return sb.toString();
        }"
254,PhoneticEngine.java,makeString,String makeString(),144,151,5812,5813,IdentifierMutator-Variable,ph,pp,1,0.0010608406,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(<mask>.getPhonemeText());
            }

            return sb.toString();
        }"
255,PhoneticEngine.java,makeString,String makeString(),144,151,5812,5813,IdentifierMutator-Variable,ph,pl,3,3.9051162E-4,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(<mask>.getPhonemeText());
            }

            return sb.toString();
        }"
256,PhoneticEngine.java,makeString,String makeString(),144,151,5812,5813,IdentifierMutator-Variable,ph,th,4,1.2108981E-4,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(<mask>.getPhonemeText());
            }

            return sb.toString();
        }"
257,PhoneticEngine.java,makeString,String makeString(),144,154,5871,5878,MethodCallMutator,toString,build,0,0.48363855,sb.<mask>(),"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.<mask>();
        }"
258,PhoneticEngine.java,makeString,String makeString(),144,154,5871,5878,MethodCallMutator,toString,join,1,0.108366266,sb.<mask>(),"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.<mask>();
        }"
259,PhoneticEngine.java,makeString,String makeString(),144,154,5871,5878,MethodCallMutator,toString,length,2,0.098761626,sb.<mask>(),"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.<mask>();
        }"
260,PhoneticEngine.java,makeString,String makeString(),144,154,5871,5878,MethodCallMutator,toString,string,3,0.08992073,sb.<mask>(),"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.<mask>();
        }"
261,PhoneticEngine.java,makeString,String makeString(),144,154,5871,5878,MethodCallMutator,toString,to,4,0.047382005,sb.<mask>(),"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return sb.<mask>();
        }"
262,PhoneticEngine.java,makeString,String makeString(),144,154,5868,5869,IdentifierMutator-Variable,sb,s,1,0.009810279,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return<mask>.toString();
        }"
263,PhoneticEngine.java,makeString,String makeString(),144,154,5868,5869,IdentifierMutator-Variable,sb,SB,2,0.0077548726,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return<mask>.toString();
        }"
264,PhoneticEngine.java,makeString,String makeString(),144,154,5868,5869,IdentifierMutator-Variable,sb,b,3,0.0076384093,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return<mask>.toString();
        }"
265,PhoneticEngine.java,makeString,String makeString(),144,154,5868,5869,IdentifierMutator-Variable,sb,ss,4,0.0073008863,<mask>,"String makeString() {
            final StringBuilder sb = new StringBuilder();

            for (final Rule.Phoneme ph : this.phonemes) {
                if (sb.length() > 0) {
                    sb.append(""|"");
                }
                sb.append(ph.getPhonemeText());
            }

            return<mask>.toString();
        }"
266,PhoneticEngine.java,getI,int getI(),191,192,7633,7638,IdentifierMutator-Variable,this.i,i,0,0.8585244,<mask>,"int getI() {
            return<mask>;
        }"
267,PhoneticEngine.java,getI,int getI(),191,192,7633,7638,IdentifierMutator-Variable,this.i,0,1,0.034011073,<mask>,"int getI() {
            return<mask>;
        }"
268,PhoneticEngine.java,getI,int getI(),191,192,7633,7638,IdentifierMutator-Variable,this.i,I,2,0.024765348,<mask>,"int getI() {
            return<mask>;
        }"
269,PhoneticEngine.java,getI,int getI(),191,192,7633,7638,IdentifierMutator-Variable,this.i,1,3,0.023559455,<mask>,"int getI() {
            return<mask>;
        }"
270,PhoneticEngine.java,getI,int getI(),191,192,7633,7638,IdentifierMutator-Variable,this.i,j,4,0.0040553506,<mask>,"int getI() {
            return<mask>;
        }"
271,PhoneticEngine.java,getI,int getI(),191,192,7633,7636,IdentifierMutator-ThisAccess,this,super,1,0.057307974,<mask>,"int getI() {
            return<mask>.i;
        }"
272,PhoneticEngine.java,getI,int getI(),191,192,7633,7636,IdentifierMutator-ThisAccess,this,i,2,0.031189112,<mask>,"int getI() {
            return<mask>.i;
        }"
273,PhoneticEngine.java,getI,int getI(),191,192,7633,7636,IdentifierMutator-ThisAccess,this,b,3,0.016319273,<mask>,"int getI() {
            return<mask>.i;
        }"
274,PhoneticEngine.java,getI,int getI(),191,192,7633,7636,IdentifierMutator-ThisAccess,this,j,4,0.013501879,<mask>,"int getI() {
            return<mask>.i;
        }"
275,PhoneticEngine.java,getI,int getI(),191,192,7638,7638,FieldReferenceMutator,i,I,1,0.30689865,th<mask>s.<mask>,"int getI() {
            return this.<mask>;
        }"
276,PhoneticEngine.java,getI,int getI(),191,192,7638,7638,FieldReferenceMutator,i,j,2,0.008160139,th<mask>s.<mask>,"int getI() {
            return this.<mask>;
        }"
277,PhoneticEngine.java,getI,int getI(),191,192,7638,7638,FieldReferenceMutator,i,SI,3,0.0050260024,th<mask>s.<mask>,"int getI() {
            return this.<mask>;
        }"
278,PhoneticEngine.java,getI,int getI(),191,192,7638,7638,FieldReferenceMutator,i,II,4,0.0046233665,th<mask>s.<mask>,"int getI() {
            return this.<mask>;
        }"
279,PhoneticEngine.java,getPhonemeBuilder,PhonemeBuilder getPhonemeBuilder(),195,196,7723,7741,IdentifierMutator-Variable,this.phonemeBuilder,builder,0,0.59331626,<mask>,"PhonemeBuilder getPhonemeBuilder() {
            return<mask>;
        }"
280,PhoneticEngine.java,getPhonemeBuilder,PhonemeBuilder getPhonemeBuilder(),195,196,7723,7741,IdentifierMutator-Variable,this.phonemeBuilder,this,1,0.08992461,<mask>,"PhonemeBuilder getPhonemeBuilder() {
            return<mask>;
        }"
281,PhoneticEngine.java,getPhonemeBuilder,PhonemeBuilder getPhonemeBuilder(),195,196,7723,7741,IdentifierMutator-Variable,this.phonemeBuilder,null,2,0.057378624,<mask>,"PhonemeBuilder getPhonemeBuilder() {
            return<mask>;
        }"
282,PhoneticEngine.java,getPhonemeBuilder,PhonemeBuilder getPhonemeBuilder(),195,196,7723,7741,IdentifierMutator-Variable,this.phonemeBuilder,bc,3,0.039720796,<mask>,"PhonemeBuilder getPhonemeBuilder() {
            return<mask>;
        }"
283,PhoneticEngine.java,getPhonemeBuilder,PhonemeBuilder getPhonemeBuilder(),195,196,7723,7741,IdentifierMutator-Variable,this.phonemeBuilder,b,4,0.028198006,<mask>,"PhonemeBuilder getPhonemeBuilder() {
            return<mask>;
        }"
284,PhoneticEngine.java,getPhonemeBuilder,PhonemeBuilder getPhonemeBuilder(),195,196,7723,7726,IdentifierMutator-ThisAccess,this,super,1,0.03148277,<mask>,"PhonemeBuilder getPhonemeBuilder() {
            return<mask>.phonemeBuilder;
        }"
285,PhoneticEngine.java,getPhonemeBuilder,PhonemeBuilder getPhonemeBuilder(),195,196,7723,7726,IdentifierMutator-ThisAccess,this,builder,2,0.021493312,<mask>,"PhonemeBuilder getPhonemeBuilder() {
            return<mask>.phonemeBuilder;
        }"
286,PhoneticEngine.java,getPhonemeBuilder,PhonemeBuilder getPhonemeBuilder(),195,196,7723,7726,IdentifierMutator-ThisAccess,this,me,3,0.014895523,<mask>,"PhonemeBuilder getPhonemeBuilder() {
            return<mask>.phonemeBuilder;
        }"
287,PhoneticEngine.java,getPhonemeBuilder,PhonemeBuilder getPhonemeBuilder(),195,196,7723,7726,IdentifierMutator-ThisAccess,this,parent,4,0.009244697,<mask>,"PhonemeBuilder getPhonemeBuilder() {
            return<mask>.phonemeBuilder;
        }"
288,PhoneticEngine.java,getPhonemeBuilder,PhonemeBuilder getPhonemeBuilder(),195,196,7728,7741,FieldReferenceMutator,phonemeBuilder,builder,0,0.79342854,this.<mask>,"PhonemeBuilder getPhonemeBuilder() {
            return this.<mask>;
        }"
289,PhoneticEngine.java,getPhonemeBuilder,PhonemeBuilder getPhonemeBuilder(),195,196,7728,7741,FieldReferenceMutator,phonemeBuilder,b,1,0.02786066,this.<mask>,"PhonemeBuilder getPhonemeBuilder() {
            return this.<mask>;
        }"
290,PhoneticEngine.java,getPhonemeBuilder,PhonemeBuilder getPhonemeBuilder(),195,196,7728,7741,FieldReferenceMutator,phonemeBuilder,parser,2,0.012161118,this.<mask>,"PhonemeBuilder getPhonemeBuilder() {
            return this.<mask>;
        }"
291,PhoneticEngine.java,getPhonemeBuilder,PhonemeBuilder getPhonemeBuilder(),195,196,7728,7741,FieldReferenceMutator,phonemeBuilder,pb,3,0.010454595,this.<mask>,"PhonemeBuilder getPhonemeBuilder() {
            return this.<mask>;
        }"
292,PhoneticEngine.java,getPhonemeBuilder,PhonemeBuilder getPhonemeBuilder(),195,196,7728,7741,FieldReferenceMutator,phonemeBuilder,parent,4,0.00860225,this.<mask>,"PhonemeBuilder getPhonemeBuilder() {
            return this.<mask>;
        }"
293,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8233,8233,AssignmentMutator,this.found=false,!,0,0.4016056,this.found <mask>= false,"RulesApplication invoke() {
            this.found<mask>= false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
294,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8233,8233,AssignmentMutator,this.found=false,|,1,0.22433357,this.found <mask>= false,"RulesApplication invoke() {
            this.found<mask>= false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
295,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8233,8233,AssignmentMutator,this.found=false,&,2,0.11520841,this.found <mask>= false,"RulesApplication invoke() {
            this.found<mask>= false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
296,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8233,8233,AssignmentMutator,this.found=false,||,3,0.056127694,this.found <mask>= false,"RulesApplication invoke() {
            this.found<mask>= false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
297,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8233,8233,AssignmentMutator,this.found=false,!,4,0.047729816,this.found <mask>= false,"RulesApplication invoke() {
            this.found<mask>= false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
298,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8223,8232,IdentifierMutator-Variable,this.found,found,0,0.60544616,<mask>,"RulesApplication invoke() {<mask> = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
299,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8223,8232,IdentifierMutator-Variable,this.found,found,1,0.17033087,<mask>,"RulesApplication invoke() {<mask> = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
300,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8223,8232,IdentifierMutator-Variable,this.found,done,2,0.01841764,<mask>,"RulesApplication invoke() {<mask> = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
301,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8223,8232,IdentifierMutator-Variable,this.found,first,3,0.013764635,<mask>,"RulesApplication invoke() {<mask> = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
302,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8223,8232,IdentifierMutator-Variable,this.found,result,4,0.012133458,<mask>,"RulesApplication invoke() {<mask> = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
303,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8223,8226,IdentifierMutator-ThisAccess,this,super,2,0.0011351651,<mask>,"RulesApplication invoke() {<mask>.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
304,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8223,8226,IdentifierMutator-ThisAccess,this,self,3,3.518711E-4,<mask>,"RulesApplication invoke() {<mask>.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
305,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8223,8226,IdentifierMutator-ThisAccess,this,This,4,3.4963962E-4,<mask>,"RulesApplication invoke() {<mask>.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
306,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8228,8232,FieldReferenceMutator,found,Found,1,5.4910546E-4,this.<mask>,"RulesApplication invoke() {
            this.<mask> = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
307,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8228,8232,FieldReferenceMutator,found,result,2,4.8362726E-4,this.<mask>,"RulesApplication invoke() {
            this.<mask> = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
308,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8228,8232,FieldReferenceMutator,found,valid,3,3.84895E-4,this.<mask>,"RulesApplication invoke() {
            this.<mask> = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
309,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8228,8232,FieldReferenceMutator,found,matched,4,2.505902E-4,this.<mask>,"RulesApplication invoke() {
            this.<mask> = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
310,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8236,8240,IdentifierMutator-Literal,false,true,0,0.6015929,<mask>,"RulesApplication invoke() {
            this.found =<mask>;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
311,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8236,8240,IdentifierMutator-Literal,false,true,2,5.268197E-4,<mask>,"RulesApplication invoke() {
            this.found =<mask>;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
312,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8236,8240,IdentifierMutator-Literal,false,True,3,2.4094323E-4,<mask>,"RulesApplication invoke() {
            this.found =<mask>;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
313,PhoneticEngine.java,invoke,RulesApplication invoke(),206,207,8236,8240,IdentifierMutator-Literal,false,0,4,2.2098704E-4,<mask>,"RulesApplication invoke() {
            this.found =<mask>;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
314,PhoneticEngine.java,invoke,RulesApplication invoke(),206,208,8275,8275,IdentifierMutator-Literal,1,0,0,0.5710084,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength =<mask>;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
315,PhoneticEngine.java,invoke,RulesApplication invoke(),206,208,8275,8275,IdentifierMutator-Literal,1,2,2,0.009587492,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength =<mask>;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
316,PhoneticEngine.java,invoke,RulesApplication invoke(),206,208,8275,8275,IdentifierMutator-Literal,1,i,3,0.005136358,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength =<mask>;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
317,PhoneticEngine.java,invoke,RulesApplication invoke(),206,208,8275,8275,IdentifierMutator-Literal,1,3,4,0.0024185278,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength =<mask>;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
318,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8331,8333,MethodCallMutator,get,parse,1,0.027719583,"this.finalRules.<mask>(input.subSequence(i, i + patternLength))","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.<mask>(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
319,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8331,8333,MethodCallMutator,get,find,2,0.008853106,"this.finalRules.<mask>(input.subSequence(i, i + patternLength))","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.<mask>(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
320,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8331,8333,MethodCallMutator,get,filter,3,0.0065469863,"this.finalRules.<mask>(input.subSequence(i, i + patternLength))","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.<mask>(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
321,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8331,8333,MethodCallMutator,get,list,4,0.004965399,"this.finalRules.<mask>(input.subSequence(i, i + patternLength))","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.<mask>(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
322,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8315,8329,IdentifierMutator-Variable,this.finalRules,rules,0,0.71352935,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules =<mask>.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
323,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8315,8329,IdentifierMutator-Variable,this.finalRules,patterns,1,0.026057936,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules =<mask>.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
324,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8315,8329,IdentifierMutator-Variable,this.finalRules,cache,2,0.018977413,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules =<mask>.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
325,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8315,8329,IdentifierMutator-Variable,this.finalRules,grammar,3,0.009915192,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules =<mask>.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
326,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8315,8329,IdentifierMutator-Variable,this.finalRules,map,4,0.008320098,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules =<mask>.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
327,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8315,8318,IdentifierMutator-ThisAccess,this,super,1,0.005069287,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules =<mask>.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
328,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8315,8318,IdentifierMutator-ThisAccess,this,context,2,0.0025999316,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules =<mask>.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
329,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8315,8318,IdentifierMutator-ThisAccess,this,rule,3,0.0024727983,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules =<mask>.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
330,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8315,8318,IdentifierMutator-ThisAccess,this,app,4,0.0021745749,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules =<mask>.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
331,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8320,8329,FieldReferenceMutator,finalRules,rules,0,0.8959249,this.<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.<mask>.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
332,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8320,8329,FieldReferenceMutator,finalRules,Rules,1,0.010284434,this.<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.<mask>.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
333,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8320,8329,FieldReferenceMutator,finalRules,cache,2,0.008404837,this.<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.<mask>.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
334,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8320,8329,FieldReferenceMutator,finalRules,data,3,0.004996103,this.<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.<mask>.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
335,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8320,8329,FieldReferenceMutator,finalRules,groups,4,0.0044843066,this.<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.<mask>.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
336,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8341,8351,MethodCallMutator,subSequence,slice,0,0.6280495,"input.<mask>(i, i + patternLength)","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.<mask>(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
337,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8341,8351,MethodCallMutator,subSequence,get,1,0.16569504,"input.<mask>(i, i + patternLength)","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.<mask>(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
338,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8341,8351,MethodCallMutator,subSequence,replace,2,0.043444984,"input.<mask>(i, i + patternLength)","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.<mask>(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
339,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8341,8351,MethodCallMutator,subSequence,remove,3,0.017699473,"input.<mask>(i, i + patternLength)","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.<mask>(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
340,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8341,8351,MethodCallMutator,subSequence,offset,4,0.014958019,"input.<mask>(i, i + patternLength)","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.<mask>(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
341,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8335,8339,IdentifierMutator-Variable,input,pattern,1,0.17027374,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(<mask>.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
342,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8335,8339,IdentifierMutator-Variable,input,url,2,0.017418725,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(<mask>.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
343,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8335,8339,IdentifierMutator-Variable,input,path,3,0.013466953,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(<mask>.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
344,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8335,8339,FieldReferenceMutator,input,pattern,1,0.17027374,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(<mask>.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
345,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8335,8339,FieldReferenceMutator,input,url,2,0.017418725,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(<mask>.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
346,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8335,8339,FieldReferenceMutator,input,path,3,0.013466953,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(<mask>.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
347,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8353,8353,IdentifierMutator-Variable,i,0,1,2.200006E-4,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(<mask>, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
348,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8353,8353,IdentifierMutator-Variable,i,1,3,3.797905E-5,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(<mask>, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
349,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8353,8353,IdentifierMutator-Variable,i,I,4,3.4731358E-5,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(<mask>, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
350,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8353,8353,FieldReferenceMutator,i,0,1,2.200006E-4,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(<mask>, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
351,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8353,8353,FieldReferenceMutator,i,1,3,3.797905E-5,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(<mask>, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
352,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8353,8353,FieldReferenceMutator,i,I,4,3.4731358E-5,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(<mask>, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
353,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8357,8357,BinaryOperatorMutator,+,-,1,0.011622303,i <mask> patternLength,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i<mask>patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
354,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8357,8357,BinaryOperatorMutator,+,.,3,0.006919322,i <mask> patternLength,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i<mask>patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
355,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8357,8357,BinaryOperatorMutator,+,)+,4,0.0024988006,i <mask> patternLength,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i<mask>patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
356,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8356,8356,IdentifierMutator-Variable,i,I,2,2.9175484E-4,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i,<mask>+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
357,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8356,8356,IdentifierMutator-Variable,i,1,3,6.820664E-5,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i,<mask>+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
358,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8356,8356,IdentifierMutator-Variable,i,j,4,5.0018727E-5,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i,<mask>+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
359,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8356,8356,FieldReferenceMutator,i,I,2,2.9175484E-4,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i,<mask>+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
360,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8356,8356,FieldReferenceMutator,i,1,3,6.820664E-5,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i,<mask>+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
361,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8356,8356,FieldReferenceMutator,i,j,4,5.0018727E-5,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i,<mask>+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
362,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8358,8370,IdentifierMutator-Variable,patternLength,1,0,0.7182871,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+<mask>));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
363,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8358,8370,IdentifierMutator-Variable,patternLength,2,1,0.06860284,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+<mask>));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
364,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8358,8370,IdentifierMutator-Variable,patternLength,1,2,0.03421182,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+<mask>));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
365,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8358,8370,IdentifierMutator-Variable,patternLength,length,3,0.01172902,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+<mask>));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
366,PhoneticEngine.java,invoke,RulesApplication invoke(),206,209,8358,8370,IdentifierMutator-Variable,patternLength,3,4,0.010614876,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+<mask>));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
367,PhoneticEngine.java,invoke,RulesApplication invoke(),206,210,8396,8399,BinaryOperatorMutator,!=,==,0,0.5269037,rules <mask> null,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules<mask>null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
368,PhoneticEngine.java,invoke,RulesApplication invoke(),206,210,8396,8399,BinaryOperatorMutator,!=,=,2,0.21215788,rules <mask> null,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules<mask>null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
369,PhoneticEngine.java,invoke,RulesApplication invoke(),206,210,8396,8399,BinaryOperatorMutator,!=,==,3,0.015994119,rules <mask> null,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules<mask>null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
370,PhoneticEngine.java,invoke,RulesApplication invoke(),206,210,8396,8399,BinaryOperatorMutator,!=,.,4,0.003799371,rules <mask> null,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules<mask>null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
371,PhoneticEngine.java,invoke,RulesApplication invoke(),206,210,8391,8395,IdentifierMutator-Variable,rules,Rules,1,1.6237625E-4,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (<mask> != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
372,PhoneticEngine.java,invoke,RulesApplication invoke(),206,210,8391,8395,IdentifierMutator-Variable,rules,plugins,3,5.9405356E-6,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (<mask> != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
373,PhoneticEngine.java,invoke,RulesApplication invoke(),206,210,8391,8395,IdentifierMutator-Variable,rules,rule,4,4.051495E-6,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (<mask> != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
374,PhoneticEngine.java,invoke,RulesApplication invoke(),206,210,8400,8403,IdentifierMutator-Literal,null,NULL,2,2.1446083E-5,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules !=<mask>) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
375,PhoneticEngine.java,invoke,RulesApplication invoke(),206,210,8400,8403,IdentifierMutator-Literal,null,nil,3,1.483522E-5,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules !=<mask>) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
376,PhoneticEngine.java,invoke,RulesApplication invoke(),206,210,8400,8403,IdentifierMutator-Literal,null,undefined,4,4.7440685E-6,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules !=<mask>) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
377,PhoneticEngine.java,invoke,RulesApplication invoke(),206,211,8447,8451,IdentifierMutator-Variable,rules,Rules,2,2.7440915E-6,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule :<mask>) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
378,PhoneticEngine.java,invoke,RulesApplication invoke(),206,211,8447,8451,IdentifierMutator-Variable,rules,Rules,3,7.453649E-7,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule :<mask>) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
379,PhoneticEngine.java,invoke,RulesApplication invoke(),206,211,8447,8451,IdentifierMutator-Variable,rules,this,4,6.8296976E-7,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule :<mask>) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
380,PhoneticEngine.java,invoke,RulesApplication invoke(),206,212,8504,8513,MethodCallMutator,getPattern,pattern,0,0.9460985,rule.<mask>(),"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.<mask>();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
381,PhoneticEngine.java,invoke,RulesApplication invoke(),206,212,8504,8513,MethodCallMutator,getPattern,rule,1,0.009844709,rule.<mask>(),"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.<mask>();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
382,PhoneticEngine.java,invoke,RulesApplication invoke(),206,212,8504,8513,MethodCallMutator,getPattern,name,2,0.0052550603,rule.<mask>(),"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.<mask>();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
383,PhoneticEngine.java,invoke,RulesApplication invoke(),206,212,8504,8513,MethodCallMutator,getPattern,match,3,0.003585465,rule.<mask>(),"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.<mask>();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
384,PhoneticEngine.java,invoke,RulesApplication invoke(),206,212,8504,8513,MethodCallMutator,getPattern,get,4,0.0022651253,rule.<mask>(),"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.<mask>();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
385,PhoneticEngine.java,invoke,RulesApplication invoke(),206,212,8499,8502,IdentifierMutator-Variable,rule,this,1,3.4669333E-4,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern =<mask>.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
386,PhoneticEngine.java,invoke,RulesApplication invoke(),206,212,8499,8502,IdentifierMutator-Variable,rule,rules,3,5.0281888E-5,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern =<mask>.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
387,PhoneticEngine.java,invoke,RulesApplication invoke(),206,212,8499,8502,IdentifierMutator-Variable,rule,block,4,1.9333791E-5,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern =<mask>.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
388,PhoneticEngine.java,invoke,RulesApplication invoke(),206,213,8551,8551,AssignmentMutator,patternLength=pattern.length(),*,0,0.87122875,patternLength <mask>= pattern.length(),"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength<mask>= pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
389,PhoneticEngine.java,invoke,RulesApplication invoke(),206,213,8551,8551,AssignmentMutator,patternLength=pattern.length(),/,1,0.07501538,patternLength <mask>= pattern.length(),"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength<mask>= pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
390,PhoneticEngine.java,invoke,RulesApplication invoke(),206,213,8551,8551,AssignmentMutator,patternLength=pattern.length(),*,2,0.014374932,patternLength <mask>= pattern.length(),"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength<mask>= pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
391,PhoneticEngine.java,invoke,RulesApplication invoke(),206,213,8551,8551,AssignmentMutator,patternLength=pattern.length(),|,3,0.008792484,patternLength <mask>= pattern.length(),"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength<mask>= pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
392,PhoneticEngine.java,invoke,RulesApplication invoke(),206,213,8551,8551,AssignmentMutator,patternLength=pattern.length(),//,4,0.0034014592,patternLength <mask>= pattern.length(),"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength<mask>= pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
393,PhoneticEngine.java,invoke,RulesApplication invoke(),206,213,8538,8550,IdentifierMutator-Variable,patternLength,i,0,0.86927354,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();<mask> = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
394,PhoneticEngine.java,invoke,RulesApplication invoke(),206,213,8538,8550,IdentifierMutator-Variable,patternLength,i,1,0.050239667,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();<mask> = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
395,PhoneticEngine.java,invoke,RulesApplication invoke(),206,213,8538,8550,IdentifierMutator-Variable,patternLength,length,2,0.03403577,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();<mask> = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
396,PhoneticEngine.java,invoke,RulesApplication invoke(),206,213,8538,8550,IdentifierMutator-Variable,patternLength,len,3,0.0074592885,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();<mask> = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
397,PhoneticEngine.java,invoke,RulesApplication invoke(),206,213,8538,8550,IdentifierMutator-Variable,patternLength,length,4,0.0068603074,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();<mask> = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
398,PhoneticEngine.java,invoke,RulesApplication invoke(),206,213,8562,8567,MethodCallMutator,length,width,2,2.5992143E-5,pattern.<mask>(),"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.<mask>();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
399,PhoneticEngine.java,invoke,RulesApplication invoke(),206,213,8562,8567,MethodCallMutator,length,len,3,1.7576198E-5,pattern.<mask>(),"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.<mask>();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
400,PhoneticEngine.java,invoke,RulesApplication invoke(),206,213,8562,8567,MethodCallMutator,length,size,4,1.2402635E-5,pattern.<mask>(),"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.<mask>();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
401,PhoneticEngine.java,invoke,RulesApplication invoke(),206,213,8554,8560,IdentifierMutator-Variable,pattern,rule,1,3.8480572E-4,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength =<mask>.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
402,PhoneticEngine.java,invoke,RulesApplication invoke(),206,213,8554,8560,IdentifierMutator-Variable,pattern,regex,3,1.4582196E-4,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength =<mask>.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
403,PhoneticEngine.java,invoke,RulesApplication invoke(),206,213,8554,8560,IdentifierMutator-Variable,pattern,string,4,7.493997E-5,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength =<mask>.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
404,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8601,8624,MethodCallMutator,patternAndContextMatches,apply,0,0.18666014,"rule.<mask>(this.input, this.i)","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.<mask>(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
405,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8601,8624,MethodCallMutator,patternAndContextMatches,match,1,0.1584025,"rule.<mask>(this.input, this.i)","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.<mask>(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
406,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8601,8624,MethodCallMutator,patternAndContextMatches,process,2,0.085759036,"rule.<mask>(this.input, this.i)","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.<mask>(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
407,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8601,8624,MethodCallMutator,patternAndContextMatches,evaluate,3,0.08319664,"rule.<mask>(this.input, this.i)","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.<mask>(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
408,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8601,8624,MethodCallMutator,patternAndContextMatches,accept,4,0.04579485,"rule.<mask>(this.input, this.i)","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.<mask>(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
409,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8596,8599,IdentifierMutator-Variable,rule,pattern,1,0.004608762,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (<mask>.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
410,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8596,8599,IdentifierMutator-Variable,rule,this,2,0.004102833,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (<mask>.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
411,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8596,8599,IdentifierMutator-Variable,rule,Rule,4,0.0024026746,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (<mask>.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
412,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8626,8635,IdentifierMutator-Variable,this.input,pattern,0,0.8736102,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(<mask>, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
413,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8626,8635,IdentifierMutator-Variable,this.input,input,1,0.10921882,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(<mask>, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
414,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8626,8635,IdentifierMutator-Variable,this.input,this,2,0.0036998636,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(<mask>, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
415,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8626,8635,IdentifierMutator-Variable,this.input,context,3,0.0017756236,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(<mask>, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
416,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8626,8635,IdentifierMutator-Variable,this.input,pattern,4,5.088028E-4,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(<mask>, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
417,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8626,8629,IdentifierMutator-ThisAccess,this,rule,1,0.002426428,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(<mask>.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
418,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8626,8629,IdentifierMutator-ThisAccess,this,pattern,2,4.454361E-4,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(<mask>.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
419,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8626,8629,IdentifierMutator-ThisAccess,this,rules,4,1.8049101E-4,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(<mask>.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
420,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8631,8635,FieldReferenceMutator,input,pattern,0,0.9047283,this.<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.<mask>, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
421,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8631,8635,FieldReferenceMutator,input,p,2,0.0076567205,this.<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.<mask>, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
422,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8631,8635,FieldReferenceMutator,input,context,3,0.0038908648,this.<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.<mask>, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
423,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8631,8635,FieldReferenceMutator,input,text,4,0.0019253887,this.<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.<mask>, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
424,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8638,8643,IdentifierMutator-Variable,this.i,pattern,0,0.6070439,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input,<mask>)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
425,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8638,8643,IdentifierMutator-Variable,this.i,context,1,0.35011658,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input,<mask>)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
426,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8638,8643,IdentifierMutator-Variable,this.i,this,2,0.012885505,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input,<mask>)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
427,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8638,8643,IdentifierMutator-Variable,this.i,input,3,0.0031228636,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input,<mask>)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
428,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8638,8643,IdentifierMutator-Variable,this.i,rule,4,0.0023537502,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input,<mask>)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
429,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8638,8641,IdentifierMutator-ThisAccess,this,rule,2,0.005661637,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input,<mask>.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
430,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8638,8641,IdentifierMutator-ThisAccess,this,pattern,3,5.465232E-4,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input,<mask>.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
431,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8638,8641,IdentifierMutator-ThisAccess,this,rules,4,2.1598936E-4,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input,<mask>.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
432,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8643,8643,FieldReferenceMutator,i,context,0,0.75853586,th<mask>s.<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.<mask>)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
433,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8643,8643,FieldReferenceMutator,i,ctx,2,0.033412393,th<mask>s.<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.<mask>)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
434,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8643,8643,FieldReferenceMutator,i,c,3,0.007290143,th<mask>s.<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.<mask>)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
435,PhoneticEngine.java,invoke,RulesApplication invoke(),206,214,8643,8643,FieldReferenceMutator,i,pattern,4,0.0051256865,th<mask>s.<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.<mask>)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
436,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8693,8697,MethodCallMutator,apply,build,0,0.36219102,"this.phonemeBuilder.<mask>(rule.getPhoneme(), maxPhonemes)","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.<mask>(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
437,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8693,8697,MethodCallMutator,apply,add,1,0.19654761,"this.phonemeBuilder.<mask>(rule.getPhoneme(), maxPhonemes)","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.<mask>(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
438,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8693,8697,MethodCallMutator,apply,append,2,0.049539525,"this.phonemeBuilder.<mask>(rule.getPhoneme(), maxPhonemes)","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.<mask>(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
439,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8693,8697,MethodCallMutator,apply,replace,3,0.0385659,"this.phonemeBuilder.<mask>(rule.getPhoneme(), maxPhonemes)","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.<mask>(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
440,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8693,8697,MethodCallMutator,apply,create,4,0.033321556,"this.phonemeBuilder.<mask>(rule.getPhoneme(), maxPhonemes)","RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.<mask>(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
441,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8673,8691,IdentifierMutator-Variable,this.phonemeBuilder,rule,0,0.17493463,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {<mask>.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
442,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8673,8691,IdentifierMutator-Variable,this.phonemeBuilder,pattern,1,0.16657282,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {<mask>.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
443,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8673,8691,IdentifierMutator-Variable,this.phonemeBuilder,context,2,0.08445784,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {<mask>.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
444,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8673,8691,IdentifierMutator-Variable,this.phonemeBuilder,callback,3,0.059904996,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {<mask>.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
445,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8673,8691,IdentifierMutator-Variable,this.phonemeBuilder,handler,4,0.030911738,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {<mask>.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
446,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8673,8676,IdentifierMutator-ThisAccess,this,rule,1,0.022549817,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {<mask>.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
447,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8673,8676,IdentifierMutator-ThisAccess,this,rule,3,8.076347E-4,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {<mask>.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
448,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8673,8676,IdentifierMutator-ThisAccess,this,builder,4,4.0809705E-4,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {<mask>.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
449,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8678,8691,FieldReferenceMutator,phonemeBuilder,context,0,0.13533844,this.<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.<mask>.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
450,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8678,8691,FieldReferenceMutator,phonemeBuilder,apply,1,0.10944614,this.<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.<mask>.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
451,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8678,8691,FieldReferenceMutator,phonemeBuilder,rule,2,0.07056589,this.<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.<mask>.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
452,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8678,8691,FieldReferenceMutator,phonemeBuilder,pattern,3,0.06730112,this.<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.<mask>.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
453,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8678,8691,FieldReferenceMutator,phonemeBuilder,filter,4,0.046734083,this.<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.<mask>.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
454,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8704,8713,MethodCallMutator,getPhoneme,context,0,0.2755112,rule.<mask>(),"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.<mask>(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
455,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8704,8713,MethodCallMutator,getPhoneme,pattern,1,0.21753822,rule.<mask>(),"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.<mask>(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
456,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8704,8713,MethodCallMutator,getPhoneme,rules,2,0.07151381,rule.<mask>(),"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.<mask>(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
457,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8704,8713,MethodCallMutator,getPhoneme,expression,3,0.035233393,rule.<mask>(),"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.<mask>(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
458,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8704,8713,MethodCallMutator,getPhoneme,build,4,0.026074443,rule.<mask>(),"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.<mask>(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
459,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8699,8702,IdentifierMutator-Variable,rule,this,1,0.003279768,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(<mask>.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
460,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8699,8702,IdentifierMutator-Variable,rule,rules,2,9.986276E-4,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(<mask>.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
461,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8699,8702,IdentifierMutator-Variable,rule,Rule,4,6.891296E-4,<mask>,"RulesApplication invoke() {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(<mask>.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
462,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8718,8728,IdentifierMutator-Variable,maxPhonemes,pattern,0,0.5395733,<mask>," {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(),<mask>);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
463,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8718,8728,IdentifierMutator-Variable,maxPhonemes,this,1,0.21914399,<mask>," {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(),<mask>);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
464,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8718,8728,IdentifierMutator-Variable,maxPhonemes,context,2,0.08578464,<mask>," {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(),<mask>);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
465,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8718,8728,IdentifierMutator-Variable,maxPhonemes,rule,3,0.045356467,<mask>," {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(),<mask>);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
466,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8718,8728,IdentifierMutator-Variable,maxPhonemes,null,4,0.013704249,<mask>," {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(),<mask>);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
467,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8718,8728,FieldReferenceMutator,maxPhonemes,pattern,0,0.5395733,<mask>," {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(),<mask>);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
468,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8718,8728,FieldReferenceMutator,maxPhonemes,this,1,0.21914399,<mask>," {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(),<mask>);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
469,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8718,8728,FieldReferenceMutator,maxPhonemes,context,2,0.08578464,<mask>," {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(),<mask>);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
470,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8718,8728,FieldReferenceMutator,maxPhonemes,rule,3,0.045356467,<mask>," {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(),<mask>);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
471,PhoneticEngine.java,invoke,RulesApplication invoke(),206,215,8718,8728,FieldReferenceMutator,maxPhonemes,null,4,0.013704249,<mask>," {
            this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(),<mask>);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
472,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8766,8766,AssignmentMutator,this.found=true,|,0,0.90907574,this.found <mask>= true,"Length = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found<mask>= true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
473,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8766,8766,AssignmentMutator,this.found=true,&,1,0.06532642,this.found <mask>= true,"Length = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found<mask>= true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
474,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8766,8766,AssignmentMutator,this.found=true,*,2,0.0077819303,this.found <mask>= true,"Length = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found<mask>= true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
475,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8766,8766,AssignmentMutator,this.found=true,^,3,0.0036361623,this.found <mask>= true,"Length = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found<mask>= true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
476,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8766,8766,AssignmentMutator,this.found=true,|,4,0.0035569202,this.found <mask>= true,"Length = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found<mask>= true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
477,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8756,8765,IdentifierMutator-Variable,this.found,found,0,0.87230223,<mask>,"        this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);<mask> = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
478,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8756,8765,IdentifierMutator-Variable,this.found,found,1,0.10278168,<mask>,"        this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);<mask> = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
479,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8756,8765,IdentifierMutator-Variable,this.found,Found,2,0.0052620173,<mask>,"        this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);<mask> = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
480,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8756,8765,IdentifierMutator-Variable,this.found,matched,3,0.002329179,<mask>,"        this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);<mask> = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
481,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8756,8765,IdentifierMutator-Variable,this.found,result,4,0.0023272608,<mask>,"        this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);<mask> = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
482,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8756,8759,IdentifierMutator-ThisAccess,this,rule,1,0.015668025,<mask>,"        this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);<mask>.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
483,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8756,8759,IdentifierMutator-ThisAccess,this,rule,3,1.0557576E-4,<mask>,"        this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);<mask>.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
484,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8756,8759,IdentifierMutator-ThisAccess,this,rules,4,7.108817E-5,<mask>,"        this.found = false;
            int patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);<mask>.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
485,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8761,8765,FieldReferenceMutator,found,Found,1,3.3117176E-4,this.<mask>," patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.<mask> = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
486,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8761,8765,FieldReferenceMutator,found,matched,3,8.282999E-5,this.<mask>," patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.<mask> = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
487,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8761,8765,FieldReferenceMutator,found,result,4,2.8898803E-5,this.<mask>," patternLength = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.<mask> = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
488,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8769,8772,IdentifierMutator-Literal,true,false,1,0.01607092,<mask>," = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found =<mask>;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
489,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8769,8772,IdentifierMutator-Literal,true,rule,2,0.0013337275,<mask>," = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found =<mask>;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
490,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8769,8772,IdentifierMutator-Literal,true,True,3,0.0010806819,<mask>," = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found =<mask>;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
491,PhoneticEngine.java,invoke,RulesApplication invoke(),206,216,8769,8772,IdentifierMutator-Literal,true,TRUE,4,6.2246475E-4,<mask>," = 1;
            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));
            if (rules != null) {
                for (final Rule rule : rules) {
                    final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found =<mask>;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
492,PhoneticEngine.java,invoke,RulesApplication invoke(),206,222,8877,8877,UnaryOperatorMutator,!,...,2,0.0017907271,<mask>this.found,"              final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (<mask>this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
493,PhoneticEngine.java,invoke,RulesApplication invoke(),206,222,8877,8877,UnaryOperatorMutator,!,!!,3,3.869662E-4,<mask>this.found,"              final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (<mask>this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
494,PhoneticEngine.java,invoke,RulesApplication invoke(),206,222,8877,8877,UnaryOperatorMutator,!,?,4,2.0704237E-4,<mask>this.found,"              final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (<mask>this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
495,PhoneticEngine.java,invoke,RulesApplication invoke(),206,222,8878,8887,IdentifierMutator-Variable,this.found,found,0,0.97755706,<mask>,"              final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!<mask>) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
496,PhoneticEngine.java,invoke,RulesApplication invoke(),206,222,8878,8887,IdentifierMutator-Variable,this.found,matched,1,0.0030368909,<mask>,"              final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!<mask>) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
497,PhoneticEngine.java,invoke,RulesApplication invoke(),206,222,8878,8887,IdentifierMutator-Variable,this.found,find,2,0.0011674464,<mask>,"              final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!<mask>) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
498,PhoneticEngine.java,invoke,RulesApplication invoke(),206,222,8878,8887,IdentifierMutator-Variable,this.found,continue,3,7.9374574E-4,<mask>,"              final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!<mask>) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
499,PhoneticEngine.java,invoke,RulesApplication invoke(),206,222,8878,8887,IdentifierMutator-Variable,this.found,done,4,7.7140605E-4,<mask>,"              final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!<mask>) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
500,PhoneticEngine.java,invoke,RulesApplication invoke(),206,222,8878,8881,IdentifierMutator-ThisAccess,this,rule,2,0.0039034344,<mask>,"              final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!<mask>.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
501,PhoneticEngine.java,invoke,RulesApplication invoke(),206,222,8878,8881,IdentifierMutator-ThisAccess,this,self,3,1.1519349E-4,<mask>,"              final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!<mask>.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
502,PhoneticEngine.java,invoke,RulesApplication invoke(),206,222,8878,8881,IdentifierMutator-ThisAccess,this,rules,4,1.0552689E-4,<mask>,"              final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!<mask>.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
503,PhoneticEngine.java,invoke,RulesApplication invoke(),206,222,8883,8887,FieldReferenceMutator,found,matched,1,0.0013594202,this.<mask>,"            final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.<mask>) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
504,PhoneticEngine.java,invoke,RulesApplication invoke(),206,222,8883,8887,FieldReferenceMutator,found,valid,2,4.0988126E-4,this.<mask>,"            final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.<mask>) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
505,PhoneticEngine.java,invoke,RulesApplication invoke(),206,222,8883,8887,FieldReferenceMutator,found,finished,3,3.9489838E-4,this.<mask>,"            final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.<mask>) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
506,PhoneticEngine.java,invoke,RulesApplication invoke(),206,222,8883,8887,FieldReferenceMutator,found,Found,4,2.679365E-4,this.<mask>,"            final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.<mask>) {
                patternLength = 1;
            }

            this.i += patternLength;
            return this;
        }"
507,PhoneticEngine.java,invoke,RulesApplication invoke(),206,223,8921,8921,AssignmentMutator,patternLength=1,*,0,0.80661106,patternLength <mask>= 1,"                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength<mask>= 1;
            }

            this.i += patternLength;
            return this;
        }"
508,PhoneticEngine.java,invoke,RulesApplication invoke(),206,223,8921,8921,AssignmentMutator,patternLength=1,<<,1,0.12074988,patternLength <mask>= 1,"                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength<mask>= 1;
            }

            this.i += patternLength;
            return this;
        }"
509,PhoneticEngine.java,invoke,RulesApplication invoke(),206,223,8921,8921,AssignmentMutator,patternLength=1,>>,2,0.03143143,patternLength <mask>= 1,"                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength<mask>= 1;
            }

            this.i += patternLength;
            return this;
        }"
510,PhoneticEngine.java,invoke,RulesApplication invoke(),206,223,8921,8921,AssignmentMutator,patternLength=1,/,3,0.017025204,patternLength <mask>= 1,"                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength<mask>= 1;
            }

            this.i += patternLength;
            return this;
        }"
511,PhoneticEngine.java,invoke,RulesApplication invoke(),206,223,8921,8921,AssignmentMutator,patternLength=1,>>>,4,0.0050415522,patternLength <mask>= 1,"                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength<mask>= 1;
            }

            this.i += patternLength;
            return this;
        }"
512,PhoneticEngine.java,invoke,RulesApplication invoke(),206,223,8908,8920,IdentifierMutator-Variable,patternLength,found,0,0.1703855,<mask>,"         final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {<mask> = 1;
            }

            this.i += patternLength;
            return this;
        }"
513,PhoneticEngine.java,invoke,RulesApplication invoke(),206,223,8908,8920,IdentifierMutator-Variable,patternLength,i,1,0.09783594,<mask>,"         final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {<mask> = 1;
            }

            this.i += patternLength;
            return this;
        }"
514,PhoneticEngine.java,invoke,RulesApplication invoke(),206,223,8908,8920,IdentifierMutator-Variable,patternLength,index,2,0.059514664,<mask>,"         final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {<mask> = 1;
            }

            this.i += patternLength;
            return this;
        }"
515,PhoneticEngine.java,invoke,RulesApplication invoke(),206,223,8908,8920,IdentifierMutator-Variable,patternLength,count,3,0.054612264,<mask>,"         final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {<mask> = 1;
            }

            this.i += patternLength;
            return this;
        }"
516,PhoneticEngine.java,invoke,RulesApplication invoke(),206,223,8908,8920,IdentifierMutator-Variable,patternLength,loop,4,0.045570504,<mask>,"         final String pattern = rule.getPattern();
                    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {<mask> = 1;
            }

            this.i += patternLength;
            return this;
        }"
517,PhoneticEngine.java,invoke,RulesApplication invoke(),206,223,8924,8924,IdentifierMutator-Literal,1,0,0,0.9324484,<mask>,"                   patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength =<mask>;
            }

            this.i += patternLength;
            return this;
        }"
518,PhoneticEngine.java,invoke,RulesApplication invoke(),206,223,8924,8924,IdentifierMutator-Literal,1,"''",2,0.009551808,<mask>,"                   patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength =<mask>;
            }

            this.i += patternLength;
            return this;
        }"
519,PhoneticEngine.java,invoke,RulesApplication invoke(),206,223,8924,8924,IdentifierMutator-Literal,1,"""""",3,0.009515758,<mask>,"                   patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength =<mask>;
            }

            this.i += patternLength;
            return this;
        }"
520,PhoneticEngine.java,invoke,RulesApplication invoke(),206,223,8924,8924,IdentifierMutator-Literal,1,null,4,0.006623036,<mask>,"                   patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength =<mask>;
            }

            this.i += patternLength;
            return this;
        }"
521,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8960,8960,AssignmentMutator,this.i+=patternLength,Length,0,0.16673702,this.i <mask>= patternLength,"                if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i<mask>+= patternLength;
            return this;
        }"
522,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8960,8960,AssignmentMutator,this.i+=patternLength,Count,1,0.16179952,this.i <mask>= patternLength,"                if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i<mask>+= patternLength;
            return this;
        }"
523,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8960,8960,AssignmentMutator,this.i+=patternLength,Index,2,0.07550117,this.i <mask>= patternLength,"                if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i<mask>+= patternLength;
            return this;
        }"
524,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8960,8960,AssignmentMutator,this.i+=patternLength,Pattern,3,0.065224946,this.i <mask>= patternLength,"                if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i<mask>+= patternLength;
            return this;
        }"
525,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8960,8960,AssignmentMutator,this.i+=patternLength,Pos,4,0.04101918,this.i <mask>= patternLength,"                if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i<mask>+= patternLength;
            return this;
        }"
526,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8954,8959,IdentifierMutator-Variable,this.i,i,0,0.5134288,<mask>,"    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }<mask> += patternLength;
            return this;
        }"
527,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8954,8959,IdentifierMutator-Variable,this.i,index,1,0.09426336,<mask>,"    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }<mask> += patternLength;
            return this;
        }"
528,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8954,8959,IdentifierMutator-Variable,this.i,pos,2,0.074587375,<mask>,"    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }<mask> += patternLength;
            return this;
        }"
529,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8954,8959,IdentifierMutator-Variable,this.i,offset,3,0.07295113,<mask>,"    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }<mask> += patternLength;
            return this;
        }"
530,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8954,8959,IdentifierMutator-Variable,this.i,position,4,0.029999446,<mask>,"    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }<mask> += patternLength;
            return this;
        }"
531,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8954,8957,IdentifierMutator-ThisAccess,this,rule,2,0.0012048808,<mask>,"    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }<mask>.i += patternLength;
            return this;
        }"
532,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8954,8957,IdentifierMutator-ThisAccess,this,pattern,3,3.7366708E-4,<mask>,"    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }<mask>.i += patternLength;
            return this;
        }"
533,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8954,8957,IdentifierMutator-ThisAccess,this,self,4,1.0902618E-4,<mask>,"    patternLength = pattern.length();
                    if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }<mask>.i += patternLength;
            return this;
        }"
534,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8959,8959,FieldReferenceMutator,i,length,1,0.034385365,th<mask>s.<mask>,"                 if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.<mask> += patternLength;
            return this;
        }"
535,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8959,8959,FieldReferenceMutator,i,count,2,0.02459554,th<mask>s.<mask>,"                 if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.<mask> += patternLength;
            return this;
        }"
536,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8959,8959,FieldReferenceMutator,i,offset,3,0.014182123,th<mask>s.<mask>,"                 if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.<mask> += patternLength;
            return this;
        }"
537,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8959,8959,FieldReferenceMutator,i,total,4,0.013542424,th<mask>s.<mask>,"                 if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.<mask> += patternLength;
            return this;
        }"
538,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8964,8976,IdentifierMutator-Variable,patternLength,1,0,0.83951426,<mask>,"               if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i +=<mask>;
            return this;
        }"
539,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8964,8976,IdentifierMutator-Variable,patternLength,i,1,0.0375563,<mask>,"               if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i +=<mask>;
            return this;
        }"
540,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8964,8976,IdentifierMutator-Variable,patternLength,2,2,0.02645376,<mask>,"               if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i +=<mask>;
            return this;
        }"
541,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8964,8976,IdentifierMutator-Variable,patternLength,offset,3,0.013876565,<mask>,"               if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i +=<mask>;
            return this;
        }"
542,PhoneticEngine.java,invoke,RulesApplication invoke(),206,226,8964,8976,IdentifierMutator-Variable,patternLength,length,4,0.007517624,<mask>,"               if (rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i +=<mask>;
            return this;
        }"
543,PhoneticEngine.java,invoke,RulesApplication invoke(),206,227,8998,9001,IdentifierMutator-ThisAccess,this,true,1,0.27311614,<mask>,"rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return<mask>;
        }"
544,PhoneticEngine.java,invoke,RulesApplication invoke(),206,227,8998,9001,IdentifierMutator-ThisAccess,this,false,2,0.09424646,<mask>,"rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return<mask>;
        }"
545,PhoneticEngine.java,invoke,RulesApplication invoke(),206,227,8998,9001,IdentifierMutator-ThisAccess,this,rule,3,0.07332953,<mask>,"rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return<mask>;
        }"
546,PhoneticEngine.java,invoke,RulesApplication invoke(),206,227,8998,9001,IdentifierMutator-ThisAccess,this,null,4,0.012491695,<mask>,"rule.patternAndContextMatches(this.input, this.i)) {
                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);
                        this.found = true;
                        break;
                    }
                }
            }

            if (!this.found) {
                patternLength = 1;
            }

            this.i += patternLength;
            return<mask>;
        }"
547,PhoneticEngine.java,isFound,boolean isFound(),230,231,9069,9078,IdentifierMutator-Variable,this.found,true,0,0.62645584,<mask>,"boolean isFound() {
            return<mask>;
        }"
548,PhoneticEngine.java,isFound,boolean isFound(),230,231,9069,9078,IdentifierMutator-Variable,this.found,false,1,0.29321772,<mask>,"boolean isFound() {
            return<mask>;
        }"
549,PhoneticEngine.java,isFound,boolean isFound(),230,231,9069,9078,IdentifierMutator-Variable,this.found,found,2,0.045088,<mask>,"boolean isFound() {
            return<mask>;
        }"
550,PhoneticEngine.java,isFound,boolean isFound(),230,231,9069,9078,IdentifierMutator-Variable,this.found,result,3,0.0037608377,<mask>,"boolean isFound() {
            return<mask>;
        }"
551,PhoneticEngine.java,isFound,boolean isFound(),230,231,9069,9078,IdentifierMutator-Variable,this.found,null,4,0.0027656122,<mask>,"boolean isFound() {
            return<mask>;
        }"
552,PhoneticEngine.java,isFound,boolean isFound(),230,231,9069,9072,IdentifierMutator-ThisAccess,this,result,1,0.06934997,<mask>,"boolean isFound() {
            return<mask>.found;
        }"
553,PhoneticEngine.java,isFound,boolean isFound(),230,231,9069,9072,IdentifierMutator-ThisAccess,this,options,2,0.03286553,<mask>,"boolean isFound() {
            return<mask>.found;
        }"
554,PhoneticEngine.java,isFound,boolean isFound(),230,231,9069,9072,IdentifierMutator-ThisAccess,this,Boolean,3,0.022600472,<mask>,"boolean isFound() {
            return<mask>.found;
        }"
555,PhoneticEngine.java,isFound,boolean isFound(),230,231,9069,9072,IdentifierMutator-ThisAccess,this,m,4,0.021373937,<mask>,"boolean isFound() {
            return<mask>.found;
        }"
556,PhoneticEngine.java,isFound,boolean isFound(),230,231,9074,9078,FieldReferenceMutator,found,result,1,0.054489113,this.<mask>,"boolean isFound() {
            return this.<mask>;
        }"
557,PhoneticEngine.java,isFound,boolean isFound(),230,231,9074,9078,FieldReferenceMutator,found,next,2,0.02777151,this.<mask>,"boolean isFound() {
            return this.<mask>;
        }"
558,PhoneticEngine.java,isFound,boolean isFound(),230,231,9074,9078,FieldReferenceMutator,found,success,3,0.012654638,this.<mask>,"boolean isFound() {
            return this.<mask>;
        }"
559,PhoneticEngine.java,isFound,boolean isFound(),230,231,9074,9078,FieldReferenceMutator,found,ok,4,0.009737186,this.<mask>,"boolean isFound() {
            return this.<mask>;
        }"
560,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,259,10518,10525,MethodCallMutator,iterator,iter,1,0.0077898004,strings.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.<mask>();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
561,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,259,10518,10525,MethodCallMutator,iterator,Iterator,2,0.0011804777,strings.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.<mask>();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
562,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,259,10518,10525,MethodCallMutator,iterator,next,4,1.908382E-4,strings.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.<mask>();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
563,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,259,10510,10516,IdentifierMutator-Variable,strings,string,2,1.849871E-4,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si =<mask>.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
564,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,259,10510,10516,IdentifierMutator-Variable,strings,protocols,3,7.8531615E-5,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si =<mask>.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
565,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,259,10510,10516,IdentifierMutator-Variable,strings,patterns,4,3.3104046E-5,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si =<mask>.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
566,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,260,10545,10551,MethodCallMutator,hasNext,next,0,0.98743767,si.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.<mask>()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
567,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,260,10545,10551,MethodCallMutator,hasNext,Next,1,0.004208256,si.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.<mask>()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
568,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,260,10545,10551,MethodCallMutator,hasNext,more,2,0.0030301798,si.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.<mask>()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
569,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,260,10545,10551,MethodCallMutator,hasNext,has,3,0.0015301998,si.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.<mask>()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
570,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,260,10545,10551,MethodCallMutator,hasNext,valid,4,0.0011079451,si.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.<mask>()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
571,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,260,10542,10543,IdentifierMutator-Variable,si,i,1,3.8770324E-4,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (<mask>.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
572,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,260,10542,10543,IdentifierMutator-Variable,si,sa,2,1.4197502E-4,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (<mask>.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
573,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,260,10542,10543,IdentifierMutator-Variable,si,ski,3,7.11515E-5,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (<mask>.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
574,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,260,10542,10543,IdentifierMutator-Variable,si,ci,4,6.37961E-5,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (<mask>.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
575,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,261,10573,10578,MethodCallMutator,append,end,2,1.4869148E-4,sb.<mask>(si.next()),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.<mask>(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
576,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,261,10573,10578,MethodCallMutator,append,push,3,1.1471987E-4,sb.<mask>(si.next()),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.<mask>(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
577,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,261,10573,10578,MethodCallMutator,append,write,4,1.0322214E-4,sb.<mask>(si.next()),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.<mask>(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
578,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,261,10570,10571,IdentifierMutator-Variable,sb,s,1,0.04935494,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {<mask>.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
579,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,261,10570,10571,IdentifierMutator-Variable,sb,b,2,0.01749028,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {<mask>.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
580,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,261,10570,10571,IdentifierMutator-Variable,sb,b,3,0.011389046,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {<mask>.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
581,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,261,10570,10571,IdentifierMutator-Variable,sb,sep,4,0.008430712,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {<mask>.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
582,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,261,10583,10586,MethodCallMutator,next,current,2,1.0813114E-4,si.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.<mask>());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
583,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,261,10583,10586,MethodCallMutator,next,Next,3,6.548661E-5,si.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.<mask>());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
584,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,261,10583,10586,MethodCallMutator,next,prev,4,1.5001951E-5,si.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.<mask>());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
585,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,261,10580,10581,IdentifierMutator-Variable,si,i,1,1.6485872E-4,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(<mask>.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
586,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,261,10580,10581,IdentifierMutator-Variable,si,sa,2,9.810574E-5,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(<mask>.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
587,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,261,10580,10581,IdentifierMutator-Variable,si,ci,3,7.6328935E-5,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(<mask>.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
588,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,261,10580,10581,IdentifierMutator-Variable,si,sie,4,4.0996834E-5,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(<mask>.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
589,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,263,10620,10626,MethodCallMutator,hasNext,next,0,0.9905117,si.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.<mask>()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
590,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,263,10620,10626,MethodCallMutator,hasNext,more,1,0.0053113764,si.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.<mask>()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
591,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,263,10620,10626,MethodCallMutator,hasNext,has,2,0.0023421564,si.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.<mask>()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
592,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,263,10620,10626,MethodCallMutator,hasNext,valid,3,5.167596E-4,si.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.<mask>()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
593,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,263,10620,10626,MethodCallMutator,hasNext,Next,4,3.1862757E-4,si.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.<mask>()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
594,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,263,10617,10618,IdentifierMutator-Variable,si,i,1,3.699711E-4,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (<mask>.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
595,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,263,10617,10618,IdentifierMutator-Variable,si,sa,2,1.4668654E-4,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (<mask>.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
596,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,263,10617,10618,IdentifierMutator-Variable,si,isi,3,6.271118E-5,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (<mask>.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
597,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,263,10617,10618,IdentifierMutator-Variable,si,ini,4,5.9435275E-5,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (<mask>.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.toString();
    }"
598,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10660,10665,MethodCallMutator,append,join,1,0.2365587,sb.<mask>(sep).<mask>(si.next()),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).<mask>(si.next());
        }

        return sb.toString();
    }"
599,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10660,10665,MethodCallMutator,append,replace,2,0.0015914047,sb.<mask>(sep).<mask>(si.next()),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).<mask>(si.next());
        }

        return sb.toString();
    }"
600,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10660,10665,MethodCallMutator,append,add,4,5.483596E-4,sb.<mask>(sep).<mask>(si.next()),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).<mask>(si.next());
        }

        return sb.toString();
    }"
601,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10648,10653,MethodCallMutator,append,replace,2,1.7634053E-4,sb.<mask>(sep),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.<mask>(sep).append(si.next());
        }

        return sb.toString();
    }"
602,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10648,10653,MethodCallMutator,append,join,3,5.7067213E-5,sb.<mask>(sep),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.<mask>(sep).append(si.next());
        }

        return sb.toString();
    }"
603,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10648,10653,MethodCallMutator,append,insert,4,4.0050305E-5,sb.<mask>(sep),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.<mask>(sep).append(si.next());
        }

        return sb.toString();
    }"
604,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10645,10646,IdentifierMutator-Variable,sb,b,1,0.040731557,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {<mask>.append(sep).append(si.next());
        }

        return sb.toString();
    }"
605,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10645,10646,IdentifierMutator-Variable,sb,s,2,0.0048719007,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {<mask>.append(sep).append(si.next());
        }

        return sb.toString();
    }"
606,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10645,10646,IdentifierMutator-Variable,sb,b,3,0.003709579,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {<mask>.append(sep).append(si.next());
        }

        return sb.toString();
    }"
607,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10645,10646,IdentifierMutator-Variable,sb,bb,4,0.0022073998,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {<mask>.append(sep).append(si.next());
        }

        return sb.toString();
    }"
608,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10655,10657,IdentifierMutator-Variable,sep,Sep,0,0.23238738,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(<mask>).append(si.next());
        }

        return sb.toString();
    }"
609,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10655,10657,IdentifierMutator-Variable,sep,p,2,0.064821914,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(<mask>).append(si.next());
        }

        return sb.toString();
    }"
610,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10655,10657,IdentifierMutator-Variable,sep,prefix,3,0.06275342,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(<mask>).append(si.next());
        }

        return sb.toString();
    }"
611,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10655,10657,IdentifierMutator-Variable,sep,join,4,0.05232425,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(<mask>).append(si.next());
        }

        return sb.toString();
    }"
612,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10670,10673,MethodCallMutator,next,current,1,1.3161793E-4,si.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.<mask>());
        }

        return sb.toString();
    }"
613,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10670,10673,MethodCallMutator,next,get,3,2.6248328E-5,si.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.<mask>());
        }

        return sb.toString();
    }"
614,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10670,10673,MethodCallMutator,next,value,4,2.0826807E-5,si.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.<mask>());
        }

        return sb.toString();
    }"
615,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10667,10668,IdentifierMutator-Variable,si,sa,1,1.2486965E-4,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(<mask>.next());
        }

        return sb.toString();
    }"
616,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10667,10668,IdentifierMutator-Variable,si,i,2,8.7809196E-5,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(<mask>.next());
        }

        return sb.toString();
    }"
617,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10667,10668,IdentifierMutator-Variable,si,ini,3,2.3121043E-5,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(<mask>.next());
        }

        return sb.toString();
    }"
618,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,264,10667,10668,IdentifierMutator-Variable,si,isi,4,2.1829937E-5,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(<mask>.next());
        }

        return sb.toString();
    }"
619,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,267,10708,10715,MethodCallMutator,toString,build,0,0.44744894,sb.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.<mask>();
    }"
620,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,267,10708,10715,MethodCallMutator,toString,join,1,0.3233321,sb.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.<mask>();
    }"
621,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,267,10708,10715,MethodCallMutator,toString,string,2,0.12965003,sb.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.<mask>();
    }"
622,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,267,10708,10715,MethodCallMutator,toString,to,3,0.016349139,sb.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.<mask>();
    }"
623,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,267,10708,10715,MethodCallMutator,toString,String,4,0.011368564,sb.<mask>(),"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return sb.<mask>();
    }"
624,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,267,10705,10706,IdentifierMutator-Variable,sb,s,1,0.077911966,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return<mask>.toString();
    }"
625,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,267,10705,10706,IdentifierMutator-Variable,sb,b,2,0.06665988,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return<mask>.toString();
    }"
626,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,267,10705,10706,IdentifierMutator-Variable,sb,b,3,0.050422907,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return<mask>.toString();
    }"
627,PhoneticEngine.java,join,"String join(final Iterable<String> strings, final String sep)",257,267,10705,10706,IdentifierMutator-Variable,sb,buf,4,0.020758688,<mask>,"String join(final Iterable<String> strings, final String sep) {
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> si = strings.iterator();
        if (si.hasNext()) {
            sb.append(si.next());
        }
        while (si.hasNext()) {
            sb.append(sep).append(si.next());
        }

        return<mask>.toString();
    }"
628,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,331,12829,12832,BinaryOperatorMutator,==,=,2,0.04364614,finalRules <mask> null,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules<mask>null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
        "
629,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,331,12829,12832,BinaryOperatorMutator,==,!=,3,0.023521088,finalRules <mask> null,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules<mask>null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
        "
630,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,331,12829,12832,BinaryOperatorMutator,==,.,4,0.0026683898,finalRules <mask> null,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules<mask>null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
        "
631,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,331,12819,12828,IdentifierMutator-Variable,finalRules,rules,0,0.9226385,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (<mask> == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
         "
632,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,331,12819,12828,IdentifierMutator-Variable,finalRules,Rules,1,0.021436097,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (<mask> == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
         "
633,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,331,12819,12828,IdentifierMutator-Variable,finalRules,rule,2,0.018680606,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (<mask> == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
         "
634,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,331,12819,12828,IdentifierMutator-Variable,finalRules,null,3,0.0041713594,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (<mask> == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
         "
635,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,331,12819,12828,IdentifierMutator-Variable,finalRules,result,4,0.0028354845,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (<mask> == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
         "
636,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,331,12833,12836,IdentifierMutator-Literal,null,NULL,2,1.10260306E-4,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules ==<mask>) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
        "
637,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,331,12833,12836,IdentifierMutator-Literal,null,nil,3,1.7095317E-5,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules ==<mask>) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
        "
638,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,331,12833,12836,IdentifierMutator-Literal,null,this,4,8.105725E-6,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules ==<mask>) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
        "
639,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,332,12884,12911,IdentifierMutator-Literal,"""finalRulescannotbenull""",null,0,0.774358,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(<mask>);
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
             "
640,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,332,12884,12911,IdentifierMutator-Literal,"""finalRulescannotbenull""",this,1,0.1217952,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(<mask>);
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
             "
641,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,332,12884,12911,IdentifierMutator-Literal,"""finalRulescannotbenull""",rules,2,0.015701242,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(<mask>);
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
             "
642,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,332,12884,12911,IdentifierMutator-Literal,"""finalRulescannotbenull""",rule,3,0.005441647,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(<mask>);
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
             "
643,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,332,12884,12911,IdentifierMutator-Literal,"""finalRulescannotbenull""",properties,4,0.0050561097,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(<mask>);
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
             "
644,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,334,12948,12954,MethodCallMutator,isEmpty,empty,0,0.9091228,finalRules.<mask>(),"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.<mask>()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
         "
645,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,334,12948,12954,MethodCallMutator,isEmpty,Empty,1,0.03662064,finalRules.<mask>(),"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.<mask>()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
         "
646,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,334,12948,12954,MethodCallMutator,isEmpty,size,2,0.02189364,finalRules.<mask>(),"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.<mask>()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
         "
647,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,334,12948,12954,MethodCallMutator,isEmpty,clear,3,0.012534557,finalRules.<mask>(),"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.<mask>()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
         "
648,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,334,12948,12954,MethodCallMutator,isEmpty,build,4,0.0026304193,finalRules.<mask>(),"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.<mask>()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
         "
649,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,334,12937,12946,IdentifierMutator-Variable,finalRules,rules,0,0.89224887,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (<mask>.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
         "
650,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,334,12937,12946,IdentifierMutator-Variable,finalRules,Rules,1,0.090556666,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (<mask>.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
         "
651,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,334,12937,12946,IdentifierMutator-Variable,finalRules,rule,2,0.002662215,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (<mask>.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
         "
652,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,334,12937,12946,IdentifierMutator-Variable,finalRules,Rule,3,0.0011803812,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (<mask>.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
         "
653,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,334,12937,12946,IdentifierMutator-Variable,finalRules,rules,4,0.0011783183,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (<mask>.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
         "
654,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,335,12980,12993,IdentifierMutator-Variable,phonemeBuilder,this,0,0.58547544,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return<mask>;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
          "
655,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,335,12980,12993,IdentifierMutator-Variable,phonemeBuilder,null,1,0.3413459,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return<mask>;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
          "
656,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,335,12980,12993,IdentifierMutator-Variable,phonemeBuilder,builder,2,0.02468098,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return<mask>;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
          "
657,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,335,12980,12993,IdentifierMutator-Variable,phonemeBuilder,true,3,0.010981204,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return<mask>;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
          "
658,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,335,12980,12993,IdentifierMutator-Variable,phonemeBuilder,false,4,0.007714557,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return<mask>;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
          "
659,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,339,13116,13138,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.Rule.Phoneme.COMPARATOR,map,0,0.11137829,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(<mask>);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                "
660,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,339,13116,13138,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.Rule.Phoneme.COMPARATOR,1,1,0.08735015,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(<mask>);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                "
661,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,339,13116,13138,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.Rule.Phoneme.COMPARATOR,0,2,0.078091584,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(<mask>);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                "
662,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,339,13116,13138,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.Rule.Phoneme.COMPARATOR,this,3,0.07368475,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(<mask>);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                "
663,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,339,13116,13138,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.Rule.Phoneme.COMPARATOR,rules,4,0.044474244,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(<mask>);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                "
664,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,339,13129,13138,FieldReferenceMutator,COMPARATOR,class,0,0.6158846,org.apache.commons.codec.language.bm.Rule.Phoneme.<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.<mask>);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
          "
665,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,339,13129,13138,FieldReferenceMutator,COMPARATOR,SIZE,1,0.06736689,org.apache.commons.codec.language.bm.Rule.Phoneme.<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.<mask>);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
          "
666,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,339,13129,13138,FieldReferenceMutator,COMPARATOR,VALUE,2,0.03961164,org.apache.commons.codec.language.bm.Rule.Phoneme.<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.<mask>);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
          "
667,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,339,13129,13138,FieldReferenceMutator,COMPARATOR,CLASS,3,0.026769549,org.apache.commons.codec.language.bm.Rule.Phoneme.<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.<mask>);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
          "
668,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,339,13129,13138,FieldReferenceMutator,COMPARATOR,length,4,0.025908945,org.apache.commons.codec.language.bm.Rule.Phoneme.<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.<mask>);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
          "
669,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,341,13200,13210,MethodCallMutator,getPhonemes,values,0,0.49337927,phonemeBuilder.<mask>(),"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.<mask>()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
            "
670,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,341,13200,13210,MethodCallMutator,getPhonemes,rules,1,0.14672627,phonemeBuilder.<mask>(),"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.<mask>()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
            "
671,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,341,13200,13210,MethodCallMutator,getPhonemes,children,2,0.055251505,phonemeBuilder.<mask>(),"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.<mask>()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
            "
672,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,341,13200,13210,MethodCallMutator,getPhonemes,keys,3,0.040945802,phonemeBuilder.<mask>(),"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.<mask>()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
            "
673,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,341,13200,13210,MethodCallMutator,getPhonemes,iterator,4,0.038177475,phonemeBuilder.<mask>(),"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.<mask>()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
            "
674,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,341,13185,13198,IdentifierMutator-Variable,phonemeBuilder,rule,0,0.6860031,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme :<mask>.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
          "
675,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,341,13185,13198,IdentifierMutator-Variable,phonemeBuilder,rules,1,0.11961145,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme :<mask>.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
          "
676,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,341,13185,13198,IdentifierMutator-Variable,phonemeBuilder,grammar,2,0.07961225,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme :<mask>.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
          "
677,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,341,13185,13198,IdentifierMutator-Variable,phonemeBuilder,this,3,0.01880205,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme :<mask>.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
          "
678,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,341,13185,13198,IdentifierMutator-Variable,phonemeBuilder,Rule,4,0.007492453,<mask>,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme :<mask>.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
          "
679,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,342,13272,13276,MethodCallMutator,empty,create,0,0.5889498,PhonemeBuilder.<mask>(phoneme.getLanguages()),"                              final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.<mask>(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
          "
680,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,342,13272,13276,MethodCallMutator,empty,builder,1,0.10673859,PhonemeBuilder.<mask>(phoneme.getLanguages()),"                              final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.<mask>(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
          "
681,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,342,13272,13276,MethodCallMutator,empty,of,2,0.046540357,PhonemeBuilder.<mask>(phoneme.getLanguages()),"                              final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.<mask>(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
          "
682,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,342,13272,13276,MethodCallMutator,empty,build,3,0.026488679,PhonemeBuilder.<mask>(phoneme.getLanguages()),"                              final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.<mask>(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
          "
683,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,342,13272,13276,MethodCallMutator,empty,for,4,0.025983775,PhonemeBuilder.<mask>(phoneme.getLanguages()),"                              final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.<mask>(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
          "
684,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,342,13286,13297,MethodCallMutator,getLanguages,length,0,0.19955927,phoneme.<mask>(),"                        final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.<mask>());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                  "
685,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,342,13286,13297,MethodCallMutator,getLanguages,type,1,0.07662034,phoneme.<mask>(),"                        final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.<mask>());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                  "
686,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,342,13286,13297,MethodCallMutator,getLanguages,name,2,0.05229141,phoneme.<mask>(),"                        final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.<mask>());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                  "
687,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,342,13286,13297,MethodCallMutator,getLanguages,format,3,0.04681823,phoneme.<mask>(),"                        final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.<mask>());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                  "
688,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,342,13286,13297,MethodCallMutator,getLanguages,position,4,0.042578712,phoneme.<mask>(),"                        final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.<mask>());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                  "
689,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,342,13278,13284,IdentifierMutator-Variable,phoneme,rule,0,0.5982284,<mask>,"                            final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(<mask>.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
              "
690,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,342,13278,13284,IdentifierMutator-Variable,phoneme,this,1,0.072104566,<mask>,"                            final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(<mask>.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
              "
691,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,342,13278,13284,IdentifierMutator-Variable,phoneme,Rule,2,0.05416806,<mask>,"                            final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(<mask>.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
              "
692,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,342,13278,13284,IdentifierMutator-Variable,phoneme,parser,3,0.026062544,<mask>,"                            final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(<mask>.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
              "
693,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,342,13278,13284,IdentifierMutator-Variable,phoneme,rules,4,0.022002,<mask>,"                            final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(<mask>.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
              "
694,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,343,13367,13374,MethodCallMutator,toString,text,0,0.41121063,phoneme.getPhonemeText().<mask>(),">> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().<mask>();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
        "
695,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,343,13367,13374,MethodCallMutator,toString,get,1,0.15539208,phoneme.getPhonemeText().<mask>(),">> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().<mask>();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
        "
696,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,343,13367,13374,MethodCallMutator,toString,string,2,0.08910899,phoneme.getPhonemeText().<mask>(),">> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().<mask>();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
        "
697,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,343,13367,13374,MethodCallMutator,toString,value,3,0.05301996,phoneme.getPhonemeText().<mask>(),">> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().<mask>();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
        "
698,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,343,13367,13374,MethodCallMutator,toString,build,4,0.03377393,phoneme.getPhonemeText().<mask>(),">> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().<mask>();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
        "
699,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,343,13350,13363,MethodCallMutator,getPhonemeText,text,0,0.54889387,phoneme.<mask>(),"<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.<mask>().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
     "
700,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,343,13350,13363,MethodCallMutator,getPhonemeText,get,1,0.18380347,phoneme.<mask>(),"<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.<mask>().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
     "
701,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,343,13350,13363,MethodCallMutator,getPhonemeText,value,2,0.03240675,phoneme.<mask>(),"<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.<mask>().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
     "
702,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,343,13350,13363,MethodCallMutator,getPhonemeText,translation,3,0.013217629,phoneme.<mask>(),"<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.<mask>().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
     "
703,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,343,13350,13363,MethodCallMutator,getPhonemeText,split,4,0.009177736,phoneme.<mask>(),"<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.<mask>().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
     "
704,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,343,13342,13348,IdentifierMutator-Variable,phoneme,rule,0,0.6365473,<mask>,"  final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText =<mask>.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));"
705,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,343,13342,13348,IdentifierMutator-Variable,phoneme,rules,1,0.09079778,<mask>,"  final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText =<mask>.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));"
706,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,343,13342,13348,IdentifierMutator-Variable,phoneme,grammar,2,0.06369204,<mask>,"  final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText =<mask>.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));"
707,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,343,13342,13348,IdentifierMutator-Variable,phoneme,this,3,0.043185387,<mask>,"  final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText =<mask>.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));"
708,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,343,13342,13348,IdentifierMutator-Variable,phoneme,parser,4,0.0063657155,<mask>,"  final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText =<mask>.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));"
709,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,345,13405,13405,IdentifierMutator-Literal,0,1,1,0.017416121,<mask>," {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i =<mask>; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

          "
710,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,345,13405,13405,IdentifierMutator-Literal,0,2,3,5.2744476E-4,<mask>," {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i =<mask>; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

          "
711,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,345,13405,13405,IdentifierMutator-Literal,0,i,4,3.851328E-4,<mask>," {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i =<mask>; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

          "
712,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,345,13409,13411,BinaryOperatorMutator,<,<=,2,0.0025672496,i <mask> phonemeText.length(),"           throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i<mask>phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

            "
713,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,345,13409,13411,BinaryOperatorMutator,<,++,3,7.917808E-4,i <mask> phonemeText.length(),"           throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i<mask>phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

            "
714,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,345,13409,13411,BinaryOperatorMutator,<,+=,4,4.4705803E-4,i <mask> phonemeText.length(),"           throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i<mask>phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

            "
715,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,345,13408,13408,IdentifierMutator-Variable,i,index,2,1.67774E-4,<mask>,"            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0;<mask> < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

            "
716,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,345,13408,13408,IdentifierMutator-Variable,i,I,3,1.4750939E-4,<mask>,"            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0;<mask> < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

            "
717,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,345,13408,13408,IdentifierMutator-Variable,i,0,4,5.128347E-5,<mask>,"            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0;<mask> < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

            "
718,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,345,13424,13429,MethodCallMutator,length,size,1,2.2194622E-4,phonemeText.<mask>(),"      throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.<mask>();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rules"
719,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,345,13424,13429,MethodCallMutator,length,width,3,2.4355235E-5,phonemeText.<mask>(),"      throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.<mask>();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rules"
720,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,345,13424,13429,MethodCallMutator,length,len,4,1.8612254E-5,phonemeText.<mask>(),"      throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.<mask>();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rules"
721,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,345,13412,13422,IdentifierMutator-Variable,phonemeText,text,0,0.84321475,<mask>,"          throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i <<mask>.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i"
722,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,345,13412,13422,IdentifierMutator-Variable,phonemeText,Text,1,0.08345112,<mask>,"          throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i <<mask>.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i"
723,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,345,13412,13422,IdentifierMutator-Variable,phonemeText,Text,2,0.022589108,<mask>,"          throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i <<mask>.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i"
724,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,345,13412,13422,IdentifierMutator-Variable,phonemeText,texts,3,0.005956039,<mask>,"          throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i <<mask>.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i"
725,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,345,13412,13422,IdentifierMutator-Variable,phonemeText,rules,4,0.005412237,<mask>,"          throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
            return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i <<mask>.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i"
726,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13593,13598,MethodCallMutator,invoke,build,0,0.5996831,"new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).<mask>()","        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).<mask>();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes,"
727,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13593,13598,MethodCallMutator,invoke,create,1,0.14787868,"new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).<mask>()","        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).<mask>();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes,"
728,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13593,13598,MethodCallMutator,invoke,apply,2,0.031752046,"new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).<mask>()","        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).<mask>();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes,"
729,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13593,13598,MethodCallMutator,invoke,parse,3,0.020550855,"new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).<mask>()","        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).<mask>();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes,"
730,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13593,13598,MethodCallMutator,invoke,init,4,0.020232666,"new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).<mask>()","        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).<mask>();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes,"
731,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13540,13549,IdentifierMutator-Variable,finalRules,this,0,0.21420975,<mask>,"    return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(<mask>, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
  "
732,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13540,13549,IdentifierMutator-Variable,finalRules,rules,1,0.11338976,<mask>,"    return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(<mask>, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
  "
733,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13540,13549,IdentifierMutator-Variable,finalRules,language,2,0.09890389,<mask>,"    return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(<mask>, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
  "
734,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13540,13549,IdentifierMutator-Variable,finalRules,rule,3,0.060540263,<mask>,"    return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(<mask>, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
  "
735,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13540,13549,IdentifierMutator-Variable,finalRules,context,4,0.041013233,<mask>,"    return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(<mask>, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
  "
736,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13552,13562,IdentifierMutator-Variable,phonemeText,rules,0,0.25684312,<mask>," return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules,<mask>, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
      "
737,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13552,13562,IdentifierMutator-Variable,phonemeText,rule,1,0.16924985,<mask>," return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules,<mask>, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
      "
738,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13552,13562,IdentifierMutator-Variable,phonemeText,grammar,2,0.04932131,<mask>," return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules,<mask>, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
      "
739,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13552,13562,IdentifierMutator-Variable,phonemeText,this,3,0.040852282,<mask>," return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules,<mask>, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
      "
740,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13552,13562,IdentifierMutator-Variable,phonemeText,language,4,0.03296423,<mask>," return phonemeBuilder;
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules,<mask>, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
      "
741,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13565,13574,IdentifierMutator-Variable,subBuilder,rule,0,0.2243261,<mask>,";
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText,<mask>, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
         "
742,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13565,13574,IdentifierMutator-Variable,subBuilder,rules,1,0.15236531,<mask>,";
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText,<mask>, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
         "
743,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13565,13574,IdentifierMutator-Variable,subBuilder,language,2,0.05415155,<mask>,";
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText,<mask>, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
         "
744,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13565,13574,IdentifierMutator-Variable,subBuilder,i,3,0.051220346,<mask>,";
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText,<mask>, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
         "
745,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13565,13574,IdentifierMutator-Variable,subBuilder,0,4,0.030307023,<mask>,";
        }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText,<mask>, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
         "
746,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13577,13577,IdentifierMutator-Variable,i,rules,1,0.118594095,<mask>,"       }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder,<mask>, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
           "
747,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13577,13577,IdentifierMutator-Variable,i,rule,2,0.08670094,<mask>,"       }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder,<mask>, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
           "
748,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13577,13577,IdentifierMutator-Variable,i,language,3,0.046464533,<mask>,"       }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder,<mask>, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
           "
749,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13577,13577,IdentifierMutator-Variable,i,0,4,0.02271504,<mask>,"       }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder,<mask>, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
           "
750,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13580,13590,IdentifierMutator-Variable,maxPhonemes,rule,0,0.17496769,<mask>,"     }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i,<mask>).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonem"
751,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13580,13590,IdentifierMutator-Variable,maxPhonemes,rules,1,0.13824712,<mask>,"     }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i,<mask>).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonem"
752,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13580,13590,IdentifierMutator-Variable,maxPhonemes,false,2,0.07294531,<mask>,"     }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i,<mask>).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonem"
753,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13580,13590,IdentifierMutator-Variable,maxPhonemes,true,3,0.07139968,<mask>,"     }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i,<mask>).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonem"
754,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13580,13590,IdentifierMutator-Variable,maxPhonemes,i,4,0.05564788,<mask>,"     }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i,<mask>).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonem"
755,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13580,13590,FieldReferenceMutator,maxPhonemes,rule,0,0.17496769,<mask>,"     }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i,<mask>).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonem"
756,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13580,13590,FieldReferenceMutator,maxPhonemes,rules,1,0.13824712,<mask>,"     }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i,<mask>).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonem"
757,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13580,13590,FieldReferenceMutator,maxPhonemes,false,2,0.07294531,<mask>,"     }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i,<mask>).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonem"
758,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13580,13590,FieldReferenceMutator,maxPhonemes,true,3,0.07139968,<mask>,"     }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i,<mask>).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonem"
759,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,347,13580,13590,FieldReferenceMutator,maxPhonemes,i,4,0.05564788,<mask>,"     }

        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i,<mask>).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonem"
760,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,348,13658,13664,MethodCallMutator,isFound,found,0,0.31756064,rulesApplication.<mask>()," =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.<mask>();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            //"
761,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,348,13658,13664,MethodCallMutator,isFound,find,1,0.2351248,rulesApplication.<mask>()," =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.<mask>();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            //"
762,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,348,13658,13664,MethodCallMutator,isFound,get,2,0.08353608,rulesApplication.<mask>()," =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.<mask>();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            //"
763,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,348,13658,13664,MethodCallMutator,isFound,next,3,0.041968863,rulesApplication.<mask>()," =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.<mask>();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            //"
764,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,348,13658,13664,MethodCallMutator,isFound,search,4,0.029847356,rulesApplication.<mask>()," =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.<mask>();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            //"
765,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,348,13641,13656,IdentifierMutator-Variable,rulesApplication,rule,0,0.1529334,<mask>," phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found =<mask>.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
         "
766,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,348,13641,13656,IdentifierMutator-Variable,rulesApplication,application,1,0.13723367,<mask>," phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found =<mask>.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
         "
767,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,348,13641,13656,IdentifierMutator-Variable,rulesApplication,result,2,0.12712912,<mask>," phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found =<mask>.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
         "
768,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,348,13641,13656,IdentifierMutator-Variable,rulesApplication,app,3,0.075257614,<mask>," phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found =<mask>.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
         "
769,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,348,13641,13656,IdentifierMutator-Variable,rulesApplication,rules,4,0.07129401,<mask>," phonemes =
            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found =<mask>.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
         "
770,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13695,13695,AssignmentMutator,subBuilder=rulesApplication.getPhonemeBuilder(),*,0,0.13477513,subBuilder <mask>= rulesApplication.getPhonemeBuilder(),"eme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder<mask>= rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
     "
771,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13695,13695,AssignmentMutator,subBuilder=rulesApplication.getPhonemeBuilder(),|,1,0.11544717,subBuilder <mask>= rulesApplication.getPhonemeBuilder(),"eme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder<mask>= rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
     "
772,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13695,13695,AssignmentMutator,subBuilder=rulesApplication.getPhonemeBuilder(),&,2,0.091646165,subBuilder <mask>= rulesApplication.getPhonemeBuilder(),"eme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder<mask>= rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
     "
773,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13695,13695,AssignmentMutator,subBuilder=rulesApplication.getPhonemeBuilder(),.,3,0.070746705,subBuilder <mask>= rulesApplication.getPhonemeBuilder(),"eme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder<mask>= rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
     "
774,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13695,13695,AssignmentMutator,subBuilder=rulesApplication.getPhonemeBuilder(),||,4,0.06963195,subBuilder <mask>= rulesApplication.getPhonemeBuilder(),"eme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder<mask>= rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
     "
775,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13685,13694,IdentifierMutator-Variable,subBuilder,builder,0,0.9194454,<mask>,"           new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();<mask> = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
     "
776,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13685,13694,IdentifierMutator-Variable,subBuilder,Builder,1,0.037040506,<mask>,"           new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();<mask> = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
     "
777,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13685,13694,IdentifierMutator-Variable,subBuilder,builder,2,0.019727467,<mask>,"           new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();<mask> = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
     "
778,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13685,13694,IdentifierMutator-Variable,subBuilder,b,3,0.0039047292,<mask>,"           new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();<mask> = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
     "
779,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13685,13694,IdentifierMutator-Variable,subBuilder,builders,4,0.0012629136,<mask>,"           new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();<mask> = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
     "
780,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13715,13731,MethodCallMutator,getPhonemeBuilder,build,0,0.6962797,rulesApplication.<mask>(),"Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.<mask>();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final"
781,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13715,13731,MethodCallMutator,getPhonemeBuilder,builder,1,0.068437934,rulesApplication.<mask>(),"Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.<mask>();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final"
782,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13715,13731,MethodCallMutator,getPhonemeBuilder,get,2,0.059641413,rulesApplication.<mask>(),"Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.<mask>();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final"
783,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13715,13731,MethodCallMutator,getPhonemeBuilder,create,3,0.025044907,rulesApplication.<mask>(),"Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.<mask>();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final"
784,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13715,13731,MethodCallMutator,getPhonemeBuilder,clone,4,0.013097994,rulesApplication.<mask>(),"Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.<mask>();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final"
785,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13698,13713,IdentifierMutator-Variable,rulesApplication,rule,0,0.225622,<mask>,", Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder =<mask>.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
        "
786,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13698,13713,IdentifierMutator-Variable,rulesApplication,builder,1,0.12909032,<mask>,", Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder =<mask>.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
        "
787,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13698,13713,IdentifierMutator-Variable,rulesApplication,grammar,2,0.097795516,<mask>,", Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder =<mask>.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
        "
788,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13698,13713,IdentifierMutator-Variable,rulesApplication,this,3,0.08762932,<mask>,", Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder =<mask>.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
        "
789,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,349,13698,13713,IdentifierMutator-Variable,rulesApplication,rules,4,0.06591906,<mask>,", Rule.Phoneme>(Rule.Phoneme.COMPARATOR);

        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder =<mask>.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
        "
790,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,351,13757,13757,UnaryOperatorMutator,!,un,2,0.006255886,<mask>found,"final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (<mask>found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes())"
791,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,351,13757,13757,UnaryOperatorMutator,!,...,3,0.0023519024,<mask>found,"final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (<mask>found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes())"
792,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,351,13757,13757,UnaryOperatorMutator,!,?,4,9.4420026E-4,<mask>found,"final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (<mask>found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes())"
793,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,351,13758,13762,IdentifierMutator-Variable,found,Found,2,4.4222747E-4,<mask>,"final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!<mask>) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {"
794,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,351,13758,13762,IdentifierMutator-Variable,found,find,3,1.738064E-5,<mask>,"final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!<mask>) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {"
795,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,351,13758,13762,IdentifierMutator-Variable,found,all,4,5.1317825E-6,<mask>,"final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!<mask>) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {"
796,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13848,13853,MethodCallMutator,append,add,1,0.033954218,"subBuilder.<mask>(phonemeText.subSequence(i, i + 1))","            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.<mask>(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule"
797,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13848,13853,MethodCallMutator,append,push,2,0.0068338388,"subBuilder.<mask>(phonemeText.subSequence(i, i + 1))","            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.<mask>(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule"
798,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13848,13853,MethodCallMutator,append,next,3,0.003442745,"subBuilder.<mask>(phonemeText.subSequence(i, i + 1))","            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.<mask>(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule"
799,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13848,13853,MethodCallMutator,append,insert,4,0.0026658075,"subBuilder.<mask>(phonemeText.subSequence(i, i + 1))","            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.<mask>(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule"
800,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13837,13846,IdentifierMutator-Variable,subBuilder,result,0,0.26490638,<mask>," PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is<mask>.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                   "
801,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13837,13846,IdentifierMutator-Variable,subBuilder,text,1,0.14314307,<mask>," PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is<mask>.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                   "
802,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13837,13846,IdentifierMutator-Variable,subBuilder,buffer,2,0.052190527,<mask>," PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is<mask>.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                   "
803,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13837,13846,IdentifierMutator-Variable,subBuilder,out,3,0.036336035,<mask>," PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is<mask>.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                   "
804,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13837,13846,IdentifierMutator-Variable,subBuilder,output,4,0.033267017,<mask>," PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is<mask>.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                   "
805,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13867,13877,MethodCallMutator,subSequence,replace,0,0.48539454,"phonemeText.<mask>(i, i + 1)","     final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.<mask>(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme ="
806,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13867,13877,MethodCallMutator,subSequence,slice,1,0.28253797,"phonemeText.<mask>(i, i + 1)","     final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.<mask>(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme ="
807,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13867,13877,MethodCallMutator,subSequence,ring,2,0.07663697,"phonemeText.<mask>(i, i + 1)","     final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.<mask>(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme ="
808,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13867,13877,MethodCallMutator,subSequence,get,3,0.026680486,"phonemeText.<mask>(i, i + 1)","     final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.<mask>(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme ="
809,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13867,13877,MethodCallMutator,subSequence,fill,4,0.019721536,"phonemeText.<mask>(i, i + 1)","     final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.<mask>(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme ="
810,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13855,13865,IdentifierMutator-Variable,phonemeText,text,0,0.1692679,<mask>,"          final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(<mask>.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme old"
811,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13855,13865,IdentifierMutator-Variable,phonemeText,rules,1,0.13849977,<mask>,"          final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(<mask>.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme old"
812,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13855,13865,IdentifierMutator-Variable,phonemeText,Text,2,0.05305131,<mask>,"          final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(<mask>.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme old"
813,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13855,13865,IdentifierMutator-Variable,phonemeText,rule,3,0.04196088,<mask>,"          final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(<mask>.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme old"
814,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13855,13865,IdentifierMutator-Variable,phonemeText,Rule,4,0.039295226,<mask>,"          final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(<mask>.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme old"
815,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13879,13879,IdentifierMutator-Variable,i,0,0,0.5061735,<mask>," final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(<mask>, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonem"
816,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13879,13879,IdentifierMutator-Variable,i,1,2,0.11154907,<mask>," final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(<mask>, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonem"
817,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13879,13879,IdentifierMutator-Variable,i,2,3,0.0064943214,<mask>," final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(<mask>, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonem"
818,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13879,13879,IdentifierMutator-Variable,i,start,4,0.0061830054,<mask>," final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(<mask>, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonem"
819,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13883,13885,BinaryOperatorMutator,+,-,2,0.0062929597,i <mask> 1,"emeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i<mask>1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove"
820,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13883,13885,BinaryOperatorMutator,+,)+,3,0.003973904,i <mask> 1,"emeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i<mask>1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove"
821,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13883,13885,BinaryOperatorMutator,+,+=,4,4.6034367E-4,i <mask> 1,"emeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i<mask>1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove"
822,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13882,13882,IdentifierMutator-Variable,i,index,2,6.6212774E-4,<mask>," phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i,<mask> + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes."
823,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13882,13882,IdentifierMutator-Variable,i,j,3,5.560604E-4,<mask>," phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i,<mask> + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes."
824,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13882,13882,IdentifierMutator-Variable,i,I,4,4.8018998E-4,<mask>," phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i,<mask> + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes."
825,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13886,13886,IdentifierMutator-Literal,1,2,1,0.097241044,<mask>,"Text = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i +<mask>));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove("
826,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13886,13886,IdentifierMutator-Literal,1,length,2,0.085726246,<mask>,"Text = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i +<mask>));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove("
827,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13886,13886,IdentifierMutator-Literal,1,4,3,0.033302642,<mask>,"Text = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i +<mask>));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove("
828,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,353,13886,13886,IdentifierMutator-Literal,1,i,4,0.018386327,<mask>,"Text = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i +<mask>));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove("
829,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,356,13927,13927,AssignmentMutator,i=rulesApplication.getI(),*,0,0.54187816,i <mask>= rulesApplication.getI(),"emeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i<mask>= rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme"
830,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,356,13927,13927,AssignmentMutator,i=rulesApplication.getI(),|,1,0.057384506,i <mask>= rulesApplication.getI(),"emeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i<mask>= rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme"
831,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,356,13927,13927,AssignmentMutator,i=rulesApplication.getI(),>,2,0.051077932,i <mask>= rulesApplication.getI(),"emeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i<mask>= rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme"
832,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,356,13927,13927,AssignmentMutator,i=rulesApplication.getI(),/,3,0.029364476,i <mask>= rulesApplication.getI(),"emeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i<mask>= rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme"
833,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,356,13927,13927,AssignmentMutator,i=rulesApplication.getI(),%,4,0.029237082,i <mask>= rulesApplication.getI(),"emeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i<mask>= rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme"
834,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,356,13926,13926,IdentifierMutator-Variable,i,I,2,0.003195014,<mask>,"        for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }<mask> = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme"
835,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,356,13926,13926,IdentifierMutator-Variable,i,I,3,0.0030418963,<mask>,"        for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }<mask> = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme"
836,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,356,13926,13926,IdentifierMutator-Variable,i,found,4,0.0017597842,<mask>,"        for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }<mask> = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme"
837,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,356,13947,13950,MethodCallMutator,getI,next,0,0.74893606,rulesApplication.<mask>(),"();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.<mask>();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme."
838,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,356,13947,13950,MethodCallMutator,getI,size,1,0.053341795,rulesApplication.<mask>(),"();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.<mask>();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme."
839,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,356,13947,13950,MethodCallMutator,getI,index,2,0.02742257,rulesApplication.<mask>(),"();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.<mask>();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme."
840,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,356,13947,13950,MethodCallMutator,getI,find,3,0.010132794,rulesApplication.<mask>(),"();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.<mask>();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme."
841,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,356,13947,13950,MethodCallMutator,getI,insert,4,0.010114875,rulesApplication.<mask>(),"();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.<mask>();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme."
842,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,356,13930,13945,IdentifierMutator-Variable,rulesApplication,i,0,0.15250342,<mask>,"Text.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i =<mask>.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPh"
843,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,356,13930,13945,IdentifierMutator-Variable,rulesApplication,builder,1,0.10534679,<mask>,"Text.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i =<mask>.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPh"
844,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,356,13930,13945,IdentifierMutator-Variable,rulesApplication,rule,2,0.08722394,<mask>,"Text.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i =<mask>.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPh"
845,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,356,13930,13945,IdentifierMutator-Variable,rulesApplication,match,3,0.039607126,<mask>,"Text.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i =<mask>.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPh"
846,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,356,13930,13945,IdentifierMutator-Variable,rulesApplication,this,4,0.025492467,<mask>,"Text.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i =<mask>.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPh"
847,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,362,14322,14332,MethodCallMutator,getPhonemes,values,0,0.69794804,subBuilder.<mask>(),"       if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.<mask>()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
   "
848,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,362,14322,14332,MethodCallMutator,getPhonemes,keys,1,0.22118545,subBuilder.<mask>(),"       if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.<mask>()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
   "
849,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,362,14322,14332,MethodCallMutator,getPhonemes,build,2,0.023241205,subBuilder.<mask>(),"       if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.<mask>()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
   "
850,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,362,14322,14332,MethodCallMutator,getPhonemes,reverse,3,0.011625784,subBuilder.<mask>(),"       if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.<mask>()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
   "
851,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,362,14322,14332,MethodCallMutator,getPhonemes,iterator,4,0.008081288,subBuilder.<mask>(),"       if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.<mask>()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
   "
852,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,362,14311,14320,IdentifierMutator-Variable,subBuilder,rule,0,0.6720102,<mask>,"          if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme :<mask>.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
          "
853,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,362,14311,14320,IdentifierMutator-Variable,subBuilder,rules,1,0.08914587,<mask>,"          if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme :<mask>.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
          "
854,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,362,14311,14320,IdentifierMutator-Variable,subBuilder,grammar,2,0.054969225,<mask>,"          if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme :<mask>.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
          "
855,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,362,14311,14320,IdentifierMutator-Variable,subBuilder,this,3,0.022369001,<mask>,"          if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme :<mask>.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
          "
856,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,362,14311,14320,IdentifierMutator-Variable,subBuilder,rule,4,0.010282083,<mask>,"          if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme :<mask>.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
          "
857,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,363,14368,14378,MethodCallMutator,containsKey,remove,0,0.6474125,phonemes.<mask>(newPhoneme),"  // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.<mask>(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());"
858,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,363,14368,14378,MethodCallMutator,containsKey,add,1,0.13567527,phonemes.<mask>(newPhoneme),"  // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.<mask>(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());"
859,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,363,14368,14378,MethodCallMutator,containsKey,has,2,0.05768778,phonemes.<mask>(newPhoneme),"  // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.<mask>(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());"
860,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,363,14368,14378,MethodCallMutator,containsKey,delete,3,0.022159534,phonemes.<mask>(newPhoneme),"  // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.<mask>(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());"
861,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,363,14368,14378,MethodCallMutator,containsKey,include,4,0.01949178,phonemes.<mask>(newPhoneme),"  // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.<mask>(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());"
862,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,363,14359,14366,IdentifierMutator-Variable,phonemes,map,0,0.30224308,<mask>,"       // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (<mask>.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes"
863,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,363,14359,14366,IdentifierMutator-Variable,phonemes,dict,1,0.062345218,<mask>,"       // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (<mask>.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes"
864,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,363,14359,14366,IdentifierMutator-Variable,phonemes,rules,2,0.0562127,<mask>,"       // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (<mask>.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes"
865,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,363,14359,14366,IdentifierMutator-Variable,phonemes,maps,3,0.042865388,<mask>,"       // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (<mask>.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes"
866,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,363,14359,14366,IdentifierMutator-Variable,phonemes,existing,4,0.04072169,<mask>,"       // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (<mask>.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes"
867,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,363,14380,14389,IdentifierMutator-Variable,newPhoneme,new,0,0.8334141,<mask>,", appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(<mask>)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
868,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,363,14380,14389,IdentifierMutator-Variable,newPhoneme,word,1,0.0590572,<mask>,", appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(<mask>)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
869,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,363,14380,14389,IdentifierMutator-Variable,newPhoneme,old,2,0.02786527,<mask>,", appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(<mask>)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
870,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,363,14380,14389,IdentifierMutator-Variable,newPhoneme,existing,3,0.02382493,<mask>,", appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(<mask>)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
871,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,363,14380,14389,IdentifierMutator-Variable,newPhoneme,this,4,0.00582026,<mask>,", appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(<mask>)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
872,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,364,14456,14461,MethodCallMutator,remove,get,0,0.9826743,phonemes.<mask>(newPhoneme),", i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.<mask>(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
873,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,364,14456,14461,MethodCallMutator,remove,delete,2,0.005444431,phonemes.<mask>(newPhoneme),", i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.<mask>(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
874,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,364,14456,14461,MethodCallMutator,remove,pop,3,0.002143589,phonemes.<mask>(newPhoneme),", i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.<mask>(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
875,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,364,14456,14461,MethodCallMutator,remove,clone,4,3.0986467E-4,phonemes.<mask>(newPhoneme),", i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.<mask>(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
876,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,364,14447,14454,IdentifierMutator-Variable,phonemes,phrases,0,0.24177021,<mask>,"Sequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme =<mask>.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
877,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,364,14447,14454,IdentifierMutator-Variable,phonemes,rules,1,0.15147105,<mask>,"Sequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme =<mask>.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
878,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,364,14447,14454,IdentifierMutator-Variable,phonemes,map,2,0.0806837,<mask>,"Sequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme =<mask>.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
879,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,364,14447,14454,IdentifierMutator-Variable,phonemes,languages,3,0.05123948,<mask>,"Sequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme =<mask>.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
880,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,364,14447,14454,IdentifierMutator-Variable,phonemes,translations,4,0.031029863,<mask>,"Sequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme =<mask>.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
881,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,364,14463,14472,IdentifierMutator-Variable,newPhoneme,i,0,0.5290022,<mask>," + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(<mask>);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
882,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,364,14463,14472,IdentifierMutator-Variable,newPhoneme,0,1,0.14674094,<mask>," + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(<mask>);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
883,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,364,14463,14472,IdentifierMutator-Variable,newPhoneme,key,2,0.06439018,<mask>," + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(<mask>);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
884,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,364,14463,14472,IdentifierMutator-Variable,newPhoneme,old,3,0.03813726,<mask>," + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(<mask>);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
885,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,364,14463,14472,IdentifierMutator-Variable,newPhoneme,name,4,0.02621988,<mask>," + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(<mask>);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
886,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14542,14558,MethodCallMutator,mergeWithLanguage,replace,0,0.47738394,oldPhoneme.<mask>(newPhoneme.getLanguages()),"getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.<mask>(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
887,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14542,14558,MethodCallMutator,mergeWithLanguage,add,1,0.13552631,oldPhoneme.<mask>(newPhoneme.getLanguages()),"getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.<mask>(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
888,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14542,14558,MethodCallMutator,mergeWithLanguage,get,2,0.07262618,oldPhoneme.<mask>(newPhoneme.getLanguages()),"getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.<mask>(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
889,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14542,14558,MethodCallMutator,mergeWithLanguage,join,3,0.05949777,oldPhoneme.<mask>(newPhoneme.getLanguages()),"getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.<mask>(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
890,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14542,14558,MethodCallMutator,mergeWithLanguage,merge,4,0.035870988,oldPhoneme.<mask>(newPhoneme.getLanguages()),"getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.<mask>(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
891,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14531,14540,IdentifierMutator-Variable,oldPhoneme,rule,0,0.31753337,<mask>," i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme =<mask>.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
892,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14531,14540,IdentifierMutator-Variable,oldPhoneme,grammar,1,0.17399909,<mask>," i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme =<mask>.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
893,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14531,14540,IdentifierMutator-Variable,oldPhoneme,rules,2,0.079923436,<mask>," i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme =<mask>.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
894,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14531,14540,IdentifierMutator-Variable,oldPhoneme,this,3,0.07210744,<mask>," i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme =<mask>.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
895,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14531,14540,IdentifierMutator-Variable,oldPhoneme,language,4,0.044783976,<mask>," i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme =<mask>.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
896,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14571,14582,MethodCallMutator,getLanguages,language,0,0.9538084,newPhoneme.<mask>(),"      }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.<mask>());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
897,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14571,14582,MethodCallMutator,getLanguages,get,1,0.011718905,newPhoneme.<mask>(),"      }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.<mask>());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
898,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14571,14582,MethodCallMutator,getLanguages,translation,2,0.010420724,newPhoneme.<mask>(),"      }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.<mask>());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
899,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14571,14582,MethodCallMutator,getLanguages,text,3,0.005290028,newPhoneme.<mask>(),"      }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.<mask>());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
900,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14571,14582,MethodCallMutator,getLanguages,lang,4,0.0036055462,newPhoneme.<mask>(),"      }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.<mask>());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
901,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14560,14569,IdentifierMutator-Variable,newPhoneme,rule,0,0.22935626,<mask>,"           }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(<mask>.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
902,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14560,14569,IdentifierMutator-Variable,newPhoneme,builder,1,0.08457331,<mask>,"           }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(<mask>.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
903,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14560,14569,IdentifierMutator-Variable,newPhoneme,this,2,0.057453576,<mask>,"           }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(<mask>.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
904,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14560,14569,IdentifierMutator-Variable,newPhoneme,translation,3,0.033905692,<mask>,"           }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(<mask>.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
905,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,365,14560,14569,IdentifierMutator-Variable,newPhoneme,parser,4,0.03174625,<mask>,"           }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(<mask>.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
906,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14617,14619,MethodCallMutator,put,replace,1,0.005040068,"phonemes.<mask>(mergedPhoneme, mergedPhoneme)","es only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.<mask>(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
907,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14617,14619,MethodCallMutator,put,add,2,0.001999729,"phonemes.<mask>(mergedPhoneme, mergedPhoneme)","es only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.<mask>(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
908,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14617,14619,MethodCallMutator,put,set,3,0.001162691,"phonemes.<mask>(mergedPhoneme, mergedPhoneme)","es only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.<mask>(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
909,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14617,14619,MethodCallMutator,put,update,4,3.6125616E-4,"phonemes.<mask>(mergedPhoneme, mergedPhoneme)","es only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.<mask>(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
910,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14608,14615,IdentifierMutator-Variable,phonemes,map,0,0.22452465,<mask>,"  }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());<mask>.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
911,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14608,14615,IdentifierMutator-Variable,phonemes,translations,1,0.1211029,<mask>,"  }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());<mask>.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
912,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14608,14615,IdentifierMutator-Variable,phonemes,result,2,0.08856099,<mask>,"  }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());<mask>.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
913,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14608,14615,IdentifierMutator-Variable,phonemes,maps,3,0.07027425,<mask>,"  }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());<mask>.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
914,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14608,14615,IdentifierMutator-Variable,phonemes,mapping,4,0.04591912,<mask>,"  }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());<mask>.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
915,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14621,14633,IdentifierMutator-Variable,mergedPhoneme,new,0,0.52443415,<mask>," based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(<mask>, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
916,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14621,14633,IdentifierMutator-Variable,mergedPhoneme,old,1,0.21221492,<mask>," based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(<mask>, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
917,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14621,14633,IdentifierMutator-Variable,mergedPhoneme,existing,2,0.033029106,<mask>," based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(<mask>, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
918,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14621,14633,IdentifierMutator-Variable,mergedPhoneme,word,3,0.031964768,<mask>," based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(<mask>, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
919,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14621,14633,IdentifierMutator-Variable,mergedPhoneme,key,4,0.020048607,<mask>," based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(<mask>, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
920,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14636,14648,IdentifierMutator-Variable,mergedPhoneme,merged,0,0.5583522,<mask>," ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme,<mask>);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
921,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14636,14648,IdentifierMutator-Variable,mergedPhoneme,new,1,0.08487672,<mask>," ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme,<mask>);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
922,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14636,14648,IdentifierMutator-Variable,mergedPhoneme,old,2,0.031028513,<mask>," ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme,<mask>);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
923,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14636,14648,IdentifierMutator-Variable,mergedPhoneme,rule,3,0.030149247,<mask>," ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme,<mask>);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
924,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,366,14636,14648,IdentifierMutator-Variable,mergedPhoneme,this,4,0.020249743,<mask>," ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme,<mask>);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
925,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,368,14706,14708,MethodCallMutator,put,add,1,0.001590157,"phonemes.<mask>(newPhoneme, newPhoneme)","  // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.<mask>(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
926,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,368,14706,14708,MethodCallMutator,put,set,2,0.0015830967,"phonemes.<mask>(newPhoneme, newPhoneme)","  // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.<mask>(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
927,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,368,14706,14708,MethodCallMutator,put,replace,3,0.0011826492,"phonemes.<mask>(newPhoneme, newPhoneme)","  // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.<mask>(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
928,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,368,14697,14704,IdentifierMutator-Variable,phonemes,translations,0,0.14704229,<mask>," check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {<mask>.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
929,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,368,14697,14704,IdentifierMutator-Variable,phonemes,phrases,1,0.09592015,<mask>," check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {<mask>.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
930,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,368,14697,14704,IdentifierMutator-Variable,phonemes,map,2,0.08835669,<mask>," check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {<mask>.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
931,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,368,14697,14704,IdentifierMutator-Variable,phonemes,mapping,3,0.03796946,<mask>," check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {<mask>.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
932,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,368,14697,14704,IdentifierMutator-Variable,phonemes,maps,4,0.036433753,<mask>," check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {<mask>.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
933,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,368,14710,14719,IdentifierMutator-Variable,newPhoneme,text,0,0.31008545,<mask>," phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(<mask>, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
934,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,368,14710,14719,IdentifierMutator-Variable,newPhoneme,rule,1,0.0593362,<mask>," phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(<mask>, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
935,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,368,14710,14719,IdentifierMutator-Variable,newPhoneme,key,2,0.047033835,<mask>," phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(<mask>, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
936,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,368,14710,14719,IdentifierMutator-Variable,newPhoneme,word,3,0.04268832,<mask>," phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(<mask>, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
937,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,368,14710,14719,IdentifierMutator-Variable,newPhoneme,old,4,0.03909851,<mask>," phonemes with the same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(<mask>, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
938,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,368,14722,14731,IdentifierMutator-Variable,newPhoneme,rule,0,0.13533741,<mask>," same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme,<mask>);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
939,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,368,14722,14731,IdentifierMutator-Variable,newPhoneme,null,1,0.08231276,<mask>," same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme,<mask>);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
940,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,368,14722,14731,IdentifierMutator-Variable,newPhoneme,text,2,0.039660618,<mask>," same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme,<mask>);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
941,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,368,14722,14731,IdentifierMutator-Variable,newPhoneme,language,3,0.033804808,<mask>," same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme,<mask>);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
942,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,368,14722,14731,IdentifierMutator-Variable,newPhoneme,sub,4,0.028582305,<mask>," same text but different language set get lost
            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {
                if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme,<mask>);
                }
            }
        }

        return new PhonemeBuilder(phonemes.keySet());
   "
943,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,373,14821,14826,MethodCallMutator,keySet,values,0,0.72874224,phonemes.<mask>(),"es.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.<mask>());
   "
944,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,373,14821,14826,MethodCallMutator,keySet,build,1,0.19314942,phonemes.<mask>(),"es.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.<mask>());
   "
945,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,373,14821,14826,MethodCallMutator,keySet,keys,2,0.023944106,phonemes.<mask>(),"es.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.<mask>());
   "
946,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,373,14821,14826,MethodCallMutator,keySet,reverse,3,0.009251087,phonemes.<mask>(),"es.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.<mask>());
   "
947,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,373,14821,14826,MethodCallMutator,keySet,clone,4,0.0078279385,phonemes.<mask>(),"es.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(phonemes.<mask>());
   "
948,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,373,14812,14819,IdentifierMutator-Variable,phonemes,rules,0,0.2499145,<mask>," if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(<mask>.keySet());
   "
949,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,373,14812,14819,IdentifierMutator-Variable,phonemes,map,1,0.17225914,<mask>," if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(<mask>.keySet());
   "
950,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,373,14812,14819,IdentifierMutator-Variable,phonemes,result,2,0.07566124,<mask>," if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(<mask>.keySet());
   "
951,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,373,14812,14819,IdentifierMutator-Variable,phonemes,dict,3,0.040764283,<mask>," if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(<mask>.keySet());
   "
952,PhoneticEngine.java,applyFinalRules,"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules)",329,373,14812,14819,IdentifierMutator-Variable,phonemes,properties,4,0.039137334,<mask>," if (phonemes.containsKey(newPhoneme)) {
                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);
                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());
                    phonemes.put(mergedPhoneme, mergedPhoneme);
                } else {
                    phonemes.put(newPhoneme, newPhoneme);
                }
            }
        }

        return new PhonemeBuilder(<mask>.keySet());
   "
953,PhoneticEngine.java,encode,String encode(final String input),383,384,15125,15138,MethodCallMutator,guessLanguages,get,0,0.42194217,this.lang.<mask>(input),"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.<mask>(input);
        return encode(input, languageSet);
    }"
954,PhoneticEngine.java,encode,String encode(final String input),383,384,15125,15138,MethodCallMutator,guessLanguages,parse,1,0.13898103,this.lang.<mask>(input),"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.<mask>(input);
        return encode(input, languageSet);
    }"
955,PhoneticEngine.java,encode,String encode(final String input),383,384,15125,15138,MethodCallMutator,guessLanguages,set,2,0.08807068,this.lang.<mask>(input),"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.<mask>(input);
        return encode(input, languageSet);
    }"
956,PhoneticEngine.java,encode,String encode(final String input),383,384,15125,15138,MethodCallMutator,guessLanguages,create,3,0.066980965,this.lang.<mask>(input),"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.<mask>(input);
        return encode(input, languageSet);
    }"
957,PhoneticEngine.java,encode,String encode(final String input),383,384,15125,15138,MethodCallMutator,guessLanguages,define,4,0.056168944,this.lang.<mask>(input),"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.<mask>(input);
        return encode(input, languageSet);
    }"
958,PhoneticEngine.java,encode,String encode(final String input),383,384,15115,15123,IdentifierMutator-Variable,this.lang,Language,0,0.27370486,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet =<mask>.guessLanguages(input);
        return encode(input, languageSet);
    }"
959,PhoneticEngine.java,encode,String encode(final String input),383,384,15115,15123,IdentifierMutator-Variable,this.lang,Languages,1,0.15731043,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet =<mask>.guessLanguages(input);
        return encode(input, languageSet);
    }"
960,PhoneticEngine.java,encode,String encode(final String input),383,384,15115,15123,IdentifierMutator-Variable,this.lang,languages,2,0.056086056,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet =<mask>.guessLanguages(input);
        return encode(input, languageSet);
    }"
961,PhoneticEngine.java,encode,String encode(final String input),383,384,15115,15123,IdentifierMutator-Variable,this.lang,language,3,0.04626299,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet =<mask>.guessLanguages(input);
        return encode(input, languageSet);
    }"
962,PhoneticEngine.java,encode,String encode(final String input),383,384,15115,15123,IdentifierMutator-Variable,this.lang,this,4,0.022911869,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet =<mask>.guessLanguages(input);
        return encode(input, languageSet);
    }"
963,PhoneticEngine.java,encode,String encode(final String input),383,384,15115,15118,IdentifierMutator-ThisAccess,this,java,1,0.07604626,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet =<mask>.lang.guessLanguages(input);
        return encode(input, languageSet);
    }"
964,PhoneticEngine.java,encode,String encode(final String input),383,384,15115,15118,IdentifierMutator-ThisAccess,this,Languages,2,0.06967411,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet =<mask>.lang.guessLanguages(input);
        return encode(input, languageSet);
    }"
965,PhoneticEngine.java,encode,String encode(final String input),383,384,15115,15118,IdentifierMutator-ThisAccess,this,Config,3,0.043795142,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet =<mask>.lang.guessLanguages(input);
        return encode(input, languageSet);
    }"
966,PhoneticEngine.java,encode,String encode(final String input),383,384,15115,15118,IdentifierMutator-ThisAccess,this,System,4,0.028809179,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet =<mask>.lang.guessLanguages(input);
        return encode(input, languageSet);
    }"
967,PhoneticEngine.java,encode,String encode(final String input),383,384,15120,15123,FieldReferenceMutator,lang,language,0,0.1018284,this.<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.<mask>.guessLanguages(input);
        return encode(input, languageSet);
    }"
968,PhoneticEngine.java,encode,String encode(final String input),383,384,15120,15123,FieldReferenceMutator,lang,parser,1,0.098158546,this.<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.<mask>.guessLanguages(input);
        return encode(input, languageSet);
    }"
969,PhoneticEngine.java,encode,String encode(final String input),383,384,15120,15123,FieldReferenceMutator,lang,model,2,0.047192797,this.<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.<mask>.guessLanguages(input);
        return encode(input, languageSet);
    }"
970,PhoneticEngine.java,encode,String encode(final String input),383,384,15120,15123,FieldReferenceMutator,lang,engine,3,0.03938258,this.<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.<mask>.guessLanguages(input);
        return encode(input, languageSet);
    }"
971,PhoneticEngine.java,encode,String encode(final String input),383,384,15120,15123,FieldReferenceMutator,lang,features,4,0.026416194,this.<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.<mask>.guessLanguages(input);
        return encode(input, languageSet);
    }"
972,PhoneticEngine.java,encode,String encode(final String input),383,384,15140,15144,IdentifierMutator-Variable,input,this,1,0.016373163,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.guessLanguages(<mask>);
        return encode(input, languageSet);
    }"
973,PhoneticEngine.java,encode,String encode(final String input),383,384,15140,15144,IdentifierMutator-Variable,input,language,2,0.013993494,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.guessLanguages(<mask>);
        return encode(input, languageSet);
    }"
974,PhoneticEngine.java,encode,String encode(final String input),383,384,15140,15144,IdentifierMutator-Variable,input,Input,3,0.007943842,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.guessLanguages(<mask>);
        return encode(input, languageSet);
    }"
975,PhoneticEngine.java,encode,String encode(final String input),383,384,15140,15144,IdentifierMutator-Variable,input,true,4,0.0059830225,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.guessLanguages(<mask>);
        return encode(input, languageSet);
    }"
976,PhoneticEngine.java,encode,String encode(final String input),383,385,15163,15168,MethodCallMutator,encode,decode,1,0.03708216,"<mask>(input, languageSet)","String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);
        return<mask>(input, languageSet);
    }"
977,PhoneticEngine.java,encode,String encode(final String input),383,385,15163,15168,MethodCallMutator,encode,convert,2,0.0034387605,"<mask>(input, languageSet)","String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);
        return<mask>(input, languageSet);
    }"
978,PhoneticEngine.java,encode,String encode(final String input),383,385,15163,15168,MethodCallMutator,encode,translate,3,0.0019013908,"<mask>(input, languageSet)","String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);
        return<mask>(input, languageSet);
    }"
979,PhoneticEngine.java,encode,String encode(final String input),383,385,15163,15168,MethodCallMutator,encode,escape,4,0.0014792223,"<mask>(input, languageSet)","String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);
        return<mask>(input, languageSet);
    }"
980,PhoneticEngine.java,encode,String encode(final String input),383,385,15170,15174,IdentifierMutator-Variable,input,Input,1,0.0027178791,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);
        return encode(<mask>, languageSet);
    }"
981,PhoneticEngine.java,encode,String encode(final String input),383,385,15170,15174,IdentifierMutator-Variable,input,output,2,0.0018595194,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);
        return encode(<mask>, languageSet);
    }"
982,PhoneticEngine.java,encode,String encode(final String input),383,385,15170,15174,IdentifierMutator-Variable,input,in,3,0.001562349,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);
        return encode(<mask>, languageSet);
    }"
983,PhoneticEngine.java,encode,String encode(final String input),383,385,15170,15174,IdentifierMutator-Variable,input,this,4,0.0011846536,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);
        return encode(<mask>, languageSet);
    }"
984,PhoneticEngine.java,encode,String encode(final String input),383,385,15177,15187,IdentifierMutator-Variable,languageSet,language,0,0.627312,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);
        return encode(input,<mask>);
    }"
985,PhoneticEngine.java,encode,String encode(final String input),383,385,15177,15187,IdentifierMutator-Variable,languageSet,lang,1,0.076175354,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);
        return encode(input,<mask>);
    }"
986,PhoneticEngine.java,encode,String encode(final String input),383,385,15177,15187,IdentifierMutator-Variable,languageSet,languages,2,0.046198413,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);
        return encode(input,<mask>);
    }"
987,PhoneticEngine.java,encode,String encode(final String input),383,385,15177,15187,IdentifierMutator-Variable,languageSet,this,3,0.03226624,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);
        return encode(input,<mask>);
    }"
988,PhoneticEngine.java,encode,String encode(final String input),383,385,15177,15187,IdentifierMutator-Variable,languageSet,true,4,0.031121777,<mask>,"String encode(final String input) {
        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);
        return encode(input,<mask>);
    }"
989,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15742,15755,MethodCallMutator,getInstanceMap,get,0,0.3720019,"Rule.<mask>(this.nameType, RULES, languageSet)","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.<mask>(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
990,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15742,15755,MethodCallMutator,getInstanceMap,create,1,0.27049392,"Rule.<mask>(this.nameType, RULES, languageSet)","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.<mask>(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
991,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15742,15755,MethodCallMutator,getInstanceMap,parse,2,0.13136286,"Rule.<mask>(this.nameType, RULES, languageSet)","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.<mask>(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
992,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15742,15755,MethodCallMutator,getInstanceMap,map,3,0.04171358,"Rule.<mask>(this.nameType, RULES, languageSet)","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.<mask>(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
993,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15742,15755,MethodCallMutator,getInstanceMap,define,4,0.015638893,"Rule.<mask>(this.nameType, RULES, languageSet)","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.<mask>(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
994,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15757,15769,IdentifierMutator-Variable,this.nameType,input,0,0.9446387,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(<mask>, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
995,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15757,15769,IdentifierMutator-Variable,this.nameType,this,1,0.04282807,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(<mask>, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
996,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15757,15769,IdentifierMutator-Variable,this.nameType,in,2,0.004924507,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(<mask>, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
997,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15757,15769,IdentifierMutator-Variable,this.nameType,Input,3,0.0016101772,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(<mask>, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
998,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15757,15769,IdentifierMutator-Variable,this.nameType,null,4,5.7228527E-4,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(<mask>, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
999,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15757,15760,IdentifierMutator-ThisAccess,this,This,1,1.646344E-4,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(<mask>.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1000,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15757,15760,IdentifierMutator-ThisAccess,this,super,3,4.1913445E-6,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(<mask>.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1001,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15757,15760,IdentifierMutator-ThisAccess,this,rule,4,3.1315171E-6,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(<mask>.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1002,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15762,15769,FieldReferenceMutator,nameType,name,0,0.62323284,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.<mask>, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1003,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15762,15769,FieldReferenceMutator,nameType,language,1,0.07366846,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.<mask>, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1004,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15762,15769,FieldReferenceMutator,nameType,type,2,0.064593546,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.<mask>, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1005,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15762,15769,FieldReferenceMutator,nameType,rules,3,0.04358622,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.<mask>, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1006,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15762,15769,FieldReferenceMutator,nameType,pattern,4,0.023720253,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.<mask>, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1007,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15788,15798,IdentifierMutator-Variable,languageSet,language,0,0.19600241,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES,<mask>);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1008,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15788,15798,IdentifierMutator-Variable,languageSet,true,1,0.17095064,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES,<mask>);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1009,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15788,15798,IdentifierMutator-Variable,languageSet,false,2,0.15385403,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES,<mask>);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1010,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15788,15798,IdentifierMutator-Variable,languageSet,input,3,0.117190614,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES,<mask>);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1011,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,398,15788,15798,IdentifierMutator-Variable,languageSet,null,4,0.10129021,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES,<mask>);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1012,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15911,15924,MethodCallMutator,getInstanceMap,get,0,0.34538415,"Rule.<mask>(this.nameType, this.ruleType, ""common"")","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.<mask>(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1013,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15911,15924,MethodCallMutator,getInstanceMap,create,1,0.3396846,"Rule.<mask>(this.nameType, this.ruleType, ""common"")","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.<mask>(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1014,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15911,15924,MethodCallMutator,getInstanceMap,map,2,0.09959004,"Rule.<mask>(this.nameType, this.ruleType, ""common"")","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.<mask>(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1015,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15911,15924,MethodCallMutator,getInstanceMap,parse,3,0.039227188,"Rule.<mask>(this.nameType, this.ruleType, ""common"")","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.<mask>(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1016,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15911,15924,MethodCallMutator,getInstanceMap,list,4,0.0251768,"Rule.<mask>(this.nameType, this.ruleType, ""common"")","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.<mask>(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1017,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15926,15938,IdentifierMutator-Variable,this.nameType,rules,0,0.92333555,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(<mask>, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1018,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15926,15938,IdentifierMutator-Variable,this.nameType,this,1,0.03081086,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(<mask>, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1019,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15926,15938,IdentifierMutator-Variable,this.nameType,Rules,2,0.025695754,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(<mask>, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1020,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15926,15938,IdentifierMutator-Variable,this.nameType,null,3,0.0030202463,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(<mask>, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1021,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15926,15938,IdentifierMutator-Variable,this.nameType,rule,4,0.0029545678,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(<mask>, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1022,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15926,15929,IdentifierMutator-ThisAccess,this,This,1,9.410219E-5,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(<mask>.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1023,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15926,15929,IdentifierMutator-ThisAccess,this,that,3,1.761526E-6,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(<mask>.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1024,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15926,15929,IdentifierMutator-ThisAccess,this,other,4,9.918123E-7,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(<mask>.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1025,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15931,15938,FieldReferenceMutator,nameType,name,0,0.7566764,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.<mask>, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1026,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15931,15938,FieldReferenceMutator,nameType,language,1,0.18204242,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.<mask>, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1027,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15931,15938,FieldReferenceMutator,nameType,type,2,0.023256006,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.<mask>, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1028,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15931,15938,FieldReferenceMutator,nameType,Name,3,0.0019883674,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.<mask>, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1029,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15931,15938,FieldReferenceMutator,nameType,NAME,4,0.0017332068,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.<mask>, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1030,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15941,15953,IdentifierMutator-Variable,this.ruleType,rules,0,0.8797121,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType,<mask>, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1031,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15941,15953,IdentifierMutator-Variable,this.ruleType,rule,1,0.023200413,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType,<mask>, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1032,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15941,15953,IdentifierMutator-Variable,this.ruleType,null,2,0.01964848,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType,<mask>, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1033,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15941,15953,IdentifierMutator-Variable,this.ruleType,"""""",3,0.015800785,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType,<mask>, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1034,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15941,15953,IdentifierMutator-Variable,this.ruleType,1,4,0.009644256,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType,<mask>, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1035,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15941,15944,IdentifierMutator-ThisAccess,this,rule,2,3.4069322E-5,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType,<mask>.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1036,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15941,15944,IdentifierMutator-ThisAccess,this,super,3,2.2350667E-5,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType,<mask>.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1037,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15941,15944,IdentifierMutator-ThisAccess,this,This,4,1.2492304E-5,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType,<mask>.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1038,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15946,15953,FieldReferenceMutator,ruleType,rules,0,0.3262036,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.<mask>, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1039,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15946,15953,FieldReferenceMutator,ruleType,rule,1,0.32613456,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.<mask>, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1040,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15946,15953,FieldReferenceMutator,ruleType,type,2,0.09424995,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.<mask>, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1041,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15946,15953,FieldReferenceMutator,ruleType,name,3,0.037308,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.<mask>, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1042,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15946,15953,FieldReferenceMutator,ruleType,language,4,0.030983387,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.<mask>, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1043,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15956,15963,IdentifierMutator-Literal,"""common""",rules,0,0.964475,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType,<mask>);
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1044,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15956,15963,IdentifierMutator-Literal,"""common""",rule,1,0.006336634,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType,<mask>);
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1045,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15956,15963,IdentifierMutator-Literal,"""common""",null,2,0.004316456,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType,<mask>);
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1046,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15956,15963,IdentifierMutator-Literal,"""common""",language,3,0.004123787,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType,<mask>);
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1047,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,400,15956,15963,IdentifierMutator-Literal,"""common""",languages,4,0.0034331314,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType,<mask>);
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1048,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16136,16149,MethodCallMutator,getInstanceMap,create,0,0.32213712,"Rule.<mask>(this.nameType, this.ruleType, languageSet)","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.<mask>(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1049,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16136,16149,MethodCallMutator,getInstanceMap,get,1,0.26869246,"Rule.<mask>(this.nameType, this.ruleType, languageSet)","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.<mask>(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1050,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16136,16149,MethodCallMutator,getInstanceMap,parse,2,0.104707964,"Rule.<mask>(this.nameType, this.ruleType, languageSet)","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.<mask>(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1051,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16136,16149,MethodCallMutator,getInstanceMap,map,3,0.06625865,"Rule.<mask>(this.nameType, this.ruleType, languageSet)","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.<mask>(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1052,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16136,16149,MethodCallMutator,getInstanceMap,define,4,0.027197162,"Rule.<mask>(this.nameType, this.ruleType, languageSet)","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.<mask>(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1053,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16151,16163,IdentifierMutator-Variable,this.nameType,rules,0,0.7415254,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(<mask>, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1054,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16151,16163,IdentifierMutator-Variable,this.nameType,this,1,0.1040162,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(<mask>, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1055,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16151,16163,IdentifierMutator-Variable,this.nameType,input,2,0.046471477,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(<mask>, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1056,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16151,16163,IdentifierMutator-Variable,this.nameType,rule,3,0.017221343,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(<mask>, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1057,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16151,16163,IdentifierMutator-Variable,this.nameType,null,4,0.013008133,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(<mask>, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1058,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16151,16154,IdentifierMutator-ThisAccess,this,This,1,1.18864125E-4,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(<mask>.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1059,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16151,16154,IdentifierMutator-ThisAccess,this,other,3,3.674414E-6,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(<mask>.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1060,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16151,16154,IdentifierMutator-ThisAccess,this,current,4,2.596471E-6,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(<mask>.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1061,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16156,16163,FieldReferenceMutator,nameType,language,0,0.4310583,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.<mask>, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1062,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16156,16163,FieldReferenceMutator,nameType,name,1,0.40123528,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.<mask>, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1063,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16156,16163,FieldReferenceMutator,nameType,type,2,0.03915766,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.<mask>, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1064,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16156,16163,FieldReferenceMutator,nameType,pattern,3,0.013435514,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.<mask>, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1065,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16156,16163,FieldReferenceMutator,nameType,rules,4,0.0133782085,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.<mask>, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1066,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16166,16178,IdentifierMutator-Variable,this.ruleType,rules,0,0.7719145,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType,<mask>, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1067,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16166,16178,IdentifierMutator-Variable,this.ruleType,"""""",1,0.054320782,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType,<mask>, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1068,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16166,16178,IdentifierMutator-Variable,this.ruleType,rule,2,0.046267938,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType,<mask>, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1069,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16166,16178,IdentifierMutator-Variable,this.ruleType,null,3,0.04399186,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType,<mask>, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1070,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16166,16178,IdentifierMutator-Variable,this.ruleType,1,4,0.006407988,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType,<mask>, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1071,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16166,16169,IdentifierMutator-ThisAccess,this,super,2,1.388846E-5,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType,<mask>.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1072,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16166,16169,IdentifierMutator-ThisAccess,this,other,3,8.506662E-6,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType,<mask>.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1073,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16166,16169,IdentifierMutator-ThisAccess,this,rule,4,2.8685395E-6,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType,<mask>.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1074,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16171,16178,FieldReferenceMutator,ruleType,rules,0,0.6714892,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.<mask>, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1075,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16171,16178,FieldReferenceMutator,ruleType,rule,1,0.19717944,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.<mask>, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1076,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16171,16178,FieldReferenceMutator,ruleType,type,2,0.010625845,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.<mask>, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1077,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16171,16178,FieldReferenceMutator,ruleType,language,3,0.00753164,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.<mask>, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1078,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16171,16178,FieldReferenceMutator,ruleType,name,4,0.0058055655,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.<mask>, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1079,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16181,16191,IdentifierMutator-Variable,languageSet,rules,0,0.3412771,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType,<mask>);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1080,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16181,16191,IdentifierMutator-Variable,languageSet,null,1,0.14922962,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType,<mask>);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1081,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16181,16191,IdentifierMutator-Variable,languageSet,"""""",2,0.14829499,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType,<mask>);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1082,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16181,16191,IdentifierMutator-Variable,languageSet,rule,3,0.051894,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType,<mask>);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1083,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,402,16181,16191,IdentifierMutator-Variable,languageSet,true,4,0.029057061,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType,<mask>);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1084,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16289,16289,AssignmentMutator,"input=input.toLowerCase(java.util.Locale.ENGLISH).replace('-','').trim()",.,0,0.2751994,"input <mask>= input.toLowerCase(java.util.Locale.ENGLISH).replace('-', ' ').trim()","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input<mask>= input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
           "
1085,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16289,16289,AssignmentMutator,"input=input.toLowerCase(java.util.Locale.ENGLISH).replace('-','').trim()",,1,0.24106184,"input <mask>= input.toLowerCase(java.util.Locale.ENGLISH).replace('-', ' ').trim()","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input<mask>= input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
           "
1086,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16289,16289,AssignmentMutator,"input=input.toLowerCase(java.util.Locale.ENGLISH).replace('-','').trim()",//,2,0.11149983,"input <mask>= input.toLowerCase(java.util.Locale.ENGLISH).replace('-', ' ').trim()","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input<mask>= input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
           "
1087,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16289,16289,AssignmentMutator,"input=input.toLowerCase(java.util.Locale.ENGLISH).replace('-','').trim()",/,3,0.08353094,"input <mask>= input.toLowerCase(java.util.Locale.ENGLISH).replace('-', ' ').trim()","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input<mask>= input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
           "
1088,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16289,16289,AssignmentMutator,"input=input.toLowerCase(java.util.Locale.ENGLISH).replace('-','').trim()",*,4,0.07778971,"input <mask>= input.toLowerCase(java.util.Locale.ENGLISH).replace('-', ' ').trim()","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input<mask>= input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
           "
1089,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16284,16288,IdentifierMutator-Variable,input,output,1,0.002495591,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation<mask> = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    //"
1090,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16284,16288,IdentifierMutator-Variable,input,text,3,4.3740903E-4,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation<mask> = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    //"
1091,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16284,16288,IdentifierMutator-Variable,input,result,4,4.0309498E-4,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation<mask> = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    //"
1092,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16344,16347,MethodCallMutator,trim,strip,0,0.43704182,"input.toLowerCase(Locale.ENGLISH).replace('-', ' ').<mask>()","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').<mask>();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1093,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16344,16347,MethodCallMutator,trim,join,1,0.121630244,"input.toLowerCase(Locale.ENGLISH).replace('-', ' ').<mask>()","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').<mask>();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1094,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16344,16347,MethodCallMutator,trim,clean,2,0.09956639,"input.toLowerCase(Locale.ENGLISH).replace('-', ' ').<mask>()","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').<mask>();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1095,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16344,16347,MethodCallMutator,trim,split,3,0.07131437,"input.toLowerCase(Locale.ENGLISH).replace('-', ' ').<mask>()","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').<mask>();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1096,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16344,16347,MethodCallMutator,trim,replace,4,0.030917384,"input.toLowerCase(Locale.ENGLISH).replace('-', ' ').<mask>()","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').<mask>();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1097,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16326,16332,MethodCallMutator,replace,remove,1,2.497211E-4,"input.toLowerCase(Locale.ENGLISH).<mask>('-', ' ')","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).<mask>('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1098,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16326,16332,MethodCallMutator,replace,split,2,1.400002E-4,"input.toLowerCase(Locale.ENGLISH).<mask>('-', ' ')","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).<mask>('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1099,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16326,16332,MethodCallMutator,replace,strip,3,5.833884E-5,"input.toLowerCase(Locale.ENGLISH).<mask>('-', ' ')","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).<mask>('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1100,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16326,16332,MethodCallMutator,replace,sub,4,4.116065E-5,"input.toLowerCase(Locale.ENGLISH).<mask>('-', ' ')","String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).<mask>('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1101,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16298,16308,MethodCallMutator,toLowerCase,language,0,0.4477735,input.<mask>(Locale.ENGLISH),"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.<mask>(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1102,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16298,16308,MethodCallMutator,toLowerCase,region,1,0.14549865,input.<mask>(Locale.ENGLISH),"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.<mask>(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1103,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16298,16308,MethodCallMutator,toLowerCase,name,2,0.048243087,input.<mask>(Locale.ENGLISH),"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.<mask>(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1104,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16298,16308,MethodCallMutator,toLowerCase,case,3,0.034984004,input.<mask>(Locale.ENGLISH),"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.<mask>(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1105,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16298,16308,MethodCallMutator,toLowerCase,replace,4,0.027714297,input.<mask>(Locale.ENGLISH),"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.<mask>(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1106,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16292,16296,IdentifierMutator-Variable,input,output,1,0.0013074949,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input =<mask>.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1107,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16292,16296,IdentifierMutator-Variable,input,text,2,2.3932228E-4,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input =<mask>.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1108,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16292,16296,IdentifierMutator-Variable,input,source,4,9.657265E-5,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input =<mask>.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1109,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16310,16323,IdentifierMutator-Variable,java.util.Locale.ENGLISH,true,0,0.29379687,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(<mask>).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                 "
1110,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16310,16323,IdentifierMutator-Variable,java.util.Locale.ENGLISH,false,1,0.21770339,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(<mask>).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                 "
1111,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16310,16323,IdentifierMutator-Variable,java.util.Locale.ENGLISH,language,2,0.040295698,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(<mask>).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                 "
1112,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16310,16323,IdentifierMutator-Variable,java.util.Locale.ENGLISH,null,3,0.0195086,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(<mask>).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                 "
1113,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16310,16323,IdentifierMutator-Variable,java.util.Locale.ENGLISH,true,4,0.015677722,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(<mask>).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                 "
1114,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16317,16323,FieldReferenceMutator,ENGLISH,US,0,0.62903225,java.util.Locale.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.<mask>).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1115,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16317,16323,FieldReferenceMutator,ENGLISH,ALL,1,0.10520949,java.util.Locale.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.<mask>).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1116,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16317,16323,FieldReferenceMutator,ENGLISH,UG,2,0.026527505,java.util.Locale.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.<mask>).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1117,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16317,16323,FieldReferenceMutator,ENGLISH,US,3,0.020887231,java.util.Locale.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.<mask>).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1118,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16317,16323,FieldReferenceMutator,ENGLISH,GB,4,0.014088438,java.util.Locale.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.<mask>).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
              "
1119,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16334,16336,IdentifierMutator-Literal,"'-'","','",0,0.29942816,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace(<mask>, ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1120,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16334,16336,IdentifierMutator-Literal,"'-'","''",1,0.116707414,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace(<mask>, ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1121,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16334,16336,IdentifierMutator-Literal,"'-'",space,2,0.04908486,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace(<mask>, ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1122,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16334,16336,IdentifierMutator-Literal,"'-'","'",3,0.026309615,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace(<mask>, ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1123,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16334,16336,IdentifierMutator-Literal,"'-'","-'",4,0.022259729,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace(<mask>, ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1124,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16339,16341,IdentifierMutator-Literal,"''","""""",1,0.20649487,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-',<mask>).trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1125,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16339,16341,IdentifierMutator-Literal,"''",_,2,0.011941203,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-',<mask>).trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1126,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16339,16341,IdentifierMutator-Literal,"''","""_",3,0.008464158,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-',<mask>).trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1127,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,406,16339,16341,IdentifierMutator-Literal,"''","'",4,0.008419011,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-',<mask>).trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1128,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16378,16381,BinaryOperatorMutator,==,!=,1,0.24178387,this.nameType <mask> NameType.GENERIC,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType<mask>NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1129,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16378,16381,BinaryOperatorMutator,==,===,3,0.008145977,this.nameType <mask> NameType.GENERIC,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType<mask>NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1130,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16378,16381,BinaryOperatorMutator,==,is,4,0.0014360646,this.nameType <mask> NameType.GENERIC,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType<mask>NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1131,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16365,16377,IdentifierMutator-Variable,this.nameType,type,0,0.97956973,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (<mask> == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1132,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16365,16377,IdentifierMutator-Variable,this.nameType,this,1,0.004840069,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (<mask> == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1133,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16365,16377,IdentifierMutator-Variable,this.nameType,t,2,0.004018509,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (<mask> == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1134,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16365,16377,IdentifierMutator-Variable,this.nameType,Type,3,0.0013383863,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (<mask> == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1135,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16365,16377,IdentifierMutator-Variable,this.nameType,types,4,5.702802E-4,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (<mask> == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
               "
1136,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16365,16368,IdentifierMutator-ThisAccess,this,This,2,2.6095094E-4,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (<mask>.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1137,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16365,16368,IdentifierMutator-ThisAccess,this,super,3,5.356058E-5,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (<mask>.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1138,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16365,16368,IdentifierMutator-ThisAccess,this,rule,4,1.5449768E-5,<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (<mask>.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
            "
1139,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16370,16377,FieldReferenceMutator,nameType,type,0,0.98854196,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.<mask> == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1140,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16370,16377,FieldReferenceMutator,nameType,name,1,0.0052586203,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.<mask> == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1141,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16370,16377,FieldReferenceMutator,nameType,Type,2,9.148924E-4,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.<mask> == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1142,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16370,16377,FieldReferenceMutator,nameType,kind,3,5.802148E-4,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.<mask> == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1143,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16370,16377,FieldReferenceMutator,nameType,TYPE,4,2.792615E-4,this.<mask>,"String encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.<mask> == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
             "
1144,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16382,16397,IdentifierMutator-Variable,NameType.GENERIC,NAME,0,0.20850456,<mask>," encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType ==<mask>) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                  "
1145,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16382,16397,IdentifierMutator-Variable,NameType.GENERIC,name,1,0.08774197,<mask>," encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType ==<mask>) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                  "
1146,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16382,16397,IdentifierMutator-Variable,NameType.GENERIC,1,2,0.07424341,<mask>," encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType ==<mask>) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                  "
1147,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16382,16397,IdentifierMutator-Variable,NameType.GENERIC,null,3,0.06420001,<mask>," encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType ==<mask>) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                  "
1148,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16382,16397,IdentifierMutator-Variable,NameType.GENERIC,3,4,0.053556062,<mask>," encode(String input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType ==<mask>) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                  "
1149,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16391,16397,FieldReferenceMutator,GENERIC,NAME,0,0.20490533,NameType.<mask>," input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.<mask>) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                  "
1150,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16391,16397,FieldReferenceMutator,GENERIC,D,1,0.03478751,NameType.<mask>," input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.<mask>) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                  "
1151,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16391,16397,FieldReferenceMutator,GENERIC,TEXT,2,0.03009342,NameType.<mask>," input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.<mask>) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                  "
1152,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16391,16397,FieldReferenceMutator,GENERIC,DEF,3,0.017357407,NameType.<mask>," input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.<mask>) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                  "
1153,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,408,16391,16397,FieldReferenceMutator,GENERIC,ASC,4,0.01630761,NameType.<mask>," input, final Languages.LanguageSet languageSet) {
        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.<mask>) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                  "
1154,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16437,16440,BinaryOperatorMutator,&&,||,2,0.0031174244,"(input.length() >= 2) <mask> input.substring(0, 2).equals(""d'"")","<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2<mask>input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
            "
1155,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16437,16440,BinaryOperatorMutator,&&,&,3,0.0022658235,"(input.length() >= 2) <mask> input.substring(0, 2).equals(""d'"")","<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2<mask>input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
            "
1156,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16437,16440,BinaryOperatorMutator,&&,||,4,0.001624468,"(input.length() >= 2) <mask> input.substring(0, 2).equals(""d'"")","<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2<mask>input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
            "
1157,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16432,16435,BinaryOperatorMutator,>=,>,0,0.52006906,input.length() <mask> 2,", List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length()<mask>2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
          "
1158,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16432,16435,BinaryOperatorMutator,>=,>,1,0.20069924,input.length() <mask> 2,", List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length()<mask>2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
          "
1159,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16432,16435,BinaryOperatorMutator,>=,==,3,0.0653169,input.length() <mask> 2,", List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length()<mask>2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
          "
1160,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16432,16435,BinaryOperatorMutator,>=,-,4,0.019361442,input.length() <mask> 2,", List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length()<mask>2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
          "
1161,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16424,16429,MethodCallMutator,length,len,1,3.5241456E-4,input.<mask>(),"<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.<mask>() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
        "
1162,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16424,16429,MethodCallMutator,length,size,2,2.754698E-4,input.<mask>(),"<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.<mask>() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
        "
1163,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16424,16429,MethodCallMutator,length,width,3,2.563472E-4,input.<mask>(),"<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.<mask>() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
        "
1164,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16418,16422,IdentifierMutator-Variable,input,output,1,0.001989383,<mask>," final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (<mask>.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
      "
1165,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16418,16422,IdentifierMutator-Variable,input,in,3,2.4082087E-4,<mask>," final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (<mask>.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
      "
1166,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16418,16422,IdentifierMutator-Variable,input,Input,4,1.9320074E-4,<mask>," final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (<mask>.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
      "
1167,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16436,16436,IdentifierMutator-Literal,2,3,1,0.18056062,<mask>," List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >=<mask> && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
           "
1168,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16436,16436,IdentifierMutator-Literal,2,4,2,0.09749763,<mask>," List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >=<mask> && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
           "
1169,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16436,16436,IdentifierMutator-Literal,2,6,3,0.022030711,<mask>," List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >=<mask> && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
           "
1170,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16436,16436,IdentifierMutator-Literal,2,5,4,0.018024793,<mask>," List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >=<mask> && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
           "
1171,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16463,16468,MethodCallMutator,equals,match,0,0.4710541,"input.substring(0, 2).<mask>(""d'"")","(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).<mask>(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder ="
1172,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16463,16468,MethodCallMutator,equals,is,1,0.1901275,"input.substring(0, 2).<mask>(""d'"")","(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).<mask>(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder ="
1173,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16463,16468,MethodCallMutator,equals,has,2,0.059234142,"input.substring(0, 2).<mask>(""d'"")","(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).<mask>(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder ="
1174,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16463,16468,MethodCallMutator,equals,split,3,0.053604197,"input.substring(0, 2).<mask>(""d'"")","(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).<mask>(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder ="
1175,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16463,16468,MethodCallMutator,equals,include,4,0.023017399,"input.substring(0, 2).<mask>(""d'"")","(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).<mask>(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder ="
1176,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16447,16455,MethodCallMutator,substring,slice,0,0.6615979,"input.<mask>(0, 2)"," rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.<mask>(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                "
1177,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16447,16455,MethodCallMutator,substring,ring,1,0.14665087,"input.<mask>(0, 2)"," rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.<mask>(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                "
1178,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16447,16455,MethodCallMutator,substring,string,2,0.042549174,"input.<mask>(0, 2)"," rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.<mask>(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                "
1179,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16447,16455,MethodCallMutator,substring,fill,3,0.018682264,"input.<mask>(0, 2)"," rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.<mask>(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                "
1180,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16447,16455,MethodCallMutator,substring,char,4,0.018156234,"input.<mask>(0, 2)"," rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.<mask>(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                "
1181,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16441,16445,IdentifierMutator-Variable,input,output,1,5.0147186E-4,<mask>,"Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 &&<mask>.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
             "
1182,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16441,16445,IdentifierMutator-Variable,input,text,2,5.9253583E-5,<mask>,"Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 &&<mask>.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
             "
1183,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16441,16445,IdentifierMutator-Variable,input,in,4,2.9385177E-5,<mask>,"Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 &&<mask>.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
             "
1184,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16457,16457,IdentifierMutator-Literal,0,1,1,0.2863233,<mask>,".getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(<mask>, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                  "
1185,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16457,16457,IdentifierMutator-Literal,0,2,2,0.114206314,<mask>,".getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(<mask>, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                  "
1186,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16457,16457,IdentifierMutator-Literal,0,3,3,0.0021851591,<mask>,".getInstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(<mask>, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                  "
1187,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16460,16460,IdentifierMutator-Literal,2,1,2,0.011408991,<mask>,"InstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0,<mask>).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final"
1188,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16460,16460,IdentifierMutator-Literal,2,3,3,0.0015084972,<mask>,"InstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0,<mask>).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final"
1189,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16460,16460,IdentifierMutator-Literal,2,1,4,7.5471523E-4,<mask>,"InstanceMap(this.nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0,<mask>).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final"
1190,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16470,16473,IdentifierMutator-Literal,"""d'""",d,0,0.7048669,<mask>,"nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(<mask>)) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.sub"
1191,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16470,16473,IdentifierMutator-Literal,"""d'""","''",1,0.036499947,<mask>,"nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(<mask>)) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.sub"
1192,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16470,16473,IdentifierMutator-Literal,"""d'""",-,2,0.019487033,<mask>,"nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(<mask>)) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.sub"
1193,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16470,16473,IdentifierMutator-Literal,"""d'""","""""",3,0.014276637,<mask>,"nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(<mask>)) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.sub"
1194,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,409,16470,16473,IdentifierMutator-Literal,"""d'""","-'",4,0.013197626,<mask>,"nameType, RuleType.RULES, languageSet);
        // rules common across many (all) languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(<mask>)) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.sub"
1195,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,410,16542,16550,MethodCallMutator,substring,slice,0,0.7282793,input.<mask>(2),"        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.<mask>(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                "
1196,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,410,16542,16550,MethodCallMutator,substring,ring,1,0.054473523,input.<mask>(2),"        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.<mask>(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                "
1197,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,410,16542,16550,MethodCallMutator,substring,get,2,0.032955147,input.<mask>(2),"        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.<mask>(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                "
1198,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,410,16542,16550,MethodCallMutator,substring,shift,3,0.031773154,input.<mask>(2),"        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.<mask>(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                "
1199,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,410,16542,16550,MethodCallMutator,substring,split,4,0.014730641,input.<mask>(2),"        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.<mask>(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                "
1200,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,410,16536,16540,IdentifierMutator-Variable,input,output,1,0.0012745986,<mask>," languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder =<mask>.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
             "
1201,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,410,16536,16540,IdentifierMutator-Variable,input,remainder,2,1.1841242E-4,<mask>," languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder =<mask>.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
             "
1202,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,410,16536,16540,IdentifierMutator-Variable,input,text,3,4.3996155E-5,<mask>," languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder =<mask>.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
             "
1203,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,410,16536,16540,IdentifierMutator-Variable,input,original,4,4.2005293E-5,<mask>," languages
        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder =<mask>.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
             "
1204,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,410,16552,16552,IdentifierMutator-Literal,2,1,1,0.0035017664,<mask>,"     final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(<mask>);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                  "
1205,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,410,16552,16552,IdentifierMutator-Literal,2,3,2,0.0029587038,<mask>,"     final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(<mask>);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                  "
1206,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,410,16552,16552,IdentifierMutator-Literal,2,4,3,0.0012963421,<mask>,"     final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(<mask>);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                  "
1207,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,411,16599,16601,BinaryOperatorMutator,+,//,2,6.2003406E-4,"""d"" <mask> remainder","nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d""<mask>remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
       "
1208,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,411,16599,16601,BinaryOperatorMutator,+,"""+",3,5.681792E-4,"""d"" <mask> remainder","nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d""<mask>remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
       "
1209,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,411,16599,16601,BinaryOperatorMutator,+,//,4,2.2359661E-4,"""d"" <mask> remainder","nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d""<mask>remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
       "
1210,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,411,16596,16598,IdentifierMutator-Literal,"""d""",l,0,0.62499577,<mask>,"(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined =<mask> + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
        "
1211,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,411,16596,16598,IdentifierMutator-Literal,"""d""","""""",1,0.11093655,<mask>,"(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined =<mask> + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
        "
1212,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,411,16596,16598,IdentifierMutator-Literal,"""d""","''",2,0.023956615,<mask>,"(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined =<mask> + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
        "
1213,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,411,16596,16598,IdentifierMutator-Literal,"""d""",r,3,0.02132093,<mask>,"(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined =<mask> + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
        "
1214,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,411,16596,16598,IdentifierMutator-Literal,"""d""",remainder,4,0.017146856,<mask>,"(this.nameType, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined =<mask> + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
        "
1215,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,411,16602,16610,IdentifierMutator-Variable,remainder,input,1,0.0026252011,<mask>,"Type, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" +<mask>;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
          "
1216,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,411,16602,16610,IdentifierMutator-Variable,remainder,remaining,2,0.0011376431,<mask>,"Type, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" +<mask>;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
          "
1217,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,411,16602,16610,IdentifierMutator-Variable,remainder,output,3,7.6281803E-4,<mask>,"Type, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" +<mask>;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
          "
1218,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,411,16602,16610,IdentifierMutator-Variable,remainder,result,4,7.545582E-4,<mask>,"Type, this.ruleType, ""common"");
        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" +<mask>;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
          "
1219,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16686,16688,BinaryOperatorMutator,+,)+,2,0.0025364237,"(((""("" + encode(remainder)) + "")-("") + encode(combined)) <mask> "")""","        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined)<mask>"")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
     "
1220,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16686,16688,BinaryOperatorMutator,+,"\",3,4.0457462E-4,"(((""("" + encode(remainder)) + "")-("") + encode(combined)) <mask> "")""","        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined)<mask>"")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
     "
1221,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16686,16688,BinaryOperatorMutator,+,//,4,2.5876236E-4,"(((""("" + encode(remainder)) + "")-("") + encode(combined)) <mask> "")""","        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined)<mask>"")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
     "
1222,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16667,16669,BinaryOperatorMutator,+,"""+",2,0.0014480749,"((""("" + encode(remainder)) + "")-("") <mask> encode(combined)"," if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-(""<mask>encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + """
1223,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16667,16669,BinaryOperatorMutator,+,+(,3,1.6042545E-4,"((""("" + encode(remainder)) + "")-("") <mask> encode(combined)"," if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-(""<mask>encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + """
1224,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16667,16669,BinaryOperatorMutator,+,.,4,7.758452E-5,"((""("" + encode(remainder)) + "")-("") <mask> encode(combined)"," if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-(""<mask>encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + """
1225,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16659,16661,BinaryOperatorMutator,+,"\",2,2.3876516E-4,"(""("" + encode(remainder)) <mask> "")-("""," be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder)<mask>"")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined"
1226,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16659,16661,BinaryOperatorMutator,+,)+,3,6.8898924E-5,"(""("" + encode(remainder)) <mask> "")-("""," be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder)<mask>"")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined"
1227,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16659,16661,BinaryOperatorMutator,+,"\",4,5.800367E-5,"(""("" + encode(remainder)) <mask> "")-("""," be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder)<mask>"")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined"
1228,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16639,16641,BinaryOperatorMutator,+,+(,2,4.1147132E-4,"""("" <mask> encode(remainder)"," apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""(""<mask>encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) +"
1229,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16639,16641,BinaryOperatorMutator,+,"""+",3,1.6932418E-4,"""("" <mask> encode(remainder)"," apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""(""<mask>encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) +"
1230,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16639,16641,BinaryOperatorMutator,+,(,4,4.851682E-5,"""("" <mask> encode(remainder)"," apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""(""<mask>encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) +"
1231,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16636,16638,IdentifierMutator-Literal,"""(""","(""",0,0.70429677,<mask>," rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return<mask> + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) +"
1232,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16636,16638,IdentifierMutator-Literal,"""(""","(""",1,0.2161534,<mask>," rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return<mask> + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) +"
1233,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16636,16638,IdentifierMutator-Literal,"""(""","""(",2,0.06806306,<mask>," rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return<mask> + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) +"
1234,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16636,16638,IdentifierMutator-Literal,"""(""","""",3,0.003552274,<mask>," rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return<mask> + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) +"
1235,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16636,16638,IdentifierMutator-Literal,"""(""",((,4,0.003344961,<mask>," rules that apply to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return<mask> + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) +"
1236,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16642,16647,MethodCallMutator,encode,decode,1,0.00299149,<mask>(remainder)," to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" +<mask>(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-"
1237,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16642,16647,MethodCallMutator,encode,encoded,2,1.5768065E-4,<mask>(remainder)," to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" +<mask>(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-"
1238,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16642,16647,MethodCallMutator,encode,escape,3,9.262252E-5,<mask>(remainder)," to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" +<mask>(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-"
1239,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16642,16647,MethodCallMutator,encode,encrypt,4,3.7196158E-5,<mask>(remainder)," to a specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" +<mask>(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-"
1240,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16649,16657,IdentifierMutator-Variable,remainder,input,0,0.21392219,<mask>," specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(<mask>) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode("
1241,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16649,16657,IdentifierMutator-Variable,remainder,original,1,0.1011789,<mask>," specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(<mask>) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode("
1242,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16649,16657,IdentifierMutator-Variable,remainder,partial,2,0.08247451,<mask>," specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(<mask>) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode("
1243,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16649,16657,IdentifierMutator-Variable,remainder,result,3,0.06012893,<mask>," specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(<mask>) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode("
1244,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16649,16657,IdentifierMutator-Variable,remainder,joined,4,0.0507882,<mask>," specific language that may be ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(<mask>) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode("
1245,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16662,16666,IdentifierMutator-Literal,""")-(""","""",0,0.6011678,<mask>," ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) +<mask> + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + """
1246,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16662,16666,IdentifierMutator-Literal,""")-(""","""""",1,0.32673833,<mask>," ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) +<mask> + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + """
1247,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16662,16666,IdentifierMutator-Literal,""")-(""",""",",2,0.013232914,<mask>," ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) +<mask> + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + """
1248,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16662,16666,IdentifierMutator-Literal,""")-(""","""",3,0.007852709,<mask>," ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) +<mask> + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + """
1249,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16662,16666,IdentifierMutator-Literal,""")-(""",1,4,0.0031047505,<mask>," ambiguous or wrong if applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) +<mask> + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + """
1250,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16670,16675,MethodCallMutator,encode,decode,1,9.184557E-4,<mask>(combined)," applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" +<mask>(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";"
1251,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16670,16675,MethodCallMutator,encode,encoded,2,1.09800654E-4,<mask>(combined)," applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" +<mask>(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";"
1252,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16670,16675,MethodCallMutator,encode,escape,3,4.3820284E-5,<mask>(combined)," applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" +<mask>(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";"
1253,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16670,16675,MethodCallMutator,encode,enc,4,1.6196847E-5,<mask>(combined)," applied to other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" +<mask>(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";"
1254,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16677,16684,IdentifierMutator-Variable,combined,joined,0,0.35916752,<mask>," other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(<mask>) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
  "
1255,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16677,16684,IdentifierMutator-Variable,combined,result,2,0.067842685,<mask>," other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(<mask>) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
  "
1256,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16677,16684,IdentifierMutator-Variable,combined,input,3,0.033902828,<mask>," other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(<mask>) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
  "
1257,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16677,16684,IdentifierMutator-Variable,combined,comb,4,0.011458153,<mask>," other languages
        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(<mask>) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
  "
1258,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16689,16691,IdentifierMutator-Literal,""")""","""",0,0.8201538,<mask>,"       final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) +<mask>;
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
      "
1259,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16689,16691,IdentifierMutator-Literal,""")""",")""",1,0.123214275,<mask>,"       final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) +<mask>;
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
      "
1260,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16689,16691,IdentifierMutator-Literal,""")""","""""",2,0.023297278,<mask>,"       final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) +<mask>;
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
      "
1261,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16689,16691,IdentifierMutator-Literal,""")""",""")",3,0.017968692,<mask>,"       final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) +<mask>;
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
      "
1262,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,412,16689,16691,IdentifierMutator-Literal,""")""",").""",4,0.0031079273,<mask>,"       final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) +<mask>;
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
      "
1263,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16756,16758,MethodCallMutator,get,keys,1,0.035062496,NAME_PREFIXES.<mask>(this.nameType),"      // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.<mask>(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

       "
1264,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16756,16758,MethodCallMutator,get,values,2,0.011164724,NAME_PREFIXES.<mask>(this.nameType),"      // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.<mask>(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

       "
1265,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16756,16758,MethodCallMutator,get,list,3,0.0035576543,NAME_PREFIXES.<mask>(this.nameType),"      // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.<mask>(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

       "
1266,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16756,16758,MethodCallMutator,get,key,4,0.0018365389,NAME_PREFIXES.<mask>(this.nameType),"      // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.<mask>(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

       "
1267,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16742,16754,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.PhoneticEngine.NAME_PREFIXES,names,0,0.23111387,<mask>,", languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l :<mask>.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

     "
1268,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16742,16754,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.PhoneticEngine.NAME_PREFIXES,words,1,0.20467569,<mask>,", languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l :<mask>.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

     "
1269,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16742,16754,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.PhoneticEngine.NAME_PREFIXES,list,2,0.04259265,<mask>,", languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l :<mask>.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

     "
1270,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16742,16754,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.PhoneticEngine.NAME_PREFIXES,map,3,0.03509384,<mask>,", languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l :<mask>.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

     "
1271,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16742,16754,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.PhoneticEngine.NAME_PREFIXES,keywords,4,0.034575637,<mask>,", languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l :<mask>.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

     "
1272,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16742,16754,FieldReferenceMutator,NAME_PREFIXES,names,0,0.23111387,org.apache.commons.codec.language.bm.PhoneticEngine.<mask>,", languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l :<mask>.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

     "
1273,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16742,16754,FieldReferenceMutator,NAME_PREFIXES,words,1,0.20467569,org.apache.commons.codec.language.bm.PhoneticEngine.<mask>,", languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l :<mask>.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

     "
1274,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16742,16754,FieldReferenceMutator,NAME_PREFIXES,list,2,0.04259265,org.apache.commons.codec.language.bm.PhoneticEngine.<mask>,", languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l :<mask>.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

     "
1275,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16742,16754,FieldReferenceMutator,NAME_PREFIXES,map,3,0.03509384,org.apache.commons.codec.language.bm.PhoneticEngine.<mask>,", languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l :<mask>.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

     "
1276,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16742,16754,FieldReferenceMutator,NAME_PREFIXES,keywords,4,0.034575637,org.apache.commons.codec.language.bm.PhoneticEngine.<mask>,", languageSet);

        // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l :<mask>.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

     "
1277,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16760,16772,IdentifierMutator-Variable,this.nameType,name,0,0.17462607,<mask>,"    // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(<mask>)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String>"
1278,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16760,16772,IdentifierMutator-Variable,this.nameType,this,1,0.10221571,<mask>,"    // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(<mask>)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String>"
1279,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16760,16772,IdentifierMutator-Variable,this.nameType,type,2,0.045745004,<mask>,"    // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(<mask>)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String>"
1280,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16760,16772,IdentifierMutator-Variable,this.nameType,word,3,0.045339394,<mask>,"    // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(<mask>)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String>"
1281,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16760,16772,IdentifierMutator-Variable,this.nameType,null,4,0.03265705,<mask>,"    // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(<mask>)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String>"
1282,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16760,16763,IdentifierMutator-ThisAccess,this,super,2,8.634117E-4,<mask>,"    // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(<mask>.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List"
1283,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16760,16763,IdentifierMutator-ThisAccess,this,This,3,8.028993E-4,<mask>,"    // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(<mask>.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List"
1284,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16760,16763,IdentifierMutator-ThisAccess,this,name,4,7.551649E-5,<mask>,"    // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(<mask>.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List"
1285,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16765,16772,FieldReferenceMutator,nameType,name,0,0.76149654,this.<mask>,"  // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.<mask>)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String>"
1286,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16765,16772,FieldReferenceMutator,nameType,prefix,1,0.048973367,this.<mask>,"  // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.<mask>)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String>"
1287,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16765,16772,FieldReferenceMutator,nameType,type,2,0.038846042,this.<mask>,"  // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.<mask>)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String>"
1288,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16765,16772,FieldReferenceMutator,nameType,language,3,0.014488087,this.<mask>,"  // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.<mask>)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String>"
1289,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,414,16765,16772,FieldReferenceMutator,nameType,pattern,4,0.008966925,this.<mask>,"  // tidy the input
        // lower case is a locale-dependent operation
        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.<mask>)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String>"
1290,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16847,16856,MethodCallMutator,startsWith,has,0,0.28961384,"input.<mask>(l + "" "")","replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.<mask>(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

     "
1291,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16847,16856,MethodCallMutator,startsWith,includes,1,0.12543371,"input.<mask>(l + "" "")","replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.<mask>(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

     "
1292,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16847,16856,MethodCallMutator,startsWith,append,2,0.11716331,"input.<mask>(l + "" "")","replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.<mask>(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

     "
1293,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16847,16856,MethodCallMutator,startsWith,match,3,0.08874078,"input.<mask>(l + "" "")","replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.<mask>(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

     "
1294,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16847,16856,MethodCallMutator,startsWith,remove,4,0.06259768,"input.<mask>(l + "" "")","replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.<mask>(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

     "
1295,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16841,16845,IdentifierMutator-Variable,input,output,1,0.0027812659,<mask>,"ISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (<mask>.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

 "
1296,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16841,16845,IdentifierMutator-Variable,input,word,2,0.002008899,<mask>,"ISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (<mask>.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

 "
1297,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16841,16845,IdentifierMutator-Variable,input,Input,3,0.0011289621,<mask>,"ISH).replace('-', ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (<mask>.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

 "
1298,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16859,16861,BinaryOperatorMutator,+,)+,0,0.68524504,"l <mask> "" """," ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l<mask>"" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        //"
1299,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16859,16861,BinaryOperatorMutator,+,)(,3,0.0045121503,"l <mask> "" """," ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l<mask>"" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        //"
1300,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16859,16861,BinaryOperatorMutator,+,).,4,8.718403E-4,"l <mask> "" """," ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l<mask>"" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        //"
1301,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16858,16858,IdentifierMutator-Variable,l,lc,1,0.008253948,<mask>," ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(<mask> + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

       "
1302,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16858,16858,IdentifierMutator-Variable,l,L,2,0.005775729,<mask>," ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(<mask> + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

       "
1303,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16858,16858,IdentifierMutator-Variable,l,lr,3,0.002961878,<mask>," ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(<mask> + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

       "
1304,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16858,16858,IdentifierMutator-Variable,l,r,4,0.0027641146,<mask>," ' ').trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(<mask> + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

       "
1305,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16862,16864,IdentifierMutator-Literal,"""""",1,0,0.41597807,<mask>,").trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l +<mask>)) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-"
1306,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16862,16864,IdentifierMutator-Literal,"""""","""",2,0.09308568,<mask>,").trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l +<mask>)) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-"
1307,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16862,16864,IdentifierMutator-Literal,"""""",remainder,3,0.06626938,<mask>,").trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l +<mask>)) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-"
1308,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,416,16862,16864,IdentifierMutator-Literal,"""""",suffix,4,0.034613255,<mask>,").trim();

        if (this.nameType == NameType.GENERIC) {
            if (input.length() >= 2 && input.substring(0, 2).equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l +<mask>)) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-"
1309,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,16983,16991,MethodCallMutator,substring,slice,0,0.3135053,input.<mask>(l.length() + 1),"(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.<mask>(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord"
1310,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,16983,16991,MethodCallMutator,substring,ring,1,0.20778823,input.<mask>(l.length() + 1),"(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.<mask>(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord"
1311,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,16983,16991,MethodCallMutator,substring,get,2,0.19313432,input.<mask>(l.length() + 1),"(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.<mask>(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord"
1312,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,16983,16991,MethodCallMutator,substring,remove,3,0.041018054,input.<mask>(l.length() + 1),"(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.<mask>(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord"
1313,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,16983,16991,MethodCallMutator,substring,shift,4,0.025333276,input.<mask>(l.length() + 1),"(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.<mask>(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord"
1314,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,16977,16981,IdentifierMutator-Variable,input,l,1,0.0016123714,<mask>,"equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder =<mask>.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final"
1315,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,16977,16981,IdentifierMutator-Variable,input,output,2,0.0010869846,<mask>,"equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder =<mask>.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final"
1316,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,16977,16981,IdentifierMutator-Variable,input,original,3,2.3430005E-4,<mask>,"equals(""d'"")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder =<mask>.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final"
1317,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,17003,17005,BinaryOperatorMutator,+,-,0,0.43853527,l.length() <mask> 1," for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length()<mask>1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
 "
1318,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,17003,17005,BinaryOperatorMutator,+,)+,2,0.086916186,l.length() <mask> 1," for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length()<mask>1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
 "
1319,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,17003,17005,BinaryOperatorMutator,+,)-,3,0.08488966,l.length() <mask> 1," for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length()<mask>1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
 "
1320,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,17003,17005,BinaryOperatorMutator,+,",-",4,0.006066903,l.length() <mask> 1," for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length()<mask>1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
 "
1321,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,16995,17000,MethodCallMutator,length,width,1,6.98071E-5,l.<mask>()," // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.<mask>() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {"
1322,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,16995,17000,MethodCallMutator,length,position,3,3.46557E-5,l.<mask>()," // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.<mask>() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {"
1323,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,16995,17000,MethodCallMutator,length,len,4,3.4651403E-5,l.<mask>()," // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.<mask>() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {"
1324,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,16993,16993,IdentifierMutator-Variable,l,input,0,0.73927784,<mask>,")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(<mask>.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words"
1325,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,16993,16993,IdentifierMutator-Variable,l,lc,2,0.012827201,<mask>,")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(<mask>.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words"
1326,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,16993,16993,IdentifierMutator-Variable,l,L,3,0.006218893,<mask>,")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(<mask>.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words"
1327,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,16993,16993,IdentifierMutator-Variable,l,output,4,0.0055218167,<mask>,")) { // check for d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(<mask>.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words"
1328,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,17006,17006,IdentifierMutator-Literal,1,2,1,0.24860877,<mask>," d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() +<mask>); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
  "
1329,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,17006,17006,IdentifierMutator-Literal,1,3,2,0.009182254,<mask>," d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() +<mask>); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
  "
1330,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,418,17006,17006,IdentifierMutator-Literal,1,4,3,0.007426073,<mask>," d'
                final String remainder = input.substring(2);
                final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() +<mask>); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
  "
1331,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,419,17083,17085,BinaryOperatorMutator,+,-,2,0.009808154,l <mask> remainder,"              final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l<mask>remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
    "
1332,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,419,17083,17085,BinaryOperatorMutator,+,.,3,0.008095421,l <mask> remainder,"              final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l<mask>remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
    "
1333,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,419,17083,17085,BinaryOperatorMutator,+,)+,4,0.0055105505,l <mask> remainder,"              final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l<mask>remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
    "
1334,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,419,17082,17082,IdentifierMutator-Variable,l,"""""",1,0.009178856,<mask>,"               final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined =<mask> + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
     "
1335,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,419,17082,17082,IdentifierMutator-Variable,l,L,2,0.0014578162,<mask>,"               final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined =<mask> + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
     "
1336,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,419,17082,17082,IdentifierMutator-Variable,l,left,3,0.0012540236,<mask>,"               final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined =<mask> + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
     "
1337,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,419,17082,17082,IdentifierMutator-Variable,l,combined,4,8.1058947E-4,<mask>,"               final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined =<mask> + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
     "
1338,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,419,17086,17094,IdentifierMutator-Variable,remainder,combined,0,0.91652584,<mask>,"             final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l +<mask>; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
       "
1339,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,419,17086,17094,IdentifierMutator-Variable,remainder,"""""",2,0.009390824,<mask>,"             final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l +<mask>; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
       "
1340,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,419,17086,17094,IdentifierMutator-Variable,remainder,result,3,0.0066052345,<mask>,"             final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l +<mask>; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
       "
1341,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,419,17086,17094,IdentifierMutator-Variable,remainder,suffix,4,0.0041955444,<mask>,"             final String combined = ""d"" + remainder;
                return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l +<mask>; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
       "
1342,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17209,17211,BinaryOperatorMutator,+,)+,2,0.0014505843,"(((""("" + encode(remainder)) + "")-("") + encode(combined)) <mask> "")"""," + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined)<mask>"")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
   "
1343,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17209,17211,BinaryOperatorMutator,+,"\",3,5.0863024E-4,"(((""("" + encode(remainder)) + "")-("") + encode(combined)) <mask> "")"""," + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined)<mask>"")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
   "
1344,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17209,17211,BinaryOperatorMutator,+,"\",4,4.051497E-4,"(((""("" + encode(remainder)) + "")-("") + encode(combined)) <mask> "")"""," + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined)<mask>"")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
   "
1345,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17190,17192,BinaryOperatorMutator,+,"""+",2,0.004569144,"((""("" + encode(remainder)) + "")-("") <mask> encode(combined)"," encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-(""<mask>encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add"
1346,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17190,17192,BinaryOperatorMutator,+,+(,3,2.0915944E-4,"((""("" + encode(remainder)) + "")-("") <mask> encode(combined)"," encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-(""<mask>encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add"
1347,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17190,17192,BinaryOperatorMutator,+,.,4,5.729247E-5,"((""("" + encode(remainder)) + "")-("") <mask> encode(combined)"," encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-(""<mask>encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add"
1348,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17182,17184,BinaryOperatorMutator,+,"\",2,4.2966037E-4,"(""("" + encode(remainder)) <mask> "")-("""," return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder)<mask>"")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words"
1349,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17182,17184,BinaryOperatorMutator,+,"\",3,2.612173E-4,"(""("" + encode(remainder)) <mask> "")-("""," return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder)<mask>"")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words"
1350,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17182,17184,BinaryOperatorMutator,+,)+,4,2.0214358E-4,"(""("" + encode(remainder)) <mask> "")-("""," return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder)<mask>"")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words"
1351,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17162,17164,BinaryOperatorMutator,+,+(,2,2.3973503E-4,"""("" <mask> encode(remainder)","        return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""(""<mask>encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
        "
1352,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17162,17164,BinaryOperatorMutator,+,"""+",3,5.397144E-5,"""("" <mask> encode(remainder)","        return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""(""<mask>encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
        "
1353,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17162,17164,BinaryOperatorMutator,+,++,4,5.3776817E-5,"""("" <mask> encode(remainder)","        return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""(""<mask>encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
        "
1354,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17159,17161,IdentifierMutator-Literal,"""(""","(""",0,0.71873295,<mask>,"          return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return<mask> + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
        "
1355,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17159,17161,IdentifierMutator-Literal,"""(""","""(",1,0.16833718,<mask>,"          return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return<mask> + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
        "
1356,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17159,17161,IdentifierMutator-Literal,"""(""","(""",2,0.09921338,<mask>,"          return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return<mask> + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
        "
1357,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17159,17161,IdentifierMutator-Literal,"""(""","""",3,0.0047762506,<mask>,"          return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return<mask> + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
        "
1358,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17159,17161,IdentifierMutator-Literal,"""(""",(,4,0.0037463203,<mask>,"          return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return<mask> + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
        "
1359,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17165,17170,MethodCallMutator,encode,decode,1,3.5179E-4,<mask>(remainder),"       return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" +<mask>(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
          "
1360,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17165,17170,MethodCallMutator,encode,encoded,2,7.893215E-5,<mask>(remainder),"       return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" +<mask>(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
          "
1361,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17165,17170,MethodCallMutator,encode,enc,3,1.792358E-5,<mask>(remainder),"       return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" +<mask>(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
          "
1362,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17165,17170,MethodCallMutator,encode,encrypt,4,9.8608225E-6,<mask>(remainder),"       return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" +<mask>(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
          "
1363,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17172,17180,IdentifierMutator-Variable,remainder,inner,1,0.120073445,<mask>,"     return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(<mask>) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
              "
1364,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17172,17180,IdentifierMutator-Variable,remainder,word,2,0.07236809,<mask>,"     return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(<mask>) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
              "
1365,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17172,17180,IdentifierMutator-Variable,remainder,partial,3,0.060203943,<mask>,"     return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(<mask>) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
              "
1366,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17172,17180,IdentifierMutator-Variable,remainder,result,4,0.03541125,<mask>,"     return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(<mask>) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
              "
1367,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17185,17189,IdentifierMutator-Literal,""")-(""","""",0,0.60218126,<mask>," ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) +<mask> + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add"
1368,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17185,17189,IdentifierMutator-Literal,""")-(""","""""",1,0.29493648,<mask>," ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) +<mask> + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add"
1369,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17185,17189,IdentifierMutator-Literal,""")-(""",l,2,0.030470485,<mask>," ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) +<mask> + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add"
1370,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17185,17189,IdentifierMutator-Literal,""")-(""",""",",3,0.0071325935,<mask>," ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) +<mask> + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add"
1371,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17185,17189,IdentifierMutator-Literal,""")-(""",1,4,0.0068396274,<mask>," ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) +<mask> + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add"
1372,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17193,17198,MethodCallMutator,encode,decode,1,0.0025575475,<mask>(combined),"(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" +<mask>(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(last"
1373,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17193,17198,MethodCallMutator,encode,encoded,2,2.6282034E-4,<mask>(combined),"(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" +<mask>(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(last"
1374,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17193,17198,MethodCallMutator,encode,enc,3,4.4349326E-5,<mask>(combined),"(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" +<mask>(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(last"
1375,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17193,17198,MethodCallMutator,encode,eval,4,2.8299697E-5,<mask>(combined),"(remainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" +<mask>(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(last"
1376,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17200,17207,IdentifierMutator-Variable,combined,joined,1,0.3485655,<mask>,"ainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(<mask>) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
"
1377,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17200,17207,IdentifierMutator-Variable,combined,result,2,0.041884363,<mask>,"ainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(<mask>) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
"
1378,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17200,17207,IdentifierMutator-Variable,combined,comb,3,0.018623972,<mask>,"ainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(<mask>) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
"
1379,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17200,17207,IdentifierMutator-Variable,combined,input,4,0.0069786636,<mask>,"ainder) + "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(<mask>) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
"
1380,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17212,17214,IdentifierMutator-Literal,""")""","""",0,0.9578686,<mask>," "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) +<mask>;
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
    "
1381,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17212,17214,IdentifierMutator-Literal,""")""",")""",1,0.02303672,<mask>," "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) +<mask>;
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
    "
1382,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17212,17214,IdentifierMutator-Literal,""")""",""")",2,0.0091579575,<mask>," "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) +<mask>;
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
    "
1383,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17212,17214,IdentifierMutator-Literal,""")""","""""",3,0.002843729,<mask>," "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) +<mask>;
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
    "
1384,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,420,17212,17214,IdentifierMutator-Literal,""")""",),4,0.001459679,<mask>," "")-("" + encode(combined) + "")"";
            }
            for (final String l : NAME_PREFIXES.get(this.nameType)) {
                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) +<mask>;
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
    "
1385,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,425,17302,17307,MethodCallMutator,asList,filter,0,0.19292136,"Arrays.<mask>(input.split(""\\s+""))","                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.<mask>(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
     "
1386,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,425,17302,17307,MethodCallMutator,asList,List,1,0.17652074,"Arrays.<mask>(input.split(""\\s+""))","                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.<mask>(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
     "
1387,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,425,17302,17307,MethodCallMutator,asList,copy,2,0.15748575,"Arrays.<mask>(input.split(""\\s+""))","                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.<mask>(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
     "
1388,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,425,17302,17307,MethodCallMutator,asList,as,3,0.09946512,"Arrays.<mask>(input.split(""\\s+""))","                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.<mask>(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
     "
1389,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,425,17302,17307,MethodCallMutator,asList,list,4,0.054182317,"Arrays.<mask>(input.split(""\\s+""))","                // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.<mask>(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
     "
1390,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,425,17315,17319,MethodCallMutator,split,strip,2,8.0952486E-5,"input.<mask>(""\\s+"")","           // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.<mask>(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case AS"
1391,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,425,17315,17319,MethodCallMutator,split,Split,3,6.087058E-5,"input.<mask>(""\\s+"")","           // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.<mask>(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case AS"
1392,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,425,17315,17319,MethodCallMutator,split,map,4,3.289828E-5,"input.<mask>(""\\s+"")","           // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.<mask>(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case AS"
1393,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,425,17309,17313,IdentifierMutator-Variable,input,word,1,0.041235983,<mask>,"             // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(<mask>.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
       "
1394,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,425,17309,17313,IdentifierMutator-Variable,input,output,2,0.024827022,<mask>,"             // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(<mask>.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
       "
1395,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,425,17309,17313,IdentifierMutator-Variable,input,string,3,0.022400104,<mask>,"             // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(<mask>.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
       "
1396,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,425,17309,17313,IdentifierMutator-Variable,input,prefix,4,0.02050787,<mask>,"             // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(<mask>.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
       "
1397,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,425,17321,17326,IdentifierMutator-Literal,"""\\s+""",l,0,0.1253814,<mask>,"         // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(<mask>));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:"
1398,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,425,17321,17326,IdentifierMutator-Literal,"""\\s+""",L,1,0.070090994,<mask>,"         // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(<mask>));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:"
1399,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,425,17321,17326,IdentifierMutator-Literal,"""\\s+""","''",2,0.04201802,<mask>,"         // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(<mask>));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:"
1400,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,425,17321,17326,IdentifierMutator-Literal,"""\\s+""",/,3,0.040921126,<mask>,"         // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(<mask>));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:"
1401,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,425,17321,17326,IdentifierMutator-Literal,"""\\s+""",""":""",4,0.03232423,<mask>,"         // handle generic prefixes
                if (input.startsWith(l + "" "")) {
                    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(<mask>));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:"
1402,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,429,17484,17496,IdentifierMutator-Variable,this.nameType,type,0,0.96612865,<mask>,"    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (<mask>) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
       "
1403,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,429,17484,17496,IdentifierMutator-Variable,this.nameType,name,1,0.005885118,<mask>,"    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (<mask>) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
       "
1404,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,429,17484,17496,IdentifierMutator-Variable,this.nameType,case,2,0.0021534124,<mask>,"    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (<mask>) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
       "
1405,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,429,17484,17496,IdentifierMutator-Variable,this.nameType,mode,3,0.001693833,<mask>,"    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (<mask>) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
       "
1406,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,429,17484,17496,IdentifierMutator-Variable,this.nameType,this,4,0.0013302746,<mask>,"    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (<mask>) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
       "
1407,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,429,17484,17487,IdentifierMutator-ThisAccess,this,This,2,2.7346562E-4,<mask>,"    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (<mask>.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
    "
1408,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,429,17484,17487,IdentifierMutator-ThisAccess,this,super,3,1.0942322E-4,<mask>,"    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (<mask>.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
    "
1409,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,429,17484,17487,IdentifierMutator-ThisAccess,this,options,4,3.0082061E-5,<mask>,"    // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (<mask>.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
    "
1410,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,429,17489,17496,FieldReferenceMutator,nameType,type,0,0.9508908,this.<mask>,"  // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.<mask>) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
       "
1411,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,429,17489,17496,FieldReferenceMutator,nameType,name,1,0.0159286,this.<mask>,"  // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.<mask>) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
       "
1412,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,429,17489,17496,FieldReferenceMutator,nameType,kind,2,0.0061705043,this.<mask>,"  // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.<mask>) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
       "
1413,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,429,17489,17496,FieldReferenceMutator,nameType,case,3,0.0016154192,this.<mask>,"  // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.<mask>) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
       "
1414,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,429,17489,17496,FieldReferenceMutator,nameType,style,4,0.0014584023,this.<mask>,"  // check for any prefix in the words list
                    final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.<mask>) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
       "
1415,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,430,17514,17522,IdentifierMutator-Variable,SEPHARDIC,NAME,0,0.18720955,<mask>,"                  final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case<mask>:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case"
1416,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,430,17514,17522,IdentifierMutator-Variable,SEPHARDIC,ASCII,1,0.04706988,<mask>,"                  final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case<mask>:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case"
1417,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,430,17514,17522,IdentifierMutator-Variable,SEPHARDIC,MAP,2,0.04588187,<mask>,"                  final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case<mask>:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case"
1418,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,430,17514,17522,IdentifierMutator-Variable,SEPHARDIC,CASE,3,0.03102309,<mask>,"                  final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case<mask>:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case"
1419,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,430,17514,17522,IdentifierMutator-Variable,SEPHARDIC,TEXT,4,0.029650131,<mask>,"                  final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case<mask>:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case"
1420,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,430,17514,17522,FieldReferenceMutator,SEPHARDIC,NAME,0,0.18720955,<mask>,"                  final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case<mask>:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case"
1421,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,430,17514,17522,FieldReferenceMutator,SEPHARDIC,ASCII,1,0.04706988,<mask>,"                  final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case<mask>:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case"
1422,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,430,17514,17522,FieldReferenceMutator,SEPHARDIC,MAP,2,0.04588187,<mask>,"                  final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case<mask>:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case"
1423,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,430,17514,17522,FieldReferenceMutator,SEPHARDIC,CASE,3,0.03102309,<mask>,"                  final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case<mask>:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case"
1424,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,430,17514,17522,FieldReferenceMutator,SEPHARDIC,TEXT,4,0.029650131,<mask>,"                  final String remainder = input.substring(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case<mask>:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case"
1425,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,431,17563,17567,IdentifierMutator-Variable,words,word,2,0.0071919374,<mask>,"string(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord :<mask>) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll"
1426,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,431,17563,17567,IdentifierMutator-Variable,words,word,3,0.0037692594,<mask>,"string(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord :<mask>) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll"
1427,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,431,17563,17567,IdentifierMutator-Variable,words,keywords,4,0.0031284161,<mask>,"string(l.length() + 1); // input without the prefix
                    final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord :<mask>) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll"
1428,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,432,17617,17621,MethodCallMutator,split,Split,2,2.4199432E-4,"aWord.<mask>(""'"")","        final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.<mask>(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:"
1429,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,432,17617,17621,MethodCallMutator,split,strip,3,1.2184374E-5,"aWord.<mask>(""'"")","        final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.<mask>(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:"
1430,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,432,17617,17621,MethodCallMutator,split,get,4,1.14552895E-5,"aWord.<mask>(""'"")","        final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.<mask>(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:"
1431,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,432,17611,17615,IdentifierMutator-Variable,aWord,word,0,0.94854593,<mask>,"           final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts =<mask>.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
       "
1432,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,432,17611,17615,IdentifierMutator-Variable,aWord,Word,1,0.022193413,<mask>,"           final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts =<mask>.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
       "
1433,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,432,17611,17615,IdentifierMutator-Variable,aWord,word,2,0.018262215,<mask>,"           final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts =<mask>.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
       "
1434,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,432,17611,17615,IdentifierMutator-Variable,aWord,w,3,0.003312255,<mask>,"           final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts =<mask>.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
       "
1435,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,432,17611,17615,IdentifierMutator-Variable,aWord,part,4,0.0017047833,<mask>,"           final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts =<mask>.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
       "
1436,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,432,17623,17625,IdentifierMutator-Literal,"""'""",/,0,0.142521,<mask>,"      final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(<mask>);
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
 "
1437,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,432,17623,17625,IdentifierMutator-Literal,"""'""",word,1,0.10082137,<mask>,"      final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(<mask>);
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
 "
1438,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,432,17623,17625,IdentifierMutator-Literal,"""'""",""",""",2,0.056979403,<mask>,"      final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(<mask>);
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
 "
1439,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,432,17623,17625,IdentifierMutator-Literal,"""'""",""":""",3,0.052055728,<mask>,"      final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(<mask>);
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
 "
1440,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,432,17623,17625,IdentifierMutator-Literal,"""'""",/-,4,0.027574519,<mask>,"      final String combined = l + remainder; // input with prefix without space
                    return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(<mask>);
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
 "
1441,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17675,17690,ArrayAccessMutator,parts.length-1,0,0,0.41225228,parts[<mask>],"               return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[<mask>];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
"
1442,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17675,17690,ArrayAccessMutator,parts.length-1,1,1,0.38420716,parts[<mask>],"               return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[<mask>];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
"
1443,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17675,17690,ArrayAccessMutator,parts.length-1,2,2,0.15636739,parts[<mask>],"               return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[<mask>];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
"
1444,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17675,17690,ArrayAccessMutator,parts.length-1,3,3,0.01363782,parts[<mask>],"               return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[<mask>];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
"
1445,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17675,17690,ArrayAccessMutator,parts.length-1,6,4,0.0057508196,parts[<mask>],"               return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[<mask>];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
"
1446,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17669,17673,IdentifierMutator-Variable,parts,part,2,0.0012416625,<mask>,"                 return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart =<mask>[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" +"
1447,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17669,17673,IdentifierMutator-Variable,parts,words,3,7.715851E-4,<mask>,"                 return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart =<mask>[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" +"
1448,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17669,17673,IdentifierMutator-Variable,parts,word,4,3.433392E-5,<mask>,"                 return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart =<mask>[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" +"
1449,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17687,17689,BinaryOperatorMutator,-,)-,2,0.0022234367,parts.length <mask> 1,"            return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length<mask>1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);"
1450,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17687,17689,BinaryOperatorMutator,-,+,3,4.6721738E-4,parts.length <mask> 1,"            return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length<mask>1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);"
1451,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17687,17689,BinaryOperatorMutator,-,=-,4,1.8410862E-4,parts.length <mask> 1,"            return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length<mask>1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);"
1452,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17675,17686,IdentifierMutator-Variable,parts.length,0,0,0.20963293,<mask>,"               return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[<mask> - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType"
1453,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17675,17686,IdentifierMutator-Variable,parts.length,i,1,0.1995077,<mask>,"               return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[<mask> - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType"
1454,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17675,17686,IdentifierMutator-Variable,parts.length,length,2,0.09034878,<mask>,"               return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[<mask> - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType"
1455,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17675,17686,IdentifierMutator-Variable,parts.length,n,3,0.084066994,<mask>,"               return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[<mask> - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType"
1456,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17675,17686,IdentifierMutator-Variable,parts.length,1,4,0.08298892,<mask>,"               return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[<mask> - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType"
1457,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17675,17679,IdentifierMutator-Variable,parts,part,1,0.00610292,<mask>,"               return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[<mask>.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this."
1458,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17675,17679,IdentifierMutator-Variable,parts,Parts,2,0.0033389556,<mask>,"               return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[<mask>.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this."
1459,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17675,17679,IdentifierMutator-Variable,parts,words,3,0.0013925129,<mask>,"               return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[<mask>.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this."
1460,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17681,17686,FieldReferenceMutator,length,size,1,0.016722899,parts.<mask>,"             return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.<mask> - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType"
1461,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17681,17686,FieldReferenceMutator,length,count,3,1.1010814E-4,parts.<mask>,"             return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.<mask> - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType"
1462,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17681,17686,FieldReferenceMutator,length,nr,4,4.9686267E-5,parts.<mask>,"             return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.<mask> - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType"
1463,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17690,17690,IdentifierMutator-Literal,1,2,1,0.023788558,<mask>,"           return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length -<mask>];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
"
1464,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17690,17690,IdentifierMutator-Literal,1,3,2,0.0022849657,<mask>,"           return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length -<mask>];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
"
1465,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,433,17690,17690,IdentifierMutator-Literal,1,4,4,5.696171E-4,<mask>,"           return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length -<mask>];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
"
1466,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,434,17717,17719,MethodCallMutator,add,remove,1,0.008169861,words2.<mask>(lastPart)," "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.<mask>(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.con"
1467,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,434,17717,17719,MethodCallMutator,add,append,2,0.0019058923,words2.<mask>(lastPart)," "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.<mask>(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.con"
1468,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,434,17717,17719,MethodCallMutator,add,Add,4,3.9031458E-4,words2.<mask>(lastPart)," "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.<mask>(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.con"
1469,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,434,17710,17715,IdentifierMutator-Variable,words2,words,0,0.96998954,<mask>,"         return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];<mask>.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this"
1470,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,434,17710,17715,IdentifierMutator-Variable,words2,words,1,0.012412414,<mask>,"         return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];<mask>.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this"
1471,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,434,17710,17715,IdentifierMutator-Variable,words2,word,2,0.0075568724,<mask>,"         return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];<mask>.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this"
1472,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,434,17710,17715,IdentifierMutator-Variable,words2,parts,3,0.001579704,<mask>,"         return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];<mask>.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this"
1473,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,434,17710,17715,IdentifierMutator-Variable,words2,Words,4,8.169248E-4,<mask>,"         return ""("" + encode(remainder) + "")-("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];<mask>.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this"
1474,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,434,17721,17728,IdentifierMutator-Variable,lastPart,word,0,0.44947067,<mask>,"("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(<mask>);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {"
1475,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,434,17721,17728,IdentifierMutator-Variable,lastPart,part,1,0.32533488,<mask>,"("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(<mask>);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {"
1476,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,434,17721,17728,IdentifierMutator-Variable,lastPart,parts,2,0.10830115,<mask>,"("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(<mask>);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {"
1477,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,434,17721,17728,IdentifierMutator-Variable,lastPart,words,3,0.09085702,<mask>,"("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(<mask>);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {"
1478,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,434,17721,17728,IdentifierMutator-Variable,lastPart,piece,4,0.003698426,<mask>,"("" + encode(combined) + "")"";
                }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(<mask>);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {"
1479,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17765,17773,MethodCallMutator,removeAll,remove,0,0.7787217,words2.<mask>(NAME_PREFIXES.get(this.nameType)),"          }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.<mask>(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input ="
1480,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17765,17773,MethodCallMutator,removeAll,add,1,0.20858511,words2.<mask>(NAME_PREFIXES.get(this.nameType)),"          }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.<mask>(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input ="
1481,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17765,17773,MethodCallMutator,removeAll,delete,2,0.0033934382,words2.<mask>(NAME_PREFIXES.get(this.nameType)),"          }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.<mask>(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input ="
1482,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17765,17773,MethodCallMutator,removeAll,append,3,0.0019068203,words2.<mask>(NAME_PREFIXES.get(this.nameType)),"          }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.<mask>(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input ="
1483,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17765,17773,MethodCallMutator,removeAll,clear,4,0.0013887014,words2.<mask>(NAME_PREFIXES.get(this.nameType)),"          }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.<mask>(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input ="
1484,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17758,17763,IdentifierMutator-Variable,words2,words,0,0.7994592,<mask>,"            }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }<mask>.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
          "
1485,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17758,17763,IdentifierMutator-Variable,words2,words,1,0.1515212,<mask>,"            }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }<mask>.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
          "
1486,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17758,17763,IdentifierMutator-Variable,words2,word,2,0.0230182,<mask>,"            }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }<mask>.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
          "
1487,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17758,17763,IdentifierMutator-Variable,words2,Words,3,0.0057958625,<mask>,"            }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }<mask>.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
          "
1488,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17758,17763,IdentifierMutator-Variable,words2,word,4,0.0029141926,<mask>,"            }
            }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }<mask>.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
          "
1489,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17789,17791,MethodCallMutator,get,remove,1,1.0670158E-4,NAME_PREFIXES.<mask>(this.nameType),"
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.<mask>(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
"
1490,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17789,17791,MethodCallMutator,get,set,3,2.1726917E-5,NAME_PREFIXES.<mask>(this.nameType),"
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.<mask>(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
"
1491,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17789,17791,MethodCallMutator,get,delete,4,1.1467332E-5,NAME_PREFIXES.<mask>(this.nameType),"
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.<mask>(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
"
1492,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17775,17787,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.PhoneticEngine.NAME_PREFIXES,NAME,0,0.35056075,<mask>,"       }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" """
1493,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17775,17787,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.PhoneticEngine.NAME_PREFIXES,MAP,1,0.23181438,<mask>,"       }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" """
1494,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17775,17787,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.PhoneticEngine.NAME_PREFIXES,LIST,2,0.07564653,<mask>,"       }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" """
1495,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17775,17787,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.PhoneticEngine.NAME_PREFIXES,WS,3,0.050902274,<mask>,"       }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" """
1496,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17775,17787,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.PhoneticEngine.NAME_PREFIXES,RESULTS,4,0.0181139,<mask>,"       }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" """
1497,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17775,17787,FieldReferenceMutator,NAME_PREFIXES,NAME,0,0.35056075,org.apache.commons.codec.language.bm.PhoneticEngine.<mask>,"       }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" """
1498,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17775,17787,FieldReferenceMutator,NAME_PREFIXES,MAP,1,0.23181438,org.apache.commons.codec.language.bm.PhoneticEngine.<mask>,"       }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" """
1499,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17775,17787,FieldReferenceMutator,NAME_PREFIXES,LIST,2,0.07564653,org.apache.commons.codec.language.bm.PhoneticEngine.<mask>,"       }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" """
1500,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17775,17787,FieldReferenceMutator,NAME_PREFIXES,WS,3,0.050902274,org.apache.commons.codec.language.bm.PhoneticEngine.<mask>,"       }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" """
1501,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17775,17787,FieldReferenceMutator,NAME_PREFIXES,RESULTS,4,0.0181139,org.apache.commons.codec.language.bm.PhoneticEngine.<mask>,"       }
        }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" """
1502,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17793,17805,IdentifierMutator-Variable,this.nameType,this,0,0.33917806,<mask>,"       }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(<mask>));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
     "
1503,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17793,17805,IdentifierMutator-Variable,this.nameType,word,1,0.27531886,<mask>,"       }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(<mask>));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
     "
1504,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17793,17805,IdentifierMutator-Variable,this.nameType,words,2,0.07206891,<mask>,"       }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(<mask>));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
     "
1505,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17793,17805,IdentifierMutator-Variable,this.nameType,null,3,0.031606626,<mask>,"       }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(<mask>));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
     "
1506,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17793,17805,IdentifierMutator-Variable,this.nameType,name,4,0.026202613,<mask>,"       }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(<mask>));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
     "
1507,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17793,17796,IdentifierMutator-ThisAccess,this,This,2,4.247238E-5,<mask>,"       }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(<mask>.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
  "
1508,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17793,17796,IdentifierMutator-ThisAccess,this,self,3,1.1674837E-5,<mask>,"       }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(<mask>.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
  "
1509,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17793,17796,IdentifierMutator-ThisAccess,this,super,4,8.5516E-6,<mask>,"       }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(<mask>.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
  "
1510,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17798,17805,FieldReferenceMutator,nameType,name,0,0.7452655,this.<mask>,"     }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.<mask>));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
     "
1511,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17798,17805,FieldReferenceMutator,nameType,type,1,0.105459064,this.<mask>,"     }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.<mask>));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
     "
1512,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17798,17805,FieldReferenceMutator,nameType,prefix,2,0.066655956,this.<mask>,"     }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.<mask>));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
     "
1513,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17798,17805,FieldReferenceMutator,nameType,word,3,0.02761178,this.<mask>,"     }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.<mask>));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
     "
1514,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,436,17798,17805,FieldReferenceMutator,nameType,NAME,4,0.0034026697,this.<mask>,"     }

        final List<String> words = Arrays.asList(input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.<mask>));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
     "
1515,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,438,17842,17850,IdentifierMutator-Variable,ASHKENAZI,OTHER,0,0.23858953,<mask>,"input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not"
1516,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,438,17842,17850,IdentifierMutator-Variable,ASHKENAZI,NAME,1,0.11510444,<mask>,"input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not"
1517,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,438,17842,17850,IdentifierMutator-Variable,ASHKENAZI,GENERAL,2,0.054739844,<mask>,"input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not"
1518,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,438,17842,17850,IdentifierMutator-Variable,ASHKENAZI,ASCII,3,0.051092338,<mask>,"input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not"
1519,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,438,17842,17850,IdentifierMutator-Variable,ASHKENAZI,ALL,4,0.04031835,<mask>,"input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not"
1520,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,438,17842,17850,FieldReferenceMutator,ASHKENAZI,OTHER,0,0.23858953,<mask>,"input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not"
1521,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,438,17842,17850,FieldReferenceMutator,ASHKENAZI,NAME,1,0.11510444,<mask>,"input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not"
1522,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,438,17842,17850,FieldReferenceMutator,ASHKENAZI,GENERAL,2,0.054739844,<mask>,"input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not"
1523,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,438,17842,17850,FieldReferenceMutator,ASHKENAZI,ASCII,3,0.051092338,<mask>,"input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not"
1524,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,438,17842,17850,FieldReferenceMutator,ASHKENAZI,ALL,4,0.04031835,<mask>,"input.split(""\\s+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not"
1525,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,439,17872,17877,MethodCallMutator,addAll,add,0,0.9331764,words2.<mask>(words),"> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.<mask>(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input"
1526,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,439,17872,17877,MethodCallMutator,addAll,remove,1,0.017408062,words2.<mask>(words),"> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.<mask>(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input"
1527,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,439,17872,17877,MethodCallMutator,addAll,append,2,0.0070596742,words2.<mask>(words),"> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.<mask>(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input"
1528,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,439,17872,17877,MethodCallMutator,addAll,all,3,0.0048095714,words2.<mask>(words),"> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.<mask>(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input"
1529,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,439,17872,17877,MethodCallMutator,addAll,Add,4,0.003445181,words2.<mask>(words),"> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.<mask>(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input"
1530,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,439,17865,17870,IdentifierMutator-Variable,words2,this,0,0.16799638,<mask>,"+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:<mask>.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
         "
1531,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,439,17865,17870,IdentifierMutator-Variable,words2,words,1,0.13767506,<mask>,"+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:<mask>.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
         "
1532,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,439,17865,17870,IdentifierMutator-Variable,words2,input,2,0.034016866,<mask>,"+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:<mask>.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
         "
1533,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,439,17865,17870,IdentifierMutator-Variable,words2,output,3,0.033415407,<mask>,"+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:<mask>.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
         "
1534,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,439,17865,17870,IdentifierMutator-Variable,words2,words,4,0.03185311,<mask>,"+""));
        final List<String> words2 = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:<mask>.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
         "
1535,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,439,17879,17883,IdentifierMutator-Variable,words,word,1,0.007539393,<mask>," = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(<mask>);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words"
1536,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,439,17879,17883,IdentifierMutator-Variable,words,Words,2,1.1066094E-4,<mask>," = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(<mask>);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words"
1537,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,439,17879,17883,IdentifierMutator-Variable,words,this,3,1.07127045E-4,<mask>," = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(<mask>);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words"
1538,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,439,17879,17883,IdentifierMutator-Variable,words,names,4,1.0527507E-4,<mask>," = new ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(<mask>);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words"
1539,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17906,17914,MethodCallMutator,removeAll,remove,0,0.951152,words2.<mask>(NAME_PREFIXES.get(this.nameType))," special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.<mask>(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
 "
1540,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17906,17914,MethodCallMutator,removeAll,add,1,0.033884287,words2.<mask>(NAME_PREFIXES.get(this.nameType))," special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.<mask>(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
 "
1541,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17906,17914,MethodCallMutator,removeAll,delete,2,0.006236421,words2.<mask>(NAME_PREFIXES.get(this.nameType))," special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.<mask>(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
 "
1542,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17906,17914,MethodCallMutator,removeAll,append,3,0.0013204839,words2.<mask>(NAME_PREFIXES.get(this.nameType))," special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.<mask>(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
 "
1543,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17906,17914,MethodCallMutator,removeAll,clear,4,9.122211E-4,words2.<mask>(NAME_PREFIXES.get(this.nameType))," special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.<mask>(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
 "
1544,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17899,17904,IdentifierMutator-Variable,words2,words,0,0.59636,<mask>," ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);<mask>.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else"
1545,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17899,17904,IdentifierMutator-Variable,words2,words,1,0.3235709,<mask>," ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);<mask>.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else"
1546,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17899,17904,IdentifierMutator-Variable,words2,word,2,0.018745206,<mask>," ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);<mask>.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else"
1547,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17899,17904,IdentifierMutator-Variable,words2,keywords,3,0.00811479,<mask>," ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);<mask>.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else"
1548,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17899,17904,IdentifierMutator-Variable,words2,Words,4,0.0052762814,<mask>," ArrayList<String>();

        // special-case handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);<mask>.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else"
1549,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17930,17932,MethodCallMutator,get,remove,1,7.715102E-5,NAME_PREFIXES.<mask>(this.nameType)," the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.<mask>(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
          "
1550,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17930,17932,MethodCallMutator,get,set,3,1.0123698E-5,NAME_PREFIXES.<mask>(this.nameType)," the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.<mask>(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
          "
1551,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17930,17932,MethodCallMutator,get,gets,4,7.793886E-6,NAME_PREFIXES.<mask>(this.nameType)," the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.<mask>(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
          "
1552,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17916,17928,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.PhoneticEngine.NAME_PREFIXES,NAME,0,0.30239123,<mask>," handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
        "
1553,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17916,17928,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.PhoneticEngine.NAME_PREFIXES,MAP,1,0.14264783,<mask>," handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
        "
1554,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17916,17928,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.PhoneticEngine.NAME_PREFIXES,LIST,2,0.05393882,<mask>," handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
        "
1555,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17916,17928,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.PhoneticEngine.NAME_PREFIXES,RESULTS,3,0.03397926,<mask>," handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
        "
1556,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17916,17928,IdentifierMutator-Variable,org.apache.commons.codec.language.bm.PhoneticEngine.NAME_PREFIXES,WS,4,0.025242552,<mask>," handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
        "
1557,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17916,17928,FieldReferenceMutator,NAME_PREFIXES,NAME,0,0.30239123,org.apache.commons.codec.language.bm.PhoneticEngine.<mask>," handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
        "
1558,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17916,17928,FieldReferenceMutator,NAME_PREFIXES,MAP,1,0.14264783,org.apache.commons.codec.language.bm.PhoneticEngine.<mask>," handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
        "
1559,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17916,17928,FieldReferenceMutator,NAME_PREFIXES,LIST,2,0.05393882,org.apache.commons.codec.language.bm.PhoneticEngine.<mask>," handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
        "
1560,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17916,17928,FieldReferenceMutator,NAME_PREFIXES,RESULTS,3,0.03397926,org.apache.commons.codec.language.bm.PhoneticEngine.<mask>," handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
        "
1561,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17916,17928,FieldReferenceMutator,NAME_PREFIXES,WS,4,0.025242552,org.apache.commons.codec.language.bm.PhoneticEngine.<mask>," handling of word prefixes based upon the name type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(<mask>.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
        "
1562,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17934,17946,IdentifierMutator-Variable,this.nameType,word,0,0.19204447,<mask>," type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(<mask>));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word"
1563,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17934,17946,IdentifierMutator-Variable,this.nameType,this,1,0.1902627,<mask>," type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(<mask>));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word"
1564,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17934,17946,IdentifierMutator-Variable,this.nameType,name,2,0.07530524,<mask>," type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(<mask>));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word"
1565,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17934,17946,IdentifierMutator-Variable,this.nameType,type,3,0.064107224,<mask>," type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(<mask>));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word"
1566,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17934,17946,IdentifierMutator-Variable,this.nameType,words,4,0.061195347,<mask>," type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(<mask>));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word"
1567,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17934,17937,IdentifierMutator-ThisAccess,this,This,2,3.180579E-5,<mask>," type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(<mask>.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            //"
1568,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17934,17937,IdentifierMutator-ThisAccess,this,other,3,6.4858286E-6,<mask>," type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(<mask>.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            //"
1569,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17934,17937,IdentifierMutator-ThisAccess,this,self,4,4.8949014E-6,<mask>," type
        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(<mask>.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            //"
1570,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17939,17946,FieldReferenceMutator,nameType,name,0,0.60118145,this.<mask>,"        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.<mask>));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word"
1571,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17939,17946,FieldReferenceMutator,nameType,prefix,1,0.1617555,this.<mask>,"        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.<mask>));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word"
1572,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17939,17946,FieldReferenceMutator,nameType,type,2,0.103703946,this.<mask>,"        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.<mask>));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word"
1573,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17939,17946,FieldReferenceMutator,nameType,word,3,0.012312946,this.<mask>,"        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.<mask>));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word"
1574,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,440,17939,17946,FieldReferenceMutator,nameType,NAME,4,0.0062925755,this.<mask>,"        switch (this.nameType) {
        case SEPHARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.<mask>));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word"
1575,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,442,17983,17989,IdentifierMutator-Variable,GENERIC,OTHER,0,0.12890856,<mask>,"ARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
           "
1576,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,442,17983,17989,IdentifierMutator-Variable,GENERIC,NAME,1,0.08446358,<mask>,"ARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
           "
1577,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,442,17983,17989,IdentifierMutator-Variable,GENERIC,ALL,2,0.074492164,<mask>,"ARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
           "
1578,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,442,17983,17989,IdentifierMutator-Variable,GENERIC,MAP,3,0.032540698,<mask>,"ARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
           "
1579,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,442,17983,17989,IdentifierMutator-Variable,GENERIC,CASE,4,0.026118677,<mask>,"ARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
           "
1580,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,442,17983,17989,FieldReferenceMutator,GENERIC,OTHER,0,0.12890856,<mask>,"ARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
           "
1581,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,442,17983,17989,FieldReferenceMutator,GENERIC,NAME,1,0.08446358,<mask>,"ARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
           "
1582,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,442,17983,17989,FieldReferenceMutator,GENERIC,ALL,2,0.074492164,<mask>,"ARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
           "
1583,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,442,17983,17989,FieldReferenceMutator,GENERIC,MAP,3,0.032540698,<mask>,"ARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
           "
1584,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,442,17983,17989,FieldReferenceMutator,GENERIC,CASE,4,0.026118677,<mask>,"ARDIC:
            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case<mask>:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
           "
1585,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,443,18011,18016,MethodCallMutator,addAll,add,0,0.9188626,words2.<mask>(words)," aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.<mask>(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
        "
1586,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,443,18011,18016,MethodCallMutator,addAll,remove,1,0.03891093,words2.<mask>(words)," aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.<mask>(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
        "
1587,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,443,18011,18016,MethodCallMutator,addAll,append,2,0.005498035,words2.<mask>(words)," aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.<mask>(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
        "
1588,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,443,18011,18016,MethodCallMutator,addAll,push,3,0.0024153744,words2.<mask>(words)," aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.<mask>(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
        "
1589,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,443,18011,18016,MethodCallMutator,addAll,Add,4,0.0017734144,words2.<mask>(words)," aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.<mask>(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
        "
1590,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,443,18004,18009,IdentifierMutator-Variable,words2,input,0,0.12901996,<mask>,"            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:<mask>.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
     "
1591,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,443,18004,18009,IdentifierMutator-Variable,words2,output,1,0.11735678,<mask>,"            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:<mask>.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
     "
1592,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,443,18004,18009,IdentifierMutator-Variable,words2,this,2,0.09378099,<mask>,"            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:<mask>.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
     "
1593,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,443,18004,18009,IdentifierMutator-Variable,words2,result,3,0.08134355,<mask>,"            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:<mask>.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
     "
1594,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,443,18004,18009,IdentifierMutator-Variable,words2,super,4,0.035799373,<mask>,"            for (final String aWord : words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:<mask>.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
     "
1595,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,443,18018,18022,IdentifierMutator-Variable,words,word,1,0.03626316,<mask>," words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(<mask>);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
          "
1596,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,443,18018,18022,IdentifierMutator-Variable,words,this,2,0.0011140552,<mask>," words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(<mask>);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
          "
1597,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,443,18018,18022,IdentifierMutator-Variable,words,names,3,3.6566332E-4,<mask>," words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(<mask>);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
          "
1598,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,443,18018,18022,IdentifierMutator-Variable,words,Words,4,3.338486E-4,<mask>," words) {
                final String[] parts = aWord.split(""'"");
                final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(<mask>);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
          "
1599,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18126,18128,BinaryOperatorMutator,+,"""+",2,8.9037966E-4,"""Unreachable case: "" <mask> this.nameType","Part = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: ""<mask>this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
         "
1600,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18126,18128,BinaryOperatorMutator,+,+(,3,8.8965136E-4,"""Unreachable case: "" <mask> this.nameType","Part = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: ""<mask>this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
         "
1601,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18126,18128,BinaryOperatorMutator,+,//,4,1.9695763E-4,"""Unreachable case: "" <mask> this.nameType","Part = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: ""<mask>this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
         "
1602,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18106,18125,IdentifierMutator-Literal,"""Unreachablecase:""",name,0,0.058870453,<mask>,"    final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(<mask> + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
        "
1603,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18106,18125,IdentifierMutator-Literal,"""Unreachablecase:""","""""",1,0.057337344,<mask>,"    final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(<mask> + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
        "
1604,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18106,18125,IdentifierMutator-Literal,"""Unreachablecase:""","''",2,0.05282768,<mask>,"    final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(<mask> + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
        "
1605,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18106,18125,IdentifierMutator-Literal,"""Unreachablecase:""",this,3,0.038608335,<mask>,"    final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(<mask> + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
        "
1606,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18106,18125,IdentifierMutator-Literal,"""Unreachablecase:""","\""",4,0.032240752,<mask>,"    final String lastPart = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(<mask> + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
        "
1607,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18129,18141,IdentifierMutator-Variable,this.nameType,case,0,0.57522166,<mask>," = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" +<mask>);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
"
1608,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18129,18141,IdentifierMutator-Variable,this.nameType,this,1,0.09875113,<mask>," = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" +<mask>);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
"
1609,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18129,18141,IdentifierMutator-Variable,this.nameType,type,2,0.036186427,<mask>," = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" +<mask>);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
"
1610,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18129,18141,IdentifierMutator-Variable,this.nameType,c,3,0.03543464,<mask>," = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" +<mask>);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
"
1611,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18129,18141,IdentifierMutator-Variable,this.nameType,exception,4,0.030079473,<mask>," = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" +<mask>);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
"
1612,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18129,18132,IdentifierMutator-ThisAccess,this,super,2,3.9347823E-4,<mask>," = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" +<mask>.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
          "
1613,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18129,18132,IdentifierMutator-ThisAccess,this,type,3,5.294725E-5,<mask>," = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" +<mask>.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
          "
1614,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18129,18132,IdentifierMutator-ThisAccess,this,node,4,3.8420407E-5,<mask>," = parts[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" +<mask>.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
          "
1615,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18134,18141,FieldReferenceMutator,nameType,case,0,0.53617513,this.<mask>,"[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.<mask>);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
"
1616,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18134,18141,FieldReferenceMutator,nameType,type,1,0.22485241,this.<mask>,"[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.<mask>);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
"
1617,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18134,18141,FieldReferenceMutator,nameType,name,2,0.062244844,this.<mask>,"[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.<mask>);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
"
1618,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18134,18141,FieldReferenceMutator,nameType,class,3,0.017675033,this.<mask>,"[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.<mask>);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
"
1619,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,446,18134,18141,FieldReferenceMutator,nameType,cases,4,0.006990708,this.<mask>,"[parts.length - 1];
                words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.<mask>);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
"
1620,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,449,18168,18178,IdentifierMutator-Variable,this.concat,join,0,0.15016516,<mask>,"  words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (<mask>) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
   "
1621,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,449,18168,18178,IdentifierMutator-Variable,this.concat,union,1,0.075210966,<mask>,"  words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (<mask>) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
   "
1622,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,449,18168,18178,IdentifierMutator-Variable,this.concat,flat,2,0.07230899,<mask>,"  words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (<mask>) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
   "
1623,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,449,18168,18178,IdentifierMutator-Variable,this.concat,append,3,0.057504077,<mask>,"  words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (<mask>) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
   "
1624,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,449,18168,18178,IdentifierMutator-Variable,this.concat,debug,4,0.047405522,<mask>,"  words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (<mask>) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
   "
1625,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,449,18168,18171,IdentifierMutator-ThisAccess,this,options,1,0.07892186,<mask>,"  words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (<mask>.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
"
1626,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,449,18168,18171,IdentifierMutator-ThisAccess,this,config,2,0.067826815,<mask>,"  words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (<mask>.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
"
1627,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,449,18168,18171,IdentifierMutator-ThisAccess,this,settings,3,0.0029634999,<mask>,"  words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (<mask>.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
"
1628,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,449,18168,18171,IdentifierMutator-ThisAccess,this,super,4,0.0026135792,<mask>,"  words2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (<mask>.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
"
1629,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,449,18173,18178,FieldReferenceMutator,concat,union,0,0.07192679,this.<mask>,"2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.<mask>) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
   "
1630,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,449,18173,18178,FieldReferenceMutator,concat,join,1,0.058503006,this.<mask>,"2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.<mask>) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
   "
1631,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,449,18173,18178,FieldReferenceMutator,concat,multiple,2,0.053382725,this.<mask>,"2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.<mask>) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
   "
1632,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,449,18173,18178,FieldReferenceMutator,concat,debug,3,0.041384436,this.<mask>,"2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.<mask>) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
   "
1633,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,449,18173,18178,FieldReferenceMutator,concat,flat,4,0.03694763,this.<mask>,"2.add(lastPart);
            }
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.<mask>) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
   "
1634,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18235,18235,AssignmentMutator,"input=org.apache.commons.codec.language.bm.PhoneticEngine.join(words2,"""")",.,0,0.17931758,"input <mask>= org.apache.commons.codec.language.bm.PhoneticEngine.join(words2, "" "")",".removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input<mask>= join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

      "
1635,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18235,18235,AssignmentMutator,"input=org.apache.commons.codec.language.bm.PhoneticEngine.join(words2,"""")",+,1,0.16003533,"input <mask>= org.apache.commons.codec.language.bm.PhoneticEngine.join(words2, "" "")",".removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input<mask>= join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

      "
1636,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18235,18235,AssignmentMutator,"input=org.apache.commons.codec.language.bm.PhoneticEngine.join(words2,"""")",|,2,0.121495835,"input <mask>= org.apache.commons.codec.language.bm.PhoneticEngine.join(words2, "" "")",".removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input<mask>= join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

      "
1637,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18235,18235,AssignmentMutator,"input=org.apache.commons.codec.language.bm.PhoneticEngine.join(words2,"""")",*,3,0.07991269,"input <mask>= org.apache.commons.codec.language.bm.PhoneticEngine.join(words2, "" "")",".removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input<mask>= join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

      "
1638,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18235,18235,AssignmentMutator,"input=org.apache.commons.codec.language.bm.PhoneticEngine.join(words2,"""")",.,4,0.0606901,"input <mask>= org.apache.commons.codec.language.bm.PhoneticEngine.join(words2, "" "")",".removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input<mask>= join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

      "
1639,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18230,18234,IdentifierMutator-Variable,input,output,1,0.09846935,<mask>,"            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled<mask> = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

      "
1640,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18230,18234,IdentifierMutator-Variable,input,words,2,0.010559187,<mask>,"            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled<mask> = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

      "
1641,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18230,18234,IdentifierMutator-Variable,input,result,3,0.0091044465,<mask>,"            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled<mask> = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

      "
1642,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18230,18234,IdentifierMutator-Variable,input,word,4,0.0041348045,<mask>,"            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled<mask> = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

      "
1643,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18238,18241,MethodCallMutator,join,append,1,0.032170814,"<mask>(words2, "" "")","removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input =<mask>(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        Ph"
1644,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18238,18241,MethodCallMutator,join,combine,2,0.015135729,"<mask>(words2, "" "")","removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input =<mask>(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        Ph"
1645,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18238,18241,MethodCallMutator,join,merge,3,0.012690836,"<mask>(words2, "" "")","removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input =<mask>(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        Ph"
1646,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18238,18241,MethodCallMutator,join,cat,4,0.008128985,"<mask>(words2, "" "")","removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input =<mask>(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        Ph"
1647,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18243,18248,IdentifierMutator-Variable,words2,input,0,0.5203304,<mask>,"(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(<mask>, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder"
1648,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18243,18248,IdentifierMutator-Variable,words2,words,1,0.35399222,<mask>,"(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(<mask>, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder"
1649,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18243,18248,IdentifierMutator-Variable,words2,word,2,0.07950296,<mask>,"(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(<mask>, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder"
1650,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18243,18248,IdentifierMutator-Variable,words2,output,3,0.0072475546,<mask>,"(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(<mask>, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder"
1651,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18243,18248,IdentifierMutator-Variable,words2,in,4,0.003068,<mask>,"(NAME_PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(<mask>, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder"
1652,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18251,18253,IdentifierMutator-Literal,"""""",input,0,0.7701513,<mask>,"PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2,<mask>);
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder"
1653,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18251,18253,IdentifierMutator-Literal,"""""",output,1,0.024318632,<mask>,"PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2,<mask>);
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder"
1654,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18251,18253,IdentifierMutator-Literal,"""""",word,2,0.022672623,<mask>,"PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2,<mask>);
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder"
1655,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18251,18253,IdentifierMutator-Literal,"""""",true,3,0.01764009,<mask>,"PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2,<mask>);
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder"
1656,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,451,18251,18253,IdentifierMutator-Literal,"""""",words,4,0.016400352,<mask>,"PREFIXES.get(this.nameType));
            break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2,<mask>);
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder"
1657,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,452,18289,18292,BinaryOperatorMutator,==,>,0,0.497987,words2.size() <mask> 1,"     break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size()<mask>1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

       "
1658,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,452,18289,18292,BinaryOperatorMutator,==,>,2,0.04273063,words2.size() <mask> 1,"     break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size()<mask>1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

       "
1659,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,452,18289,18292,BinaryOperatorMutator,==,=,3,0.019555897,words2.size() <mask> 1,"     break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size()<mask>1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

       "
1660,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,452,18289,18292,BinaryOperatorMutator,==,-,4,0.018635577,words2.size() <mask> 1,"     break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size()<mask>1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

       "
1661,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,452,18283,18286,MethodCallMutator,size,length,1,0.0029139007,words2.<mask>(),"       break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.<mask>() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

     "
1662,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,452,18283,18286,MethodCallMutator,size,count,2,5.4339215E-4,words2.<mask>(),"       break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.<mask>() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

     "
1663,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,452,18283,18286,MethodCallMutator,size,capacity,3,2.0874129E-4,words2.<mask>(),"       break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.<mask>() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

     "
1664,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,452,18276,18281,IdentifierMutator-Variable,words2,words,0,0.99693465,<mask>,"          break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (<mask>.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

   "
1665,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,452,18276,18281,IdentifierMutator-Variable,words2,word,1,0.0017559205,<mask>,"          break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (<mask>.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

   "
1666,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,452,18276,18281,IdentifierMutator-Variable,words2,names,2,3.8158064E-4,<mask>,"          break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (<mask>.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

   "
1667,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,452,18276,18281,IdentifierMutator-Variable,words2,Words,3,1.4452123E-4,<mask>,"          break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (<mask>.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

   "
1668,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,452,18276,18281,IdentifierMutator-Variable,words2,words,4,1.0553634E-4,<mask>,"          break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (<mask>.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

   "
1669,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,452,18293,18293,IdentifierMutator-Literal,1,0,1,0.102080785,<mask>,"    break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() ==<mask>) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        //"
1670,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,452,18293,18293,IdentifierMutator-Literal,1,2,2,0.053213567,<mask>,"    break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() ==<mask>) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        //"
1671,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,452,18293,18293,IdentifierMutator-Literal,1,3,3,0.016658653,<mask>,"    break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() ==<mask>) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        //"
1672,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,452,18293,18293,IdentifierMutator-Literal,1,4,4,0.008648183,<mask>,"    break;
        case ASHKENAZI:
            words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() ==<mask>) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        //"
1673,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18352,18352,AssignmentMutator,input=words.iterator().next(),*,0,0.20050018,input <mask>= words.iterator().next(),"addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input<mask>= words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length"
1674,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18352,18352,AssignmentMutator,input=words.iterator().next(),|,1,0.15801218,input <mask>= words.iterator().next(),"addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input<mask>= words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length"
1675,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18352,18352,AssignmentMutator,input=words.iterator().next(),.,2,0.08887974,input <mask>= words.iterator().next(),"addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input<mask>= words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length"
1676,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18352,18352,AssignmentMutator,input=words.iterator().next(),.,3,0.08663391,input <mask>= words.iterator().next(),"addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input<mask>= words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length"
1677,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18352,18352,AssignmentMutator,input=words.iterator().next(),[],4,0.051675905,input <mask>= words.iterator().next(),"addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input<mask>= words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length"
1678,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18347,18351,IdentifierMutator-Variable,input,word,1,0.029915206,<mask>,"           words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name<mask> = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length"
1679,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18347,18351,IdentifierMutator-Variable,input,output,2,0.017678088,<mask>,"           words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name<mask> = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length"
1680,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18347,18351,IdentifierMutator-Variable,input,result,3,0.009053468,<mask>,"           words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name<mask> = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length"
1681,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18347,18351,IdentifierMutator-Variable,input,name,4,0.0028935326,<mask>,"           words2.addAll(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name<mask> = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length"
1682,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18372,18375,MethodCallMutator,next,value,2,5.592529E-4,words.iterator().<mask>(),"
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().<mask>();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
  "
1683,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18372,18375,MethodCallMutator,next,current,3,2.561726E-4,words.iterator().<mask>(),"
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().<mask>();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
  "
1684,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18372,18375,MethodCallMutator,next,last,4,2.507037E-4,words.iterator().<mask>(),"
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().<mask>();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
  "
1685,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18361,18368,MethodCallMutator,iterator,values,1,0.02742835,words.<mask>(),"words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.<mask>().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
"
1686,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18361,18368,MethodCallMutator,iterator,iter,2,0.01710011,words.<mask>(),"words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.<mask>().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
"
1687,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18361,18368,MethodCallMutator,iterator,next,3,0.0059179864,words.<mask>(),"words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.<mask>().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
"
1688,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18361,18368,MethodCallMutator,iterator,Iterator,4,0.0032828045,words.<mask>(),"words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.<mask>().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
"
1689,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18355,18359,IdentifierMutator-Variable,words,input,0,0.64085263,<mask>,"All(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input =<mask>.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();)"
1690,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18355,18359,IdentifierMutator-Variable,words,output,2,0.034902297,<mask>,"All(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input =<mask>.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();)"
1691,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18355,18359,IdentifierMutator-Variable,words,result,3,0.011724334,<mask>,"All(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input =<mask>.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();)"
1692,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,454,18355,18359,IdentifierMutator-Variable,words,sentence,4,0.010413062,<mask>,"All(words);
            words2.removeAll(NAME_PREFIXES.get(this.nameType));
            break;
        case GENERIC:
            words2.addAll(words);
            break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input =<mask>.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();)"
1693,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,458,18595,18600,IdentifierMutator-Variable,words2,words,0,0.7862831,<mask>,"         break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word :<mask>) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
      "
1694,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,458,18595,18600,IdentifierMutator-Variable,words2,words,1,0.07563958,<mask>,"         break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word :<mask>) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
      "
1695,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,458,18595,18600,IdentifierMutator-Variable,words2,input,2,0.051876474,<mask>,"         break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word :<mask>) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
      "
1696,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,458,18595,18600,IdentifierMutator-Variable,words2,output,3,0.00977464,<mask>,"         break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word :<mask>) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
      "
1697,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,458,18595,18600,IdentifierMutator-Variable,words2,word,4,0.008534045,<mask>,"         break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word :<mask>) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
      "
1698,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18640,18645,MethodCallMutator,append,replace,1,0.0029403726,"result.<mask>(""-"").<mask>(encode(word))","       throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").<mask>(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
      "
1699,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18640,18645,MethodCallMutator,append,add,2,0.0010850626,"result.<mask>(""-"").<mask>(encode(word))","       throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").<mask>(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
      "
1700,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18640,18645,MethodCallMutator,append,join,3,5.865645E-4,"result.<mask>(""-"").<mask>(encode(word))","       throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").<mask>(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
      "
1701,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18628,18633,MethodCallMutator,append,remove,1,0.0077856905,"result.<mask>(""-"")","           throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.<mask>(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
  "
1702,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18628,18633,MethodCallMutator,append,replace,2,0.005468574,"result.<mask>(""-"")","           throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.<mask>(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
  "
1703,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18628,18633,MethodCallMutator,append,split,3,0.0037742823,"result.<mask>(""-"")","           throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.<mask>(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
  "
1704,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18621,18626,IdentifierMutator-Variable,result,output,2,1.463056E-4,<mask>,"     break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {<mask>.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
"
1705,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18621,18626,IdentifierMutator-Variable,result,Result,3,1.4412678E-4,<mask>,"     break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {<mask>.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
"
1706,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18621,18626,IdentifierMutator-Variable,result,results,4,1.9338537E-5,<mask>,"     break;
        default:
            throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {<mask>.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
"
1707,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18635,18637,IdentifierMutator-Literal,"""-""",word,0,0.25185007,<mask>,"         throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(<mask>).append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
    "
1708,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18635,18637,IdentifierMutator-Literal,"""-""",prefix,1,0.15890485,<mask>,"         throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(<mask>).append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
    "
1709,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18635,18637,IdentifierMutator-Literal,"""-""",key,2,0.034634423,<mask>,"         throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(<mask>).append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
    "
1710,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18635,18637,IdentifierMutator-Literal,"""-""",prefix,3,0.03293054,<mask>,"         throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(<mask>).append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
    "
1711,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18635,18637,IdentifierMutator-Literal,"""-""",1,4,0.02193302,<mask>,"         throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(<mask>).append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
    "
1712,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18647,18652,MethodCallMutator,encode,escape,0,0.7281975,<mask>(word),"     throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(<mask>(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

"
1713,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18647,18652,MethodCallMutator,encode,quote,1,0.07067615,<mask>(word),"     throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(<mask>(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

"
1714,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18647,18652,MethodCallMutator,encode,format,3,0.025545234,<mask>(word),"     throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(<mask>(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

"
1715,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18647,18652,MethodCallMutator,encode,hex,4,0.005807801,<mask>(word),"     throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(<mask>(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

"
1716,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18654,18657,IdentifierMutator-Variable,word,Word,2,1.7029288E-5,<mask>,"  throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(<mask>));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

  "
1717,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18654,18657,IdentifierMutator-Variable,word,words,3,1.0451912E-5,<mask>,"  throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(<mask>));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

  "
1718,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,459,18654,18657,IdentifierMutator-Variable,word,work,4,2.9196424E-6,<mask>,"  throw new IllegalStateException(""Unreachable case: "" + this.nameType);
        }

        if (this.concat) {
            // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(<mask>));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

  "
1719,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,462,18759,18767,MethodCallMutator,substring,delete,0,0.16289824,result.<mask>(1),"      // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.<mask>(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
 "
1720,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,462,18759,18767,MethodCallMutator,substring,slice,1,0.15924707,result.<mask>(1),"      // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.<mask>(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
 "
1721,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,462,18759,18767,MethodCallMutator,substring,fill,2,0.10055471,result.<mask>(1),"      // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.<mask>(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
 "
1722,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,462,18759,18767,MethodCallMutator,substring,ring,3,0.09391054,result.<mask>(1),"      // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.<mask>(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
 "
1723,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,462,18759,18767,MethodCallMutator,substring,repeat,4,0.07280843,result.<mask>(1),"      // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.<mask>(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
 "
1724,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,462,18752,18757,IdentifierMutator-Variable,result,input,1,0.03621561,<mask>,"        // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return<mask>.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific"
1725,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,462,18752,18757,IdentifierMutator-Variable,result,output,2,0.029451959,<mask>,"        // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return<mask>.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific"
1726,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,462,18752,18757,IdentifierMutator-Variable,result,word,3,7.7177637E-4,<mask>,"        // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return<mask>.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific"
1727,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,462,18769,18769,IdentifierMutator-Literal,1,2,1,0.117375754,<mask>,"   // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(<mask>);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
   "
1728,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,462,18769,18769,IdentifierMutator-Literal,1,3,2,0.04985944,<mask>,"   // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(<mask>);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
   "
1729,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,462,18769,18769,IdentifierMutator-Literal,1,40,3,0.029720064,<mask>,"   // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(<mask>);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
   "
1730,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,462,18769,18769,IdentifierMutator-Literal,1,6,4,0.027877485,<mask>,"   // concat mode enabled
            input = join(words2, "" "");
        } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(<mask>);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
   "
1731,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,465,18839,18843,MethodCallMutator,empty,create,0,0.7596157,PhonemeBuilder.<mask>(languageSet),"      } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.<mask>(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phoneme"
1732,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,465,18839,18843,MethodCallMutator,empty,get,1,0.025134237,PhonemeBuilder.<mask>(languageSet),"      } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.<mask>(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phoneme"
1733,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,465,18839,18843,MethodCallMutator,empty,new,2,0.024080064,PhonemeBuilder.<mask>(languageSet),"      } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.<mask>(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phoneme"
1734,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,465,18839,18843,MethodCallMutator,empty,build,3,0.020286268,PhonemeBuilder.<mask>(languageSet),"      } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.<mask>(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phoneme"
1735,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,465,18839,18843,MethodCallMutator,empty,builder,4,0.020216314,PhonemeBuilder.<mask>(languageSet),"      } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.<mask>(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phoneme"
1736,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,465,18845,18855,IdentifierMutator-Variable,languageSet,1,0,0.12991399,<mask>,"    } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(<mask>);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.make"
1737,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,465,18845,18855,IdentifierMutator-Variable,languageSet,0,1,0.05460621,<mask>,"    } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(<mask>);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.make"
1738,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,465,18845,18855,IdentifierMutator-Variable,languageSet,2,2,0.053554524,<mask>,"    } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(<mask>);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.make"
1739,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,465,18845,18855,IdentifierMutator-Variable,languageSet,10,3,0.0277412,<mask>,"    } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(<mask>);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.make"
1740,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,465,18845,18855,IdentifierMutator-Variable,languageSet,true,4,0.027028993,<mask>,"    } else if (words2.size() == 1) {
            // not a multi-word name
            input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(<mask>);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.make"
1741,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,468,18965,18965,IdentifierMutator-Literal,0,1,1,0.01495127,<mask>,"         input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i =<mask>; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1742,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,468,18965,18965,IdentifierMutator-Literal,0,2,3,4.3418343E-4,<mask>,"         input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i =<mask>; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1743,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,468,18965,18965,IdentifierMutator-Literal,0,i,4,2.89116E-4,<mask>,"         input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i =<mask>; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1744,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,468,18969,18971,BinaryOperatorMutator,<,<=,2,0.0016207941,i <mask> input.length(),"      input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i<mask>input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1745,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,468,18969,18971,BinaryOperatorMutator,<,++,3,9.69339E-4,i <mask> input.length(),"      input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i<mask>input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1746,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,468,18969,18971,BinaryOperatorMutator,<,.<,4,5.087318E-4,i <mask> input.length(),"      input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i<mask>input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1747,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,468,18968,18968,IdentifierMutator-Variable,i,I,2,2.4918042E-4,<mask>,"       input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0;<mask> < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1748,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,468,18968,18968,IdentifierMutator-Variable,i,I,3,1.3814053E-4,<mask>,"       input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0;<mask> < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1749,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,468,18968,18968,IdentifierMutator-Variable,i,0,4,6.370832E-5,<mask>,"       input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0;<mask> < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1750,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,468,18978,18983,MethodCallMutator,length,size,1,0.2038691,input.<mask>(),"   input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.<mask>();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1751,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,468,18978,18983,MethodCallMutator,length,position,2,0.002209176,input.<mask>(),"   input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.<mask>();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1752,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,468,18978,18983,MethodCallMutator,length,count,3,7.4831996E-4,input.<mask>(),"   input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.<mask>();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1753,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,468,18978,18983,MethodCallMutator,length,width,4,5.792746E-4,input.<mask>(),"   input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.<mask>();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1754,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,468,18972,18976,IdentifierMutator-Variable,input,rules,1,0.0015473407,<mask>,"     input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i <<mask>.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1755,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,468,18972,18976,IdentifierMutator-Variable,input,rule,2,0.001536915,<mask>,"     input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i <<mask>.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1756,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,468,18972,18976,IdentifierMutator-Variable,input,text,3,0.0012005563,<mask>,"     input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i <<mask>.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1757,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,468,18972,18976,IdentifierMutator-Variable,input,output,4,7.0515106E-4,<mask>,"     input = words.iterator().next();
        } else {
            // encode each word in a multi-word name separately (normally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i <<mask>.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1758,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19132,19137,MethodCallMutator,invoke,build,0,0.3320342,"new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).<mask>()","   final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).<mask>();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1759,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19132,19137,MethodCallMutator,invoke,apply,1,0.121052444,"new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).<mask>()","   final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).<mask>();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1760,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19132,19137,MethodCallMutator,invoke,process,2,0.07246013,"new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).<mask>()","   final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).<mask>();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1761,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19132,19137,MethodCallMutator,invoke,create,3,0.06517709,"new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).<mask>()","   final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).<mask>();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1762,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19132,19137,MethodCallMutator,invoke,parse,4,0.06442709,"new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).<mask>()","   final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).<mask>();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1763,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19086,19090,IdentifierMutator-Variable,rules,this,0,0.27785206,<mask>,"ally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(<mask>, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1764,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19086,19090,IdentifierMutator-Variable,rules,context,1,0.102757044,<mask>,"ally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(<mask>, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1765,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19086,19090,IdentifierMutator-Variable,rules,null,3,0.026635475,<mask>,"ally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(<mask>, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1766,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19086,19090,IdentifierMutator-Variable,rules,rule,4,0.02369555,<mask>,"ally used for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(<mask>, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1767,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19093,19097,IdentifierMutator-Variable,input,i,1,0.027667372,<mask>," for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules,<mask>, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1768,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19093,19097,IdentifierMutator-Variable,input,output,2,0.014637316,<mask>," for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules,<mask>, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1769,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19093,19097,IdentifierMutator-Variable,input,grammar,3,0.014118099,<mask>," for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules,<mask>, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1770,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19093,19097,IdentifierMutator-Variable,input,language,4,0.009093675,<mask>," for approx matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules,<mask>, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1771,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19100,19113,IdentifierMutator-Variable,phonemeBuilder,0,0,0.119282044,<mask>," matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input,<mask>, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1772,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19100,19113,IdentifierMutator-Variable,phonemeBuilder,i,1,0.11786011,<mask>," matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input,<mask>, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1773,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19100,19113,IdentifierMutator-Variable,phonemeBuilder,result,2,0.06637533,<mask>," matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input,<mask>, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1774,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19100,19113,IdentifierMutator-Variable,phonemeBuilder,locale,3,0.025629558,<mask>," matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input,<mask>, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1775,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19100,19113,IdentifierMutator-Variable,phonemeBuilder,output,4,0.023796013,<mask>," matches)
            final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input,<mask>, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1776,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19116,19116,IdentifierMutator-Variable,i,0,2,0.004830245,<mask>,"           final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder,<mask>, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1777,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19116,19116,IdentifierMutator-Variable,i,1,3,0.0029376429,<mask>,"           final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder,<mask>, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1778,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19116,19116,IdentifierMutator-Variable,i,true,4,0.0018052474,<mask>,"           final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder,<mask>, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1779,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19119,19129,IdentifierMutator-Variable,maxPhonemes,i,0,0.10133889,<mask>,"         final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i,<mask>).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1780,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19119,19129,IdentifierMutator-Variable,maxPhonemes,0,1,0.054745868,<mask>,"         final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i,<mask>).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1781,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19119,19129,IdentifierMutator-Variable,maxPhonemes,false,2,0.04677208,<mask>,"         final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i,<mask>).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1782,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19119,19129,IdentifierMutator-Variable,maxPhonemes,true,3,0.04606412,<mask>,"         final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i,<mask>).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1783,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19119,19129,IdentifierMutator-Variable,maxPhonemes,increment,4,0.043770302,<mask>,"         final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i,<mask>).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1784,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19119,19129,FieldReferenceMutator,maxPhonemes,i,0,0.10133889,<mask>,"         final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i,<mask>).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1785,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19119,19129,FieldReferenceMutator,maxPhonemes,0,1,0.054745868,<mask>,"         final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i,<mask>).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1786,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19119,19129,FieldReferenceMutator,maxPhonemes,false,2,0.04677208,<mask>,"         final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i,<mask>).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1787,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19119,19129,FieldReferenceMutator,maxPhonemes,true,3,0.04606412,<mask>,"         final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i,<mask>).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1788,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,470,19119,19129,FieldReferenceMutator,maxPhonemes,increment,4,0.043770302,<mask>,"         final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i,<mask>).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1789,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,471,19155,19155,AssignmentMutator,i=rulesApplication.getI(),*,0,0.7143459,i <mask>= rulesApplication.getI(),"         for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i<mask>= rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1790,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,471,19155,19155,AssignmentMutator,i=rulesApplication.getI(),|,1,0.08006015,i <mask>= rulesApplication.getI(),"         for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i<mask>= rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1791,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,471,19155,19155,AssignmentMutator,i=rulesApplication.getI(),*,2,0.02708662,i <mask>= rulesApplication.getI(),"         for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i<mask>= rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1792,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,471,19155,19155,AssignmentMutator,i=rulesApplication.getI(),/,3,0.020686867,i <mask>= rulesApplication.getI(),"         for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i<mask>= rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1793,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,471,19155,19155,AssignmentMutator,i=rulesApplication.getI(),!,4,0.01751479,i <mask>= rulesApplication.getI(),"         for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i<mask>= rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1794,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,471,19154,19154,IdentifierMutator-Variable,i,input,2,0.0034277875,<mask>," final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();<mask> = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1795,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,471,19154,19154,IdentifierMutator-Variable,i,I,3,0.0022398809,<mask>," final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();<mask> = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1796,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,471,19154,19154,IdentifierMutator-Variable,i,I,4,0.0013464243,<mask>," final StringBuilder result = new StringBuilder();
            for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();<mask> = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1797,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,471,19175,19178,MethodCallMutator,getI,next,0,0.8928258,rulesApplication.<mask>(),"     for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.<mask>();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1798,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,471,19175,19178,MethodCallMutator,getI,size,1,0.01774088,rulesApplication.<mask>(),"     for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.<mask>();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1799,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,471,19175,19178,MethodCallMutator,getI,index,2,0.010217425,rulesApplication.<mask>(),"     for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.<mask>();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1800,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,471,19175,19178,MethodCallMutator,getI,length,3,0.007399167,rulesApplication.<mask>(),"     for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.<mask>();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1801,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,471,19175,19178,MethodCallMutator,getI,position,4,0.004440281,rulesApplication.<mask>(),"     for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.<mask>();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1802,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,471,19158,19173,IdentifierMutator-Variable,rulesApplication,input,0,0.25593555,<mask>,"        for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i =<mask>.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1803,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,471,19158,19173,IdentifierMutator-Variable,rulesApplication,rule,1,0.2272334,<mask>,"        for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i =<mask>.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1804,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,471,19158,19173,IdentifierMutator-Variable,rulesApplication,i,2,0.19409277,<mask>,"        for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i =<mask>.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1805,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,471,19158,19173,IdentifierMutator-Variable,rulesApplication,rules,3,0.15282668,<mask>,"        for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i =<mask>.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1806,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,471,19158,19173,IdentifierMutator-Variable,rulesApplication,grammar,4,0.018612524,<mask>,"        for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i =<mask>.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1807,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19209,19209,AssignmentMutator,phonemeBuilder=rulesApplication.getPhonemeBuilder(),*,0,0.28199473,phonemeBuilder <mask>= rulesApplication.getPhonemeBuilder(),"             result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder<mask>= rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1808,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19209,19209,AssignmentMutator,phonemeBuilder=rulesApplication.getPhonemeBuilder(),|,1,0.14828452,phonemeBuilder <mask>= rulesApplication.getPhonemeBuilder(),"             result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder<mask>= rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1809,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19209,19209,AssignmentMutator,phonemeBuilder=rulesApplication.getPhonemeBuilder(),^,2,0.07690501,phonemeBuilder <mask>= rulesApplication.getPhonemeBuilder(),"             result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder<mask>= rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1810,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19209,19209,AssignmentMutator,phonemeBuilder=rulesApplication.getPhonemeBuilder(),.,3,0.05800297,phonemeBuilder <mask>= rulesApplication.getPhonemeBuilder(),"             result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder<mask>= rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1811,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19209,19209,AssignmentMutator,phonemeBuilder=rulesApplication.getPhonemeBuilder(),&,4,0.052264966,phonemeBuilder <mask>= rulesApplication.getPhonemeBuilder(),"             result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder<mask>= rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1812,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19195,19208,IdentifierMutator-Variable,phonemeBuilder,builder,0,0.88735795,<mask>,"  for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();<mask> = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1813,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19195,19208,IdentifierMutator-Variable,phonemeBuilder,b,1,0.019183133,<mask>,"  for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();<mask> = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1814,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19195,19208,IdentifierMutator-Variable,phonemeBuilder,input,2,0.016489035,<mask>,"  for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();<mask> = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1815,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19195,19208,IdentifierMutator-Variable,phonemeBuilder,output,3,0.01556695,<mask>,"  for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();<mask> = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1816,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19195,19208,IdentifierMutator-Variable,phonemeBuilder,bc,4,0.00788496,<mask>,"  for (final String word : words2) {
                result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();<mask> = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1817,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19229,19245,MethodCallMutator,getPhonemeBuilder,build,0,0.4727858,rulesApplication.<mask>(),"         result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.<mask>();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1818,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19229,19245,MethodCallMutator,getPhonemeBuilder,get,1,0.110234156,rulesApplication.<mask>(),"         result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.<mask>();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1819,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19229,19245,MethodCallMutator,getPhonemeBuilder,make,2,0.07662717,rulesApplication.<mask>(),"         result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.<mask>();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1820,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19229,19245,MethodCallMutator,getPhonemeBuilder,clone,3,0.051445346,rulesApplication.<mask>(),"         result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.<mask>();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1821,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19229,19245,MethodCallMutator,getPhonemeBuilder,next,4,0.04843806,rulesApplication.<mask>(),"         result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.<mask>();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1822,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19212,19227,IdentifierMutator-Variable,rulesApplication,i,0,0.27365342,<mask>,"            result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder =<mask>.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1823,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19212,19227,IdentifierMutator-Variable,rulesApplication,rule,1,0.10511393,<mask>,"            result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder =<mask>.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1824,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19212,19227,IdentifierMutator-Variable,rulesApplication,grammar,2,0.07659916,<mask>,"            result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder =<mask>.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1825,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19212,19227,IdentifierMutator-Variable,rulesApplication,rules,3,0.066656515,<mask>,"            result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder =<mask>.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1826,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,472,19212,19227,IdentifierMutator-Variable,rulesApplication,application,4,0.046347067,<mask>,"            result.append(""-"").append(encode(word));
            }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder =<mask>.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1827,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19318,19318,AssignmentMutator,"phonemeBuilder=applyFinalRules(phonemeBuilder,finalRules1)",*,0,0.3272114,"phonemeBuilder <mask>= applyFinalRules(phonemeBuilder, finalRules1)","        // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder<mask>= applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1828,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19318,19318,AssignmentMutator,"phonemeBuilder=applyFinalRules(phonemeBuilder,finalRules1)",|,1,0.13621794,"phonemeBuilder <mask>= applyFinalRules(phonemeBuilder, finalRules1)","        // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder<mask>= applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1829,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19318,19318,AssignmentMutator,"phonemeBuilder=applyFinalRules(phonemeBuilder,finalRules1)",&,2,0.12197764,"phonemeBuilder <mask>= applyFinalRules(phonemeBuilder, finalRules1)","        // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder<mask>= applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1830,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19318,19318,AssignmentMutator,"phonemeBuilder=applyFinalRules(phonemeBuilder,finalRules1)",/,3,0.09164237,"phonemeBuilder <mask>= applyFinalRules(phonemeBuilder, finalRules1)","        // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder<mask>= applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1831,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19318,19318,AssignmentMutator,"phonemeBuilder=applyFinalRules(phonemeBuilder,finalRules1)",||,4,0.064755216,"phonemeBuilder <mask>= applyFinalRules(phonemeBuilder, finalRules1)","        // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder<mask>= applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1832,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19304,19317,IdentifierMutator-Variable,phonemeBuilder,input,0,0.22613811,<mask>,"      }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules<mask> = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1833,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19304,19317,IdentifierMutator-Variable,phonemeBuilder,result,1,0.15690668,<mask>,"      }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules<mask> = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1834,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19304,19317,IdentifierMutator-Variable,phonemeBuilder,output,2,0.13305719,<mask>,"      }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules<mask> = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1835,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19304,19317,IdentifierMutator-Variable,phonemeBuilder,rules,3,0.10957916,<mask>,"      }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules<mask> = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1836,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19304,19317,IdentifierMutator-Variable,phonemeBuilder,rule,4,0.066260226,<mask>,"      }
            // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules<mask> = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1837,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19321,19335,MethodCallMutator,applyFinalRules,apply,0,0.9391813,"<mask>(phonemeBuilder, finalRules1)","       // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder =<mask>(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1838,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19321,19335,MethodCallMutator,applyFinalRules,rules,1,0.007048849,"<mask>(phonemeBuilder, finalRules1)","       // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder =<mask>(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1839,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19321,19335,MethodCallMutator,applyFinalRules,merge,2,0.0057811253,"<mask>(phonemeBuilder, finalRules1)","       // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder =<mask>(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1840,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19321,19335,MethodCallMutator,applyFinalRules,rule,3,0.0044419793,"<mask>(phonemeBuilder, finalRules1)","       // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder =<mask>(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1841,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19321,19335,MethodCallMutator,applyFinalRules,process,4,0.0038472642,"<mask>(phonemeBuilder, finalRules1)","       // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder =<mask>(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1842,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19337,19350,IdentifierMutator-Variable,phonemeBuilder,builder,0,0.28198802,<mask>,"   // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(<mask>, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1843,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19337,19350,IdentifierMutator-Variable,phonemeBuilder,this,1,0.22028203,<mask>,"   // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(<mask>, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1844,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19337,19350,IdentifierMutator-Variable,phonemeBuilder,rules,2,0.14263226,<mask>,"   // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(<mask>, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1845,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19337,19350,IdentifierMutator-Variable,phonemeBuilder,parser,3,0.07832839,<mask>,"   // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(<mask>, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1846,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19337,19350,IdentifierMutator-Variable,phonemeBuilder,input,4,0.022103466,<mask>,"   // return the result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(<mask>, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1847,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19353,19363,IdentifierMutator-Variable,finalRules1,rules,0,0.7993204,<mask>," result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder,<mask>);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1848,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19353,19363,IdentifierMutator-Variable,finalRules1,rule,1,0.043700196,<mask>," result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder,<mask>);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1849,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19353,19363,IdentifierMutator-Variable,finalRules1,general,2,0.040622465,<mask>," result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder,<mask>);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1850,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19353,19363,IdentifierMutator-Variable,finalRules1,main,3,0.012100852,<mask>," result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder,<mask>);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1851,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,476,19353,19363,IdentifierMutator-Variable,finalRules1,grammar,4,0.007952737,<mask>," result without the leading ""-""
            return result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder,<mask>);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1852,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19434,19434,AssignmentMutator,"phonemeBuilder=applyFinalRules(phonemeBuilder,finalRules2)",*,0,0.26443827,"phonemeBuilder <mask>= applyFinalRules(phonemeBuilder, finalRules2)","     }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder<mask>= applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1853,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19434,19434,AssignmentMutator,"phonemeBuilder=applyFinalRules(phonemeBuilder,finalRules2)",|,1,0.17441322,"phonemeBuilder <mask>= applyFinalRules(phonemeBuilder, finalRules2)","     }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder<mask>= applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1854,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19434,19434,AssignmentMutator,"phonemeBuilder=applyFinalRules(phonemeBuilder,finalRules2)",&,2,0.12990457,"phonemeBuilder <mask>= applyFinalRules(phonemeBuilder, finalRules2)","     }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder<mask>= applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1855,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19434,19434,AssignmentMutator,"phonemeBuilder=applyFinalRules(phonemeBuilder,finalRules2)",||,3,0.082120255,"phonemeBuilder <mask>= applyFinalRules(phonemeBuilder, finalRules2)","     }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder<mask>= applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1856,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19434,19434,AssignmentMutator,"phonemeBuilder=applyFinalRules(phonemeBuilder,finalRules2)",/,4,0.040372636,"phonemeBuilder <mask>= applyFinalRules(phonemeBuilder, finalRules2)","     }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder<mask>= applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1857,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19420,19433,IdentifierMutator-Variable,phonemeBuilder,builder,0,0.6297985,<mask>," result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules<mask> = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1858,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19420,19433,IdentifierMutator-Variable,phonemeBuilder,Builder,1,0.2916223,<mask>," result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules<mask> = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1859,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19420,19433,IdentifierMutator-Variable,phonemeBuilder,result,2,0.021973321,<mask>," result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules<mask> = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1860,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19420,19433,IdentifierMutator-Variable,phonemeBuilder,build,3,0.005579556,<mask>," result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules<mask> = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1861,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19420,19433,IdentifierMutator-Variable,phonemeBuilder,language,4,0.0034782896,<mask>," result.substring(1);
        }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules<mask> = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1862,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19437,19451,MethodCallMutator,applyFinalRules,apply,0,0.7404071,"<mask>(phonemeBuilder, finalRules2)","    }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder =<mask>(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1863,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19437,19451,MethodCallMutator,applyFinalRules,merge,1,0.052189793,"<mask>(phonemeBuilder, finalRules2)","    }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder =<mask>(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1864,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19437,19451,MethodCallMutator,applyFinalRules,combine,2,0.014028646,"<mask>(phonemeBuilder, finalRules2)","    }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder =<mask>(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1865,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19437,19451,MethodCallMutator,applyFinalRules,translate,3,0.012807223,"<mask>(phonemeBuilder, finalRules2)","    }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder =<mask>(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1866,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19437,19451,MethodCallMutator,applyFinalRules,add,4,0.0119642,"<mask>(phonemeBuilder, finalRules2)","    }

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder =<mask>(phonemeBuilder, finalRules2);

        return phonemeBuilder.makeString();
   "
1867,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19453,19466,IdentifierMutator-Variable,phonemeBuilder,builder,0,0.2641242,<mask>,"

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(<mask>, finalRules2);

        return phonemeBuilder.makeString();
   "
1868,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19453,19466,IdentifierMutator-Variable,phonemeBuilder,this,1,0.19327906,<mask>,"

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(<mask>, finalRules2);

        return phonemeBuilder.makeString();
   "
1869,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19453,19466,IdentifierMutator-Variable,phonemeBuilder,language,2,0.1922177,<mask>,"

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(<mask>, finalRules2);

        return phonemeBuilder.makeString();
   "
1870,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19453,19466,IdentifierMutator-Variable,phonemeBuilder,parser,3,0.076837555,<mask>,"

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(<mask>, finalRules2);

        return phonemeBuilder.makeString();
   "
1871,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19453,19466,IdentifierMutator-Variable,phonemeBuilder,output,4,0.019156683,<mask>,"

        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(<mask>, finalRules2);

        return phonemeBuilder.makeString();
   "
1872,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19469,19479,IdentifierMutator-Variable,finalRules2,language,0,0.38227025,<mask>,"    PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder,<mask>);

        return phonemeBuilder.makeString();
   "
1873,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19469,19479,IdentifierMutator-Variable,finalRules2,languages,1,0.25005877,<mask>,"    PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder,<mask>);

        return phonemeBuilder.makeString();
   "
1874,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19469,19479,IdentifierMutator-Variable,finalRules2,rules,2,0.09907352,<mask>,"    PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder,<mask>);

        return phonemeBuilder.makeString();
   "
1875,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19469,19479,IdentifierMutator-Variable,finalRules2,lang,3,0.02939414,<mask>,"    PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder,<mask>);

        return phonemeBuilder.makeString();
   "
1876,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,478,19469,19479,IdentifierMutator-Variable,finalRules2,translations,4,0.017846802,<mask>,"    PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder,<mask>);

        return phonemeBuilder.makeString();
   "
1877,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,480,19514,19523,MethodCallMutator,makeString,build,0,0.7881639,phonemeBuilder.<mask>(),"(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.<mask>();
   "
1878,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,480,19514,19523,MethodCallMutator,makeString,join,1,0.020723509,phonemeBuilder.<mask>(),"(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.<mask>();
   "
1879,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,480,19514,19523,MethodCallMutator,makeString,get,2,0.015707176,phonemeBuilder.<mask>(),"(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.<mask>();
   "
1880,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,480,19514,19523,MethodCallMutator,makeString,reverse,3,0.012353207,phonemeBuilder.<mask>(),"(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.<mask>();
   "
1881,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,480,19514,19523,MethodCallMutator,makeString,string,4,0.009857537,phonemeBuilder.<mask>(),"(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return phonemeBuilder.<mask>();
   "
1882,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,480,19499,19512,IdentifierMutator-Variable,phonemeBuilder,output,0,0.37322807,<mask>,"emeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return<mask>.makeString();
   "
1883,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,480,19499,19512,IdentifierMutator-Variable,phonemeBuilder,builder,1,0.36467823,<mask>,"emeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return<mask>.makeString();
   "
1884,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,480,19499,19512,IdentifierMutator-Variable,phonemeBuilder,result,2,0.08525,<mask>,"emeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return<mask>.makeString();
   "
1885,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,480,19499,19512,IdentifierMutator-Variable,phonemeBuilder,input,3,0.03718019,<mask>,"emeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return<mask>.makeString();
   "
1886,PhoneticEngine.java,encode,"String encode(String input, final Languages.LanguageSet languageSet)",397,480,19499,19512,IdentifierMutator-Variable,phonemeBuilder,this,4,0.023573063,<mask>,"emeBuilder.empty(languageSet);

        // loop over each char in the input - we will handle the increment manually
        for (int i = 0; i < input.length();) {
            final RulesApplication rulesApplication =
                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();
            i = rulesApplication.getI();
            phonemeBuilder = rulesApplication.getPhonemeBuilder();
        }

        // Apply the general rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
        // Apply the language-specific rules
        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);

        return<mask>.makeString();
   "
1887,PhoneticEngine.java,getLang,Lang getLang(),488,489,19689,19697,IdentifierMutator-Variable,this.lang,lang,0,0.7786855,<mask>,"Lang getLang() {
        return<mask>;
    }"
1888,PhoneticEngine.java,getLang,Lang getLang(),488,489,19689,19697,IdentifierMutator-Variable,this.lang,language,1,0.06331396,<mask>,"Lang getLang() {
        return<mask>;
    }"
1889,PhoneticEngine.java,getLang,Lang getLang(),488,489,19689,19697,IdentifierMutator-Variable,this.lang,null,2,0.0562343,<mask>,"Lang getLang() {
        return<mask>;
    }"
1890,PhoneticEngine.java,getLang,Lang getLang(),488,489,19689,19697,IdentifierMutator-Variable,this.lang,locale,3,0.010288887,<mask>,"Lang getLang() {
        return<mask>;
    }"
1891,PhoneticEngine.java,getLang,Lang getLang(),488,489,19689,19697,IdentifierMutator-Variable,this.lang,true,4,0.008788558,<mask>,"Lang getLang() {
        return<mask>;
    }"
1892,PhoneticEngine.java,getLang,Lang getLang(),488,489,19689,19692,IdentifierMutator-ThisAccess,this,lang,1,0.024633141,<mask>,"Lang getLang() {
        return<mask>.lang;
    }"
1893,PhoneticEngine.java,getLang,Lang getLang(),488,489,19689,19692,IdentifierMutator-ThisAccess,this,l,2,0.023104882,<mask>,"Lang getLang() {
        return<mask>.lang;
    }"
1894,PhoneticEngine.java,getLang,Lang getLang(),488,489,19689,19692,IdentifierMutator-ThisAccess,this,config,3,0.015605541,<mask>,"Lang getLang() {
        return<mask>.lang;
    }"
1895,PhoneticEngine.java,getLang,Lang getLang(),488,489,19689,19692,IdentifierMutator-ThisAccess,this,super,4,0.013959157,<mask>,"Lang getLang() {
        return<mask>.lang;
    }"
1896,PhoneticEngine.java,getLang,Lang getLang(),488,489,19694,19697,FieldReferenceMutator,lang,language,1,0.32176432,this.<mask>,"Lang getLang() {
        return this.<mask>;
    }"
1897,PhoneticEngine.java,getLang,Lang getLang(),488,489,19694,19697,FieldReferenceMutator,lang,default,2,0.0027954248,this.<mask>,"Lang getLang() {
        return this.<mask>;
    }"
1898,PhoneticEngine.java,getLang,Lang getLang(),488,489,19694,19697,FieldReferenceMutator,lang,ang,3,0.0020520142,this.<mask>,"Lang getLang() {
        return this.<mask>;
    }"
1899,PhoneticEngine.java,getLang,Lang getLang(),488,489,19694,19697,FieldReferenceMutator,lang,name,4,0.0013090489,this.<mask>,"Lang getLang() {
        return this.<mask>;
    }"
1900,PhoneticEngine.java,getNameType,NameType getNameType(),497,498,19853,19865,IdentifierMutator-Variable,this.nameType,type,0,0.42875856,<mask>,"NameType getNameType() {
        return<mask>;
    }"
1901,PhoneticEngine.java,getNameType,NameType getNameType(),497,498,19853,19865,IdentifierMutator-Variable,this.nameType,null,1,0.2564017,<mask>,"NameType getNameType() {
        return<mask>;
    }"
1902,PhoneticEngine.java,getNameType,NameType getNameType(),497,498,19853,19865,IdentifierMutator-Variable,this.nameType,name,2,0.058196075,<mask>,"NameType getNameType() {
        return<mask>;
    }"
1903,PhoneticEngine.java,getNameType,NameType getNameType(),497,498,19853,19865,IdentifierMutator-Variable,this.nameType,this,3,0.026816506,<mask>,"NameType getNameType() {
        return<mask>;
    }"
1904,PhoneticEngine.java,getNameType,NameType getNameType(),497,498,19853,19865,IdentifierMutator-Variable,this.nameType,t,4,0.017208913,<mask>,"NameType getNameType() {
        return<mask>;
    }"
1905,PhoneticEngine.java,getNameType,NameType getNameType(),497,498,19853,19856,IdentifierMutator-ThisAccess,this,super,1,0.045048296,<mask>,"NameType getNameType() {
        return<mask>.nameType;
    }"
1906,PhoneticEngine.java,getNameType,NameType getNameType(),497,498,19853,19856,IdentifierMutator-ThisAccess,this,info,2,0.01938248,<mask>,"NameType getNameType() {
        return<mask>.nameType;
    }"
1907,PhoneticEngine.java,getNameType,NameType getNameType(),497,498,19853,19856,IdentifierMutator-ThisAccess,this,m,3,0.011490334,<mask>,"NameType getNameType() {
        return<mask>.nameType;
    }"
1908,PhoneticEngine.java,getNameType,NameType getNameType(),497,498,19853,19856,IdentifierMutator-ThisAccess,this,type,4,0.01052388,<mask>,"NameType getNameType() {
        return<mask>.nameType;
    }"
1909,PhoneticEngine.java,getNameType,NameType getNameType(),497,498,19858,19865,FieldReferenceMutator,nameType,type,0,0.4509814,this.<mask>,"NameType getNameType() {
        return this.<mask>;
    }"
1910,PhoneticEngine.java,getNameType,NameType getNameType(),497,498,19858,19865,FieldReferenceMutator,nameType,name,1,0.41973278,this.<mask>,"NameType getNameType() {
        return this.<mask>;
    }"
1911,PhoneticEngine.java,getNameType,NameType getNameType(),497,498,19858,19865,FieldReferenceMutator,nameType,class,2,0.014664412,this.<mask>,"NameType getNameType() {
        return this.<mask>;
    }"
1912,PhoneticEngine.java,getNameType,NameType getNameType(),497,498,19858,19865,FieldReferenceMutator,nameType,value,3,0.004376638,this.<mask>,"NameType getNameType() {
        return this.<mask>;
    }"
1913,PhoneticEngine.java,getNameType,NameType getNameType(),497,498,19858,19865,FieldReferenceMutator,nameType,id,4,0.0028537347,this.<mask>,"NameType getNameType() {
        return this.<mask>;
    }"
1914,PhoneticEngine.java,getRuleType,RuleType getRuleType(),506,507,20021,20033,IdentifierMutator-Variable,this.ruleType,type,0,0.30857033,<mask>,"RuleType getRuleType() {
        return<mask>;
    }"
1915,PhoneticEngine.java,getRuleType,RuleType getRuleType(),506,507,20021,20033,IdentifierMutator-Variable,this.ruleType,rule,1,0.28933448,<mask>,"RuleType getRuleType() {
        return<mask>;
    }"
1916,PhoneticEngine.java,getRuleType,RuleType getRuleType(),506,507,20021,20033,IdentifierMutator-Variable,this.ruleType,null,2,0.22126448,<mask>,"RuleType getRuleType() {
        return<mask>;
    }"
1917,PhoneticEngine.java,getRuleType,RuleType getRuleType(),506,507,20021,20033,IdentifierMutator-Variable,this.ruleType,this,3,0.01682801,<mask>,"RuleType getRuleType() {
        return<mask>;
    }"
1918,PhoneticEngine.java,getRuleType,RuleType getRuleType(),506,507,20021,20033,IdentifierMutator-Variable,this.ruleType,t,4,0.008482127,<mask>,"RuleType getRuleType() {
        return<mask>;
    }"
1919,PhoneticEngine.java,getRuleType,RuleType getRuleType(),506,507,20021,20024,IdentifierMutator-ThisAccess,this,rule,1,0.2630501,<mask>,"RuleType getRuleType() {
        return<mask>.ruleType;
    }"
1920,PhoneticEngine.java,getRuleType,RuleType getRuleType(),506,507,20021,20024,IdentifierMutator-ThisAccess,this,rules,2,0.015670177,<mask>,"RuleType getRuleType() {
        return<mask>.ruleType;
    }"
1921,PhoneticEngine.java,getRuleType,RuleType getRuleType(),506,507,20021,20024,IdentifierMutator-ThisAccess,this,super,3,0.013616005,<mask>,"RuleType getRuleType() {
        return<mask>.ruleType;
    }"
1922,PhoneticEngine.java,getRuleType,RuleType getRuleType(),506,507,20021,20024,IdentifierMutator-ThisAccess,this,options,4,0.010986626,<mask>,"RuleType getRuleType() {
        return<mask>.ruleType;
    }"
1923,PhoneticEngine.java,getRuleType,RuleType getRuleType(),506,507,20026,20033,FieldReferenceMutator,ruleType,type,0,0.6689095,this.<mask>,"RuleType getRuleType() {
        return this.<mask>;
    }"
1924,PhoneticEngine.java,getRuleType,RuleType getRuleType(),506,507,20026,20033,FieldReferenceMutator,ruleType,rule,1,0.21086426,this.<mask>,"RuleType getRuleType() {
        return this.<mask>;
    }"
1925,PhoneticEngine.java,getRuleType,RuleType getRuleType(),506,507,20026,20033,FieldReferenceMutator,ruleType,name,2,0.014802552,this.<mask>,"RuleType getRuleType() {
        return this.<mask>;
    }"
1926,PhoneticEngine.java,getRuleType,RuleType getRuleType(),506,507,20026,20033,FieldReferenceMutator,ruleType,class,3,0.0134639125,this.<mask>,"RuleType getRuleType() {
        return this.<mask>;
    }"
1927,PhoneticEngine.java,getRuleType,RuleType getRuleType(),506,507,20026,20033,FieldReferenceMutator,ruleType,value,4,0.00769295,this.<mask>,"RuleType getRuleType() {
        return this.<mask>;
    }"
1928,PhoneticEngine.java,isConcat,boolean isConcat(),515,516,20299,20309,IdentifierMutator-Variable,this.concat,true,0,0.5728365,<mask>,"boolean isConcat() {
        return<mask>;
    }"
1929,PhoneticEngine.java,isConcat,boolean isConcat(),515,516,20299,20309,IdentifierMutator-Variable,this.concat,false,1,0.4074753,<mask>,"boolean isConcat() {
        return<mask>;
    }"
1930,PhoneticEngine.java,isConcat,boolean isConcat(),515,516,20299,20309,IdentifierMutator-Variable,this.concat,1,2,0.0020594343,<mask>,"boolean isConcat() {
        return<mask>;
    }"
1931,PhoneticEngine.java,isConcat,boolean isConcat(),515,516,20299,20309,IdentifierMutator-Variable,this.concat,c,3,0.0014033357,<mask>,"boolean isConcat() {
        return<mask>;
    }"
1932,PhoneticEngine.java,isConcat,boolean isConcat(),515,516,20299,20309,IdentifierMutator-Variable,this.concat,TRUE,4,0.001379425,<mask>,"boolean isConcat() {
        return<mask>;
    }"
1933,PhoneticEngine.java,isConcat,boolean isConcat(),515,516,20299,20302,IdentifierMutator-ThisAccess,this,super,1,0.010227777,<mask>,"boolean isConcat() {
        return<mask>.concat;
    }"
1934,PhoneticEngine.java,isConcat,boolean isConcat(),515,516,20299,20302,IdentifierMutator-ThisAccess,this,options,2,0.009585484,<mask>,"boolean isConcat() {
        return<mask>.concat;
    }"
1935,PhoneticEngine.java,isConcat,boolean isConcat(),515,516,20299,20302,IdentifierMutator-ThisAccess,this,config,3,0.0087408265,<mask>,"boolean isConcat() {
        return<mask>.concat;
    }"
1936,PhoneticEngine.java,isConcat,boolean isConcat(),515,516,20299,20302,IdentifierMutator-ThisAccess,this,result,4,0.0057571977,<mask>,"boolean isConcat() {
        return<mask>.concat;
    }"
1937,PhoneticEngine.java,isConcat,boolean isConcat(),515,516,20304,20309,FieldReferenceMutator,concat,cat,0,0.2127203,this.<mask>,"boolean isConcat() {
        return this.<mask>;
    }"
1938,PhoneticEngine.java,isConcat,boolean isConcat(),515,516,20304,20309,FieldReferenceMutator,concat,column,1,0.04917523,this.<mask>,"boolean isConcat() {
        return this.<mask>;
    }"
1939,PhoneticEngine.java,isConcat,boolean isConcat(),515,516,20304,20309,FieldReferenceMutator,concat,join,2,0.033940308,this.<mask>,"boolean isConcat() {
        return this.<mask>;
    }"
1940,PhoneticEngine.java,isConcat,boolean isConcat(),515,516,20304,20309,FieldReferenceMutator,concat,count,3,0.031971022,this.<mask>,"boolean isConcat() {
        return this.<mask>;
    }"
1941,PhoneticEngine.java,isConcat,boolean isConcat(),515,516,20304,20309,FieldReferenceMutator,concat,append,4,0.016960746,this.<mask>,"boolean isConcat() {
        return this.<mask>;
    }"
1942,PhoneticEngine.java,getMaxPhonemes,int getMaxPhonemes(),525,526,20543,20558,IdentifierMutator-Variable,this.maxPhonemes,max,0,0.2018566,<mask>,"int getMaxPhonemes() {
        return<mask>;
    }"
1943,PhoneticEngine.java,getMaxPhonemes,int getMaxPhonemes(),525,526,20543,20558,IdentifierMutator-Variable,this.maxPhonemes,1,1,0.13457158,<mask>,"int getMaxPhonemes() {
        return<mask>;
    }"
1944,PhoneticEngine.java,getMaxPhonemes,int getMaxPhonemes(),525,526,20543,20558,IdentifierMutator-Variable,this.maxPhonemes,0,2,0.07460486,<mask>,"int getMaxPhonemes() {
        return<mask>;
    }"
1945,PhoneticEngine.java,getMaxPhonemes,int getMaxPhonemes(),525,526,20543,20558,IdentifierMutator-Variable,this.maxPhonemes,3,3,0.049662497,<mask>,"int getMaxPhonemes() {
        return<mask>;
    }"
1946,PhoneticEngine.java,getMaxPhonemes,int getMaxPhonemes(),525,526,20543,20558,IdentifierMutator-Variable,this.maxPhonemes,2,4,0.03665817,<mask>,"int getMaxPhonemes() {
        return<mask>;
    }"
1947,PhoneticEngine.java,getMaxPhonemes,int getMaxPhonemes(),525,526,20543,20546,IdentifierMutator-ThisAccess,this,options,1,0.03758088,<mask>,"int getMaxPhonemes() {
        return<mask>.maxPhonemes;
    }"
1948,PhoneticEngine.java,getMaxPhonemes,int getMaxPhonemes(),525,526,20543,20546,IdentifierMutator-ThisAccess,this,config,2,0.0322221,<mask>,"int getMaxPhonemes() {
        return<mask>.maxPhonemes;
    }"
1949,PhoneticEngine.java,getMaxPhonemes,int getMaxPhonemes(),525,526,20543,20546,IdentifierMutator-ThisAccess,this,super,3,0.02295635,<mask>,"int getMaxPhonemes() {
        return<mask>.maxPhonemes;
    }"
1950,PhoneticEngine.java,getMaxPhonemes,int getMaxPhonemes(),525,526,20543,20546,IdentifierMutator-ThisAccess,this,m,4,0.014701526,<mask>,"int getMaxPhonemes() {
        return<mask>.maxPhonemes;
    }"
1951,PhoneticEngine.java,getMaxPhonemes,int getMaxPhonemes(),525,526,20548,20558,FieldReferenceMutator,maxPhonemes,max,0,0.65561813,this.<mask>,"int getMaxPhonemes() {
        return this.<mask>;
    }"
1952,PhoneticEngine.java,getMaxPhonemes,int getMaxPhonemes(),525,526,20548,20558,FieldReferenceMutator,maxPhonemes,count,1,0.03792442,this.<mask>,"int getMaxPhonemes() {
        return this.<mask>;
    }"
1953,PhoneticEngine.java,getMaxPhonemes,int getMaxPhonemes(),525,526,20548,20558,FieldReferenceMutator,maxPhonemes,length,2,0.028094025,this.<mask>,"int getMaxPhonemes() {
        return this.<mask>;
    }"
1954,PhoneticEngine.java,getMaxPhonemes,int getMaxPhonemes(),525,526,20548,20558,FieldReferenceMutator,maxPhonemes,MAX,3,0.019836014,this.<mask>,"int getMaxPhonemes() {
        return this.<mask>;
    }"
1955,PhoneticEngine.java,getMaxPhonemes,int getMaxPhonemes(),525,526,20548,20558,FieldReferenceMutator,maxPhonemes,size,4,0.01861297,this.<mask>,"int getMaxPhonemes() {
        return this.<mask>;
    }"
